<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"killer-p.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="share Linux, arm, and some skillful things">
<meta property="og:type" content="website">
<meta property="og:title" content="killer-p blog">
<meta property="og:url" content="https://killer-p.github.io/index.html">
<meta property="og:site_name" content="killer-p blog">
<meta property="og:description" content="share Linux, arm, and some skillful things">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="killer-p">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://killer-p.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>killer-p blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">killer-p blog</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/upload/killer-p.png" alt="killer-p blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">killer-p</p>
  <div class="site-description" itemprop="description">share Linux, arm, and some skillful things</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/other/ringbuff_c_impl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/other/ringbuff_c_impl/" class="post-title-link" itemprop="url">C语言实现ringbuff</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:02:30" itemprop="dateModified" datetime="2025-06-02T10:02:30+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C语言实现ringbuff"><a href="#C语言实现ringbuff" class="headerlink" title="C语言实现ringbuff"></a>C语言实现ringbuff</h1><p>@[toc]</p>
<h2 id="一-什么是ringbuff"><a href="#一-什么是ringbuff" class="headerlink" title="一 什么是ringbuff"></a>一 什么是ringbuff</h2><p>ringbuff是环形buff，是buff缓存的一种，可以用来存放程序运行过程的暂时数据。一般的buff即是一个数组，而环形buff就是将数组的头和尾链接起来的数组。<br>老规矩，源码先放这：<br><a target="_blank" rel="noopener" href="https://gitee.com/killerp/mylib.git">码云：https://gitee.com/killerp/mylib.git</a></p>
<h3 id="1，ringbuff的优点"><a href="#1，ringbuff的优点" class="headerlink" title="1，ringbuff的优点"></a>1，ringbuff的优点</h3><p>ringbuff比普通的buff使用更加高效灵活，可以边读数据边写数据。</p>
<h2 id="二-ringbuff的实现"><a href="#二-ringbuff的实现" class="headerlink" title="二 ringbuff的实现"></a>二 ringbuff的实现</h2><p>一个ringbuff的实现至少需要以下四个功能：</p>
<ul>
<li>创建ringbuff</li>
<li>数据写入ringbuff</li>
<li>从ringbuff读取数据</li>
<li>删除ringbuff</li>
</ul>
<h3 id="0，ringbuff结构体"><a href="#0，ringbuff结构体" class="headerlink" title="0，ringbuff结构体"></a>0，ringbuff结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RingBuff</span> *<span class="title">RingBuff_handle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ringbuff结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RingBuff</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *source;	<span class="comment">//ringbuff的头部</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *tail;	<span class="comment">//尾部</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *write;	<span class="comment">//写指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *read;	<span class="comment">//读指针</span></span><br><span class="line">	<span class="type">int</span> size;	<span class="comment">//ringbuff总长度</span></span><br><span class="line">	<span class="type">int</span> writed_size;	<span class="comment">//写入数据的长度</span></span><br><span class="line">	<span class="type">int</span> remain_size;	<span class="comment">//剩余空间</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如下图所示，一般一个ringbuff创建后，size，source和tail指针是固定的。当write移动到tail时，如果有数据需要写入，write会移动到source处继续写入，但是write不会覆盖掉未被read指针读取的数据。当read移动到tail时同样，如果需要继续读取数据，会移动到source继续读取。注意！write移动的长度不能超过remain_size（剩余空间）；read移动的长度部能超过write_size(已写入长度)；基本的工作原理就是这样。<br><img src="/killer-blog/other/ringbuff_c_impl/20200828103725680.png" alt="在这里插入图片描述"></p>
<h3 id="1，ringbuff的创建"><a href="#1，ringbuff的创建" class="headerlink" title="1，ringbuff的创建"></a>1，ringbuff的创建</h3><p>ringbuff的创建实际上是调用malloc();实现动态内存分配，内存的大小由用户输入参数决定，分配的内存的地址指针会赋值给source，同时计算tail的指针，第一次创建也会初始化ringbuff的其他成员。一般的size最好比一次读写的长度大几倍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 创建一个ringbuff 用户定义字节大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RingBuff_handle <span class="title function_">createRingBuff</span><span class="params">(<span class="type">int</span> totalsize)</span></span><br><span class="line">&#123;</span><br><span class="line">	RingBuff_handle ringbuff;</span><br><span class="line">	ringbuff = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> RingBuff));</span><br><span class="line">	ringbuff-&gt;source = <span class="built_in">malloc</span>(totalsize);</span><br><span class="line">	<span class="keyword">if</span>(ringbuff-&gt;source !=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGI(<span class="string">&quot;create ringbuff success!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ringbuff-&gt;write = ringbuff-&gt;source;</span><br><span class="line">	ringbuff-&gt;read = ringbuff-&gt;source;</span><br><span class="line">	ringbuff-&gt;writed_size = <span class="number">0</span>;</span><br><span class="line">	ringbuff-&gt;tail = ringbuff-&gt;source + totalsize;</span><br><span class="line">	ringbuff-&gt;size = totalsize;</span><br><span class="line">	ringbuff-&gt;remain_size = totalsize;</span><br><span class="line">	<span class="keyword">return</span> ringbuff;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，计算已写入数据的长度"><a href="#2，计算已写入数据的长度" class="headerlink" title="2，计算已写入数据的长度"></a>2，计算已写入数据的长度</h3><p>计算writed_size的大小非常关键。这里先给出伪代码计算公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writed_size = (size +（write - read)%size</span><br></pre></td></tr></table></figure>
<p>理解它需要先了解ringbuff的读写指针的两种位置关系：</p>
<ul>
<li>写指针在读指针前面</li>
<li>读指针在写指针前面<br><img src="/killer-blog/other/ringbuff_c_impl/20200828105620827.png" alt="在这里插入图片描述">代码实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 获得已写入数据的字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRingBuffWritedSize</span><span class="params">(RingBuff_handle handle)</span></span><br><span class="line">&#123;</span><br><span class="line">	handle-&gt;writed_size = (handle-&gt;size + (handle-&gt;write - handle-&gt;read)) % handle-&gt;size;</span><br><span class="line">	LOGI(<span class="string">&quot;writed_size = %d&quot;</span>,handle-&gt;writed_size);</span><br><span class="line">	<span class="keyword">return</span> handle-&gt;writed_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，数据写入ringbuff"><a href="#3，数据写入ringbuff" class="headerlink" title="3，数据写入ringbuff"></a>3，数据写入ringbuff</h3><p>在读写数据的处理上都需要分以上两种情况处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 写入ringbuff handle 数据 数据字节长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeRingBuff</span><span class="params">(RingBuff_handle handle,<span class="type">unsigned</span> <span class="type">char</span> *data,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(handle-&gt;source == <span class="literal">NULL</span> ||handle == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGE(<span class="string">&quot;ringbuff has not been init&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查剩余内存是否足够</span></span><br><span class="line">	<span class="keyword">if</span>(handle-&gt;remain_size &gt; size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//写指针在读指针前</span></span><br><span class="line">		<span class="keyword">if</span>(handle-&gt;write - handle-&gt;read &gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> writebytes = handle-&gt;tail - handle-&gt;write - size;</span><br><span class="line">			<span class="comment">//写入的数据小于写指针到内存尾部</span></span><br><span class="line">			<span class="keyword">if</span>(writebytes &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(handle-&gt;write,data,size);</span><br><span class="line">				handle-&gt;write += size;</span><br><span class="line">		</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//写入的数据大于写指针到内存尾部，需要从头部继续写入</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//写入数据到尾部</span></span><br><span class="line">				<span class="built_in">memcpy</span>(handle-&gt;write,data,handle-&gt;tail - handle-&gt;write);</span><br><span class="line">				data += handle-&gt;tail - handle-&gt;write;</span><br><span class="line">				writebytes = <span class="built_in">abs</span>(writebytes);</span><br><span class="line">				<span class="comment">//从头部继续写入剩余数据</span></span><br><span class="line">				<span class="built_in">memcpy</span>(handle-&gt;source,data,writebytes);</span><br><span class="line">				handle-&gt;write = handle-&gt;source +  writebytes;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//读指针在写指针前</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(handle-&gt;write,data,size);</span><br><span class="line">			handle-&gt;write += size;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		LOGI(<span class="string">&quot;write success&quot;</span>);</span><br><span class="line">		<span class="comment">//更新参数</span></span><br><span class="line">		getRingBuffRemainSize(handle);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LOGE(<span class="string">&quot;write fail&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4，读取ringbuff数据"><a href="#4，读取ringbuff数据" class="headerlink" title="4，读取ringbuff数据"></a>4，读取ringbuff数据</h3><p>读取数据也要区别指针的位置情况。读取与写入逻辑上差别不大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 读取ringbuff数据 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readRingBuff</span><span class="params">(RingBuff_handle handle,<span class="type">unsigned</span> <span class="type">char</span> *data,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(handle-&gt;source == <span class="literal">NULL</span> ||handle == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGE(<span class="string">&quot;ringbuff has not been init&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//要读取的数据少于已经写入的数据</span></span><br><span class="line">	<span class="keyword">if</span>(handle-&gt;writed_size &gt;= size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//写指针在读指针前</span></span><br><span class="line">		<span class="keyword">if</span>(handle-&gt;write - handle-&gt;read &gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(data,handle-&gt;read,size);</span><br><span class="line">			handle-&gt;read += size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//读指针在写指针前</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> readbytes = handle-&gt;tail - handle-&gt;read - size;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//读取，不用从头读</span></span><br><span class="line">			<span class="keyword">if</span>(readbytes &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(data,handle-&gt;read,size);</span><br><span class="line">				handle-&gt;read += size;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> 	<span class="comment">//需要从头读</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(data,handle-&gt;read,handle-&gt;tail - handle-&gt;read);</span><br><span class="line">				readbytes = <span class="built_in">abs</span>(readbytes);</span><br><span class="line">				data += handle-&gt;tail - handle-&gt;read;</span><br><span class="line">				<span class="built_in">memcpy</span>(data,handle-&gt;source,readbytes);</span><br><span class="line">				handle-&gt;read = handle-&gt;source + readbytes;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		LOGI(<span class="string">&quot;read success&quot;</span>);</span><br><span class="line">		<span class="comment">//更新参数</span></span><br><span class="line">		getRingBuffRemainSize(handle);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LOGE(<span class="string">&quot;read fail&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5，删除ringbuff"><a href="#5，删除ringbuff" class="headerlink" title="5，删除ringbuff"></a>5，删除ringbuff</h3><p>删除函数其实是调用free();函数释放由malloc();分配的内存。需要检查指针是否空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 删除ringbuff</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteRingBuff</span><span class="params">(RingBuff_handle handle)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//需要判断指针是否空，否则free()会出错</span></span><br><span class="line">	<span class="keyword">if</span>(handle == <span class="literal">NULL</span> ||handle-&gt;source == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGE(<span class="string">&quot;free fail&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(handle-&gt;source);</span><br><span class="line">	<span class="built_in">free</span>(handle);</span><br><span class="line">	LOGI(<span class="string">&quot;free ringbuff success&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/killer-blog/other/ringbuff_c_impl/20200828110822332.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/Git/speed_github_in_cn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/Git/speed_github_in_cn/" class="post-title-link" itemprop="url">国内加速github访问、下载代码仓库的方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:06:20" itemprop="dateModified" datetime="2025-06-02T10:06:20+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="国内加速github访问、下载代码仓库的方法"><a href="#国内加速github访问、下载代码仓库的方法" class="headerlink" title="国内加速github访问、下载代码仓库的方法"></a>国内加速github访问、下载代码仓库的方法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>github上下载仓库或者克隆仓库，速度基本稳定在20k以下，这老哥是真的稳。当克隆一些大的仓库时，以这乌龟速度，很容易出现克隆超时的错误，等了几十分钟的下载一夜回到解放前，那种感觉我猜各位或多或少都经历过。本博客会整理几种亲测可用的方案，下载速度很大地提升，一个大的仓库一分钟左右就可以搞定，也会持续的更新一些可用新方法，希望对你有帮助</strong><br><strong>以下方案均来自网络的分享，我只是做整理推荐。感谢那些无私的程序员们</strong></p>
<blockquote>
<p>更新日志</p>
<blockquote>
<p>2020.9.5 增加了谷歌插件方法，github加速下载链接,使用github镜像下载三种方式。</p>
</blockquote>
</blockquote>
<h3 id="一，谷歌浏览器插件加速"><a href="#一，谷歌浏览器插件加速" class="headerlink" title="一，谷歌浏览器插件加速"></a>一，谷歌浏览器插件加速</h3><p>功能最强大，完善的一种方式，需要使用谷歌浏览器，开启浏览器的插件功能，插件下载地址：<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qGiIUzqNlN1ZczTNFbPg0A">https://pan.baidu.com/s/1qGiIUzqNlN1ZczTNFbPg0A</a> <strong>提取码 stsv</strong><br>备用地址：<a target="_blank" rel="noopener" href="https://wws.lanzous.com/ia7V3gdmv8f">https://wws.lanzous.com/ia7V3gdmv8f</a><br>下载完成后添加到谷歌浏览器的插件中，再打开github，你会发现整个访问速度提升了不止一个档次，插件对github网站添加了加速和镜像功能：亲测加速通道的下载速度可达最少1M，但是镜像方面无法访问，会被浏览器拦截，但这无关紧要，推荐！（这是要我用回谷歌吗？）<br><img src="/killer-blog/Git/speed_github_in_cn/1.png" alt="在这里插入图片描述">使用加速通道下载测试：</p>
<p><img src="/killer-blog/Git/speed_github_in_cn/2.png" alt="在这里插入图片描述"><br><img src="/killer-blog/Git/speed_github_in_cn/3.png" alt="在这里插入图片描述"></p>
<h3 id="二，gitclone-com"><a href="#二，gitclone-com" class="headerlink" title="二，gitclone.com"></a>二，gitclone.com</h3><p>这是我用过最爽最实用功能最全面的一个方式了。gitclone.com是一个提供下载缓存的代码下载网站，使用方法十分简单，只需要<strong>在仓库地址前面加上 gitclone.com</strong>，就可以使速度提升几倍。</p>
<p><strong>例如要克隆github上仓库地址<code>https://github.com/killer-p/ctool.git</code><br>只需将地址改为<code>https://gitclone.com/github.com/killer-p/ctool.git</code>，在命令行中执行<code>git clone https://gitclone.com/github.com/killer-p/ctool.git</code>，速度直接起飞！芜湖！</strong><br>官网首页：<a target="_blank" rel="noopener" href="https://gitclone.com/">https://gitclone.com/</a></p>
<blockquote>
<p>gitclone的工作机理是：当开发者第一次经gitclone.com代理clone项目时，gitclone.com异步镜像项目，以后有开发者clone该项目时，就会利用上gitclone.com的本地镜像，而不是从github.com上clone。gitclone.com会在每天夜间与github.com同步。为了解决不断增长的镜像对硬盘资源的需求，gitclone.com采用区块链集群方式扩展，每次的镜像操作都会广播到集群中所有服务器，各服务器可选择生成镜像并登记以便以响应后续的clone请求。同时，gitclone.com还对stackoverflow.com和go get等的加速访问进行了说明，做到“为开发者服务”。</p>
</blockquote>
<p><strong>这是我使用的最方便的一种方法，墙裂推荐，gitclone.com还提供了其他的加速方法，<a target="_blank" rel="noopener" href="https://www.gitclone.com/docs/howto/howto_github">查看其他方法</a></strong><br>速度非常快。<br><img src="/killer-blog/Git/speed_github_in_cn/4.png" alt="在这里插入图片描述"></p>
<h3 id="三，码云下载"><a href="#三，码云下载" class="headerlink" title="三，码云下载"></a>三，码云下载</h3><p>这也算是大家很熟悉的了，给小白科普一下。码云是国内的代码管理网站，所以在国内的下载速度非常快，码云支持从github其他代码代管网站导入码云仓库。<br><strong>使用方法：</strong><br><strong>复制github上仓库地址，例如：<br><code>https://github.com/769484623/MahonyAHRSWithMPU6050_HMC5983.git</code><br>然后注册码云账号，在码云中创建新仓库，直接在底下选择<code>导入已有仓库</code></strong><br><img src="/killer-blog/Git/speed_github_in_cn/5.png" alt="在这里插入图片描述"><strong>在方框内粘贴github的仓库地址，系统会自动检测链接是哪个代码代管网站的。点击创建。</strong><br><img src="/killer-blog/Git/speed_github_in_cn/6.png" alt="在这里插入图片描述"><br><strong>等个几十秒，码云把github上的项目拉下来，放在了码云的服务器上，这时候我们就可以从码云下载仓库了，而且由于码云服务器在中国，下载速度很快，具体操作：</strong><br><strong>复制https或者直接下载zip</strong><br><img src="/killer-blog/Git/speed_github_in_cn/7.png" alt="在这里插入图片描述"></p>
<h3 id="四，githubd"><a href="#四，githubd" class="headerlink" title="四，githubd"></a>四，githubd</h3><p>githud是一个代码代下载网站，只需要输入github仓库地址，网站就会下载GitHub仓库的压缩包，用户可以直接在网站下载。请收下地址：<a target="_blank" rel="noopener" href="https://githubd.com/#/">https://githubd.com/#/</a>，速度比直接在github上下载zip提升十倍！<code>注意！下载的zip是不包括子模块仓库的！注意检查!带子模块仓库的建议看第一点</code><br><img src="/killer-blog/Git/speed_github_in_cn/8.png" alt="在这里插入图片描述">另一个代码下载网站是：<a target="_blank" rel="noopener" href="https://d.serctl.com/?dl_start">https://d.serctl.com/?dl_start</a>，它也支持下载github仓库的压缩包，具体使用方法看上面的网址。</p>
<h3 id="五，github文件下载加速"><a href="#五，github文件下载加速" class="headerlink" title="五，github文件下载加速"></a>五，github文件下载加速</h3><p>这个网站主要是用来下载github上一些正式版(release)的zip or war 等文件资源的，不支持下载仓库。<br>话不多说，直接上地址：<a target="_blank" rel="noopener" href="https://shrill-pond-3e81.hunsh.workers.dev/">https://shrill-pond-3e81.hunsh.workers.dev/</a><br>只需要输入github上的资源地址，最好是压缩包格式，其他格式的文件可能不支持。</p>
<h3 id="六，github加速下载链接"><a href="#六，github加速下载链接" class="headerlink" title="六，github加速下载链接"></a>六，github加速下载链接</h3><p>网站地址：<a target="_blank" rel="noopener" href="https://github.zhlh6.cn/">https://github.zhlh6.cn/</a></p>
<p>复制github仓库的地址，然后粘贴到第一栏，点击加速！生成加速地址，使用加速地址进行git clone 下载，下载速度最高能提升到1M（我的测试），平均也有600多k，实测效果见下图：<br><img src="/killer-blog/Git/speed_github_in_cn/9.png" alt="在这里插入图片描述"><br><img src="/killer-blog/Git/speed_github_in_cn/10.png" alt="在这里插入图片描述"></p>
<h3 id="七，github镜像访问"><a href="#七，github镜像访问" class="headerlink" title="七，github镜像访问"></a>七，github镜像访问</h3><p>github镜像就是一个跟github一毛一样的网站，他会同步github上的资源，国内访问github镜像的速度较快，也可以在镜像下载仓库，平时逛逛gayhub也可以用这个镜像，反正比较快，缺点就是不能登录，镜像地址：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/">https://hub.fastgit.org/</a><br><code>注意这个网站不能登录github账户，点击sign in会被浏览器拦截</code></p>
<p>效果如下：可以看出下载地址的域名不是github.com,下载速度也达到700多k。</p>
<p><img src="/killer-blog/Git/speed_github_in_cn/11.png" alt="在这里插入图片描述"><br><img src="/killer-blog/Git/speed_github_in_cn/12.png" alt="在这里插入图片描述"></p>
<h3 id="注意，-带子模块的大型仓库"><a href="#注意，-带子模块的大型仓库" class="headerlink" title="注意， 带子模块的大型仓库"></a>注意， 带子模块的大型仓库</h3><p>以上的方法已经可以解决大部分仓库的下载问题，但是有一些大型仓库是带有子模块，由于在仓库根目录中的<code>.gitmodules</code>文件夹定义了子模块的地址仍然是github仓库的地址，所以用gitclone.com或者码云下载的仓库在下载子模块时会 直接越过gitclone.com和码云而从github上下载，这就又使得下载速度回到石器时代。<br><strong>一种解决办法是先下载主仓库，修改仓库中的<code>.gitmodules</code>文件夹中的仓库地址，加上gitclone.com，保存退出后，cmd执行</strong></p>
<blockquote>
<p>git submodule update –init </p>
</blockquote>
<p><strong>更新子模块或者直接在相应的文件夹下通过gitclone.com自行下载相应的模块，最后一定要记得执行 <code>git submodule update --init</code> 更新子模块。如果子模块中还有子模块，按上述方法重复进行就可以了。</strong></p>
<h3 id="参考资料，感谢以下文章"><a href="#参考资料，感谢以下文章" class="headerlink" title="参考资料，感谢以下文章"></a>参考资料，感谢以下文章</h3><p><a target="_blank" rel="noopener" href="https://code.pingbook.top/blog/2020/How-To-Speed-Github.html#_2-github%E6%96%87%E4%BB%B6%E5%8A%A0%E9%80%9F">10种访问github方法</a><br><a target="_blank" rel="noopener" href="https://github.com/Sicmatr1x/Free-Resource/blob/master/Development.md">github下载解决方案</a><br><strong>觉得博客对你有帮助的话，点个赞收藏支持一下呗，持续更新！</strong><br><img src="/killer-blog/Git/speed_github_in_cn/13.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/smart_control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/smart_control/" class="post-title-link" itemprop="url">基于ESP32的智能遥控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:20:37" itemprop="dateModified" datetime="2025-06-02T10:20:37+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基于ESP32的智能遥控"><a href="#基于ESP32的智能遥控" class="headerlink" title="基于ESP32的智能遥控"></a>基于ESP32的智能遥控</h1><h2 id="一、演示视频"><a href="#一、演示视频" class="headerlink" title="一、演示视频"></a>一、演示视频</h2><p>离线版地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/off_asr">https://gitee.com/killerp/off_asr</a><br>语音识别优化版地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/smart_control">https://gitee.com/killerp/smart_control</a><br>PCB原理图下载地址：<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1wzTGKnRF7WUzTYZ5U4v9kQ">https://pan.baidu.com/s/1wzTGKnRF7WUzTYZ5U4v9kQ</a><br>提取码：6tds</p>
<p>本项目基于esp32a1s模组，设计了一个遥控器，除了实现基本的红外遥控功能，还利用ESP32芯片具备的AI能力，WIFI及蓝牙功能，实现多种方式的输入输出控制，使人们能通过语音，手机远程进行红外遥控。同时又加入温度传感器，并支持将温度数据上传云端，使人们能随时随地查看、分析数据。<br>项目演示视频如下：</p>
<p>[video(video-19gWGs4l-1617149447766)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=972368801)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/03eaf981b73823d3c328e13cfa1250c6e418c0ca.png)">https://player.bilibili.com/player.html?aid=972368801)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/03eaf981b73823d3c328e13cfa1250c6e418c0ca.png)</a>(title-基于esp32语音助手 语音红外遥控)]</p>
<h2 id="二、程序框架"><a href="#二、程序框架" class="headerlink" title="二、程序框架"></a>二、程序框架</h2><p>项目软件分为上位机端和嵌入式终端，程序框架如图：</p>
<p>位于底层的模块可为其上层的模块提供接口<br><img src="/killer-blog/ESP32/smart_control/cc34e0b2ccef417fb412c0f3445c81e7.png" alt="在这里插入图片描述"></p>
<h2 id="三、硬件设计"><a href="#三、硬件设计" class="headerlink" title="三、硬件设计"></a>三、硬件设计</h2><h2 id="四、模块介绍"><a href="#四、模块介绍" class="headerlink" title="四、模块介绍"></a>四、模块介绍</h2><h3 id="1、语音识别模块"><a href="#1、语音识别模块" class="headerlink" title="1、语音识别模块"></a>1、语音识别模块</h3><p>语言识别模块有两种实现方式，一种是离线识别，一种是针对离线版的优化。（目前离线版不再维护）</p>
<h4 id="离线语音识别"><a href="#离线语音识别" class="headerlink" title="离线语音识别"></a>离线语音识别</h4><p>离线语音的实现依赖于乐鑫提供ESP-Skainet库，该库实现了语音唤醒，语言识别功能，可支持100条自定义的语言识别命令。</p>
<p>ESP-Skainet 由两部分组成：</p>
<p>1，唤醒词模型 <a target="_blank" rel="noopener" href="https://github.com/espressif/esp-sr/tree/master/wake_word_engine/README_cn.md">WakeNet</a>：其实现了语音唤醒的功能，目前普通用户能使用限定的唤醒词，如：嗨乐鑫。模型由乐鑫训练。</p>
<p>2，命令词识别模型 <a target="_blank" rel="noopener" href="https://github.com/espressif/esp-sr/tree/master/speech_command_recognition/README_cn.md">MultiNet</a>：其实现语音识别功能，将需要识别的语音命令写入程序，MultiNet就能在程序运行中进行识别，目前支持100条命令词。</p>
<p>在整个程序运行过程中，WakeNet和MultiNet两个模型以进程的形式运行，实时地读取麦克风的音频输入，将音频经过降噪处理等，输入模型，输出结果。其程序运行如图所示：</p>
<p><img src="/killer-blog/ESP32/smart_control/46e76acc42cf47f7b7a0bf8f84f028da.png" alt="在这里插入图片描述"><br>以下代码在main()中运行，该代码初始化了wakenet，multinet 模型，并创建一个音频流通道（ESP-ADF中的概念），该通道的作用即上图中箭头所示。main()以一个RTOS的任务运行，在循环中实时读取通道的音频，输入模型识别。</p>
<p>命令词识别成功后，在<code>asr_multinet_control</code>函数中编写对命令词的响应动作，如调用红外模块提供的接口打开空调等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">ESP_LOGI(TAG, <span class="string">&quot;Initialize SR wn handle&quot;</span>);</span><br><span class="line"><span class="type">esp_wn_iface_t</span> *wakenet;    <span class="comment">//唤醒模型</span></span><br><span class="line"><span class="type">model_coeff_getter_t</span> *model_coeff_getter;   <span class="comment">//神经网络系数获取</span></span><br><span class="line"><span class="type">model_iface_data_t</span> *model_wn_data;  <span class="comment">//识别模型的数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">esp_mn_iface_t</span> *multinet = &amp;MULTINET_MODEL;   <span class="comment">//识别模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize wakeNet model data</span></span><br><span class="line">get_wakenet_iface(&amp;wakenet);    <span class="comment">//初始化唤醒模型</span></span><br><span class="line">get_wakenet_coeff(&amp;model_coeff_getter); <span class="comment">//获取系数</span></span><br><span class="line">model_wn_data = wakenet-&gt;create(model_coeff_getter, DET_MODE_90);   <span class="comment">//创建唤醒模型，设置灵敏度90%</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wn_num = wakenet-&gt;get_word_num(model_wn_data);  <span class="comment">//唤醒词数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= wn_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name = wakenet-&gt;get_word_name(model_wn_data, i);  <span class="comment">//唤醒词文本</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;keywords: %s (index = %d)&quot;</span>, name, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> wn_threshold = wakenet-&gt;get_det_threshold(model_wn_data, <span class="number">1</span>);  <span class="comment">//获取唤醒阈值</span></span><br><span class="line"><span class="type">int</span> wn_sample_rate = wakenet-&gt;get_samp_rate(model_wn_data); <span class="comment">//唤醒词采样率16k</span></span><br><span class="line"><span class="type">int</span> audio_wn_chunksize = wakenet-&gt;get_samp_chunksize(model_wn_data);    <span class="comment">//内存块大小</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;keywords_num = %d, threshold = %f, sample_rate = %d, chunksize = %d, sizeof_uint16 = %d&quot;</span>, wn_num, wn_threshold, wn_sample_rate, audio_wn_chunksize, <span class="keyword">sizeof</span>(<span class="type">int16_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">model_iface_data_t</span> *model_mn_data = multinet-&gt;create(&amp;MULTINET_COEFF, <span class="number">4000</span>); <span class="comment">//语音识别时间，single模式下最大5s</span></span><br><span class="line"><span class="type">int</span> audio_mn_chunksize = multinet-&gt;get_samp_chunksize(model_mn_data);   <span class="comment">//识别内存块</span></span><br><span class="line"><span class="type">int</span> mn_num = multinet-&gt;get_samp_chunknum(model_mn_data);    <span class="comment">//唤醒词数量</span></span><br><span class="line"><span class="type">int</span> mn_sample_rate = multinet-&gt;get_samp_rate(model_mn_data);    <span class="comment">//采样率16k</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;keywords_num = %d , sample_rate = %d, chunksize = %d, sizeof_uint16 = %d&quot;</span>, mn_num, mn_sample_rate, audio_mn_chunksize, <span class="keyword">sizeof</span>(<span class="type">int16_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择所需的较大的内存块</span></span><br><span class="line"><span class="type">int</span> size = audio_wn_chunksize;</span><br><span class="line"><span class="keyword">if</span> (audio_mn_chunksize &gt; audio_wn_chunksize)</span><br><span class="line">&#123;</span><br><span class="line">    size = audio_mn_chunksize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int16_t</span> *buffer = (<span class="type">int16_t</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">short</span>));  <span class="comment">//buffer用于缓存经过流水线处理的音频</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*[ac101]--&gt;i2s_stream--&gt;filter--&gt;raw--&gt;[SR]*/</span></span><br><span class="line"><span class="type">audio_pipeline_handle_t</span> pipeline;   <span class="comment">//音频输入流水线</span></span><br><span class="line"><span class="type">audio_element_handle_t</span> i2s_stream_reader, filter, raw_read; <span class="comment">//流水线车间</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> enable_wn = <span class="literal">true</span>;  <span class="comment">//唤醒使能</span></span><br><span class="line"><span class="type">uint32_t</span> mn_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 1 ] Start codec chip&quot;</span>);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.0 ] Create audio pipeline for recording&quot;</span>);</span><br><span class="line"><span class="comment">//流水线初始化</span></span><br><span class="line"><span class="type">audio_pipeline_cfg_t</span> pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();</span><br><span class="line">pipeline = audio_pipeline_init(&amp;pipeline_cfg);</span><br><span class="line">mem_assert(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="comment">//i2s初始化，用于与ac101通信</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.1 ] Create i2s stream to read audio data from codec chip&quot;</span>);</span><br><span class="line"><span class="type">i2s_stream_cfg_t</span> i2s_cfg = I2S_STREAM_CFG_DEFAULT();</span><br><span class="line">i2s_cfg.i2s_config.sample_rate = <span class="number">48000</span>;</span><br><span class="line">i2s_cfg.type = AUDIO_STREAM_READER; <span class="comment">//输入流</span></span><br><span class="line">i2s_stream_reader = i2s_stream_init(&amp;i2s_cfg);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.2 ] Create filter to resample audio data&quot;</span>);</span><br><span class="line"><span class="comment">//滤波器初始化，将源采样率变为16k</span></span><br><span class="line"><span class="type">rsp_filter_cfg_t</span> rsp_cfg = DEFAULT_RESAMPLE_FILTER_CONFIG();</span><br><span class="line">rsp_cfg.src_rate = <span class="number">48000</span>;</span><br><span class="line">rsp_cfg.src_ch = <span class="number">2</span>;</span><br><span class="line">rsp_cfg.dest_rate = <span class="number">16000</span>;</span><br><span class="line">rsp_cfg.dest_ch = <span class="number">1</span>;</span><br><span class="line">filter = rsp_filter_init(&amp;rsp_cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//raw初始化，缓存经过处理的音频数据</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.3 ] Create raw to receive data&quot;</span>);</span><br><span class="line"><span class="type">raw_stream_cfg_t</span> raw_cfg = &#123;</span><br><span class="line">    .out_rb_size = <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">    .type = AUDIO_STREAM_READER,    <span class="comment">//输入流</span></span><br><span class="line">&#125;;</span><br><span class="line">raw_read = raw_stream_init(&amp;raw_cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将各个车间流连接到流水线</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 3 ] Register all elements to audio pipeline&quot;</span>);</span><br><span class="line">audio_pipeline_register(pipeline, i2s_stream_reader, <span class="string">&quot;i2s&quot;</span>);</span><br><span class="line">audio_pipeline_register(pipeline, raw_read, <span class="string">&quot;raw&quot;</span>);</span><br><span class="line">audio_pipeline_register(pipeline, filter, <span class="string">&quot;filter&quot;</span>);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 4 ] Link elements together [codec_chip]--&gt;i2s_stream--&gt;filter--&gt;raw--&gt;[SR]&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *link_tag[<span class="number">3</span>] = &#123;<span class="string">&quot;i2s&quot;</span>, <span class="string">&quot;filter&quot;</span>, <span class="string">&quot;raw&quot;</span>&#125;;</span><br><span class="line">audio_pipeline_link(pipeline, &amp;link_tag[<span class="number">0</span>], <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行流水线</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 5 ] waiting to be awake&quot;</span>);</span><br><span class="line">audio_pipeline_run(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取raw的音频到buffer</span></span><br><span class="line">    raw_stream_read(raw_read, (<span class="type">char</span> *)buffer, size * <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">    <span class="keyword">if</span> (enable_wn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测buffer是否有唤醒词</span></span><br><span class="line">        <span class="keyword">if</span> (wakenet-&gt;detect(model_wn_data, (<span class="type">int16_t</span> *)buffer) == WAKE_UP)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            LED_ON;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;wake up&quot;</span>);</span><br><span class="line">            enable_wn = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mn_count++;</span><br><span class="line">        <span class="comment">//检测buffer中是否有命令词</span></span><br><span class="line">        <span class="type">int</span> commit_id = multinet-&gt;detect(model_mn_data, buffer);</span><br><span class="line">        <span class="comment">//进入命令词控制函数</span></span><br><span class="line">        <span class="keyword">if</span> (asr_multinet_control(commit_id) == ESP_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            LED_OFF;</span><br><span class="line">            enable_wn = <span class="literal">true</span>;</span><br><span class="line">            mn_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mn_count == mn_num)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;stop multinet&quot;</span>);</span><br><span class="line">            LED_OFF;</span><br><span class="line">            enable_wn = <span class="literal">true</span>;</span><br><span class="line">            mn_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 6 ] Stop audio_pipeline&quot;</span>);</span><br><span class="line"></span><br><span class="line">audio_pipeline_stop(pipeline);</span><br><span class="line">audio_pipeline_wait_for_stop(pipeline);</span><br><span class="line">audio_pipeline_terminate(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Terminate the pipeline before removing the listener */</span></span><br><span class="line">audio_pipeline_remove_listener(pipeline);</span><br><span class="line"></span><br><span class="line">audio_pipeline_unregister(pipeline, raw_read);</span><br><span class="line">audio_pipeline_unregister(pipeline, i2s_stream_reader);</span><br><span class="line">audio_pipeline_unregister(pipeline, filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release all resources */</span></span><br><span class="line">audio_pipeline_deinit(pipeline);</span><br><span class="line">audio_element_deinit(raw_read);</span><br><span class="line">audio_element_deinit(i2s_stream_reader);</span><br><span class="line">audio_element_deinit(filter);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 7 ] Destroy model&quot;</span>);</span><br><span class="line">wakenet-&gt;destroy(model_wn_data);</span><br><span class="line">model_wn_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line">buffer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>进入项目的配置程序</p>
<blockquote>
<p>idf.py menuconfig&gt;ESP Speech Recognition&gt;Add speech commands</p>
</blockquote>
<p>即可添加命令词</p>
<h4 id="优化语音识别"><a href="#优化语音识别" class="headerlink" title="优化语音识别"></a>优化语音识别</h4><p>相对于离线版，优化版除了具有本地的语音识别之外，还加入了百度的语音识别API，当本地的语音识别未能匹配到命令时，将音频数据发送到百度语音识别接口，并对返回的文本结果进行解析，逻辑如图（百度智能云语音识别返回结果是utf-8编码的字符串，所以代码编辑器中最好设置utf-8编码.）<br><img src="/killer-blog/ESP32/smart_control/9543ad2ae9994032886c3260f22b4c99.png" alt="在这里插入图片描述"><br><strong>语音模块的工作流程如下：</strong></p>
<p>麦克风输入的音频经过音频解码芯片，通过IIS进入到ESP32内存，经过降噪处理输入WakeNet检测是否存在唤醒词，若有唤醒词则进入语音识别，将音频输入MultiNet匹配命令词，同时缓存音频数据。</p>
<p>若匹配成功则会执行命令内容，若经过设置的时间（eg 4s）匹配失败，则将缓存的音频数据通过Baidu ASR发送到百度智能云并读取返回的文本结果，对结果解析出命令内容执行。</p>
<h3 id="2、BLE模块"><a href="#2、BLE模块" class="headerlink" title="2、BLE模块"></a>2、BLE模块</h3><p>ESP32支持蓝牙双模，目前仅使用蓝牙进行配网（即给esp32发送wifi名称和密码，使esp32连接到wifi）。所以使用ble更合适。</p>
<p>BLE（低功耗蓝牙），适合数据量较小的场合，ESP32支持完整的BLE协议栈，以ESP32作为BLE从机，发送广播、建立GATT Server并等待客户端连接。客户端以微信小程序BLE为例。小程序与ESP32蓝牙通信过程如下图：</p>
<p>ESP32建立一张profile、并创建一个wifi service、用于配置ESP32的wifi。小程序可向wii service 的相应属性中写入数据，来配置ESP32的wifi。</p>
<blockquote>
<p>如图，向SSID、PSWD、CONFIG分别写入下值，ESP32会自动连接到路由器esp</p>
</blockquote>
<p><img src="/killer-blog/ESP32/smart_control/e4f4c07f8b374693af52fc1b267c2fb0.png" alt="在这里插入图片描述"></p>
<h3 id="3、MQTT模块"><a href="#3、MQTT模块" class="headerlink" title="3、MQTT模块"></a>3、MQTT模块</h3><p>该模块使用mqtt_client库实现mqtt客户端进程的登陆，订阅，发布等功能。MQTT broker则使用华为云的设备接入IOT平台。</p>
<p>华为云平台为每个设备定义了以下多个主题，用于最基本的mqtt消息上传和下发，本模块参考了<a target="_blank" rel="noopener" href="https://support.huaweicloud.com/api-iothub/iot_06_v5_3011.html">设备接入Iota-&gt;API参考-&gt;设备侧mqtt接口参考</a><br><strong>上传</strong></p>
<ul>
<li><p>设备消息上报：设备无法按照产品模型中定义的属性格式进行数据上报时，将设备的自定义数据通过设备消息上报接口上报给平台，平台将设备上报的消息转发给应用服务器或华为云其他云服务上进行存储和处理。</p>
</li>
<li><p>设备属性上报：用于设备按产品模型中定义的格式将属性数据上报给平台。</p>
</li>
<li><p>网关批量属性上报：用于网关设备将多个设备的属性数据一次性上报给平台。</p>
</li>
<li><p>设备事件上报：用于设备按产品模型中定义的格式将事件数据上报给平台。</p>
</li>
</ul>
<p><strong>下发</strong></p>
<ul>
<li><p>平台消息下发：用于平台下发自定义格式的数据给设备。</p>
</li>
<li><p>平台设置设备属性：设备的产品模型中定义了平台可向设备设置的属性，应用服务器可通过属性设置的方式修改指定设备的属性值。</p>
</li>
<li><p>平台查询设备属性：应用服务器通过属性查询的方式，实时查询指定设备的属性数据。</p>
</li>
<li><p>平台命令下发：应用服务器按产品模型中定义的命令格式下发控制命令给设备。</p>
</li>
<li><p>平台事件下发：应用服务器按产品模型中定义的事件格式下发事件给设备。</p>
</li>
</ul>
<p>目前实现的软件框架如图所示：<br><img src="/killer-blog/ESP32/smart_control/ec02f9b0affc47ae88edbe62e6b827a5.png" alt="在这里插入图片描述"></p>
<h4 id="3-1、命令下发"><a href="#3-1、命令下发" class="headerlink" title="3.1、命令下发"></a>3.1、命令下发</h4><p>该功能实现参考<a target="_blank" rel="noopener" href="https://console.huaweicloud.com/iotdm/?region=cn-north-4&locale=zh-cn#/dm-portal/device/all-device/device-detail/60b9c9383744a602a5cb9bf3_smart_control_01?appId=7e7b135b6d664d92be89ed696290524d&productId=60b9c9383744a602a5cb9bf3">华为云平台命令下发文档</a><br>华为云平台下发的mqtt命令topic格式固定为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$oc/devices/&#123;device_id&#125;/sys/commands/request_id=&#123;request_id&#125; </span><br></pre></td></tr></table></figure>
<p>数据段中的json数据是命令的具体内容（由用户定义），如空调的控制命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;paras&quot;</span>:&#123;<span class="string">&quot;ac_power&quot;</span>:<span class="number">1</span>,<span class="string">&quot;ac_temp&quot;</span>:<span class="number">27</span>,<span class="string">&quot;ac_wind_speed&quot;</span>:<span class="number">2</span>,<span class="string">&quot;ac_mode&quot;</span>:<span class="number">0</span>&#125;,<span class="string">&quot;service_id&quot;</span>:<span class="string">&quot;ac_control&quot;</span>,<span class="string">&quot;command_name&quot;</span>:<span class="string">&quot;ac_control&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2、设备属性上报"><a href="#3-2、设备属性上报" class="headerlink" title="3.2、设备属性上报"></a>3.2、设备属性上报</h4><p>设备端可主动上报设备的属性（空调的状态，温度），mqtt消息发布的topic为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topic: $oc/devices/&#123;device_id&#125;/sys/properties/report  </span><br></pre></td></tr></table></figure>
<p>并将设备属性以json格式放在数据段中。</p>
<h4 id="3-3、平台查询设备属性"><a href="#3-3、平台查询设备属性" class="headerlink" title="3.3、平台查询设备属性"></a>3.3、平台查询设备属性</h4><p>平台通过给该设备主题发布消息，通知设备端上报属性信息，主题格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$oc/devices/&#123;device_id&#125;/sys/properties/get/request_id=&#123;request_id&#125;</span><br></pre></td></tr></table></figure>
<p>数据段为json数据，包含要求上报的属性。</p>
<h4 id="3-4、应用侧接口"><a href="#3-4、应用侧接口" class="headerlink" title="3.4、应用侧接口"></a>3.4、应用侧接口</h4><p>还可以通过华为云提供的应用侧接口，查询，控制设备的信息，实现在手机&#x2F;网页端对设备的管理。</p>
<h3 id="4、音频播放模块"><a href="#4、音频播放模块" class="headerlink" title="4、音频播放模块"></a>4、音频播放模块</h3><p>本项目板子上装备了两个喇叭，可以用于播放音频，可播放 本地音频 和 网络音频流 。如图所示，由于嵌入式设备内存有限，故本地音频主要是一些简单的提示语音，其优点是播放速度快，响应及时；而HTTP音频流能灵活播放音频，但其受限于网络环境，故将二者结合互补。<br><img src="/killer-blog/ESP32/smart_control/dadd9504768e4ec4b2890331e80c3bab.png" alt="在这里插入图片描述"></p>
<h4 id="4-1、播放本地mp3"><a href="#4-1、播放本地mp3" class="headerlink" title="4.1、播放本地mp3"></a>4.1、播放本地mp3</h4><p>该模块的实现方式是在PC端，将mp3文件转换成二进制的音频文件，将音频文件嵌入到芯片的flash中。在程序运行时可通过读取flash中的二进制音频文件，经过mp3解码，输出到音频芯片播放。</p>
<p>由于flash大小有限，故音频文件只能很短小，适合一些提示性短语，其播放速度也更快。<br>具体实现细节，参考：<a href="/killer-blog/ESP32/esp32adf_play_mp3">esp32播放本地mp3</a></p>
<h4 id="4-3、文本转语音"><a href="#4-3、文本转语音" class="headerlink" title="4.3、文本转语音"></a>4.3、文本转语音</h4><p>文本转语音的核心就是依靠百度AI平台的文本转语音接口，设备端只需要准备好文本数据，发送到AI平台的文本转语音接口，并从该接口中获取音频数据，将该音频数据输出到音频芯片进行播放。</p>
<p>实现的详细代码参考：<br><a href="/killer-blog/ESP32/ESP32_baidu_SpeechSynthesis">esp32a1s 百度文本转语音实现</a></p>
<h3 id="5、红外模块"><a href="#5、红外模块" class="headerlink" title="5、红外模块"></a>5、红外模块</h3><p>目前的家具，电器中，仍有很多电器使用红外遥控，特别是空调。同类型的设备使用的红外协议大同小异，并且都可以查看其协议内容。</p>
<p>红外模块可发送不同类型，品牌的产品的红外控制信号，同时具备<strong>学习功能</strong>，能通过遥控器，学习设备的红外协议。</p>
<h4 id="5-1、红外发射"><a href="#5-1、红外发射" class="headerlink" title="5.1、红外发射"></a>5.1、红外发射</h4><p>红外遥控是通过特定的LED发射信号，设备接收该信号来响应。</p>
<p>在ESP32端来看，所有的红外信号都可看成一个方波信号，ESP32只要能产生所需要的方波信号，结合发射硬件，就能实现红外发射。ESP32中提供了一个叫RMT控制器的设备来控制信号，可利用该RMT控制器，产生所需的方波信号。</p>
<p>如何使用RMT产生方波，可参考：<a href="/killer-blog/ESP32/esp32_ir_control">红外发射与接收</a>；</p>
<p>了解了如何产生方波，但更重要的是如何获取方波信号的电平状态和持续时长，这些信息就是红外传输的具体内容。很幸运的是，一些开源红外遥控码库提供了这些信息，本模块使用的Irext就是一个开源万能红外遥控码库、编解码压缩算法以及免费周边服务。</p>
<p>将所需要的码库二进制文件下载到文件系统，就能在程序运行时，通过文件系统打开码库，输入电器类型及遥控命令，即可生成一个特定的数组，该数组表示了方波信号的电平高低及电平时长，即可产生所需的方波信号。</p>
<p>如何使用irext实现该功能，请参考：<a href="/killer-blog/ESP32/esp32_IREXT">基于irext实现万能遥控器</a></p>
<h4 id="5-2、红外学习"><a href="#5-2、红外学习" class="headerlink" title="5.2、红外学习"></a>5.2、红外学习</h4><p>红外学习主要用于快速配置空调协议。用本地空调遥控器，给esp32发射<code>制冷模式 开机 26° 一级风速 自动扫风</code>的特定命令，程序会从本地码库中匹配对应的协议。</p>
<p>红外接收的重点是解析输入的信号并将其与本地数据库进行匹配。目前由人工分别完成了对格力，美的，海尔三种空调的不同协议的分析并生成数据库，并在代码中实现对他们的识别。</p>
<p>红外接收任务负责接收与识别的实现，由parse_items()和ir_code_lib_update()完成信号识别，匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到的红外信号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RX_signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> item_num;  <span class="comment">//item数量</span></span><br><span class="line">    <span class="type">uint32_t</span> lowlevel;  <span class="comment">//低电平时间 us</span></span><br><span class="line">    <span class="type">uint32_t</span> highlevel_1;   <span class="comment">//高电平1的时间</span></span><br><span class="line">    <span class="type">uint32_t</span> highlevel_0;   <span class="comment">//高电平0的时间</span></span><br><span class="line">    <span class="type">uint32_t</span> encode;    <span class="comment">//由0和1组成的编码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 红外接收任务 rmt_rx_start()执行后才会接收数据</span></span><br><span class="line"><span class="comment"> * 接收的数据以item的数据结构存放到nvs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rmt_ir_rxTask</span><span class="params">(<span class="type">void</span> *agr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rx_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    RingbufHandle_t rb = <span class="literal">NULL</span>;</span><br><span class="line">    rmt_get_ringbuf_handle(rx_channel, &amp;rb); <span class="comment">//获取红外接收器接收的数据 放在ringbuff中</span></span><br><span class="line"></span><br><span class="line">    rmt_rx_stop(rx_channel); <span class="comment">//暂停接收</span></span><br><span class="line">    <span class="keyword">while</span> (rb)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从ringbuff读取items 会进入阻塞 直到ringbuff中有新的数据</span></span><br><span class="line">        <span class="type">rmt_item32_t</span> *item = (<span class="type">rmt_item32_t</span> *)xRingbufferReceive(rb, &amp;rx_size, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span> (item)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;rx_size = %u&quot;</span>, rx_size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//!红外线接收器有干扰，需要滤波</span></span><br><span class="line">            <span class="keyword">if</span> (rx_size &gt; <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">RX_signal</span> <span class="title">sig</span>;</span>   <span class="comment">//接收信号结构体</span></span><br><span class="line">                <span class="type">size_t</span> item_num = rx_size / <span class="number">4</span>;  <span class="comment">//一个item32bit</span></span><br><span class="line">                sig.item_num = item_num;</span><br><span class="line">                sig.highlevel_1 = <span class="number">0</span>;</span><br><span class="line">                sig.highlevel_0 = <span class="number">0</span>;</span><br><span class="line">                sig.encode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解析item</span></span><br><span class="line">                parse_items(item, item_num, &amp;sig);</span><br><span class="line"></span><br><span class="line">                ir_code_lib_update(&amp;sig); <span class="comment">//更新ac_handle</span></span><br><span class="line">                rmt_rx_stop(rx_channel);  <span class="comment">//暂停接收</span></span><br><span class="line">                xSemaphoreGive(IR_sem);   <span class="comment">//释放信号量</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析出数据后释放ringbuff的空间</span></span><br><span class="line">            vRingbufferReturnItem(rb, (<span class="type">void</span> *)item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="6、传感器模块"><a href="#6、传感器模块" class="headerlink" title="6、传感器模块"></a>6、传感器模块</h3><p>目前我们的板子上添加了ds18b20温度传感器，用于准确的读取室内的温度。</p>
<h3 id="7、定时模块"><a href="#7、定时模块" class="headerlink" title="7、定时模块"></a>7、定时模块</h3><p>定时模块主要用于记录当前的年份，月份，日期，时间，提供精确到秒的定时提醒服务，支持大时间尺度上的定时，如一天，两天甚至更长时间的定时提醒。其定时的时钟源是freertos的系统时钟。<br>其实现参考博客：<a href="/killer-blog/ESP32/esp32_time_system">基于esp32 的时间系统</a></p>
<h3 id="8，无线检测模块"><a href="#8，无线检测模块" class="headerlink" title="8，无线检测模块"></a>8，无线检测模块</h3><p>暂时未完成，预期功能为：能实时检测人体&#x2F;物体在一定空间内的活动状态，如人体是否静止OR活动中，从而来判断空间内是否有人类活动。</p>
<p>其工作原理是利用ESP32的wifi无线信号在复杂空间中传播时，在发送端和接收端之间因为物体移动影响电磁波的多径效应，可用系统的信道频率响应来描述多径传播特性。</p>
<h4 id="8-1、使用相关系数进行人体检测"><a href="#8-1、使用相关系数进行人体检测" class="headerlink" title="8.1、使用相关系数进行人体检测"></a>8.1、使用相关系数进行人体检测</h4><p>根据谈青青的论文，wifi子载波之间相关系数会随着空间环境的变换而变换，当室内无人体活动时，各个载波之间的相关系数相对小，当空间内有人活动时，各个载波会因人体活动而产生变换，此时相关系数会增大。</p>
<p>我的实验：提取2s内的载波振幅，计算相关系数，发现无论何种情况，大部分的子载波的相关系数都接近1，与论文不是很符合，且人体的活动反而导致了相关系数的减小，与论文也不符合。但初期的实验确实证实相关系数可以 反映人体的活动。</p>
<h4 id="8-2、使用振幅平均值进行人体检测"><a href="#8-2、使用振幅平均值进行人体检测" class="headerlink" title="8.2、使用振幅平均值进行人体检测"></a>8.2、使用振幅平均值进行人体检测</h4><p>根据其他论文，一定时间窗口2s内，计算载波的振幅的均值。当空间环境稳定的情况下，振幅均值应该不会出现过大的波动，当人体活动时，振幅均值会受到影响而产生波动。对于esp32的51条子载波，不同的子载波对活动的灵敏度不一样。有的子载波会产生较大的波动，而有的子载波没有明显变化。描述子载波的幅度均值变化程度可以用方差，但实验过程中，全部子载波的方差值似乎不能很好的反映人体活动。但单独一条子载波的振幅均值对人体活动却比较敏感。</p>
<h4 id="8-3、路由器与esp32相对位置对实验的影响"><a href="#8-3、路由器与esp32相对位置对实验的影响" class="headerlink" title="8.3、路由器与esp32相对位置对实验的影响"></a>8.3、路由器与esp32相对位置对实验的影响</h4><p>实验路由器有两种：一般路由器和手机热点。在相关系数实验中，以手机热点为路由的人体检测预期较好，但换成一般路由器则效果很差。</p>
<p>将路由器摆放到较高位置进行实验，实验效果也不明显。</p>
<p><img src="/killer-blog/ESP32/smart_control/20210329225345207.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/" class="post-title-link" itemprop="url">解决ESP32 SRAM不足的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:12:50" itemprop="dateModified" datetime="2025-06-02T10:12:50+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="解决ESP32-SRAM不足的问题"><a href="#解决ESP32-SRAM不足的问题" class="headerlink" title="解决ESP32 SRAM不足的问题"></a>解决ESP32 SRAM不足的问题</h1><h2 id="一，为什么需要外部RAM"><a href="#一，为什么需要外部RAM" class="headerlink" title="一，为什么需要外部RAM"></a>一，为什么需要外部RAM</h2><p>  ESP32有520kB的内部RAM空间可以使用，这对于一般的情况是够用的，但是<strong>如果设备需要涉及音频或者显示图像等处理时，需要更大的内存空间来处理这些数据。ESP32支持扩展外部RAM</strong>，其实乐鑫已经在其ESP32 WROVER系列模组中集成了一个4M大小的外部PSRAM。乐鑫官网文档对外部RAM作了详解：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/external-ram.html?highlight=RAM">片外RAM</a></p>
<p>乐鑫对于ESP32 WROVER的介绍也是：</p>
<blockquote>
<p>ESP32-WROVER 系列模组基于 ESP32-D0WD 双核芯片设计，其强大的双核性能适用于对内存需求大的应用场景，例如多样的 AIoT 应用和网关应用。</p>
</blockquote>
<p><strong>如果你的设备需要使用大内存，例如wifi与ble并存，音频处理和图像显示功能</strong>，推荐使用这个模组。</p>
<h2 id="二-快速上手外部RAM"><a href="#二-快速上手外部RAM" class="headerlink" title="二 快速上手外部RAM"></a>二 快速上手外部RAM</h2><h3 id="2-1-使能外部RAM"><a href="#2-1-使能外部RAM" class="headerlink" title="2.1 使能外部RAM"></a>2.1 使能外部RAM</h3><p><strong>首先必须确保你的芯片是有外部RAM的</strong>。例如ESP32 WROVER模组。<br>进入<code>idf.py menuconfig-&gt;component config-&gt;ESP32-specific</code><br>在下图的<code>Support for external,SPI-connected RAM</code>选项中按<code>y</code>选中,这样就使能了外部RAM。</p>
<p><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201021185500107.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-配置外部RAM"><a href="#2-2-配置外部RAM" class="headerlink" title="2.2 配置外部RAM"></a>2.2 配置外部RAM</h3><p>进入下一行的<code>SPI RAM config</code>进行配置更多的细节。这里讲一下比较重要的配置选项。</p>
<p><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201105104341985.png" alt="在这里插入图片描述"></p>
<h4 id="2-2-1-第二项配置系统的动态内存分配功能"><a href="#2-2-1-第二项配置系统的动态内存分配功能" class="headerlink" title="2.2.1 第二项配置系统的动态内存分配功能"></a>2.2.1 第二项配置系统的动态内存分配功能</h4><p>有三个选项，当选择<code>Make RAM allocatable using heap_caps_malloc(..., M</code>时，需要在代码中使用<code>heap_caps_malloc()</code>函数才能在外部RAM中分配内存。</p>
<p><strong>当选择<code>Make RAM allocatable using malloc() as well</code>时，代码中malloc()函数会自动从外部RAM中分配内存。</strong><br><strong>当使能这个选项时，还能配置第九行<code> Maximum malloc() size, in bytes, to always put in internal memory</code>，该配置设置了一个阈值，这里我设置的是1024bytes，当使用malloc()分配内存时，如果分配的内存小于1024字节，就会从内部RAM中分配，否则从外部RAM中分配。</strong></p>
<h4 id="2-2-2-将BSS段添加到外部RAM"><a href="#2-2-2-将BSS段添加到外部RAM" class="headerlink" title="2.2.2 将BSS段添加到外部RAM"></a>2.2.2 将BSS段添加到外部RAM</h4><p>第13行中选择<code>Allow .bss segment placed in external memory</code>,可以将BSS段的lwip、net80211、libpp 和 bluedroid ESP-IDF 库中零初始化的数据存入外部RAM。<strong>此外全局变量，静态变量也可以放到外部RAM中，只需要在变量声明的地方加上宏EXT_RAM_ATTR,并将变量初始化为0。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXT_RAM_ATTR <span class="type">static</span> <span class="type">int</span> num[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-其他可放入外部RAM的数据"><a href="#2-2-3-其他可放入外部RAM的数据" class="headerlink" title="2.2.3 其他可放入外部RAM的数据"></a>2.2.3 其他可放入外部RAM的数据</h4><p>第十行<code>Try to allocate memories of WiFi and LWIP in SPIRAM firstly. If failed, allocate inter</code>会尝试优先使用外部RAM给wifi与lwip协议栈分配内存，如果失败则会使用内部RAM分配。</p>
<h4 id="2-2-4-创建静态任务"><a href="#2-2-4-创建静态任务" class="headerlink" title="2.2.4 创建静态任务"></a>2.2.4 创建静态任务</h4><p>xTaskCreate()会使用内部RAM给任务分配任务堆栈。而使用xTaskCreateStatic()系统会检查传入的buff数组是否是属于内部RAM的。</p>
<p><strong>但对于不以任何方式直接或间接调用 ROM 中代码的任务,选项 <code>Allow external memory as an argument to xTaskCreateStatic</code> 将解除 xTaskCreateStatic 中的检查，从而允许任务堆栈存储在外部 RAM 中。但是，不建议使用此方法。</strong></p>
<p>实际使用过程中我也发现使用该函数创建任务会出现assert error的错误，不知道具体的原因是什么，希望了解的大佬解答一下。</p>
<h4 id="2-2-5-修改分区表"><a href="#2-2-5-修改分区表" class="headerlink" title="2.2.5 修改分区表"></a>2.2.5 修改分区表</h4><p>由于使用了外部RAM会使<code>partitionstable.bin</code>增加，0x8000的偏移地址会出现覆盖，所以需要修改分区表和partitionstable.bin的偏移地址：<br><code>idf.py menuconfig-&gt;Partition Table</code>修改成<code>0x10000</code><br>如果使用本地的分区表，还需要将分区表修改如下</p>
<p>这是由于partitionstable.bin默认是起始地址0x8000修改成0x10000后，由于其占用0xc00大小的空间，而nvs要实现内存对齐，至少要在0x11000处开始.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size</span><br><span class="line">nvs,      data, nvs,     <span class="number">0x11000</span>,  <span class="number">0x4000</span>,</span><br><span class="line">phy_init, data, phy,     <span class="number">0x15000</span>,  <span class="number">0x1000</span>,</span><br><span class="line">factory,  app,  factory, <span class="number">0x20000</span>, <span class="number">0x300000</span>,</span><br><span class="line">flash_tone,data, <span class="number">0x04</span>,   <span class="number">0x320000</span>,  <span class="number">50</span>k,</span><br></pre></td></tr></table></figure>

<p><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201021200158516.png" alt="在这里插入图片描述"></p>
<h2 id="三-深度解放内部RAM"><a href="#三-深度解放内部RAM" class="headerlink" title="三 深度解放内部RAM"></a>三 深度解放内部RAM</h2><p>IRAM是内部RAM，当我使用wifi+ble+ASR组成的一个工程时，编译后出现<strong>Section .iram0.text will not fit in region iram0_0_seg</strong>的错误，原因是IRAM的内存空间仍然不够，这是因为任务堆栈等数据是不能存放在外部RAM中的，所以IRAM中的内存依然紧张。</p>
<p>解决办法是参考 <a target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/issues/2566">https://github.com/espressif/esp-idf/issues/2566</a></p>
<p><strong>原理就是关闭一些网络功能的优化来减少IRAM的使用</strong>：<br>按照这位老哥的说法，将wifi，lwip的优化功能关闭，以减少IRAM的占用，这样下来能省出大约<code>37KB</code>的内存。这样就能正常的编译运行了。<br><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201021190227819.png" alt="在这里插入图片描述"><br><strong>具体步骤如下</strong>：<br><code>idf.py menuconfig-&gt;component config-&gt;Wi-Fi,</code>将箭头所指的两项按n取消选择<br><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201021190554827.png" alt="在这里插入图片描述"><br>lwip部分同理：进入<code>idf.py menuconfig-&gt;component config-&gt;LWIP</code>,取消箭头所指。</p>
<p><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201021190654481.png" alt="在这里插入图片描述"></p>
<h2 id="四-使用效果"><a href="#四-使用效果" class="headerlink" title="四 使用效果"></a>四 使用效果</h2><p>使用外部RAM前，可用的内存只有几十K，开启外部RAM后，可用的内存增加了<code>几十</code>倍，我使用内存获取函数，打印出内存的使用情况：</p>
<p>下图表示SPI RAM初始化成功。<br><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201105111102612.png" alt="在这里插入图片描述"></p>
<p><strong>下图信息说明，外部RAM可用的内存为4049k bytes，当freertos开始运行，进入main函数后，esp_get_free_heap_size()获取到的可用内存为4253k bytes，这是由内部RAM和外部RAM的所有可用的内存的总和，大概可知道可用的内部RAM只有约200k bytes。可见外部RAM极大的扩展了可用内存。</strong></p>
<p><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201105111321645.png" alt="在这里插入图片描述"></p>
<h2 id="五，小结"><a href="#五，小结" class="headerlink" title="五，小结"></a>五，小结</h2><p>由于外部RAM足足有4M 大小，使得esp32在应对语音，图像时依然能应对，对于一个使用了wifi，ble，lwip或者语音识别的程序来说，这4M的内存是必须的。</p>
<p><img src="/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/20201021191307524.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/esp32adf_play_mp3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/esp32adf_play_mp3/" class="post-title-link" itemprop="url">ESP32 ADF 实现播放MP3音频</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 09:57:14" itemprop="dateModified" datetime="2025-06-02T09:57:14+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ESP32-ADF-实现播放MP3音频"><a href="#ESP32-ADF-实现播放MP3音频" class="headerlink" title="ESP32 ADF 实现播放MP3音频"></a>ESP32 ADF 实现播放MP3音频</h1><h2 id="播放本地mp3"><a href="#播放本地mp3" class="headerlink" title="播放本地mp3"></a>播放本地mp3</h2><p>参考例程<code>esp-adf\examples\player\pipeline_flash_tone</code>，其思路是在PC端将多个mp3文件合并成一个二进制的文件，并在分区别中将为文件设置<strong>flash_tone</strong>空间。最后将该文件烧录到指定的地址中，在程序中调用flash_tone的接口函数就能读取到mp3.</p>
<h3 id="一、制作二进制音频文件"><a href="#一、制作二进制音频文件" class="headerlink" title="一、制作二进制音频文件"></a>一、制作二进制音频文件</h3><p>使用ADF提供的mk_audio_bin.py脚本来生成上述二进制文件。</p>
<p><strong>mk_audio_bin.py的作用是将当前目录下的MP3和wav文件集合生成一个<code>audio-esp.bin</code>的音频文件，并在<code>main/audio</code>目录下生成audio_tone_uri.h和audio_tone_uri.c。</strong></p>
<p><a target="_blank" rel="noopener" href="https://wwe.lanzoui.com/iRoNYtdueub">mk_audio_bin.py下载地址：https://wwe.lanzoui.com/iRoNYtdueub</a></p>
<p>首先安装python2.7，将mp3文件放在mk_audio_bin.py的同一目录下，执行下面命令生成二进制文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 mk_audio_bin.py</span><br></pre></td></tr></table></figure>

<h3 id="二、修改分区表"><a href="#二、修改分区表" class="headerlink" title="二、修改分区表"></a>二、修改分区表</h3><p>在分区表partitions.csv中添加一项</p>
<blockquote>
<p>flash_tone,data, 0x04,   0x320000,  0xc800,</p>
</blockquote>
<p>表示添加一个名称为flash_tone的分区，其分区类型是data，子类型是0x4，在flash中的偏移地址是0x320000，这个地址也说烧录地址，分区大小为0xc800，也就是100k。</p>
<h3 id="三、在代码中使用"><a href="#三、在代码中使用" class="headerlink" title="三、在代码中使用"></a>三、在代码中使用</h3><p>需要在main目录下的Makefile文件中，添加audio_tone_uri.c：</p>
<blockquote>
<p>set(COMPONENT_SRCS “.&#x2F;audio&#x2F;audio_tone_uri.c”)</p>
</blockquote>
<p>代码中具体使用参考ADF的examples&#x2F;player&#x2F;pipeline_flash_tone&#x2F;main&#x2F;play_tone_mp3_example.c</p>
<h3 id="四、烧录"><a href="#四、烧录" class="headerlink" title="四、烧录"></a>四、烧录</h3><p>使用你的烧录工具，将audio-esp.bin和程序烧录到芯片。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://tools.bugscaner.com/tts/">在线文字转语音</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/deflypig/article/details/100182475">python2和python3共存 安装</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/esp32adfsetup_in_window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/esp32adfsetup_in_window/" class="post-title-link" itemprop="url">搭建ESP32A1S的ADF开发环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:11:44" itemprop="dateModified" datetime="2025-06-02T10:11:44+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="搭建ESP32A1S的ADF开发环境"><a href="#搭建ESP32A1S的ADF开发环境" class="headerlink" title="搭建ESP32A1S的ADF开发环境"></a>搭建ESP32A1S的ADF开发环境</h1><p>@[toc]</p>
<h2 id="一，获取IDF和IDF-TOOL"><a href="#一，获取IDF和IDF-TOOL" class="headerlink" title="一，获取IDF和IDF-TOOL"></a>一，获取IDF和IDF-TOOL</h2><p>adf是乐鑫的音频开发框架，里面有许多乐鑫的音频开发API，同时ADF是基于IDF的。<br>这一部分可以按照官网的教程一步一步来。<br>官网教程地址：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/get-started/index.html#get-started-setup-esp-idf">ADF安装指南</a><br><em><strong>首先下载esp-idf，如果是第一次使用idf，可以在官网下载一个<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/get-started/windows-setup.html#get-started-windows-tools-installer">idf工具安装器</a>，通过这个安装器直接安装idf，同时还可以安装编译工具链。下载的速度也还可以接受。大概三十分钟就可以搞定。</strong></em></p>
<blockquote>
<p>本安装器可为您安装所需的交叉编译器、OpenOCD、cmake 和 Ninja 编译工具，以及一款 mconf-idf 配置工具。此外，本安装器还可在有需要时下载、运行 Python 3.7 和 Git For Windows 的安装器。本安装器还可用于下载任意 ESP-IDF 发布版本。</p>
</blockquote>
<p>下载完安装器后直接运行如下（安装器运行时需要python3和git的支持）：</p>
<p><img src="/killer-blog/ESP32/esp32adfsetup_in_window/2020080914172936.png" alt="在这里插入图片描述"><br>选择要安装的idf的<code>3.3</code>版本，记住路径不要有空格。<em><strong>使用ADF开发时最好用3.3的idf，比较稳定不会出错</strong></em><br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200810201832419.png" alt="在这里插入图片描述"></p>
<p>接下来是选择idf-tool的安装路径：<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200809142013990.png" alt="在这里插入图片描述"><br>等个半小时左右安装完成。测试工具链能不能正常工作。我们的桌面会生成这一个cmd<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200809142212112.png" alt="在这里插入图片描述">双击运行后它会自动为我们设置idf_path等编译需要的环境变量，我们直接cd到idf里examples里一个工程，例如：<br><code>D:\ESP\idf3.3\examples\get-started\hello_world</code><br>然后执行<code>idf.py build</code><br>如果编译成功的话就说明编译工具和idf安装成功。</p>
<h2 id="二，安装ADF"><a href="#二，安装ADF" class="headerlink" title="二，安装ADF"></a>二，安装ADF</h2><p>乐鑫把ADF放在了github，仓库地址是：<a target="_blank" rel="noopener" href="https://github.com/espressif/esp-adf">https://github.com/espressif/esp-adf</a>；<br>这是一个带子模块的仓库，如何加速下载请参考博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/107574297">提升github下载速度</a>里带子模块的下载。<br><strong>步骤：创建ESP文件夹，然后cmd，执行以下命令克隆仓库:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitclone.com/github.com/espressif/esp-adf.git</span><br></pre></td></tr></table></figure>

<p><strong>等待clone完成后，再打开<code>esp-adf</code>目录下的<code>.gitsubmodules</code>文件,可以看到该目录下有三个子模块仓库：<br>idf模块，esp-adf-libs模块：adf音频库，esp-sr：识别语音库</strong><br>在<code>esp-adf-libs</code>目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitclone.com/github.com/espressif/esp-adf-libs</span><br></pre></td></tr></table></figure>
<p>在<code>esp-sr</code>目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitclone.com/github.com/espressif/esp-sr.git</span><br></pre></td></tr></table></figure>
<p>在<code>esp-idf</code>目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitclone.com/github.com/espressif/esp-idf</span><br></pre></td></tr></table></figure>

<p>以上仓库下载完成后，修改<code>adf目录下.gitsubmodules</code>的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">&quot;esp-idf&quot;</span>]</span><br><span class="line">	path = esp-idf</span><br><span class="line">	url = https://gitclone.com/github.com/espressif/esp-idf</span><br><span class="line">[submodule <span class="string">&quot;components/esp-adf-libs&quot;</span>]</span><br><span class="line">	path = components/esp-adf-libs</span><br><span class="line">	url = https://gitclone.com/github.com/espressif/esp-adf-libs</span><br><span class="line">[submodule <span class="string">&quot;components/esp-sr&quot;</span>]</span><br><span class="line">	path = components/esp-sr</span><br><span class="line">	url = https://gitclone.com/github.com/espressif/esp-sr.git</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>当两个仓库下载完成后 在<code>adf</code>目录下cmd执行<code>git submodule update --init</code></strong>，<strong>这一步将两个子模块切换到当前ADF要求的版本。至此ADF已经完成安装，这时要测试一下ADF是否能编译成功。打开之前的桌面cmd，<code>需要注意的是，在每次打开cmd之前要设置ADF_PATH</code><br>在cmd执行<code>set ADF_PATH=你的ADF目录</code>例如我的是：<code>set ADF_PATH=D:\ESP\esp-adf</code>，（路径不要有空格<br>或者在<code>ESP\.espressif</code>目录下添加该语句，如图，一劳永逸：</strong><br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200911145513313.png" alt="在这里插入图片描述"></p>
<p><strong>然后cd到随便ADF目录下examples下随意一个工程，与之前一样<code>idf.py build</code>测试能否成功通过编译。</strong></p>
<h2 id="三，适配ADF到ESP32A1S"><a href="#三，适配ADF到ESP32A1S" class="headerlink" title="三，适配ADF到ESP32A1S"></a>三，适配ADF到ESP32A1S</h2><p>由于ADF里是没有ESP32A1S的初始化代码的，所以需要自己添加进去。</p>
<p><strong>1，首先修改<code>esp-adf\components\audio_board</code>目录下的三个配置文件，如下：</strong><br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200809144825414.png" alt="在这里插入图片描述"><br>1.1，CMakeLists.txt 添加内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONFIG_ESP_AI_THINKER_V2_2_BOARD)</span><br><span class="line">message(STATUS <span class="string">&quot;Current board name is &quot;</span> CONFIG_ESP_AI_THINKER_V2_2_BOARD)</span><br><span class="line">list(APPEND COMPONENT_ADD_INCLUDEDIRS ./ai_thinker_audio_kit_v2_2)</span><br><span class="line"><span class="built_in">set</span>(COMPONENT_SRCS</span><br><span class="line">./ai_thinker_audio_kit_v2_2/board.c</span><br><span class="line">./ai_thinker_audio_kit_v2_2/board_pins_config.c</span><br><span class="line">)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>1.2，compoment.mk 添加如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdef CONFIG_ESP_AI_THINKER_V2_2_BOARD</span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS += ./ai_thinker_audio_kit_v2_2</span><br><span class="line">COMPONENT_SRCDIRS += ./ai_thinker_audio_kit_v2_2</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>1.3，Kconfig.projbuild 修改如下<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/2020080914513124.png" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">choice AUDIO_BOARD</span><br><span class="line">    prompt <span class="string">&quot;Ai-Thinker Audio board&quot;</span></span><br><span class="line">    default ESP_AI_THINKER_V2_2_BOARD</span><br><span class="line">    <span class="built_in">help</span></span><br><span class="line">        Select an audio board to use with the ESP-ADF</span><br><span class="line">config AUDIO_BOARD_CUSTOM</span><br><span class="line">    bool <span class="string">&quot;Custom audio board&quot;</span></span><br><span class="line">config ESP_LYRAT_V4_3_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32-Lyrat V4.3&quot;</span></span><br><span class="line">config ESP_LYRAT_V4_2_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32-Lyrat V4.2&quot;</span></span><br><span class="line">config ESP_LYRATD_MSC_V2_1_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32-LyraTD-MSC V2.1&quot;</span></span><br><span class="line">config ESP_LYRATD_MSC_V2_2_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32-LyraTD-MSC V2.2&quot;</span></span><br><span class="line">config ESP_LYRAT_MINI_V1_1_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32-Lyrat-Mini V1.1&quot;</span></span><br><span class="line">config ESP32_KORVO_DU1906_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32_KORVO_DU1906&quot;</span></span><br><span class="line">config ESP32_S2_KALUGA_1_V1_2_BOARD</span><br><span class="line">    bool <span class="string">&quot;ESP32-S2-Kaluga-1 v1.2&quot;</span></span><br><span class="line">config ESP_AI_THINKER_V2_2_BOARD   </span><br><span class="line">    bool <span class="string">&quot;ESP32-AiThinker-audio V2.2&quot;</span></span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>


<p>1.4 <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1B_MmV_SK1fMe7AtmEfvCTA">下载ai_thinker_audio_kit_v2_2</a>，<strong>提取码：kill</strong></p>
<p>添加<code>ai_thinker_audio_kit_v2_2</code>文件夹到<code>esp-adf\components\audio_board</code>目录下，board.c是板子的初始化代码，board_def.h是对板子IO口的定义， board_pins_config.c是配置iis和iic的IO<br>引脚的代码。</p>
<p><strong>2，添加音频驱动文件，修改<code>esp-adf\components\audio_hal</code>文件夹下的CMakeLists.txt和compoment.mk</strong><br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200809145422861.png" alt="在这里插入图片描述"><br>2.1 CMakeLists.txt 修改后如下<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/2020080914561261.png" alt="在这里插入图片描述"><br>2.2 compoment.mk 添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_ADD_INCLUDEDIRS += ./driver/ac101</span><br><span class="line">COMPONENT_SRCDIRS += ./driver/ac101</span><br></pre></td></tr></table></figure>
<p>2.3 在driver文件夹下新建ac101文件夹，并添加ac101.c和ac101.h驱动文件。<a target="_blank" rel="noopener" href="https://wws.lanzous.com/iETsVfg6sni">ac101驱动下载</a><br><strong>至此，移植完成！接下来就是测试了。老套路打开cmd，设置ADF_PATH，然后cd到测试项目，先执行<code>idf.py menuconfig</code>叫出配置菜单来切换A1S开发板。在<code>Audio HAL</code>选项中选择安信可的板子，然后<code>save</code>保存配置，最后<code>idf.py build</code>.(第一次编译大概5分钟把)</strong><br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/2020080915021254.png" alt="在这里插入图片描述"><br>出现以下画面时就是编译通过：<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200809150325969.png" alt="在这里插入图片描述"><br><strong>最后进行烧录，插入开发板，查看开发板的端口号 例如我的是COM4,接着执行<code>idf.py -p  COM4 flash monitor</code>烧录进开发板的同时开启了串口监视器，可以看到串口打印</strong></p>
<h2 id="四，使用asr语音识别例程"><a href="#四，使用asr语音识别例程" class="headerlink" title="四，使用asr语音识别例程"></a>四，使用asr语音识别例程</h2><p>由于asr例程的app固件大于2M，所以需要修改项目分区表使app固件在flash有足够的内存空间，否则烧录后会出现以下错误：<br><img src="/2020081110095759.%60%E5%9C%A8%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E7%89%87%60png" alt="在这里插入图片描述"><br>步骤：<br>1，首先设置<code>menuconfig-&gt;Serial Flash config</code>,配置如下：<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200811101431911.png" alt="在这里插入图片描述"><br>2,设置项目使用本地分区表：<br><code>menuconfig-&gt;Partition Table-&gt;</code>,如下<br><img src="/killer-blog/ESP32/esp32adfsetup_in_window/20200811101635795.png" alt="在这里插入图片描述"><br>3，修改项目根目录下的partitions.csv，如下<br>修改factory的size为2M或者更大的内存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Espressif ESP32 Partition Table</span></span><br><span class="line"><span class="comment"># Name,   Type, SubType, Offset,  Size</span></span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 0x200000,</span><br></pre></td></tr></table></figure>





<p>参考文章：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xh870189248/article/details/104160104">esp32-a1s 音频开发板移植最新 esp-adf 音频框架</a><br><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/get-started/index.html#get-started-setup-esp-idf">ADF安装指南</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/gree_ir_code_parse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/gree_ir_code_parse/" class="post-title-link" itemprop="url">格力红外编码解析（简单易懂）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:20:53" itemprop="dateModified" datetime="2025-06-02T10:20:53+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="格力红外编码解析（简单易懂）"><a href="#格力红外编码解析（简单易懂）" class="headerlink" title="格力红外编码解析（简单易懂）"></a>格力红外编码解析（简单易懂）</h1><blockquote>
<p>使用红外遥控空调，就必须先了解红外遥控的原理，数据的定义等。本博客解析了空调的最基本的功能的红外编码，包括：开关，温度，定时，风速，扫风，校验码。其他的功能因为空调型号不同而差别较大，所以暂时不作解析。同时，空调大部分时间工作在制冷模式下，其他模式下的编码也暂时未解析。</p>
</blockquote>
<h2 id="一，红外遥控原理"><a href="#一，红外遥控原理" class="headerlink" title="一，红外遥控原理"></a>一，红外遥控原理</h2><h3 id="1，红外线"><a href="#1，红外线" class="headerlink" title="1，红外线"></a>1，红外线</h3><p>红外线是波长在760nm到1mm的电磁波，根据波长的不同可分为可见光（0.38um-0.76um）和不可见光。使用红外线作为遥控的话，由于红外发射管与红外接收管的响应波长一般为0.8um-0.94um，所以选择波长为0.76um-1.5um的红外光作为通讯的波长。</p>
<p>红外通信广泛应用于家电控制，其优点是抗干扰能力强（频率低），功耗小，性价比高等。</p>
<h3 id="2，工作原理"><a href="#2，工作原理" class="headerlink" title="2，工作原理"></a>2，工作原理</h3><p>发射器发射38khz方波为载波的红外光（占空比50），即红外光以38khz的频率闪烁着，接收器接收到以此频率闪烁的红外光时，会在其信号脚输出高电平信号，否则输出低电平。</p>
<p>根据这个最基本的原理来，来实现编码解码数据。数据就是一组二进制的数据，0和1的区别就是高低电平时间的不同。比如，以下例子中，0与1的区别就是1的高电平时间较长。发射器首先需要编码，根据二进制数据每一位的内容，发射持续时间不一样的红外光（控制低高电平时间），而接收器则需要判断高低电平的时间来解码数据。</p>
<h2 id="二，实验波形"><a href="#二，实验波形" class="headerlink" title="二，实验波形"></a>二，实验波形</h2><p>本实验是基于格力空调的红外数据<br>一帧红外编码数据的组成如下：<br><strong>起始码+35位数据+连接码+32位数据+结束码</strong><br><img src="/killer-blog/ESP32/gree_ir_code_parse/20200921205928763.png" alt="在这里插入图片描述">其中多次测量得出：</p>
<p><strong>起始码：9000us 低电平 + 4500us高电平；<br>连接码：646us低电平 + 20000us高电平；<br>结束码：646us低电平 + 高电平；</strong></p>
<p><strong>数据0：646us低电平 + 516us高电平；<br>数据1：646us低电平 + 1643us高电平；</strong></p>
<p>数据码中的0和1，经过多次的测量，取众数作为依据，实验数据如下：</p>
<p><img src="/killer-blog/ESP32/gree_ir_code_parse/20200921104951188.png" alt="在这里插入图片描述"></p>
<h2 id="三，红外编码解析"><a href="#三，红外编码解析" class="headerlink" title="三，红外编码解析"></a>三，红外编码解析</h2><p>知道了一帧红外数据的0和1的表示，我们就可以自由的组成一帧数据。接下来需要了解的是在一帧数据中，数据位中的每一个bit代表的意思。<br>这里以<code>25℃，制冷模式，低风速，无扫风，打开，定时时间为0</code>的一帧数据为例子：</p>
<h3 id="第一段数据："><a href="#第一段数据：" class="headerlink" title="第一段数据："></a>第一段数据：</h3><p><strong>开关：bit3；</strong></p>
<blockquote>
<p>0：关闭；1：开启</p>
</blockquote>
<p><strong>风速：bit4，bit5；</strong></p>
<blockquote>
<p>自动风速：00<br>一级风速：10<br>二级风速：01<br>三级风速：11</p>
</blockquote>
<p><strong>扫风开关：bit6，以及第二段bit0；</strong></p>
<blockquote>
<p>0：关闭；1：开启</p>
</blockquote>
<p><strong>温度：bit8，bit9，bit10，bit11；</strong></p>
<blockquote>
<p>16℃:	0000<br>17℃:	1000<br>18℃:	0100<br>19℃:	1100<br>20℃:	0010<br>21℃:	1010<br>22℃:	0110<br>23℃:	1110<br>24℃:	0001<br>25℃:	1001<br>26℃:	0101<br>27℃:	1101<br>28℃:	0011</p>
</blockquote>
<p><strong>定时分钟数：bit12，bit13，bit14；</strong></p>
<p>由于我的手机只能发送定时半小时为最小单位的定时时间，所以只有定时30分钟的数据</p>
<blockquote>
<p>30min:	100</p>
</blockquote>
<p><strong>bit15	定时开关；</strong></p>
<blockquote>
<p>0：关闭；1：开启</p>
</blockquote>
<p><strong>定时小时数：bit16，bit17，bit18，bit19；</strong></p>
<blockquote>
<p>一小时：1000<br>两小时：0100<br>三小时：1100<br>…..</p>
</blockquote>
<p><img src="/killer-blog/ESP32/gree_ir_code_parse/20200921215113779.png" alt="在这里插入图片描述"></p>
<h3 id="第二段数据："><a href="#第二段数据：" class="headerlink" title="第二段数据："></a>第二段数据：</h3><p>第二段数据比较简单，需要注意的就是<code>bit0</code>是扫风的开关，她与第一段数据中的<code>bit6</code>是一样的数值。另外是后四位<code>bit28,bit29,bit30,bit31</code>组成的校验码。<br>网上也有许多关于校验码的公式，但是我试了后发现并不适用，于是自己尝试出了一条公式：<br><code>校验码 = 温度 - 18 + 定时小时数 + 空调开关 × 8；</code><br>例如以上例子的校验码是：25 - 18 + 0 + 1× 8 &#x3D; 15 &#x3D; 0xf;<br><img src="/killer-blog/ESP32/gree_ir_code_parse/20200921220014146.png" alt="在这里插入图片描述"></p>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>红外遥控的实现大同小异，最好还是要自己有测试的设备进行代码的测试。红外接收管和逻辑分析仪是你的不二选择。</p>
<p>友情连接：<br><a href="/killer-blog/ESP32/esp32_ir_control">esp32实现红外发射与接收</a></p>
<p>作者才疏学浅，难免有错误，希望指正。如果文章对你有帮助，帮忙点个赞呗。</p>
<p><img src="/killer-blog/ESP32/gree_ir_code_parse/weixin.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/esp32_ir_control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/esp32_ir_control/" class="post-title-link" itemprop="url">ESP32实现红外遥控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:21:10" itemprop="dateModified" datetime="2025-06-02T10:21:10+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ESP32实现红外遥控"><a href="#ESP32实现红外遥控" class="headerlink" title="ESP32实现红外遥控"></a>ESP32实现红外遥控</h1><p>@[toc]</p>
<blockquote>
<p>对万能遥控有兴趣的同学可以参考：<a href="/killer-blog/ESP32/esp32_IREXT">esp32实现万能红外遥控器 基于开源红外码库IREXT</a>，推荐看完本文再去看万能遥控，实现效果：</p>
</blockquote>
<p>[video(video-g9CZsOEI-1607664423070)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=628075225)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/b3e048f369a70c36f80297c6eb6a2d52db6ad22a.jpg)(title-esp32%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9F%B3%E4%B8%87%E8%83%BD%E9%81%A5%E6%8E%A7)%5D">https://player.bilibili.com/player.html?aid=628075225)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/b3e048f369a70c36f80297c6eb6a2d52db6ad22a.jpg)(title-esp32实现语音万能遥控)]</a></p>
<h2 id="一，原理"><a href="#一，原理" class="headerlink" title="一，原理"></a>一，原理</h2><h3 id="1-1-概括"><a href="#1-1-概括" class="headerlink" title="1.1 概括"></a>1.1 概括</h3><p>esp32系列芯片集成了红外发送与接收控制器，可用于多种类型的红外通信。<em><strong>esp32一共有8个通道，每个通道都可以独立的进行发射和接收，一个通道不能同时进行发射和接收。</strong></em></p>
<p><strong>发射红外时，从内部特定地址的RAM中读取红外编码数据，并对这些数据进行38khz的载波调制；接收时，将接收的电平和电平时间经过转换后存放于该RAM。</strong></p>
<h3 id="1-2，时钟"><a href="#1-2，时钟" class="headerlink" title="1.2，时钟"></a>1.2，时钟</h3><p>每个通道独立配置时钟，时钟源有两个，<strong>APB &#x3D; 80MHZ</strong>,REF_TICK 。官方建议使用APB时钟源。<br>时钟可由8位的<code>DIVIDER</code>进行预分频，将分频后的信号作为<code>发射/接收计数器的时钟源</code>。<strong>接下来的例程中我将分频系数设置为100，计数器的时钟频率为tick &#x3D; 0.8MHZ，也就是1.25us</strong>。APB时钟还作为载波的时钟源，用于发射红外时需要用到的载波信号，如38Khz的典型红外载波。<br><img src="/killer-blog/ESP32/esp32_ir_control/20200915091844286.png" alt="在这里插入图片描述"></p>
<h3 id="1-3，认识-item"><a href="#1-3，认识-item" class="headerlink" title="1.3，认识 item"></a>1.3，认识 item</h3><blockquote>
<p><strong>item是esp32红外中用于描述一个脉冲信号的概念，一个item包含：电平以及电平时间信息</strong></p>
</blockquote>
<p><strong>存放红外数据的RAM分为8个block，默认一个通道对应一个block，一个block的大小是64×32bit，一个32bit的RAM就是一个item，所以一个block最多存放64个item，也就是64个脉冲信号。</strong></p>
<p><strong>item在内存中的情况如下图，level记录电平的高低，period记录电平的时间（period内存放的是计数器计数的数值，还需要经过换算才能得到真实的时间）。所以用一个item可以表示一个周期的信号。如果将多个item连起来，就是一帧的数据。</strong><br>计算公式：<code>真实时间=period*divider/80M</code>;</p>
<p><img src="/killer-blog/ESP32/esp32_ir_control/20200915092350548.png" alt="在这里插入图片描述"><br>在<code>rmt_struct.h</code>中定义的结构体<code>rmt_item32_t</code>，就是指向以上说的item。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">uint32_t</span> duration0 :<span class="number">15</span>;</span><br><span class="line">            <span class="type">uint32_t</span> level0 :<span class="number">1</span>;</span><br><span class="line">            <span class="type">uint32_t</span> duration1 :<span class="number">15</span>;</span><br><span class="line">            <span class="type">uint32_t</span> level1 :<span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">uint32_t</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="type">rmt_item32_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-4，发射-接收器"><a href="#1-4，发射-接收器" class="headerlink" title="1.4，发射&#x2F;接收器"></a>1.4，发射&#x2F;接收器</h3><p>1,发射器从内部的RAM中读取数据。每次读取32位数据，高位地址先发射，低位地址后发射。</p>
<p>2,当接收器使能时，输入gpio检查到电平变化时，开始计数，当又一次检查到电平变化时，将上次电平的高低和持续时间写入RAM中，以此持续检测，直到发射器接收的电平变化时间大于设置的<code>退出检测时间</code>，接收器才会停止接收。</p>
<p>3,通过设置RMT_IDLE_THRES_CH寄存器设置<code>退出检测时间</code>，该寄存器的计数频率与接收计数器频率相同，tick &#x3D; 100&#x2F;80M&#x3D;1.25us;</p>
<p>4,接收器还支持简单的滤波，滤波器可以帮助我们滤除一些持续时间过短的信号，比如一个几us的噪声，通过设置RMT_RX_FILTER_THRES_CH寄存器来设置滤除的噪声信号的时间宽度。注意RMT_RX_FILTER_THRES_CH寄存器的时钟源是APB时钟。所以时间宽度：fliter &#x3D; RMT_RX_FILTER_THRES_CH*0.0125us;</p>
<h3 id="1-5-电路原理图"><a href="#1-5-电路原理图" class="headerlink" title="1.5 电路原理图"></a>1.5 电路原理图</h3><h4 id="1-5-1，发射电路"><a href="#1-5-1，发射电路" class="headerlink" title="1.5.1，发射电路"></a>1.5.1，发射电路</h4><p>在1.3节的时钟中，信号输出口sig_out连接到下图三极管的基极，从而控制三极管的导通，间接控制红外发光管的亮灭，当输出38khz的载波时，LED就会以38khz的频率闪烁。<br><img src="/killer-blog/ESP32/esp32_ir_control/20201202085148986.png" alt="在这里插入图片描述"></p>
<h4 id="1-5-2-，接收电路"><a href="#1-5-2-，接收电路" class="headerlink" title="1.5.2 ，接收电路"></a>1.5.2 ，接收电路</h4><p>一般的接收管是一个集成的元器件，具备光信号到电信号的转换，信号放大，解码等功能。<strong>当二极管接收到红外线时导通，光信号转为电信号，再经过放大电路，最后解码，解码的作用是滤除非38khz的信号，当接收的信号是38khz时，OUT脚输出低电平。</strong><br><img src="/killer-blog/ESP32/esp32_ir_control/20201202085346351.png" alt="在这里插入图片描述"></p>
<h2 id="二，红外发射"><a href="#二，红外发射" class="headerlink" title="二，红外发射"></a>二，红外发射</h2><h3 id="2-1-整体的思路"><a href="#2-1-整体的思路" class="headerlink" title="2.1 整体的思路"></a>2.1 整体的思路</h3><p><strong>初始化外设，填充item的数据。然后调用以下函数将item中的内容写入RAM，发射。这个过程中填充item数据是灵活多样的，根据你要发射的数据不同，有不同的填充方法。本文就先介绍使用格力红外编码去填充，参考：</strong></p>
<p><strong>该函数将变量item中的数据写入特定的RAM中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">rmt_write_items</span><span class="params">(<span class="type">rmt_channel_t</span> channel, <span class="type">const</span> <span class="type">rmt_item32_t</span>* rmt_item, <span class="type">int</span> item_num, <span class="type">bool</span> wait_tx_done)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>该函数使能发射控制器，将对应通道的RAM中的数据发射出去，该操作会使任务进入阻塞。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">rmt_wait_tx_done</span><span class="params">(<span class="type">rmt_channel_t</span> channel, TickType_t wait_time)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-2-发射器初始化"><a href="#2-2-发射器初始化" class="headerlink" title="2.2 发射器初始化"></a>2.2 发射器初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief RMT transmitter initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_tx_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rmt_config_t</span> rmt_tx;</span><br><span class="line">    rmt_tx.channel = tx_channel;</span><br><span class="line">    rmt_tx.gpio_num = RMT_TX_GPIO_NUM;</span><br><span class="line">    rmt_tx.mem_block_num = <span class="number">2</span>;   <span class="comment">//由于格力红外有70个item，使用2个块，64×2=128个item</span></span><br><span class="line">    rmt_tx.clk_div = RMT_CLK_DIV;   </span><br><span class="line">    rmt_tx.tx_config.loop_en = <span class="literal">false</span>;   <span class="comment">//关闭循环发射，只发射一次</span></span><br><span class="line">    rmt_tx.tx_config.carrier_duty_percent = <span class="number">50</span>; <span class="comment">//载波占空比为50</span></span><br><span class="line">    rmt_tx.tx_config.carrier_freq_hz = <span class="number">38000</span>;   <span class="comment">//载波频率38khz 红外</span></span><br><span class="line">    rmt_tx.tx_config.carrier_level = <span class="number">1</span>; <span class="comment">//载波高电平</span></span><br><span class="line">    rmt_tx.tx_config.carrier_en = RMT_TX_CARRIER_EN;    <span class="comment">//使能载波</span></span><br><span class="line">    rmt_tx.tx_config.idle_level = <span class="number">0</span>;    <span class="comment">//空闲状态低电平</span></span><br><span class="line">    rmt_tx.tx_config.idle_output_en = <span class="literal">true</span>; <span class="comment">//输出使能</span></span><br><span class="line">    rmt_tx.rmt_mode = RMT_MODE_TX;  <span class="comment">//发射模式</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;[ 1.1 ] config rmt&quot;</span>);</span><br><span class="line">    rmt_config(&amp;rmt_tx);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;[ 1.2 ] install rmt driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装红外发射通道 无需ringbuff</span></span><br><span class="line">    rmt_driver_install(rmt_tx.channel, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-构建并发射item"><a href="#2-3-构建并发射item" class="headerlink" title="2.3 构建并发射item"></a>2.3 构建并发射item</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rmt_item32_t</span> *item;	<span class="comment">//发射item</span></span><br><span class="line"><span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> item_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">item_num = NEC_DATA_ITEM_NUM;   <span class="comment">//此处为70</span></span><br><span class="line">size = (<span class="keyword">sizeof</span>(<span class="type">rmt_item32_t</span>) * item_num); <span class="comment">//计算70个item所需的字节空间</span></span><br><span class="line">item = (<span class="type">rmt_item32_t</span> *)<span class="built_in">malloc</span>(size);	<span class="comment">//记得free</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)item, <span class="number">0</span>, size);</span><br><span class="line">nec_build_items(item, item_num, ir_msg-&gt;data0, ir_msg-&gt;data1); <span class="comment">//根据要发射的数据，填充item</span></span><br><span class="line"></span><br><span class="line">rmt_write_items(tx_channel, item, item_num, <span class="literal">true</span>); <span class="comment">//将item写入通道对应的RAM并进入阻塞</span></span><br><span class="line"></span><br><span class="line">rmt_wait_tx_done(tx_channel, portMAX_DELAY); <span class="comment">//等待发送完成 进入阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(item);</span><br></pre></td></tr></table></figure>
<p><strong>nec_build_items();就是填充item的代码，在本例子中，实现的是填充格力红外编码，具体代码在文末提供。</strong></p>
<h2 id="三，红外接收"><a href="#三，红外接收" class="headerlink" title="三，红外接收"></a>三，红外接收</h2><h3 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1 思路"></a>3.1 思路</h3><p>如果你理解了发射的部分，那么接收就更加容易了。你可能猜想如果发射是构建item，那么接收就应该是获得item。恭喜你，老伙计，你答对了！这里我假设需要接收格力红外。</p>
<p><img src="/killer-blog/ESP32/esp32_ir_control/20201103170130153.jpg" alt="在这里插入图片描述"></p>
<p><strong>接收器会自动把某个通道接收到的数据写入对应的RAM中，并封装成item，再放入指定的ringbuff中，我们的程序只要拿到对应通道的ringbuff，就能从ringbuff中读取出脉冲序列。</strong></p>
<blockquote>
<p>关于啥是ringbuff，ringbuff就是一个缓存区buff。废话。详细可以看看 <a href="/killer-blog/other/ringbuff_c_impl">ringbuff简单实现</a></p>
<p>关于接收的几个重要函数：</p>
</blockquote>
<p><strong>获取指定通道的ringbuff</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmt_get_ringbuf_handle(rx_channel, &amp;rb);    <span class="comment">//获取红外接收器对应通道的ringbuff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>从ringbuff读取items 会进入阻塞 直到ringbuff中有新的数据（也就是接收到信号）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rmt_item32_t</span>* item = (<span class="type">rmt_item32_t</span>*) xRingbufferReceive(rb, &amp;rx_size, portMAX_DELAY);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用完ringbuff和item后要释放内存</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vRingbufferReturnItem(rb, (<span class="type">void</span>*) item);</span><br></pre></td></tr></table></figure>

<p><strong>开启或关闭接收通道，停止后ringbuff中不再有新的数据</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmt_rx_stop(rx_channel);</span><br><span class="line"></span><br><span class="line">rmt_rx_start(rx_channel);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-接收器初始化"><a href="#3-2-接收器初始化" class="headerlink" title="3.2 接收器初始化"></a>3.2 接收器初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief RMT receiver initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_rx_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rmt_config_t</span> rmt_rx;</span><br><span class="line">    rmt_rx.channel = rx_channel;</span><br><span class="line">    rmt_rx.gpio_num = RMT_RX_GPIO_NUM;</span><br><span class="line">    rmt_rx.clk_div = RMT_CLK_DIV;   <span class="comment">//分频系数 100</span></span><br><span class="line">    rmt_rx.mem_block_num = <span class="number">2</span>;   </span><br><span class="line">    rmt_rx.rmt_mode = RMT_MODE_RX;</span><br><span class="line">    rmt_rx.rx_config.filter_en = <span class="literal">true</span>;  <span class="comment">//开启滤波器</span></span><br><span class="line">    rmt_rx.rx_config.filter_ticks_thresh = <span class="number">100</span>; <span class="comment">//滤波信号宽度100*80M=12.5us</span></span><br><span class="line">    rmt_rx.rx_config.idle_threshold = rmt_item32_tIMEOUT_US / <span class="number">10</span> * (RMT_TICK_10_US);    <span class="comment">//退出接收时间：21000us后接收不到信号变化，退出接收</span></span><br><span class="line">    rmt_config(&amp;rmt_rx);</span><br><span class="line">    ESP_LOGI(TAG,<span class="string">&quot;rmt rx config&quot;</span>);</span><br><span class="line">    <span class="comment">//安装红外接收通道，rinbuff大小1000字节</span></span><br><span class="line">    rmt_driver_install(rmt_rx.channel, <span class="number">1000</span>, <span class="number">0</span>);</span><br><span class="line">    ESP_LOGI(TAG,<span class="string">&quot;rx driver initialization ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-接收获取item"><a href="#3-3-接收获取item" class="headerlink" title="3.3 接收获取item"></a>3.3 接收获取item</h3><p><strong>接收代码就更加的简单了，只要调用这三个函数就够了。item的解析与对上文item的构建一样是最重要的，这里以格力红外为例，不同情况下有不同的解析代码。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmt_rx_start(rx_channel);</span><br><span class="line"><span class="type">rmt_item32_t</span>* item = (<span class="type">rmt_item32_t</span>*) xRingbufferReceive(rb, &amp;rx_size, portMAX_DELAY);</span><br><span class="line">rmt_rx_stop(rx_channel);</span><br></pre></td></tr></table></figure>


<h2 id="四，item的构建与解析"><a href="#四，item的构建与解析" class="headerlink" title="四，item的构建与解析"></a>四，item的构建与解析</h2><p><strong>红外编码的构建：</strong></p>
<h3 id="4-1-item的构建"><a href="#4-1-item的构建" class="headerlink" title="4.1 item的构建"></a>4.1 item的构建</h3><p>该步骤的目标，是构建item集合，因为item对应的就是RAM中的32位的数据。根据具体的红外协议的要求，将电平，逻辑0，1的电平时间长度等写入item，并根据协议的长度设置item的数量。<br>例如，格力红外协议组成：</p>
<blockquote>
<p>起始码（S）+35位数据码+连接码（C）+32位数据码<br>1、各种编码的电平宽度：<br>数据码由“0”“1”起始码、连接码组成：<br>0的电平宽度为：600us低电平+600us高电平，<br>1的电平宽度为：600us低电平+1600us高电平<br>起始码S电平宽度为：9000us低电平+4500us高电平<br>连接码C电平宽度为：600us低电平+20000us高电平</p>
</blockquote>
<p>例如item构建函数：构建70个item，item的内容由使用的协议决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief Build NEC 32bit waveform.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_build_items</span><span class="params">( <span class="type">rmt_item32_t</span>* item, <span class="type">int</span> item_num, <span class="type">uint64_t</span> ir_data0,<span class="type">uint32_t</span> ir_data1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    nec_fill_item_header(item++);   <span class="comment">//构建起始信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//35位数据码</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">35</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ir_data0 &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">            <span class="comment">//ESP_LOGI(TAG, &quot;item =1&quot;);</span></span><br><span class="line">            nec_fill_item_bit_one(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ESP_LOGI(TAG, &quot;item =0&quot;);</span></span><br><span class="line">            nec_fill_item_bit_zero(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item++;</span><br><span class="line"></span><br><span class="line">        ir_data0 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接信号</span></span><br><span class="line">    nec_fill_item_connect(item);</span><br><span class="line">    item++;</span><br><span class="line">    <span class="comment">//32位数据码</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ir_data1 &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">            <span class="comment">//ESP_LOGI(TAG, &quot;item =1&quot;);</span></span><br><span class="line">            nec_fill_item_bit_one(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ESP_LOGI(TAG, &quot;item =0&quot;);</span></span><br><span class="line">            nec_fill_item_bit_zero(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item++;</span><br><span class="line">        </span><br><span class="line">        ir_data1 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nec_fill_item_end(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief 填充item的电平和电平时间 需要将时间转换成计数器的计数值 /10*RMT_TICK_10_US</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">nec_fill_item_level</span><span class="params">(<span class="type">rmt_item32_t</span>* item, <span class="type">int</span> high_us, <span class="type">int</span> low_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    item-&gt;level0 = <span class="number">1</span>;</span><br><span class="line">    item-&gt;duration0 = (high_us) / <span class="number">10</span> * RMT_TICK_10_US;</span><br><span class="line">    item-&gt;level1 = <span class="number">0</span>;</span><br><span class="line">    item-&gt;duration1 = (low_us) / <span class="number">10</span> * RMT_TICK_10_US;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief Generate NEC header value: active 9ms + negative 4.5ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_fill_item_header</span><span class="params">(<span class="type">rmt_item32_t</span>* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    nec_fill_item_level(item, NEC_HEADER_HIGH_US, NEC_HEADER_LOW_US);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_fill_item_connect</span><span class="params">(<span class="type">rmt_item32_t</span>* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    nec_fill_item_level(item, NEC_CONNECT_HIGH_US, NEC_CONNECT_LOW_US);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief Generate NEC data bit 1: positive 0.56ms + negative 1.69ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_fill_item_bit_one</span><span class="params">(<span class="type">rmt_item32_t</span>* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    nec_fill_item_level(item, NEC_BIT_ONE_HIGH_US, NEC_BIT_ONE_LOW_US);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief Generate NEC data bit 0: positive 0.56ms + negative 0.56ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_fill_item_bit_zero</span><span class="params">(<span class="type">rmt_item32_t</span>* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    nec_fill_item_level(item, NEC_BIT_ZERO_HIGH_US, NEC_BIT_ZERO_LOW_US);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief Generate NEC end signal: positive 0.56ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nec_fill_item_end</span><span class="params">(<span class="type">rmt_item32_t</span>* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    nec_fill_item_level(item, NEC_BIT_END, <span class="number">0x7fff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-2-item解析"><a href="#4-2-item解析" class="headerlink" title="4.2 item解析"></a>4.2 item解析</h3><p>红外编码的解析是构建的逆过程。首先了解红外接收器的工作原理：</p>
<blockquote>
<p>在初始化时我们就开启了中断，红外模块的中断寄存器就只有三个，如下。在初始化过程中开启了发送和接收完成中断，在接收完成中断服务函数中，将RAM中接收到的数据写入ringbuff，所以我们需要在只需要从ringbuff中就能读取RAM中接收的数据，此部分代码如下：</p>
<p><img src="/killer-blog/ESP32/esp32_ir_control/20200915205100855.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>接收中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RMT.conf_ch[channel].conf1.rx_en = <span class="number">0</span>;</span><br><span class="line">                  <span class="type">int</span> item_len = rmt_get_mem_len(channel);</span><br><span class="line">                  <span class="comment">//change memory owner to protect data.</span></span><br><span class="line">                  RMT.conf_ch[channel].conf1.mem_owner = RMT_MEM_OWNER_TX;</span><br><span class="line">                  <span class="keyword">if</span>(p_rmt-&gt;rx_buf) &#123;</span><br><span class="line">                  	<span class="comment">//将RAM中数据写入ringbuff</span></span><br><span class="line">                      BaseType_t res = xRingbufferSendFromISR(p_rmt-&gt;rx_buf, (<span class="type">void</span>*) RMTMEM.chan[channel].data32, item_len * <span class="number">4</span>, &amp;HPTaskAwoken);</span><br><span class="line">                      <span class="keyword">if</span>(res == pdFALSE) &#123;</span><br><span class="line">                          ESP_EARLY_LOGE(RMT_TAG, <span class="string">&quot;RMT RX BUFFER FULL&quot;</span>);</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      ESP_EARLY_LOGE(RMT_TAG, <span class="string">&quot;RMT RX BUFFER ERROR\n&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  RMT.conf_ch[channel].conf1.mem_wr_rst = <span class="number">1</span>;</span><br><span class="line">                  RMT.conf_ch[channel].conf1.mem_owner = RMT_MEM_OWNER_RX;</span><br><span class="line">                  RMT.conf_ch[channel].conf1.rx_en = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在接收完成后解析items：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析从item中的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nec_parse_items</span><span class="params">(<span class="type">rmt_item32_t</span>* item, <span class="type">int</span> item_num, <span class="type">uint64_t</span>* data0, <span class="type">uint32_t</span>* data1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint64_t</span> temp0 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> temp1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收的数据长度不小于一次传输的长度</span></span><br><span class="line">    <span class="keyword">if</span>(item_num &lt; NEC_DATA_ITEM_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查起始位</span></span><br><span class="line">    <span class="keyword">if</span>(!nec_header_if(item))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    item++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据位</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGI(IR_TAG, <span class="string">&quot;item data0 %u, %u, %u, %u&quot;</span>, NEC_ITEM_DURATION(item-&gt;level0), NEC_ITEM_DURATION(item-&gt;duration0), NEC_ITEM_DURATION(item-&gt;level1), NEC_ITEM_DURATION(item-&gt;duration1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nec_bit_one_if(item))</span><br><span class="line">        &#123;</span><br><span class="line">            temp0 |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nec_bit_zero_if(item))</span><br><span class="line">        &#123;</span><br><span class="line">            temp0 &amp;= (<span class="number">0</span>&lt;&lt;i);</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(IR_TAG, <span class="string">&quot;item i= %d&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查连接段信号</span></span><br><span class="line">    <span class="keyword">if</span>(nec_bit_connect_if(item))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    item ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查第二段信号</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGI(IR_TAG, <span class="string">&quot;item data1 %u, %u, %u, %u&quot;</span>, NEC_ITEM_DURATION(item-&gt;level0), NEC_ITEM_DURATION(item-&gt;duration0), NEC_ITEM_DURATION(item-&gt;level1), NEC_ITEM_DURATION(item-&gt;duration1));</span><br><span class="line">        <span class="keyword">if</span>(nec_bit_one_if(item))</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nec_bit_zero_if(item))</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 &amp;= (<span class="number">0</span>&lt;&lt;i);</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(IR_TAG, <span class="string">&quot;item i= %d&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line">    *data0 = temp0;</span><br><span class="line">    *data1 = temp1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五，进阶—万能遥控"><a href="#五，进阶—万能遥控" class="headerlink" title="五，进阶—万能遥控"></a>五，进阶—万能遥控</h2><p>esp32 的rmt外设不仅可以用来处理红外，他可以广泛用于电平信号的接收与产生，他的分辨率可以达到微秒级别，使用rmt可以与其他的模块进行通信等。总之rmt的功能还是非常的强大的。</p>
<p>如果打算实现万能遥控的功能，可用参考我的博客：<a href="/killer-blog/ESP32/esp32_IREXT">esp32实现万能红外遥控器</a>，这篇博客是在本文的基础上增加了一个开源红外码库的使用</p>
<p><a target="_blank" rel="noopener" href="http://nick.txtcc.com/index.php/linux/scm/1956">格力红外编码</a><br><a target="_blank" rel="noopener" href="http://bbs.eeworld.com.cn/thread-462015-1-1.html">YB0F2协议：http://bbs.eeworld.com.cn/thread-462015-1-1.html</a><br><strong>esp32技术参考手册</strong></p>
<p>由于作者才疏学浅，难免有错误，欢迎指正~<br><img src="/killer-blog/ESP32/esp32_ir_control/20200915205645556.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/esp32_time_system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/esp32_time_system/" class="post-title-link" itemprop="url">ESP32 时间系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:09:02" itemprop="dateModified" datetime="2025-06-02T10:09:02+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ESP32-时间系统"><a href="#ESP32-时间系统" class="headerlink" title="ESP32 时间系统"></a>ESP32 时间系统</h1><h3 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h3><p>该系统拥有一个全局时间变量<code>global_clk</code>，该变量记录了当前的时间（年，月，日，小时，分钟，秒），并维持一个定时任务列表。用户可以添加定时任务，删除定时任务等。定时任务执行完成后会被移除列表，但不会被释放。</p>
<h3 id="二，结构体"><a href="#二，结构体" class="headerlink" title="二，结构体"></a>二，结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日历结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">calendar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> second : <span class="number">6</span> ;	<span class="comment">//低位</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> minute : <span class="number">6</span> ;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hour : <span class="number">5</span> ;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> date : <span class="number">5</span> ;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> month : <span class="number">4</span> ;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> year : <span class="number">6</span> ;	<span class="comment">//高位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间结构体，cal的值决定了value</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">calendar</span> <span class="title">cal</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">clk</span> <span class="title">clk_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="title function_">char</span> <span class="params">(*timer_cb)</span><span class="params">(<span class="keyword">struct</span> timer *tmr ,<span class="type">void</span> *arg)</span>;	<span class="comment">//回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定时任务结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> *name;	<span class="comment">//名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">next</span>;</span>	<span class="comment">//指向下一个定时</span></span><br><span class="line">    <span class="type">clk_t</span> timeout;	<span class="comment">//定时的时间</span></span><br><span class="line">    timer_cb cb;	<span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">void</span> *arg;	<span class="comment">//回调参数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">clk_t</span> global_clk;	<span class="comment">//全局时间</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">timer_list</span>;</span>	<span class="comment">//定时任务列表</span></span><br></pre></td></tr></table></figure>

<h3 id="三，函数接口"><a href="#三，函数接口" class="headerlink" title="三，函数接口"></a>三，函数接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printf_tmrlist</span><span class="params">()</span>;	<span class="comment">//打印定时列表</span></span><br><span class="line"><span class="keyword">struct</span> timer *<span class="title function_">tmr_new</span><span class="params">(<span class="type">clk_t</span> *conf,timer_cb cb,<span class="type">void</span> *arg,<span class="type">char</span> *name)</span>; <span class="comment">//新建闹钟</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update_clk</span><span class="params">(<span class="type">clk_t</span> *clk)</span>;	<span class="comment">//更新时间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmr_add</span><span class="params">(<span class="keyword">struct</span> timer *tmr)</span>;	<span class="comment">//添加定时任务</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmr_remove</span><span class="params">(<span class="keyword">struct</span> timer *tmr)</span>;	<span class="comment">//移除定时任务</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmr_delete</span><span class="params">(<span class="keyword">struct</span> timer *tmr)</span>;	<span class="comment">//删除定时任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tmr_set_global</span><span class="params">(<span class="type">clk_t</span> conf)</span>;	<span class="comment">//设置全局时间</span></span><br><span class="line"><span class="type">clk_t</span> <span class="title function_">get_current_nettime</span><span class="params">()</span>;	<span class="comment">//获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">global_clk_init</span><span class="params">()</span>;	<span class="comment">//全局时间初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tmr_process</span><span class="params">(<span class="type">void</span> *arg)</span>;	<span class="comment">//定时任务处理</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_task</span><span class="params">(<span class="type">void</span> *arg)</span>;	<span class="comment">//时间系统线程</span></span><br></pre></td></tr></table></figure>

<h3 id="四，使用示例"><a href="#四，使用示例" class="headerlink" title="四，使用示例"></a>四，使用示例</h3><p>首先需要对全局时间来一个初始化，确定当前的时间，这个部分是通过网络获取北京时间的。同时，该示例设置一个定时任务，每24小时就通过网络更新时间，当24小时也就是一天的定时到了，update_global_cb()就会被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定时器回调函数：更新全局时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer_cb <span class="title function_">update_global_cb</span><span class="params">(<span class="keyword">struct</span> timer *tmr, <span class="type">void</span> *agr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">clk_t</span> t = get_current_nettime();</span><br><span class="line">	tmr_set_global(t); <span class="comment">//更新全局时间</span></span><br><span class="line">	tmr-&gt;timeout.value = global_clk.value;</span><br><span class="line">	tmr-&gt;timeout.cal.date += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	tmr_add(tmr); <span class="comment">//将更新任务再次添加进</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局时间初始化</span></span><br><span class="line"><span class="comment"> * 获取网络事件，设置定时器，自动更新全局时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">global_clk_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">clk_t</span> t = get_current_nettime();	<span class="comment">//获取网络时间</span></span><br><span class="line">	tmr_set_global(t); <span class="comment">//更新全局时间</span></span><br><span class="line">	t.cal.date += <span class="number">1</span>;	<span class="comment">//日期+1</span></span><br><span class="line">	tmr_new(&amp;t, update_global_cb, <span class="literal">NULL</span>, <span class="string">&quot;UPDATE&quot;</span>); <span class="comment">//创建定时器，每24小时更新网络时间，并添加到列表</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，在线程中，每秒调用tmr_process();保证时间系统的正常运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 时钟任务，每秒执行，处理定时任务及时间更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_task</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	esp_log_level_set(TAG, ESP_LOG_INFO);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		vTaskDelay(<span class="number">1000</span> / portTICK_RATE_MS);</span><br><span class="line">		tmr_process(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五，代码详解"><a href="#五，代码详解" class="headerlink" title="五，代码详解"></a>五，代码详解</h3><h4 id="1-clk-t-get-current-nettime"><a href="#1-clk-t-get-current-nettime" class="headerlink" title="1,clk_t get_current_nettime();"></a>1,clk_t get_current_nettime();</h4><p>该函数先调用获取网络时间的代码。<a href="/killer-blog/ESP32/esp_get_time">esp32获取网络时间</a>;将时间字符串转换成数字格式，复制到结构体并返回；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取当前网络时间</span></span><br><span class="line"><span class="comment"> * 返回：时间结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">clk_t</span> <span class="title function_">get_current_nettime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *origin = get_Time_String(); <span class="comment">//调用myhttp.c,获取时间字符串：&quot;2021-03-24 04:49:53&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str[<span class="number">6</span>][<span class="number">10</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//year,month,date,hour,minute,second</span></span><br><span class="line">	<span class="comment">//printf(&quot;origin = %s\n&quot;, origin);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//分别提取出时间</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> *c = str[i];</span><br><span class="line">		<span class="keyword">while</span> (!((*origin == <span class="string">&#x27;-&#x27;</span>) || (*origin == <span class="string">&#x27; &#x27;</span>) || (*origin == <span class="string">&#x27;:&#x27;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*origin == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			*c = *origin;</span><br><span class="line">			origin++;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">		origin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">//将字符串转换成数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x[i] = (<span class="type">unsigned</span> <span class="type">int</span>)atoi(str[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//赋值给时间结构体</span></span><br><span class="line">	<span class="type">clk_t</span> conf;</span><br><span class="line">	conf.cal.year = x[<span class="number">0</span>] - <span class="number">2000</span>;</span><br><span class="line">	conf.cal.month = x[<span class="number">1</span>];</span><br><span class="line">	conf.cal.date = x[<span class="number">2</span>];</span><br><span class="line">	conf.cal.hour = x[<span class="number">3</span>] + <span class="number">8</span>;</span><br><span class="line">	conf.cal.minute = x[<span class="number">4</span>];</span><br><span class="line">	conf.cal.second = x[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">return</span> conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-struct-timer-tmr-new-clk-t-conf-timer-cb-cb-void-arg-char-name"><a href="#2-struct-timer-tmr-new-clk-t-conf-timer-cb-cb-void-arg-char-name" class="headerlink" title="2,struct timer *tmr_new(clk_t *conf, timer_cb cb, void *arg, char *name);"></a>2,struct timer *tmr_new(clk_t *conf, timer_cb cb, void *arg, char *name);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个定时器 并添加进定时队列</span></span><br><span class="line"><span class="comment"> * conf：定时时间</span></span><br><span class="line"><span class="comment"> * cb：定时回调函数</span></span><br><span class="line"><span class="comment"> * arg：回调函数参数</span></span><br><span class="line"><span class="comment"> * name：定时器名</span></span><br><span class="line"><span class="comment"> * 返回：定时器结构体指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> timer *<span class="title function_">tmr_new</span><span class="params">(<span class="type">clk_t</span> *conf, timer_cb cb, <span class="type">void</span> *arg, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">tmr</span>;</span></span><br><span class="line">	<span class="type">clk_t</span> clk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//tmr must &gt; global_clk</span></span><br><span class="line">	<span class="keyword">if</span> (conf == <span class="literal">NULL</span> || (conf-&gt;value &lt;= global_clk.value))</span><br><span class="line">	&#123;</span><br><span class="line">		ESP_LOGI(TAG,<span class="string">&quot;new tmr error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	tmr = (<span class="keyword">struct</span> timer *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> timer));</span><br><span class="line">	<span class="comment">//chcek the conf</span></span><br><span class="line"></span><br><span class="line">	clk.value = conf-&gt;value;</span><br><span class="line">	update_clk(&amp;clk); <span class="comment">//规范化clk</span></span><br><span class="line">	ESP_LOGI(TAG,<span class="string">&quot;new timer %s: 20%d-%d-%d %d:%d:%d values =%u\r\n&quot;</span>, name, clk.cal.year, clk.cal.month, clk.cal.date, clk.cal.hour, clk.cal.minute, clk.cal.second, clk.value);</span><br><span class="line">	<span class="comment">//printf(&quot;new timer %s: 20%d-%d-%d %d:%d:%d values =%u\r\n&quot;, name, clk.cal.year, clk.cal.month, clk.cal.date, clk.cal.hour, clk.cal.minute, clk.cal.second, clk.value);</span></span><br><span class="line">	tmr-&gt;timeout.value = clk.value; <span class="comment">//将clk赋值给定时器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cb != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tmr-&gt;cb = cb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arg != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tmr-&gt;arg = arg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> *dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name));</span><br><span class="line">		<span class="built_in">strncpy</span>(dest, name, <span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">		tmr-&gt;name = dest;</span><br><span class="line">	&#125;</span><br><span class="line">	tmr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	tmr_add(tmr);</span><br><span class="line">	printf_tmrlist();</span><br><span class="line">	<span class="keyword">return</span> tmr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 更新时间结构体，使其成员符合时间规则</span></span><br><span class="line"><span class="comment"> * clk：要更新的时间</span></span><br><span class="line"><span class="comment"> * 返回：0 年份更新；1 年份未更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update_clk</span><span class="params">(<span class="type">clk_t</span> *clk)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clk-&gt;cal.second &gt;= <span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//one minute</span></span><br><span class="line">		clk-&gt;cal.second = clk-&gt;cal.second - <span class="number">60</span>;</span><br><span class="line">		clk-&gt;cal.minute++;</span><br><span class="line">		<span class="keyword">if</span> (clk-&gt;cal.minute &gt;= <span class="number">60</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//one hour</span></span><br><span class="line">			clk-&gt;cal.minute = clk-&gt;cal.minute - <span class="number">60</span>;</span><br><span class="line">			clk-&gt;cal.hour++;</span><br><span class="line">			<span class="keyword">if</span> (clk-&gt;cal.hour &gt;= <span class="number">24</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//date +1</span></span><br><span class="line">				clk-&gt;cal.hour = clk-&gt;cal.hour - <span class="number">24</span>;</span><br><span class="line">				clk-&gt;cal.date = clk-&gt;cal.date + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">switch</span> (clk-&gt;cal.month)</span><br><span class="line">				&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">					<span class="keyword">if</span> (clk-&gt;cal.date == <span class="number">32</span>)</span><br><span class="line">					&#123;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">					<span class="comment">//29 or 28 in february</span></span><br><span class="line">					<span class="keyword">if</span> (((clk-&gt;cal.year % <span class="number">4</span>) == <span class="number">0</span> &amp;&amp; clk-&gt;cal.date == <span class="number">30</span>) || ((clk-&gt;cal.year % <span class="number">4</span> != <span class="number">0</span>) &amp;&amp; (clk-&gt;cal.date == <span class="number">29</span>)))</span><br><span class="line">					&#123;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">if</span> (clk-&gt;cal.date == <span class="number">31</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//month +1</span></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	clk-&gt;cal.date = <span class="number">1</span>;</span><br><span class="line">	clk-&gt;cal.month++;</span><br><span class="line">	<span class="keyword">if</span> (clk-&gt;cal.month == <span class="number">13</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clk-&gt;cal.month = <span class="number">1</span>;</span><br><span class="line">		clk-&gt;cal.year++; <span class="comment">//max to 2064</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-int-tmr-add-struct-timer-tmr"><a href="#3-int-tmr-add-struct-timer-tmr" class="headerlink" title="3, int tmr_add(struct timer *tmr);"></a>3, int tmr_add(struct timer *tmr);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将定时器插入链表，按时间先后顺序</span></span><br><span class="line"><span class="comment"> * tmr：要插入的定时器</span></span><br><span class="line"><span class="comment"> * 返回：0失败；1成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmr_add</span><span class="params">(<span class="keyword">struct</span> timer *tmr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">t</span>, *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	ESP_LOGI(TAG,<span class="string">&quot;adding timer to timerlist:&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (tmr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ESP_LOGI(TAG, <span class="string">&quot;new timer is null&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//若当前无定时器则，tmr将作为第一个定时器</span></span><br><span class="line">	<span class="keyword">if</span> (timer_list == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ESP_LOGI(TAG, <span class="string">&quot;timer %s is the only timer&quot;</span>,tmr-&gt;name);</span><br><span class="line">		<span class="comment">//first tmr</span></span><br><span class="line">		tmr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		timer_list = tmr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//按时间先后顺序将tmr插入链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		t = timer_list;</span><br><span class="line">		<span class="comment">//时间小的在前面</span></span><br><span class="line">		<span class="keyword">while</span> (((t-&gt;timeout.value) &lt; (tmr-&gt;timeout.value)))</span><br><span class="line">		&#123;</span><br><span class="line">			ESP_LOGI(TAG, <span class="string">&quot;step for next timer&quot;</span>);</span><br><span class="line">			prev = t; <span class="comment">//保存t的上一个</span></span><br><span class="line">			<span class="keyword">if</span> (t-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//若t是最后一个定时器</span></span><br><span class="line">				t-&gt;next = tmr; <span class="comment">//将tmr插入t后</span></span><br><span class="line">				tmr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">				ESP_LOGI(TAG, <span class="string">&quot;add timer %s to the tail of the list &quot;</span>,tmr-&gt;name);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			t = t-&gt;next; <span class="comment">//检查下一个定时器</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//上一个为空，说明tmr是最早的定时器</span></span><br><span class="line">		<span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//tmr less than the first one</span></span><br><span class="line">			tmr-&gt;next = timer_list; <span class="comment">//tmr插入timer_list的前面</span></span><br><span class="line">			timer_list = tmr;		<span class="comment">//再更新timer_list</span></span><br><span class="line">			ESP_LOGI(TAG, <span class="string">&quot;add timer %s to the head of list&quot;</span>,timer_list-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			tmr-&gt;next = t; <span class="comment">//tmr插入t之前</span></span><br><span class="line"></span><br><span class="line">			prev-&gt;next = tmr; <span class="comment">//tmr插入prev之后</span></span><br><span class="line">			ESP_LOGI(TAG, <span class="string">&quot;add timer %s behind %s&quot;</span>,tmr-&gt;name,prev-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-int-tmr-remove-struct-timer-tmr-and-int-tmr-delete-struct-timer-tmr"><a href="#4-int-tmr-remove-struct-timer-tmr-and-int-tmr-delete-struct-timer-tmr" class="headerlink" title="4,int tmr_remove(struct timer *tmr); and int tmr_delete(struct timer *tmr);"></a>4,int tmr_remove(struct timer *tmr); and int tmr_delete(struct timer *tmr);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将定时器从链表移除</span></span><br><span class="line"><span class="comment"> * tmr：要移除的定时器</span></span><br><span class="line"><span class="comment"> * 返回 0失败；1成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmr_remove</span><span class="params">(<span class="keyword">struct</span> timer *tmr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">t</span>, *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (tmr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//check if the tmr is in the list</span></span><br><span class="line">	<span class="keyword">if</span> (timer_list == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t = timer_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//find the tmr</span></span><br><span class="line">	<span class="keyword">while</span> (t != tmr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (t-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//no match</span></span><br><span class="line">		&#125;</span><br><span class="line">		prev = t;</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//t==tmr</span></span><br><span class="line">	<span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//t is the first</span></span><br><span class="line">		timer_list = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (t-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//t is the last</span></span><br><span class="line">			prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//t in the middle</span></span><br><span class="line">			prev-&gt;next = t-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除定时器，释放定时器占用的内存</span></span><br><span class="line"><span class="comment"> * tmr：要删除的定时器</span></span><br><span class="line"><span class="comment"> * 返回：0失败，1成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmr_delete</span><span class="params">(<span class="keyword">struct</span> timer *tmr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tmr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tmr_remove(tmr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(tmr-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(tmr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-void-tmr-process-void-arg"><a href="#5-void-tmr-process-void-arg" class="headerlink" title="5,void tmr_process(void *arg);"></a>5,void tmr_process(void *arg);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clk_t</span> global_clk; <span class="comment">//全局时间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 时间任务进程 负责更新全局时间以及触发定时器</span></span><br><span class="line"><span class="comment"> * 在定时器中断中，每秒执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tmr_process</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//update the global_clk</span></span><br><span class="line">	global_clk.cal.second++;</span><br><span class="line"></span><br><span class="line">	update_clk(&amp;global_clk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//check if timer_list is null</span></span><br><span class="line">	<span class="keyword">if</span> (timer_list == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//check the first timer in list</span></span><br><span class="line">	t = timer_list;</span><br><span class="line">	<span class="comment">//printf(&quot;timer_list value = %d\n&quot;,t-&gt;timeout.value);</span></span><br><span class="line">	<span class="keyword">if</span> (global_clk.value == (t-&gt;timeout.value))</span><br><span class="line">	&#123;</span><br><span class="line">		tmr_remove(t); <span class="comment">//若要重复定时，只需要在回调函数中调用tmr_add()</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timer %s\n&quot;</span>, t-&gt;name);</span><br><span class="line">		t-&gt;cb(t, t-&gt;arg); <span class="comment">//callback func</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置全局事件</span></span><br><span class="line"><span class="comment"> * conf：新的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tmr_set_global</span><span class="params">(<span class="type">clk_t</span> conf)</span></span><br><span class="line">&#123;</span><br><span class="line">	global_clk.value = conf.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/killer-blog/ESP32/esp32_time_system/20210324130446764.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://killer-p.github.io/killer-blog/ESP32/esp32_weather_report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="killer-p">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killer-p blog">
      <meta itemprop="description" content="share Linux, arm, and some skillful things">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | killer-p blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/killer-blog/ESP32/esp32_weather_report/" class="post-title-link" itemprop="url">ESP32 实现天气预报</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 18:11:17" itemprop="dateCreated datePublished" datetime="2025-06-01T18:11:17+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-02 10:09:56" itemprop="dateModified" datetime="2025-06-02T10:09:56+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ESP32/" itemprop="url" rel="index"><span itemprop="name">ESP32</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ESP32-实现天气预报"><a href="#ESP32-实现天气预报" class="headerlink" title="ESP32 实现天气预报"></a>ESP32 实现天气预报</h1><blockquote>
<p>本文即将为你示例如何使用esp32的wifi，http组件以及百度在线语音合成等功能，实现获取天气数据并通过语音播放。</p>
</blockquote>
<p>@[toc]</p>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>[video(video-9Nehbmpp-1604736367570)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=797685523)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/8eebf58ba36e0518b66f8ec8d28300f84186be1d.jpg)(title-esp32%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%94%BE%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5)%5D">https://player.bilibili.com/player.html?aid=797685523)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/8eebf58ba36e0518b66f8ec8d28300f84186be1d.jpg)(title-esp32语音播放天气预报)]</a></p>
<h2 id="一，请求天气数据"><a href="#一，请求天气数据" class="headerlink" title="一，请求天气数据"></a>一，请求天气数据</h2><h3 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h3><p>利用esp32的http组件，向Web API请求天气数据，我使用的是万维易源提供的API接口，这个接口的调用比较简单，而且提供了1000次的额度，还是比较良心的。</p>
<p><strong>请求的方式也很简单，使用GET方式向天气接口发起请求，服务端会返回json格式的当地城市的天气数据。后续我们只要解析出json中的数据，提取我们想要的天气数据。</strong></p>
<h3 id="1-2-注册账号"><a href="#1-2-注册账号" class="headerlink" title="1.2 注册账号"></a>1.2 注册账号</h3><p>在<a target="_blank" rel="noopener" href="https://www.showapi.com/">官网</a>注册账号，进入控制台，找到<code>接口使用者-》我的应用</code>，系统默认创建了一个应用，<code>just_test_app</code>，将这个应用的<code>showapi_appid</code>，和<code>sercret</code>保存下来，我们需要这两个数据作为请求参数。<br>然后进入<a target="_blank" rel="noopener" href="https://www.showapi.com/apiGateway/view/9?tab=productPrice&skuid=5ee9cb656e36cf1eb67506c1">天气api接口文档</a>，购买0.00元档的套餐，到这一步，你已经可用使用它的接口了。<br>在接口文档中，可以选择根据不同的参数来获取天气数据，这里我选择ip查询。当ip的参数为空时，会默认返回客户端的ip地址的城市的信息。<br><img src="/killer-blog/ESP32/esp32_weather_report/20201105225915438.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-获取数据"><a href="#1-3-获取数据" class="headerlink" title="1.3 获取数据"></a>1.3 获取数据</h3><p><strong>通过ip获取天气的url是<code>https://route.showapi.com/9-4</code>，我们只需要在url后加入<code>showapi_appid</code>和<code>showapi_sign</code>两个参数(showapi_sign就是上文的sercret)，然后发起GET请求，就能接收到返回的json字符串。</strong><br>例如我的url是：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://route.showapi.com/9-4?showapi_appid=421387&showapi_sign=f5f3b508fd6c43e09457be788b251a32">https://route.showapi.com/9-4?showapi_appid=421387&amp;showapi_sign=f5f3b508fd6c43e09457be788b251a32</a></p>
</blockquote>
<p>http请求代码，<strong>具体逻辑见代码注释</strong></p>
<p>全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> http_data[MX_HTTP_BUFF]; <span class="comment">//! 需要定义为全局静态变量，否则会导致任务的堆栈溢出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEATHER_URL <span class="string">&quot;https://route.showapi.com/9-4?showapi_appid=421387&amp;showapi_sign=f5f3b508fd6c43e09457be788b251a32&quot;</span></span></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> err;</span><br><span class="line"><span class="type">esp_http_client_config_t</span> config = &#123;</span><br><span class="line">            .url = WEATHER_URL,     <span class="comment">//http请求地址</span></span><br><span class="line">            .event_handler = _http_event_handle,    <span class="comment">//http请求回调函数</span></span><br><span class="line">            .method = HTTP_METHOD_GET,      <span class="comment">//GET方式</span></span><br><span class="line">            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">esp_http_client_handle_t</span> client = esp_http_client_init(&amp;config);</span><br><span class="line">AUDIO_MEM_CHECK(TAG, client, <span class="keyword">return</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起请求</span></span><br><span class="line"><span class="keyword">if</span>(esp_http_client_open(client,<span class="number">0</span>)!=ESP_OK)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取返回头</span></span><br><span class="line">esp_http_client_fetch_headers(client);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;Status = %d, content_length = %d&quot;</span>,esp_http_client_get_status_code(client),esp_http_client_get_content_length(client));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//读取返回的数据到http_data</span></span><br><span class="line">	<span class="type">int</span> read_len = esp_http_client_read(client, http_data + index, max_len - index);</span><br><span class="line">	<span class="comment">//读取完毕</span></span><br><span class="line">    <span class="keyword">if</span>(read_len &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index += read_len;</span><br><span class="line">    total += read_len;</span><br><span class="line">    http_data[index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(total&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		ESP_LOGI(TAG,<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	esp_http_client_close(client);</span><br><span class="line">	esp_http_client_cleanup(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二，解析JSON字符串"><a href="#二，解析JSON字符串" class="headerlink" title="二，解析JSON字符串"></a>二，解析JSON字符串</h2><h3 id="2-1-天气数据"><a href="#2-1-天气数据" class="headerlink" title="2.1 天气数据"></a>2.1 天气数据</h3><p>通过将返回的json数据格式化，可得到下面的json数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;showapi_res_error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	<span class="string">&quot;showapi_res_id&quot;</span>: <span class="string">&quot;5fa415b48d57ba1617db793e&quot;</span>,</span><br><span class="line">	<span class="string">&quot;showapi_res_code&quot;</span>: 0,</span><br><span class="line">	<span class="string">&quot;showapi_res_body&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;time&quot;</span>: <span class="string">&quot;20201105180000&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ret_code&quot;</span>: 0,</span><br><span class="line">		<span class="string">&quot;now&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;aqiDetail&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;num&quot;</span>: <span class="string">&quot;95&quot;</span>,</span><br><span class="line">				<span class="string">&quot;co&quot;</span>: <span class="string">&quot;0.5&quot;</span>,</span><br><span class="line">				<span class="string">&quot;so2&quot;</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">				<span class="string">&quot;area&quot;</span>: <span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">				<span class="string">&quot;o3&quot;</span>: <span class="string">&quot;84&quot;</span>,</span><br><span class="line">				<span class="string">&quot;no2&quot;</span>: <span class="string">&quot;32&quot;</span>,</span><br><span class="line">				<span class="string">&quot;aqi&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">				<span class="string">&quot;quality&quot;</span>: <span class="string">&quot;良好&quot;</span>,</span><br><span class="line">				<span class="string">&quot;pm10&quot;</span>: <span class="string">&quot;52&quot;</span>,</span><br><span class="line">				<span class="string">&quot;pm2_5&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">				<span class="string">&quot;o3_8h&quot;</span>: <span class="string">&quot;98&quot;</span>,</span><br><span class="line">				<span class="string">&quot;primary_pollutant&quot;</span>: <span class="string">&quot;颗粒物(PM10)&quot;</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;wind_direction&quot;</span>: <span class="string">&quot;东风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;temperature_time&quot;</span>: <span class="string">&quot;23:00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;wind_power&quot;</span>: <span class="string">&quot;1级&quot;</span>,</span><br><span class="line">			<span class="string">&quot;aqi&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sd&quot;</span>: <span class="string">&quot;78%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;22&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;cityInfo&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;c6&quot;</span>: <span class="string">&quot;guangdong&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c5&quot;</span>: <span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c4&quot;</span>: <span class="string">&quot;shenzhen&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c3&quot;</span>: <span class="string">&quot;宝安&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c9&quot;</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c8&quot;</span>: <span class="string">&quot;china&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c7&quot;</span>: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c17&quot;</span>: <span class="string">&quot;+8&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c16&quot;</span>: <span class="string">&quot;AZ9755&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c1&quot;</span>: <span class="string">&quot;101280605&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c2&quot;</span>: <span class="string">&quot;baoan&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c0&quot;</span>: <span class="string">&quot;440306&quot;</span>,</span><br><span class="line">			<span class="string">&quot;longitude&quot;</span>: 113.878,</span><br><span class="line">			<span class="string">&quot;c11&quot;</span>: <span class="string">&quot;0755&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c10&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">			<span class="string">&quot;latitude&quot;</span>: 22.556,</span><br><span class="line">			<span class="string">&quot;c12&quot;</span>: <span class="string">&quot;518001&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c15&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;showapi_fee_code&quot;</span>: 0,</span><br><span class="line">		<span class="string">&quot;f1&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;night_weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;jiangshui&quot;</span>: <span class="string">&quot;0%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;air_press&quot;</span>: <span class="string">&quot;1005 hPa&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sun_begin_end&quot;</span>: <span class="string">&quot;06:25|16:20&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ziwaixian&quot;</span>: <span class="string">&quot;很强&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/day/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weekday&quot;</span>: 4,</span><br><span class="line">			<span class="string">&quot;night_air_temperature&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_air_temperature&quot;</span>: <span class="string">&quot;27&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_direction&quot;</span>: <span class="string">&quot;北风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day&quot;</span>: <span class="string">&quot;20201105&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_direction&quot;</span>: <span class="string">&quot;无持续风向&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;f3&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;night_weather_code&quot;</span>: <span class="string">&quot;07&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather&quot;</span>: <span class="string">&quot;小雨&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather&quot;</span>: <span class="string">&quot;小雨&quot;</span>,</span><br><span class="line">			<span class="string">&quot;jiangshui&quot;</span>: <span class="string">&quot;70%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;air_press&quot;</span>: <span class="string">&quot;1005 hPa&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_code&quot;</span>: <span class="string">&quot;07&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sun_begin_end&quot;</span>: <span class="string">&quot;06:28|16:17&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ziwaixian&quot;</span>: <span class="string">&quot;最弱&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/day/07.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weekday&quot;</span>: 6,</span><br><span class="line">			<span class="string">&quot;night_air_temperature&quot;</span>: <span class="string">&quot;21&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_air_temperature&quot;</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_direction&quot;</span>: <span class="string">&quot;东北风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day&quot;</span>: <span class="string">&quot;20201107&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/07.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_direction&quot;</span>: <span class="string">&quot;东北风&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;f2&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;night_weather_code&quot;</span>: <span class="string">&quot;07&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather&quot;</span>: <span class="string">&quot;小雨&quot;</span>,</span><br><span class="line">			<span class="string">&quot;jiangshui&quot;</span>: <span class="string">&quot;0%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;air_press&quot;</span>: <span class="string">&quot;1005 hPa&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sun_begin_end&quot;</span>: <span class="string">&quot;06:27|16:18&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ziwaixian&quot;</span>: <span class="string">&quot;很强&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/day/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weekday&quot;</span>: 5,</span><br><span class="line">			<span class="string">&quot;night_air_temperature&quot;</span>: <span class="string">&quot;21&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_direction&quot;</span>: <span class="string">&quot;无持续风向&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_air_temperature&quot;</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_direction&quot;</span>: <span class="string">&quot;东北风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/07.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day&quot;</span>: <span class="string">&quot;20201106&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用cJSON解析出字符串"><a href="#2-2-使用cJSON解析出字符串" class="headerlink" title="2.2 使用cJSON解析出字符串"></a>2.2 使用cJSON解析出字符串</h3><p><strong>cJSON</strong>是一个用C语言写的专门用于处理json数据的库。官方地址：<a target="_blank" rel="noopener" href="http://www.json.org/">http://www.json.org/</a>。idf中已经集成了cjson组件。</p>
<p>以下代码示例展示了如何使用cjson解析出json字符串里的数据，并将字符串拼接成一句流畅的句子。简单的展示，只读取json中的天气和温度数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> data[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//解析整个json</span></span><br><span class="line">	cJSON *root = cJSON_Parse(http_data);</span><br><span class="line">	<span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">          ESP_LOGI(TAG, <span class="string">&quot;error,json parse error&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="comment">//获取showapi_res_body </span></span><br><span class="line">    cJSON *showapi_res_body = cJSON_GetObjectItem(root,<span class="string">&quot;showapi_res_body&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*---------今天天气数据----------------------------*/</span></span><br><span class="line">	cJSON *f1 = cJSON_GetObjectItem(showapi_res_body, <span class="string">&quot;f1&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//白天的天气</span></span><br><span class="line">	cJSON *item = cJSON_GetObjectItem(f1, <span class="string">&quot;day_weather&quot;</span>);</span><br><span class="line">	<span class="type">char</span> *day_weather = cJSON_GetStringValue(item);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//白天的气温</span></span><br><span class="line">	item = cJSON_GetObjectItem(f1, <span class="string">&quot;day_air_temperature&quot;</span>);</span><br><span class="line">	<span class="type">char</span> *day_air_temperature = cJSON_GetStringValue(item);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//拼接成一句话，如：今天，天气晴，气温26度</span></span><br><span class="line">	<span class="built_in">snprintf</span>(data, <span class="number">50</span>, <span class="string">&quot;今天，天气%s,气温%s度&quot;</span>, day_weather,day_air_temperature);</span><br><span class="line">	</span><br><span class="line">	cJSON_Delete(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>几个重要的函数：</p>
<p><strong>将json字符串转化成json类型的对象，这个函数必须在其他函数之前执行。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Parse(<span class="type">const</span> <span class="type">char</span> *value)</span><br></pre></td></tr></table></figure>


<p><strong>根据键值获取cjson对象的一个成员，这个成员可以也是一个json对象</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_GetObjectItem(<span class="type">const</span> cJSON * <span class="type">const</span> object, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> <span class="built_in">string</span>)</span><br></pre></td></tr></table></figure>

<p><strong>获取json对象数组中的指定成员。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_GetArrayItem(<span class="type">const</span> cJSON *<span class="built_in">array</span>, <span class="type">int</span> index);</span><br></pre></td></tr></table></figure>

<p><strong>获取json对象里的字符串</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_GetStringValue(cJSON *item);</span><br></pre></td></tr></table></figure>

<h2 id="三，语音合成"><a href="#三，语音合成" class="headerlink" title="三，语音合成"></a>三，语音合成</h2><p>使用百度语音合成，将拼接的字符串转换成语音，通过喇叭播放出来。<br>如何将文字转换成语音，请参考另一篇博客：<a href="/killer-blog/ESP32/esp32adf_play_mp3">ESP32使用百度语音合成 实现文字转语音播放</a></p>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>天气API只是一个例子，网上有许多开放的API可玩，各位有什么好玩的API也可以在评论留言<br><img src="/killer-blog/ESP32/esp32_weather_report/20201105165502804.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">killer-p</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>

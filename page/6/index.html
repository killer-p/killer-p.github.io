<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/OpenHarmony/0.dsoftbus_guide" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/0.dsoftbus_guide/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.643Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="dsoftbus-导读"><a href="#dsoftbus-导读" class="headerlink" title="dsoftbus 导读"></a>dsoftbus 导读</h1><p>本文是一篇指导，来从总体概括dsoftbus的结构，并不会涉及具体的代码实现。</p>
<p>首先看官网给的架构图</p>
<p><img src="/image-20220421165324566.png" alt="image-20220421165324566"></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/foundation/communication/dsoftbus</span><br><span class="line">├── interfaces            # 接口代码</span><br><span class="line">├── adapter               # 适配层代码</span><br><span class="line">├── core                  # 核心代码</span><br><span class="line">│   ├── common            # 通用代码</span><br><span class="line">│   ├── authentication    # 认证代码</span><br><span class="line">│   ├── bus_center        # 组网代码</span><br><span class="line">│   ├── connection        # 连接代码</span><br><span class="line">│   ├── discovery         # 发现代码</span><br><span class="line">│   ├── transmission      # 传输代码</span><br><span class="line">│   └── frame             # 框架代码</span><br><span class="line">├── sdk                   # 运行业务进程代码</span><br><span class="line">│   ├── bus_center        # 组网代码</span><br><span class="line">│   ├── discovery         # 发现代码</span><br><span class="line">│   ├── transmission      # 传输代码</span><br><span class="line">│   └── frame             # 框架代码</span><br><span class="line">└── components            # 依赖组件代码</span><br></pre></td></tr></table></figure>



<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布服务</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PublishService</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> PublishInfo *info, <span class="type">const</span> IPublishCallback *cb)</span>;</span><br><span class="line"><span class="comment">//发现设备</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StartDiscovery</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> SubscribeInfo *info, <span class="type">const</span> IDiscoveryCallback *cb)</span>;</span><br><span class="line"><span class="comment">//请求加入网络</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">JoinLNN</span><span class="params">(ConnectionAddr *target, OnJoinLNNResult cb)</span>;</span><br><span class="line"><span class="comment">//加入网络回调函数、当成功时networkId是后续网络相关操作的一个助手</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*OnJoinLNNResult)</span><span class="params">(ConnectionAddr *addr, <span class="type">const</span> <span class="type">char</span> *networkId, <span class="type">int32_t</span> retCode)</span>;</span><br><span class="line"><span class="comment">//创建会话服务</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateSessionServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> <span class="type">char</span> *sessionName, <span class="type">const</span> ISessionListener* listener)</span>;</span><br><span class="line"><span class="comment">//创建会话</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">OpenSession</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *mySessionName, <span class="type">const</span> <span class="type">char</span> *peerSessionName, <span class="type">const</span> <span class="type">char</span> *peerDeviceId, <span class="type">const</span> <span class="type">char</span> *groupId, <span class="type">const</span> SessionAttribute* attr)</span>;</span><br><span class="line"><span class="comment">// 会话发送字节数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SendBytes</span><span class="params">(<span class="type">int</span> sessionId, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="comment">// 会话发送消息数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> sessionId, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>软总线在运行时是作为一个系统服务的形式，以一个进程去运行。这里有两个点，一个是系统服务、一个是进程。</p>
<p>当softbus_server程序被执行时，由于他被定义成一个系统服务，所以会执行<code>core/frame/small/init/src/softbus_server_stub.c</code>中的Init()函数来完成初始化。随后再执行 <code>Y:\foundation\communication\dsoftbus\core\frame\small\init\src\softbus_server_main.c</code>定义的main函数。</p>
<p>softbus_server 提供了上述的函数给其他进程使用，其他进程应该如何调用这些函数呢？我们知道A进程是不能直接调用进程B的函数的，那么应该有另一套方式来实现类似于进程内的函数调用。openharmony的ipc就是实现这个功能。介绍ipc。。。。。</p>
<p>而把softbus_server作为一个系统服务去运行的好处就是，softbus把他所提供的函数注册到samgr，这样其他进程就能通过samgr去获取softbus server提供的函数。介绍samgr。。。。。</p>
<p>为了方便其他进程使用softbus_server所提供的函数，在代码中的sdk目录下封装了ipc，其他进程只需要调用sdk目录下的接口，就能完成上述的操作。例子：</p>
<blockquote>
<p>在 Y:\foundation\distributeddatamgr\distributeddatamgr\services\distributeddataservice\adapter\communicator\src\softbus_adapter_standard.cpp 中，分布式数据管理的实现就需要使用到软总线的能力，在这里他就 #include session.h 。</p>
</blockquote>
<p>那么软总线的重点就在于softbus server程序的实现上了。</p>
<p><strong>目录：</strong></p>
<ol>
<li>什么是系统服务</li>
<li>dsoftbus服务初始化、函数接口</li>
<li>dsoftbus sdk</li>
<li>dsoftbus进程</li>
<li>ipc</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/0.dsoftbus_guide/" data-id="cmbcy7rhg0027t8mthjgd2d41" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/1.samgr&amp;softbus_service" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/1.samgr&softbus_service/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.643Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="samgr-lite简介"><a href="#samgr-lite简介" class="headerlink" title="samgr_lite简介"></a>samgr_lite简介</h2><p>服务是openharmony里非常重要的概念，不同模块、进程间的调用接口都被抽象称为服务。openharmony中的系统进程都以服务的方式提供接口给其他进程。</p>
<p>系统服务框架的具体的介绍可参考：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/distributedschedule_samgr_lite">https://gitee.com/openharmony/distributedschedule_samgr_lite</a></p>
<p>openharmony定义了服务、服务的注册、发现、调用机制，这里只关注系统服务的大概使用流程，如图所示：</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/1.samgr&softbus_service/image-20220513101824918.png" alt="image-20220513101824918"></p>
<p>上图所示有三个对象：</p>
<ul>
<li>系统服务A：本质上是一个在后台运行的进程。</li>
<li>SAMGR：管理服务的注册、发现、调用。</li>
<li>用户进程B：调用系统服务A的接口。</li>
</ul>
<h2 id="dsoftbus服务"><a href="#dsoftbus服务" class="headerlink" title="dsoftbus服务"></a>dsoftbus服务</h2><p>这里开始介绍软总线服务，该服务的代码实现在<code>OpenHarmony\foundation\communication\dsoftbus\core\frame\small\init\src\softbus_server_stub.c</code></p>
<h3 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h3><p>首先看对软总线服务的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软总线服务的定义</span></span><br><span class="line"><span class="type">static</span> SoftbusSamgrService g_samgrService = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle,</span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,    <span class="comment">//SERVER_IPROXY_IMPL_BEGIN和IPROXY_END之间的代码定义了跨进程调用的函数</span></span><br><span class="line">    .Invoke = Invoke,   <span class="comment">//当进程B调用软总线服务时，Invoke会被执行</span></span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中我们需要重点关注Invoke函数的实现，当用户进程B调用软总线服务的函数时，调用的请求就会被传递到Invoke函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//when dsoftbus sdk call g_serverProxy-&gt;Invoke(),it mean this:</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">Invoke</span><span class="params">(IServerProxy *iProxy, <span class="type">int</span> funcId, <span class="type">void</span> *origin, IpcIo *req, IpcIo *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//call the special func</span></span><br><span class="line">    <span class="type">int</span> tblSize = <span class="keyword">sizeof</span>(g_serverInvokeCmdTbl) / <span class="keyword">sizeof</span>(ServerInvokeCmd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tblSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (funcId == g_serverInvokeCmdTbl[i].id) &#123;</span><br><span class="line">            <span class="keyword">return</span> g_serverInvokeCmdTbl[i].func(origin, req, reply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再给出一个例子，示例Invoke是如何起作用的，用户进程B调用软总线服务的接口的流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_CREATE_SESSION_SERVER, &amp;request, &amp;ret, ProxyCallback);</span><br></pre></td></tr></table></figure>

<ul>
<li>g_serverProxy：通过samgr获取到软总线服务</li>
<li>SERVER_CREATE_SESSION_SERVER：对应funcId，制定要调用的函数</li>
<li>request：要调用的函数的参数</li>
<li>ret：软总线服务的函数的返回值</li>
<li>ProxyCallback：软总线服务的函数执行完成的回调函数</li>
</ul>
<p>好了，当用户进程B调用上面的函数，softbus_server_stub.c中的Invoke()函数就会执行，这个函数很简单，就是根据funcId调用g_serverInvokeCmdTbl[]数组中的函数。这些函数是软总线服务的具体内容，我们先暂时不去考虑。</p>
<h3 id="服务初始化"><a href="#服务初始化" class="headerlink" title="服务初始化"></a>服务初始化</h3><p>接下来是服务的初始化，可以在文件最后看到以下宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSEX_SERVICE_INIT(Init);</span><br></pre></td></tr></table></figure>

<p>追寻这个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSEX_SERVICE_INIT(func) LAYER_INITCALL_DEF(func, app_service, <span class="string">&quot;app.service&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAYER_INITCALL_DEF(func, layer, clayer) LAYER_INITCALL(func, layer, clayer, 2)</span></span><br><span class="line"><span class="comment">//若编译成动态库，则定义一个初始化函数来执行Init</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAYER_INIT_SHARED_LIB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAYER_INITCALL(func, layer, clayer, priority)                                     \</span></span><br><span class="line"><span class="meta">    static __attribute__((constructor(CTOR_VALUE_##layer + LAYER_INIT_LEVEL_##priority))) \</span></span><br><span class="line"><span class="meta">        void BOOT_##layer##priority##func() &#123;func();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//若编译成静态库，则把Init函数放入到系统镜像的zinitcall段中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAYER_INITCALL(func, layer, clayer, priority)            \</span></span><br><span class="line"><span class="meta">    static const InitCall USED_ATTR __zinitcall_##layer##_##func \</span></span><br><span class="line"><span class="meta">        __attribute__((section(<span class="string">&quot;.zinitcall.&quot;</span> clayer #priority <span class="string">&quot;.init&quot;</span>))) = func</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>初始化函数如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//entry of dsoftbus server</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(WAIT_FOR_SERVER);</span><br><span class="line">    <span class="comment">//register dsoftbus service to samgr</span></span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_samgrService);</span><br><span class="line">    <span class="comment">//register dsoftbus features to samgr</span></span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(SOFTBUS_SERVICE, GET_IUNKNOWN(g_samgrService));</span><br><span class="line">    <span class="comment">//定位这个log</span></span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;Init success %s&quot;</span>, SOFTBUS_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么由谁来调用Init()函数呢，我们从日志中来分析：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OHOS <span class="comment"># ./softbus_server</span></span><br><span class="line">01-01 00:04:27.948 13 73 I 015C0/dsoftbus_standard: [COMM]Init success softbus_service</span><br><span class="line">01-01 00:04:27.958 13 73 I 01800/Samgr: Bootstrap core services(count:1).</span><br><span class="line">01-01 00:04:27.958 13 73 I 01800/Samgr: Init service:softbus_service</span><br><span class="line">01-01 00:04:27.959 13 74 I 01800/Samgr: Initialize Client Registry!</span><br><span class="line">01-01 00:04:27.991 13 73 W 015C0/dsoftbus_standard: mutex is already init</span><br><span class="line">01-01 00:04:27.992 13 74 I 01800/Samgr: Init service softbus_service &lt;<span class="keyword">time</span>: 60ms&gt; success!</span><br><span class="line">01-01 00:04:27.992 13 74 I 01800/Samgr: Initialized all core system services!</span><br><span class="line">01-01 00:04:27.992 13 74 I 01800/Samgr: Goto next boot step <span class="built_in">return</span> code:-9</span><br></pre></td></tr></table></figure>

<p>当我执行softbus_server时，会打印 Init success softbus_service ，这个就是Init()函数的执行结果。那么softbus_server是什么？</p>
<h3 id="服务对应的进程"><a href="#服务对应的进程" class="headerlink" title="服务对应的进程"></a>服务对应的进程</h3><p>每一个系统服务背后都有一个对应的进程，来实现服务提供的接口。softbus_server就是软总线服务对应的进程，这个进程非常重要，软总线的实现内容全在里面。这里我们先不考虑。</p>
<p>softbus_server是一个c程序，在main()函数中会调用 softbus_server_stub.c的ServerStubInit()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((weak)) HOS_SystemInit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//SAMGR_Bootstrap会检查所有未初始化的service，包括软总线服务，然后执行对应的Init函数</span></span><br><span class="line">    SAMGR_Bootstrap();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ServerStubInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HOS_SystemInit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LnnIpcInit() != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;Center Ipc init failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SERVER_InitClient() != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;client manager init failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用SAMGR_Bootstrap，它会检查所有未初始化的service，包括软总线服务，然后执行对应的Init函数，也就出现了日志中的那句打印。</p>
<p>当软总线服务注册完成以及softbus_server程序成功运行后，用户程序B就可以调用软总线服务提供的接口。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/1.samgr&softbus_service/" data-id="cmbcy7rhj0029t8mtdgyn7iql" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/mem_init" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/mem_init/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.642Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内存系统初始化"><a href="#内存系统初始化" class="headerlink" title="内存系统初始化"></a>内存系统初始化</h1><p>本文将会从内核代码分析linux 是如何对内存系统进行初始化的。</p>
<blockquote>
<p>关于地址</p>
<ol>
<li>链接地址：在编译kernel时，编译器默认kernel位于0xc0000000起始的地址，所以在链接阶段会将指令中的地址确定。</li>
<li>运行地址：即代码在soc上运行时的实际地址，在开启MMU之前，与链接地址不一样，开启MMU后，有了虚拟地址，就可以调整成和链接地址是一样的。</li>
<li>位置无关代码：在开启MMU之前，运行地址和链接地址不一样，那么会不会有错误？kernel 使用位置无关代码来避免这种情况，位置无关代码的特点是其代码中没有绝对地址，只有相对地址，也就是相对起始的偏移，所以即使运行地址与链接地址不一样，也不会影响CPU正常取指。在kernel 开启MMU前的代码都属于位置无关代码。另外像内核模块也属于位置无关代码。</li>
</ol>
</blockquote>
<h2 id="一、汇编阶段"><a href="#一、汇编阶段" class="headerlink" title="一、汇编阶段"></a>一、汇编阶段</h2><h3 id="1-1、stext"><a href="#1-1、stext" class="headerlink" title="1.1、stext"></a>1.1、stext</h3><p>在系统启动过程中，uboot会将跳转到linux入口地址执行，linux的入口地址在head.S 汇编文件中的stext，此时的kernel最先需要做什么？</p>
<p>kernel 对cpu、io设备、内存、存储设备等一切都是未知，最要命的是kernel的链接地址和运行地址不一样。所以kernel必须先开启MMU创建虚拟地址，否则kernel自身的代码都会无法运行，自身难保如何拯救苍生？</p>
<p>所以在kernel的入口函数，stext 的主要目标就是开启ARM MMU，进入虚拟地址的世界，保证kernel自身能活下来先。</p>
<p>stext 是位于arch&#x2F;arm&#x2F;kernel&#x2F;head.S中，是一段与处理器架构相关的代码，kernel对该段代码的要求就是最后必须跳转到start_kernel()函数执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel startup entry point.</span></span><br><span class="line"><span class="comment"> * ---------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is normally called from the decompressor code.  The requirements</span></span><br><span class="line"><span class="comment"> * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,</span></span><br><span class="line"><span class="comment"> * r1 = machine nr, r2 = atags or dtb pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.arm</span><br><span class="line"></span><br><span class="line">	__HEAD</span><br><span class="line"><span class="title function_">ENTRY</span><span class="params">(stext)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 强制进入svc模式并mask所有中断，svc模式有更高的权限能操作寄存器</span></span><br><span class="line"><span class="comment">	 * 此时没有中断处理系统，关闭所有中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	safe_svcmode_maskall r9</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r9, c0, c0		@ get processor id</span><br><span class="line">	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid</span><br><span class="line">	movs	r10, r5				@ invalid processor (r5=<span class="number">0</span>)?</span><br><span class="line">	beq	__error_p			@ yes, error <span class="string">&#x27;p&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这一段是为了拿到PHYS_OFFSET的值，这里为什么不直接使用宏定义？是为了兼容多个平台？</span></span><br><span class="line"><span class="comment">     * PHYS_OFFSET：cpu访问PHYS_OFFSET地址，相当于访问DDR的地址0.每个平台上由于硬件设计不同，PHYS_OFFSET的值也不同</span></span><br><span class="line"><span class="comment">     * PAGE_OFFSET：0xc0000000 也就是3G,这是内核地址空间的起始地址</span></span><br><span class="line"><span class="comment">     * 当CPU访问一个内核线性映射的虚拟地址X时，对应DDR上的地址Y，有如下关系：X - PAGE_OFFSET + PHYS_OFFSET = Y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	adr	r3, <span class="number">2f</span>              <span class="comment">//这里是取代码最后&quot;标签2&quot;的运行地址到r3，由于MMU未打开，故该地址是PHYS_OFFSET + offset</span></span><br><span class="line">	ldmia	r3, &#123;r4, r8&#125;    <span class="comment">//读r3地址处的数据到r4、r8。r4保存的是&quot;标签2&quot;的链接地址是 PAGE_OFFSET + offset</span></span><br><span class="line">	sub	r4, r3, r4			<span class="comment">// r4 = r3-r4，r4 = PHYS_OFFSET - PAGE_OFFSET</span></span><br><span class="line">	add	r8, r8, r4			<span class="comment">// PHYS_OFFSET r8 = r8 + r4，r8 = PHYS_OFFSET</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * r1 = machine no, r2 = atags or dtb,</span></span><br><span class="line"><span class="comment">	 * r8 = phys_offset, r9 = cpuid, r10 = procinfo</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//__vet_atags 是一个在 Linux 内核中的函数，主要用于验证和处理 ARM 设备启动时传递的 ATAGs，或者设备树地址</span></span><br><span class="line">	bl	__vet_atags</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建初始页表</span></span><br><span class="line">	bl	__create_page_tables</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The processor init function will be called with:</span></span><br><span class="line"><span class="comment">	 *  r1 - machine type</span></span><br><span class="line"><span class="comment">	 *  r2 - boot data (atags/dt) pointer</span></span><br><span class="line"><span class="comment">	 *  r4 - translation table base (low word)</span></span><br><span class="line"><span class="comment">	 *  r5 - translation table base (high word, if LPAE)</span></span><br><span class="line"><span class="comment">	 *  r8 - translation table base 1 (pfn if LPAE)</span></span><br><span class="line"><span class="comment">	 *  r9 - cpuid</span></span><br><span class="line"><span class="comment">	 *  r13 - virtual address for __enable_mmu -&gt; __turn_mmu_on</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * On return, the CPU will be ready for the MMU to be turned on,</span></span><br><span class="line"><span class="comment">	 * r0 will hold the CPU control register value, r1, r2, r4, and</span></span><br><span class="line"><span class="comment">	 * r9 will be preserved.  r5 will also be preserved if LPAE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">       </span><br><span class="line">     <span class="comment">//设置__mmap_switched到sp，__enable_mmu后，内核虚拟地址已建立，就能直接执行__mmap_switched是一个绝对的链接地址，在。因为__mmap_switched是一个绝对的链接地址，在内核虚拟地址建立前，是不可运行的。</span></span><br><span class="line">	ldr	r13, =__mmap_switched		</span><br><span class="line">						@ mmu has been enabled</span><br><span class="line">	badr	lr, <span class="number">1f</span>				@ <span class="keyword">return</span> (PIC) address</span><br><span class="line"></span><br><span class="line">	mov	r8, r4				@ <span class="built_in">set</span> TTBR1 to swapper_pg_dir</span><br><span class="line"></span><br><span class="line">	ldr	r12, [r10, #PROCINFO_INITFUNC]</span><br><span class="line">	add	r12, r12, r10</span><br><span class="line">	ret	r12</span><br><span class="line"><span class="number">1</span>:	b	__enable_mmu <span class="comment">//跳转到__enable_mmu</span></span><br><span class="line">ENDPROC(stext)</span><br><span class="line">    .ltorg</span><br><span class="line"><span class="number">2</span>:	.<span class="type">long</span>	.                 <span class="comment">//&quot;标签2&quot;的链接地址</span></span><br><span class="line">	.<span class="type">long</span>	PAGE_OFFSET</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2、-create-page-tables"><a href="#1-2、-create-page-tables" class="headerlink" title="1.2、__create_page_tables"></a>1.2、__create_page_tables</h3><p>开启MMU 必须先有一个页表，通过__create_page_tables 函数实现创建一个初始页表.</p>
<p>那么页表应该是放在哪里呢？从以下宏定义可以看到page table 地址在 kernel text 段之后的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.globl	swapper_pg_dir</span><br><span class="line">.equ	swapper_pg_dir, KERNEL_RAM_VADDR - PG_DIR_SIZE</span><br><span class="line"></span><br><span class="line">.macro	pgtbl, rd, phys</span><br><span class="line">add	\rd, \phys, #TEXT_OFFSET</span><br><span class="line">sub	\rd, \rd, #PG_DIR_SIZE</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>找到初始页表的地址后，就需要往里面填映射关系。先清空page table里的数据，然后为以下地址创建identify map（即虚拟地址和物理地址保持一致）</p>
<ol>
<li>__turn_mmu_on 到 __turn_mmu_on_end这段地址，是开关MMU的代码，使用identify map有助于在开启MMU后该段代码能正常执行</li>
<li>内核镜像中_start 到 _end 的地址</li>
<li>设备树所在的地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the initial page tables.  We only setup the barest</span></span><br><span class="line"><span class="comment"> * amount which are required to get the kernel running, which</span></span><br><span class="line"><span class="comment"> * generally means mapping in the kernel code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * r8 = phys_offset, r9 = cpuid, r10 = procinfo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *  r0, r3, r5-r7 corrupted</span></span><br><span class="line"><span class="comment"> *  r4 = physical page table address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__create_page_tables:</span><br><span class="line">	pgtbl	r4, r8				@ page table address</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear the swapper page table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r4</span><br><span class="line">	mov	r3, #<span class="number">0</span></span><br><span class="line">	add	r6, r0, #PG_DIR_SIZE</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	teq	r0, r6</span><br><span class="line">	bne	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">	ldr	r7, [r10, #PROCINFO_MM_MMUFLAGS] @ mm_mmuflags</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create identity mapping to cater for __enable_mmu.</span></span><br><span class="line"><span class="comment">	 * This identity mapping will be removed by paging_init().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//identity map 虚拟地址和物理地址是一样的</span></span><br><span class="line">	adr	r0, __turn_mmu_on_loc</span><br><span class="line">	ldmia	r0, &#123;r3, r5, r6&#125;</span><br><span class="line">	sub	r0, r0, r3			@ virt-&gt;phys offset</span><br><span class="line">	add	r5, r5, r0			@ phys __turn_mmu_on</span><br><span class="line">	add	r6, r6, r0			@ phys __turn_mmu_on_end</span><br><span class="line">	mov	r5, r5, lsr #SECTION_SHIFT</span><br><span class="line">	mov	r6, r6, lsr #SECTION_SHIFT</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将__turn_mmu_on 到__turn_mmu_on_end 这段地址映射到相同的虚拟地址</span></span><br><span class="line"><span class="number">1</span>:	orr	r3, r7, r5, lsl #SECTION_SHIFT	@ flags + kernel base</span><br><span class="line">	str	r3, [r4, r5, lsl #PMD_ORDER]	@ identity mapping</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	addlo	r5, r5, #<span class="number">1</span>			@ next section</span><br><span class="line">	blo	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Map our RAM from the start to the end of the kernel .bss section.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	r0, r4, #PAGE_OFFSET &gt;&gt; (SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">	ldr	r6, =(_end - <span class="number">1</span>)</span><br><span class="line">	orr	r3, r8, r7</span><br><span class="line">	add	r6, r4, r6, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	add	r3, r3, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	cmp	r0, r6</span><br><span class="line">	bls	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Then map boot params address in r2 if specified.</span></span><br><span class="line"><span class="comment">	 * We map 2 sections in case the ATAGs/DTB crosses a section boundary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r2, lsr #SECTION_SHIFT</span><br><span class="line">	movs	r0, r0, lsl #SECTION_SHIFT</span><br><span class="line">	subne	r3, r0, r8</span><br><span class="line">	addne	r3, r3, #PAGE_OFFSET</span><br><span class="line">	addne	r3, r4, r3, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">	orrne	r6, r7, r0</span><br><span class="line">	strne	r6, [r3], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	addne	r6, r6, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	strne	r6, [r3]</span><br><span class="line"></span><br><span class="line">	ret	lr</span><br><span class="line">ENDPROC(__create_page_tables)</span><br><span class="line">	.ltorg</span><br><span class="line">	.align</span><br><span class="line">__turn_mmu_on_loc:</span><br><span class="line">	.<span class="type">long</span>	.</span><br><span class="line">	.<span class="type">long</span>	__turn_mmu_on</span><br><span class="line">	.<span class="type">long</span>	__turn_mmu_on_end</span><br></pre></td></tr></table></figure>

<h3 id="1-3、enable-mmu"><a href="#1-3、enable-mmu" class="headerlink" title="1.3、enable_mmu"></a>1.3、enable_mmu</h3><p>页表准备就绪后（地址存放在r4），接下来就只需要把数据写到CP15寄存器，就可以开启MMU了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup common bits before finally enabling the MMU.  Essentially</span></span><br><span class="line"><span class="comment"> * this is just loading the page table pointer and domain access</span></span><br><span class="line"><span class="comment"> * registers.  All these registers need to be preserved by the</span></span><br><span class="line"><span class="comment"> * processor setup function (or set in the case of r0)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  r0  = cp#15 control register</span></span><br><span class="line"><span class="comment"> *  r1  = machine ID</span></span><br><span class="line"><span class="comment"> *  r2  = atags or dtb pointer</span></span><br><span class="line"><span class="comment"> *  r4  = TTBR pointer (low word)</span></span><br><span class="line"><span class="comment"> *  r5  = TTBR pointer (high word if LPAE)</span></span><br><span class="line"><span class="comment"> *  r9  = processor ID</span></span><br><span class="line"><span class="comment"> *  r13 = *virtual* address to jump to upon completion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__enable_mmu:</span><br><span class="line">	bic	r0, r0, #CR_A</span><br><span class="line">	mov	r5, #DACR_INIT</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r5, c3, c0, <span class="number">0</span>		@ load domain access <span class="keyword">register</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r4, c2, c0, <span class="number">0</span>		@ load page table pointer 设置TTBR <span class="keyword">register</span> 为r4的值</span><br><span class="line">	b	__turn_mmu_on</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__enable_mmu)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable the MMU.  This completely changes the structure of the visible</span></span><br><span class="line"><span class="comment"> * memory space.  You will not be able to trace execution through this.</span></span><br><span class="line"><span class="comment"> * If you have an enquiry about this, *please* check the linux-arm-kernel</span></span><br><span class="line"><span class="comment"> * mailing list archives BEFORE sending another post to the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  r0  = cp#15 control register</span></span><br><span class="line"><span class="comment"> *  r1  = machine ID</span></span><br><span class="line"><span class="comment"> *  r2  = atags or dtb pointer</span></span><br><span class="line"><span class="comment"> *  r9  = processor ID</span></span><br><span class="line"><span class="comment"> *  r13 = *virtual* address to jump to upon completion</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * other registers depend on the function called upon completion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.align	5</span><br><span class="line">	.pushsection	.idmap.text, &quot;ax&quot;</span><br><span class="line"><span class="title function_">ENTRY</span><span class="params">(__turn_mmu_on)</span></span><br><span class="line">	mov	r0, r0</span><br><span class="line">	instr_sync</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0		@ write control reg</span><br><span class="line">	mrc	p15, 0, r3, c0, c0, 0		@ read id reg</span><br><span class="line">	instr_sync</span><br><span class="line">	mov	r3, r3</span><br><span class="line">	mov	r3, r13 @ r13 就是__mmap_switched</span><br><span class="line">	ret	r3</span><br><span class="line">__turn_mmu_on_end:</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__turn_mmu_on)</span></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在__turn_mmu_on结尾，会跳转到__mmap_switched 最终调用start_kernel 进到C语言的世界了。那么此时的内存系统是如何的呢？我们已经知道MMU已经开启，且MMU已经映射了kenrel image的地址和设备树的地址了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following fragment of code is executed with the MMU on in MMU mode,</span></span><br><span class="line"><span class="comment"> * and uses absolute addresses; this is not position independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  r0  = cp#15 control register (exc_ret for M-class)</span></span><br><span class="line"><span class="comment"> *  r1  = machine ID</span></span><br><span class="line"><span class="comment"> *  r2  = atags/dtb pointer</span></span><br><span class="line"><span class="comment"> *  r9  = processor ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	__INIT</span><br><span class="line">__mmap_switched:</span><br><span class="line"></span><br><span class="line">	mov	r7, r1</span><br><span class="line">	mov	r8, r2</span><br><span class="line">	mov	r10, r0</span><br><span class="line"></span><br><span class="line">	adr	r4, __mmap_switched_data</span><br><span class="line">	mov	fp, #<span class="number">0</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   ARM(	ldmia	r4!, &#123;r0, r1, sp&#125; )</span><br><span class="line">	sub	r2, r1, r0</span><br><span class="line">	mov	r1, #<span class="number">0</span></span><br><span class="line">	bl	<span class="built_in">memset</span>				@ clear .bss <span class="comment">//这里是将bss段的数据清零</span></span><br><span class="line"></span><br><span class="line">	ldmia	r4, &#123;r0, r1, r2, r3&#125;</span><br><span class="line">	str	r9, [r0]			@ Save processor ID</span><br><span class="line">	str	r7, [r1]			@ Save machine type</span><br><span class="line">	str	r8, [r2]			@ Save atags pointer</span><br><span class="line">	cmp	r3, #<span class="number">0</span></span><br><span class="line">	strne	r10, [r3]			@ Save control <span class="keyword">register</span> values</span><br><span class="line">	mov	lr, #<span class="number">0</span></span><br><span class="line">	b	start_kernel</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__mmap_switched)</span></span><br><span class="line">	.align	2</span><br><span class="line">	.type	__mmap_switched_data, %object</span><br><span class="line"></span><br><span class="line">__mmap_switched_data:</span><br><span class="line">	.<span class="type">long</span>	__bss_start			@ r0</span><br><span class="line">	.<span class="type">long</span>	__bss_stop			@ r1</span><br><span class="line">	.<span class="type">long</span>	init_thread_union + THREAD_START_SP @ sp</span><br><span class="line"></span><br><span class="line">	.<span class="type">long</span>	processor_id			@ r0</span><br><span class="line">	.<span class="type">long</span>	__machine_arch_type		@ r1</span><br><span class="line">	.<span class="type">long</span>	__atags_pointer			@ r2</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_CP15</span></span><br><span class="line">	.<span class="type">long</span>	cr_alignment			@ r3</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="title function_">M_CLASS</span><span class="params">(.<span class="type">long</span>	exc_ret)</span>			@ r3</span><br><span class="line"><span class="title function_">AR_CLASS</span><span class="params">(.<span class="type">long</span>	<span class="number">0</span>)</span>				@ r3</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.size	__mmap_switched_data, . - __mmap_switched_data</span><br><span class="line"></span><br><span class="line">	__FINIT</span><br><span class="line">	.text</span><br></pre></td></tr></table></figure>



<h2 id="二、start-kernel-阶段"><a href="#二、start-kernel-阶段" class="headerlink" title="二、start_kernel 阶段"></a>二、start_kernel 阶段</h2><h2 id="一、memblock"><a href="#一、memblock" class="headerlink" title="一、memblock"></a>一、memblock</h2><h3 id="1-1、设备树描述物理内存"><a href="#1-1、设备树描述物理内存" class="headerlink" title="1.1、设备树描述物理内存"></a>1.1、设备树描述物理内存</h3><p>kernel从设备树中获取到系统的物理内存信息。内存大致可以分为通用和专用内存，kenrel可以从通用内存中申请内存用于系统运行，而专用内存则是给专门的设备进行访问的，由设备驱动管理，不允许kernel从其中申请内存。例如以下kernel doc 中的例子：</p>
<p>下面的设备树信息描述了系统的物理内存分布：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	memory &#123; </span><br><span class="line">        reg = &lt;<span class="number">0x40000000</span> <span class="number">0x40000000</span>&gt;; </span><br><span class="line">    &#125;;</span><br><span class="line">	reserved-memory &#123; </span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		ranges;</span><br><span class="line">		<span class="comment">/* global autoconfigured region for contiguous allocations */</span></span><br><span class="line">		linux,cma &#123; </span><br><span class="line">            compatible = <span class="string">&quot;shared-dma-pool&quot;</span>;</span><br><span class="line">			reusable;</span><br><span class="line">			size = &lt;<span class="number">0x4000000</span>&gt;;</span><br><span class="line">			alignment = &lt;<span class="number">0x2000</span>&gt;;</span><br><span class="line">			linux,cma-<span class="keyword">default</span>; </span><br><span class="line">        &#125;;</span><br><span class="line">		display_reserved: framebuffer@<span class="number">78000000</span> &#123; </span><br><span class="line">            reg = &lt;<span class="number">0x78000000</span> <span class="number">0x800000</span>&gt;; </span><br><span class="line">        &#125;;</span><br><span class="line">		multimedia_reserved: multimedia@<span class="number">77000000</span> &#123; </span><br><span class="line">            compatible = <span class="string">&quot;acme,multimedia-memory&quot;</span>;</span><br><span class="line">			reg = &lt;<span class="number">0x77000000</span> <span class="number">0x4000000</span>&gt;; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>对cpu来说，起始地址0x40000000，大小为0x40000000（1G）的地址映射到物理内存0-&gt;1G上。其中有三个保留内存区：</p>
<ol>
<li>cma：连续物理内存区，用于设备dma 操作</li>
<li>display：显示缓冲区</li>
<li>multimedia：多媒体处理数据区</li>
</ol>
<p>这三个区的内存都是用于特殊设备的，我们不希望kernel从这三个区中申请内存，故设置为reserved区。</p>
<h3 id="1-2、memblock"><a href="#1-2、memblock" class="headerlink" title="1.2、memblock"></a>1.2、memblock</h3><p>memblock 系统就是需要将设备中的信息解析到内核memblock数据结构中，并提供内存申请的接口给kernel中的其他驱动。对于memblock的源码，博客<a target="_blank" rel="noopener" href="https://tinylab.org/riscv-memblock/">memblock 内存分配器原理和代码分析 - 泰晓科技 (tinylab.org)</a>已经分析得很透彻.</p>
<p>memblock的初始化代码在arm_memblock_init()，初始化完成后，memblock 是以下图的方式描述物理内存的：</p>
<p><img src="/2025/05/30/hello-world/Linux/mem_init/mem_block.png" alt="物理内存管理_1"></p>
<p>memblock只是一个简单的内存分配器，只在系统初始化阶段使用，当系统开始初始化buddy system时，就需要memblock把空闲的内存区交出来给buddy system管理。buddy system 会提供内存分配功能给linux 运行时使用。</p>
<h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/mem_init/" data-id="cmbcy7rh60019t8mt1nxv5i4j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/mm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/mm/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.642Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="/2025/05/30/hello-world/Linux/mm/mm_apis.png" alt="image-20230603134828655"></p>
<h3 id="一、伙伴系统"><a href="#一、伙伴系统" class="headerlink" title="一、伙伴系统"></a>一、伙伴系统</h3><p>alloc_pages()</p>
<p>page_address()</p>
<h3 id="二、slab-高速缓存"><a href="#二、slab-高速缓存" class="headerlink" title="二、slab 高速缓存"></a>二、slab 高速缓存</h3><p>需求：在内核编程中有许多的结构体，对象需要从堆中动态申请。每个结构体大小大约是几个字节到几百个字节。这些结构体会被频繁的申请、释放，从而导致内存碎片的存在。对象缓存的机制被设计来缓解内存碎片的情况。</p>
<p>首先linux定义了一系列固定大小的内存池，16byte~4kbyte，这些内存池在初始化的时候创建</p>
<p>kmem_cache_create() </p>
<h3 id="三、创建高速缓存"><a href="#三、创建高速缓存" class="headerlink" title="三、创建高速缓存"></a>三、创建高速缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache_create_usercopy</span><br><span class="line">	create_cache</span><br><span class="line">		kmem_cache_zalloc 从指定高速缓存中申请一个对象</span><br><span class="line">		__kmem_cache_create 创建一个新的高速缓存</span><br><span class="line">			setup_cpu_cache 创建cpu cache</span><br></pre></td></tr></table></figure>



<p>slab_state 表示启动过程的slab可用的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">slab_state</span> &#123;</span></span><br><span class="line">	DOWN,			<span class="comment">/* No slab functionality yet */</span></span><br><span class="line">	PARTIAL,		<span class="comment">/* SLUB: kmem_cache_node available */</span></span><br><span class="line">	PARTIAL_NODE,		<span class="comment">/* SLAB: kmalloc size for node struct available */</span></span><br><span class="line">	UP,			<span class="comment">/* Slab caches usable but not all extras yet */</span></span><br><span class="line">	FULL			<span class="comment">/* Everything is working */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<p><img src="/2025/05/30/hello-world/Linux/mm/fork_init.png" alt="image-20230603210121511"></p>
<h3 id="四、kmalloc"><a href="#四、kmalloc" class="headerlink" title="四、kmalloc"></a>四、kmalloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache_init:start_kernel时调用创建所有kmalloc所需要的cache</span><br><span class="line">kmem_cache_node_init：初始化;</span><br><span class="line">create_boot_cache 创建boot阶段的cache;</span><br><span class="line">kmalloc_node 申请一块内存</span><br></pre></td></tr></table></figure>



<h4 id="1、创建kmalloc对应的cache"><a href="#1、创建kmalloc对应的cache" class="headerlink" title="1、创建kmalloc对应的cache"></a>1、创建kmalloc对应的cache</h4><p>启动过程中cache的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bootstrap is tricky, because several objects are allocated</span></span><br><span class="line"><span class="comment"> * from caches that do not exist yet:</span></span><br><span class="line"><span class="comment"> * 1) initialize the kmem_cache cache: it contains the struct</span></span><br><span class="line"><span class="comment"> *    kmem_cache structures of all caches, except kmem_cache itself:</span></span><br><span class="line"><span class="comment"> *    kmem_cache is statically allocated.</span></span><br><span class="line"><span class="comment"> *    Initially an __init data area is used for the head array and the</span></span><br><span class="line"><span class="comment"> *    kmem_cache_node structures, it&#x27;s replaced with a kmalloc allocated</span></span><br><span class="line"><span class="comment"> *    array at the end of the bootstrap.</span></span><br><span class="line"><span class="comment"> * 2) Create the first kmalloc cache.</span></span><br><span class="line"><span class="comment"> *    The struct kmem_cache for the new cache is allocated normally.</span></span><br><span class="line"><span class="comment"> *    An __init data area is used for the head array.</span></span><br><span class="line"><span class="comment"> * 3) Create the remaining kmalloc caches, with minimally sized</span></span><br><span class="line"><span class="comment"> *    head arrays.</span></span><br><span class="line"><span class="comment"> * 4) Replace the __init data head arrays for kmem_cache and the first</span></span><br><span class="line"><span class="comment"> *    kmalloc cache with kmalloc allocated arrays.</span></span><br><span class="line"><span class="comment"> * 5) Replace the __init data for kmem_cache_node for kmem_cache and</span></span><br><span class="line"><span class="comment"> *    the other cache&#x27;s with kmalloc allocated memory.</span></span><br><span class="line"><span class="comment"> * 6) Resize the head arrays of the kmalloc caches to their final sizes.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<p>kmalloc 所使用的所有cache：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class"><span class="title">kmalloc_caches</span>[<span class="title">NR_KMALLOC_TYPES</span>][<span class="title">KMALLOC_SHIFT_HIGH</span> + 1];</span></span><br></pre></td></tr></table></figure>

<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache_init-&gt;</span><br><span class="line">    kmem_cache = &amp;kmem_cache_boot;  <span class="comment">//初始化用于创建struct kmem_cache 的高速缓存</span></span><br><span class="line">	kmem_cache_node_init(&amp;init_kmem_cache_node[i]);  <span class="comment">//初始化节点</span></span><br><span class="line">	create_boot_cache(kmem_cache, <span class="string">&quot;kmem_cache&quot;</span>,...)  <span class="comment">//初始化kemem_cache 高速缓存</span></span><br><span class="line">        __kmem_cache_create()</span><br><span class="line">        	setup_cpu_cache()  <span class="comment">//创建cpu cache</span></span><br><span class="line">      			alloc_kmem_cache_cpus(cachep, <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//void *数组，一个数组一个元素</span></span><br><span class="line">					__alloc_percpu(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">					init_arraycache()  <span class="comment">//初始化cpu cache</span></span><br><span class="line">    list_add(&amp;kmem_cache-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	slab_state = PARTIAL;  <span class="comment">//表示高速缓存kmem_cache可用于分配 kmem_cache对象</span></span><br><span class="line">    kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE] = create_kmalloc_cache()... <span class="comment">//创建kmem_cache_nodte高速缓存</span></span><br><span class="line">    	kmem_cache_zalloc(kmem_cache, GFP_NOWAIT); <span class="comment">//从kmem_cache高速缓存中申请一个kmem_cache</span></span><br><span class="line">    	create_kmalloc_caches()  <span class="comment">//初始化kmem_cache_nodte高速缓存</span></span><br><span class="line">        list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);  <span class="comment">//添加到链表</span></span><br><span class="line">    slab_state = PARTIAL_NODE;  <span class="comment">//表示 kmem_cache_node 可以用于分配kmem_cache_node对象</span></span><br><span class="line">	setup_kmalloc_cache_index_table()</span><br><span class="line">	slab_early_init = <span class="number">0</span>;  </span><br><span class="line">	<span class="comment">//将之前的kmem_cache_node对象替换成kmalloc申请的对象</span></span><br><span class="line">	create_kmalloc_caches(ARCH_KMALLOC_FLAGS)</span><br><span class="line">        new_kmalloc_cache()  <span class="comment">//对所有kmalloc_caches[]创建高速缓存</span></span><br><span class="line">        	create_kmalloc_cache()  <span class="comment">//初始化kmem_cache高速缓存</span></span><br><span class="line">        slab_state = UP;  <span class="comment">//表示kmalloc可以正常使用了</span></span><br><span class="line">kmem_cache_init_late</span><br></pre></td></tr></table></figure>



<p>create_kmalloc_caches</p>
<p>kmalloc_slab</p>
<h4 id="2、kmalloc"><a href="#2、kmalloc" class="headerlink" title="2、kmalloc"></a>2、kmalloc</h4><p>先根据size找到kmem_cache，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache</span><br></pre></td></tr></table></figure>



<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="array-cache"><a href="#array-cache" class="headerlink" title="array_cache"></a>array_cache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct array_cache</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> * - LIFO ordering, to hand out cache-warm objects from _alloc</span></span><br><span class="line"><span class="comment"> * - reduce the number of linked list operations</span></span><br><span class="line"><span class="comment"> * - reduce spinlock operations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The limit is stored in the per-cpu structure to reduce the data cache</span></span><br><span class="line"><span class="comment"> * footprint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> avail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> touched;</span><br><span class="line">	<span class="type">void</span> *entry[];	<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Must have this definition in here for the proper</span></span><br><span class="line"><span class="comment">			 * alignment of array_cache. Also simplifies accessing</span></span><br><span class="line"><span class="comment">			 * the entries.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a>kmem_cache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Definitions unique to the original Linux SLAB allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> __<span class="title">percpu</span> *<span class="title">cpu_cache</span>;</span>  <span class="comment">//实际的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1) Cache tunables. Protected by slab_mutex */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_buffer_size</span>;</span></span><br><span class="line"><span class="comment">/* 2) touched by every alloc &amp; free from the backend */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;		<span class="comment">/* constant flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num;		<span class="comment">/* # of objs per slab */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3) cache_grow/shrink */</span></span><br><span class="line">	<span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gfporder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> colour;			<span class="comment">/* cache colouring range */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_off;	<span class="comment">/* colour offset */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">freelist_cache</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> freelist_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* constructor func */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4) cache creation/removal */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">int</span> refcount;</span><br><span class="line">	<span class="type">int</span> object_size;</span><br><span class="line">	<span class="type">int</span> align;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/mm/" data-id="cmbcy7rh6001at8mt8nsudi92" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/Linux_isr_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/Linux_isr_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.641Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux中断系统（一）进入与退出中断"><a href="#Linux中断系统（一）进入与退出中断" class="headerlink" title="Linux中断系统（一）进入与退出中断"></a>Linux中断系统（一）进入与退出中断</h1><p>本文会介绍linux 中如何进入&#x2F;退出中断处理，这部分是与ARM架构相关的，对于具体的中断处理（平台无关的），有另一篇博客介绍。</p>
<p>首先，容我在开头就指出 一个重要的结论：linux只会让代码运行在两个空间，user space 和 kernel space，这是与平台无关的。对于ARM架构来说，user space对应user mode，kernel space 则对应SVC mode。对于ARM 中的剩余mode，linux 会将其业务都放到SVC mode 中处理。例如，当IRQ产生时，cpu会短暂的进入IRQ mode，保存寄存器后，立刻切换到SVC mode，在SVC mode 中执行中断处理函数。</p>
<p>总的来说，linux 希望在user mode处理应用逻辑，在svc mode 处理其他的代码逻辑。有了这个认识，就让我们开始学习Linux 是如何从头处理arm 中断的。</p>
<h2 id="一、ARM中断"><a href="#一、ARM中断" class="headerlink" title="一、ARM中断"></a>一、ARM中断</h2><p>本文只追踪ARM 的IRQ中断，如下所示，ARM core 有R0-R15 16个通用寄存器和一个CPSR 寄存器，ARM寄存器的定义可以参考另一篇博客。这里只需要知道重点是：</p>
<p>红色框的部分是banked 寄存器，当cpu 处于user mode时，使用的是R13、R14，当切换为IRQ mode 时，R13寄存器实际上对应的是SP_svc，R14寄存器实际上对应的是LR_svc。在不同mode下，虽然寄存器在代码的命名上相同，但实际的物理电路却是不一样的。</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/reg.png" alt="image-20240312223101305"></p>
<p>当ARM core 接受到一个IRQ中断时，硬件会自动完成以下步骤：</p>
<ol>
<li>将CPSR寄存器的值复制到SPSR_irq寄存器中，保存被中断时的cpu状态</li>
<li>将返回地址保存到LR_irq寄存器中，以便将来能继续执行</li>
<li>设置CPSR，切换到IRQ mode，并且关闭中断</li>
<li>将PC 设置为中断向量表中IRQ 处理函数的地址</li>
</ol>
<p>上面4步由硬件完成后，cpu 就会去执行中断向量表IRQ处理函数，这个函数在linux 初始化时就设置好了。</p>
<h2 id="二、vector-stub"><a href="#二、vector-stub" class="headerlink" title="二、vector_stub"></a>二、vector_stub</h2><h3 id="2-1、中断向量表"><a href="#2-1、中断向量表" class="headerlink" title="2.1、中断向量表"></a>2.1、中断向量表</h3><p>我们开始进入linux 的代码世界，幸运的是，我们所需的代码都在 arch&#x2F;arm&#x2F;kernel&#x2F;entry-armv.S 中，其中中断向量表的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	.section .vectors, &quot;ax&quot;, %progbits</span><br><span class="line">.L__vectors_start:</span><br><span class="line">	W(b)	vector_rst</span><br><span class="line">	W(b)	vector_und</span><br><span class="line">	W(ldr)	pc, .L__vectors_start + 0x1000</span><br><span class="line">	W(b)	vector_pabt</span><br><span class="line">	W(b)	vector_dabt</span><br><span class="line">	W(b)	vector_addrexcptn</span><br><span class="line">	W(b)	vector_irq</span><br><span class="line">	W(b)	vector_fiq</span><br></pre></td></tr></table></figure>

<p>可以看到每个向量对应一种异常模式，可是我搜索了vector_irq，却找不到其定义，这是为何？</p>
<p>我们在文章的开头中提到，linux 希望将所有异常的实际处理逻辑都放到svc mode 中去处理，故在此，linux 定义了一个宏vector_stub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	.macro	vector_stub, name, mode, correction=0</span><br><span class="line">	.align	5</span><br><span class="line"></span><br><span class="line">vector_\name:</span><br><span class="line">	......</span><br><span class="line">ENDPROC(vector_\name)</span><br></pre></td></tr></table></figure>

<p>并且在代码中有 <code>vector_stub	irq, IRQ_MODE, 4</code> ，将其宏展开之后就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	vector_stub	irq, IRQ_MODE, 4</span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br><span class="line"></span><br><span class="line">@宏展开后：</span><br><span class="line"></span><br><span class="line">vector_irq:</span><br><span class="line">	......</span><br><span class="line">ENDPROC(vector_irq)</span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br></pre></td></tr></table></figure>

<p>原来vector_irq 就是在这里定义的。</p>
<p>vector_stub 宏的作用就是：</p>
<ol>
<li>把被打断执行的程序的寄存器保存到异常模式的栈中</li>
<li>将cpu mode切换到svc mode</li>
<li>根据被打断时的cpu mode，跳转到指定的函数处理</li>
</ol>
<p>结合文章开头说的，linux 希望将所有异常的实际处理逻辑都放到svc mode 中去处理，vector_stub概括了所有异常所需的操作，保存寄存器，切到svc mode，执行对应的代码。具体的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#name 是名称，mode 是异常模式，correction是纠正lr为下一条指令</span><br><span class="line">	.macro	vector_stub, name, mode, correction=0</span><br><span class="line"></span><br><span class="line">vector_\name:</span><br><span class="line">	# 对lr 进行纠正，将lr设置成 &quot;被打断指令&quot;的下一条指令，具体见附录说明1</span><br><span class="line">	.if \correction</span><br><span class="line">	sub	lr, lr, #\correction</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	# 将r0，lr 保存到栈中</span><br><span class="line">	stmia	sp, &#123;r0, lr&#125;</span><br><span class="line">	# 把spsr复制到lr中(spsr只能使用mrs指令访问)</span><br><span class="line">	mrs	lr, spsr</span><br><span class="line">	# 把lr保存到sp加上偏移8的地址，保存的是spsr的值</span><br><span class="line">	str	lr, [sp, #8]</span><br><span class="line"></span><br><span class="line">	# 把cpsr复制到r0</span><br><span class="line">	mrs	r0, cpsr</span><br><span class="line">	# 将r0 的mode bit 修改为SVC_MODE</span><br><span class="line">	eor	r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">	# 将r0 复制到spsr_cxsf</span><br><span class="line">	msr	spsr_cxsf, r0</span><br><span class="line"></span><br><span class="line">	# lr = lr &amp; 0x0f：lr 保存的是spsr，即取低四bit，也就是lr 保存的是cpu mode</span><br><span class="line">	and	lr, lr, #0x0f</span><br><span class="line">	# 将sp 复制到r0</span><br><span class="line">	mov	r0, sp</span><br><span class="line">    # lr = *(pc + (lr &lt;&lt; 2))，根据cpu mode更新lr 地址</span><br><span class="line">    ldr	lr, [pc, lr, lsl #2]</span><br><span class="line">    # 跳转到lr地址执行，并将spsr_cxsf 的值复制到cpsr，即切换到SVC Mode</span><br><span class="line">	movs	pc, lr</span><br><span class="line">ENDPROC(vector_\name)</span><br></pre></td></tr></table></figure>

<h3 id="2-1、vector-irq"><a href="#2-1、vector-irq" class="headerlink" title="2.1、vector_irq"></a>2.1、vector_irq</h3><p>这么看还是比较难理解，我们以vector_irq 展开后为例子进行分析，假设当前cpu 正在svc mode执行（kernel space），此时中断产生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 第一节中所述，当进入vector_irq时，lr保存的是返回地址，spsr保存的是被中断时的cpu cpsr，sp切换到SP_irq</span><br><span class="line">vector_irq:</span><br><span class="line">	# lr - 4 就是IRQ返回时要继续执行的指令</span><br><span class="line">	sub	lr, lr, #4</span><br><span class="line"></span><br><span class="line">	# 将r0，lr按地址递增保存到sp 为基地址的栈中</span><br><span class="line">	stmia	sp, &#123;r0, lr&#125;</span><br><span class="line">	# 把spsr复制到lr中(spsr只能使用mrs指令访问)</span><br><span class="line">	mrs	lr, spsr</span><br><span class="line">	# 把lr保存到sp加上偏移8的地址上，保存的是spsr的值，也就是被中断时的cpu cpsr</span><br><span class="line">	str	lr, [sp, #8]</span><br><span class="line"></span><br><span class="line">	# 把cpsr复制到r0</span><br><span class="line">	mrs	r0, cpsr</span><br><span class="line">	# 将r0 的mode bit 修改为SVC_MODE</span><br><span class="line">	eor	r0, r0, #(IRQ_MODE ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">	# 将r0 复制到spsr_cxsf</span><br><span class="line">	msr	spsr_cxsf, r0</span><br><span class="line"></span><br><span class="line">	# lr = lr &amp; 0x0f：lr 保存的是spsr，即取低四bit，也就是lr保存的是cpu mode</span><br><span class="line">	and	lr, lr, #0x0f</span><br><span class="line">	# 将sp 复制到r0</span><br><span class="line">	mov	r0, sp</span><br><span class="line">    # lr = *(pc + (lr &lt;&lt; 2))，pc 指针加上 lr &lt;&lt; 2，也就是__irq_svc的地址，lr 就是__irq_invalid的值</span><br><span class="line">    ldr	lr, [pc, lr, lsl #2]</span><br><span class="line">    # 跳转到__irq_svc执行，并将spsr_cxsf 的值复制到cpsr，即切换到SVC Mode</span><br><span class="line">	movs	pc, lr</span><br><span class="line">ENDPROC(vector_irq)</span><br><span class="line"></span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br></pre></td></tr></table></figure>

<p>执行完成后，SP_irq栈空间如图所示，并且cpu切换到svc mode，去执行__irq_svc函数，r0作为参数保存了SP_irq的值。</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/irq_stack.jpg" alt="irq_stack"></p>
<p>到此，我们可以了解vector_stub 宏所实现的目的：<strong>保存被中断的r0，lr，cpsr到异常栈中，切到svc 模式去处理异常。</strong></p>
<h2 id="三、-irq-svc"><a href="#三、-irq-svc" class="headerlink" title="三、__irq_svc"></a>三、__irq_svc</h2><p>好了，vector_stub的事告一段落，接下来就要处理与中断处理有关的逻辑了。linux 将IRQ中断处理分为两种情况：</p>
<ol>
<li>当中断产生时，cpu 正在执行用户程序</li>
<li>当中断产生时，cpu 正在执行内核代码</li>
</ol>
<p>无论哪种情况下，都需要保存被打断时刻的寄存器信息，但这两种情况所需要的处理有些不同，分别由 __irq_svc 和 __irq_user 来进行处理.</p>
<p>本节会优先分析__irq_svc，简单来说，这个函数先保存上下文，然后执行中断处理函数，在退出异常之前，检查是否需要进行抢占调度。具体代码注释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__irq_svc:</span><br><span class="line">	svc_entry          @ 保存寄存器到svc 的栈</span><br><span class="line">	irq_handler        @ 执行中断处理函数，即下一篇描述的通用中断处理流程</span><br><span class="line"></span><br><span class="line">	@以下代码是判断是否需要进行抢占调度</span><br><span class="line">	ldr	r8, [tsk, #TI_PREEMPT]		@ 获取 preempt count</span><br><span class="line">	ldr	r0, [tsk, #TI_FLAGS]		@ 获取 flags</span><br><span class="line">	teq	r8, #0                       @ 将r8 与 0 进行异或操作，若结果为0则Z标志为1，否则Z标志为0</span><br><span class="line">	movne	r0, #0				   @ 若Z为0，则将r0 强制设置为0，不允许抢占调度</span><br><span class="line">	tst	r0, #_TIF_NEED_RESCHED      @ 将r0 与 _TIF_NEED_RESCHED进行与操作，若结果为0则Z标志为1，否则为0</span><br><span class="line">	blne	svc_preempt            @ 若Z不为0，则跳转到svc_preempt 执行，进行抢占调度</span><br><span class="line"></span><br><span class="line">	svc_exit r5, irq = 1			@ 从异常退出，返回到被打断的执行流</span><br><span class="line">ENDPROC(__irq_svc)</span><br></pre></td></tr></table></figure>

<h3 id="3-1、svc-entry"><a href="#3-1、svc-entry" class="headerlink" title="3.1、svc_entry"></a>3.1、svc_entry</h3><p>在中断产生时，我们希望保存被打断执行的程序的上下文，也就是所有的寄存器信息，对于arm 来说，就是r0-&gt;r15，以及CPSR，这样中断退出后，被打断的程序就能继续执行。</p>
<p>在 vector_stub 中，我们已经保存了R0，程序返回地址LR，程序状态SPSR。那么在svc_entry中，将继续保存剩下的所有寄存器！</p>
<p>svc_entry 将要保存的r0 -&gt; r15 ，cpsr按照下图的排列顺序，保存到当前的内核栈中，kernel 的struct pt_regs 结构体表示内核栈中的寄存器信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一共有18个reg 的值，其排列如下：低地址为r0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> uregs[<span class="number">18</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/svc_stack.png" alt="image-20240313233632426"></p>
<p>接下来分析源码，以及最终栈内寄存器的局势图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.macro	svc_entry</span><br><span class="line"></span><br><span class="line">sub	sp, sp, #(SVC_REGS_SIZE - 4)  @ 将sp减去17个reg 大小，预留出17个reg 的位置</span><br><span class="line"></span><br><span class="line">stmia	sp, &#123;r1 - r12&#125;       @ 将r1-&gt;r12 的13个值依次填入预留的位置</span><br><span class="line"></span><br><span class="line"># 接下来是计算一些地址</span><br><span class="line">ldmia	r0, &#123;r3 - r5&#125;        @ 取出IRQ Stack 中r0,lr,spsr 的值到r3、r4、r5，这些值也要保存到栈中</span><br><span class="line">add	r7, sp, #S_SP - 4	     @ R7 = SP + 13个reg的大小，R7的值就是栈内r13的地址</span><br><span class="line">mov	r6, #-1			        @  r6 赋值为-1</span><br><span class="line">add	r2, sp, #(SVC_REGS_SIZE - 4)   @ R2=SP+17个reg大小，R2的值就是一开始SP的值</span><br><span class="line">str	r3, [sp, #-4]!		    @ 将r3(也就是被打断的r0)保存到sp - 4的地址</span><br><span class="line">mov	r3, lr                  @ 将lr 保存到r3</span><br><span class="line"></span><br><span class="line">@ 经过上面的操作，目前的寄存器信息如下：</span><br><span class="line">@  r2 - sp_svc 进入svc_entry时，SP_SVC的值</span><br><span class="line">@  r3 - lr_svc 进入svc_entry时，LR_SVC的值</span><br><span class="line">@  r4 - 退出中断处理后要恢复执行的地址</span><br><span class="line">@  r5 - 退出中断处理后要恢复执行的cpu 状态</span><br><span class="line">@  r6 - -1 (see pt_regs definition in ptrace.h)</span><br><span class="line">@ 将上述寄存器都保存到栈内</span><br><span class="line">stmia	r7, &#123;r2 - r6&#125;</span><br><span class="line"></span><br><span class="line">@ 似乎是访问权限相关</span><br><span class="line">get_thread_info tsk                @ 获取当前task的thread_info,保存到tsk，(tsk就是r9)</span><br><span class="line">uaccess_entry tsk, r0, r1, r2, 1   @ 保存用户空间访问的相关信息到内核栈</span><br><span class="line"></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>最终栈内的信息可以概况成下图：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/svc_stack_process.jpg" alt="中断时寄存器-1710559066915"></p>
<h3 id="3-2、svc-exit"><a href="#3-2、svc-exit" class="headerlink" title="3.2、svc_exit"></a>3.2、svc_exit</h3><p>与svc_entry 成对的是svc_exit，顾名思义，他的作用应该是恢复保存在栈中的寄存器，最终实现恢复被打断的执行流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#在irq_entry中是：svc_exit r5, irq = 1，r5保存的是要恢复的CPSR，irq=1表示中断关闭</span><br><span class="line">.macro	svc_exit, rpsr, irq = 0</span><br><span class="line"></span><br><span class="line">@ 确保中断已经关闭</span><br><span class="line">.if	\irq != 0</span><br><span class="line">.else</span><br><span class="line">disable_irq_notrace</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">@ 从栈恢复用户空间访问信息</span><br><span class="line">uaccess_exit tsk, r0, r1</span><br><span class="line"></span><br><span class="line">@ 将cpsr保存到spsr_cxsf</span><br><span class="line">msr	spsr_cxsf, \rpsr</span><br><span class="line">@ 将栈中的值恢复到r0 -&gt; pc寄存器，^ 符号会将cpsr更新为spsr_cxsf，执行完这个指令后，cpu就会恢复之前的status，并恢复之前的执行流</span><br><span class="line">ldmia	sp, &#123;r0 - pc&#125;^			@ load r0 - pc, cpsr</span><br><span class="line"></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>



<h3 id="3-3、irq-handler-svc-preempt"><a href="#3-3、irq-handler-svc-preempt" class="headerlink" title="3.3、irq_handler &amp;&amp; svc_preempt"></a>3.3、irq_handler &amp;&amp; svc_preempt</h3><p>在svc_entry 和 svc_exit 之间，由 irq_handler 负责完成中断具体逻辑的处理，从此会进入linux irq 管理的世界，与平台无关的。</p>
<p>若中断执行完成后，此时符合内核抢占，则会调用svc_prermpt 进行内核抢占调度，这就是下一话的内容了。</p>
<h2 id="四、-irq-usr"><a href="#四、-irq-usr" class="headerlink" title="四、__irq_usr"></a>四、__irq_usr</h2><p>当中断产生时，cpu正在执行用户程序，处于user mode时，vector_irq会进入到irq_usr 进行中断处理。这里的逻辑和 __irq_svc 很类似，都是保存寄存器后再进行中断处理，然后返回到被中断的地方继续执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__irq_usr:</span><br><span class="line">	usr_entry                  @ 保存寄存器</span><br><span class="line">	irq_handler                @ 中断处理</span><br><span class="line">	get_thread_info tsk        @ 获取thread_info 到r9</span><br><span class="line">	mov	why, #0                @ why 是r8</span><br><span class="line">	b	ret_to_user_from_irq  @ 返回到用户</span><br><span class="line">ENDPROC(__irq_usr)</span><br></pre></td></tr></table></figure>



<h3 id="4-1、usr-entry"><a href="#4-1、usr-entry" class="headerlink" title="4.1、usr_entry"></a>4.1、usr_entry</h3><p>usr_entry 和 svc_entry 的目的是一样的，就是将寄存器保存到当前的栈中，寄存器在栈中的排列也和struct pt_regs 一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.macro	usr_entry, trace=1, uaccess=1</span><br><span class="line"></span><br><span class="line">sub	sp, sp, #PT_REGS_SIZE     @ 在栈中预留18个reg 的位置</span><br><span class="line">   stmib	sp, &#123;r1 - r12&#125;        @ 保存r1 - r12 到栈内</span><br><span class="line"></span><br><span class="line">ldmia	r0, &#123;r3 - r5&#125;        @ 从中断栈中取出寄存器</span><br><span class="line">add	r0, sp, #S_PC			@ r0 指向栈中PC的位置</span><br><span class="line">mov	r6, #-1			        @ r6 = -1</span><br><span class="line"></span><br><span class="line">str	r3, [sp]		@ 保存之前的r0</span><br><span class="line"></span><br><span class="line">@ 保存剩余的其他寄存器</span><br><span class="line">@  r4 - lr_&lt;exception&gt;, already fixed up for correct return/restart</span><br><span class="line">@  r5 - spsr_&lt;exception&gt;</span><br><span class="line">@  r6 - orig_r0 (see pt_regs definition in ptrace.h)</span><br><span class="line">@</span><br><span class="line">@ Also, separately save sp_usr and lr_usr</span><br><span class="line">@</span><br><span class="line">stmia	r0, &#123;r4 - r6&#125;</span><br><span class="line">   stmdb	r0, &#123;sp, lr&#125;^</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>



<h3 id="4-2、ret-to-user-from-irq"><a href="#4-2、ret-to-user-from-irq" class="headerlink" title="4.2、ret_to_user_from_irq"></a>4.2、ret_to_user_from_irq</h3><p>在返回用户程序之前，也会做一些检查，查看是否需要调度、处理信号等pending job，最后通过restore_user_regs 返回到用户程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_to_user_from_irq)</span><br><span class="line">	@ 对用户空间访问的一些检查</span><br><span class="line">	ldr	r2, [tsk, #TI_ADDR_LIMIT]</span><br><span class="line">	cmp	r2, #TASK_SIZE</span><br><span class="line">	blne	addr_limit_check_failed</span><br><span class="line">	@ 检查是否需要调度、是否有信号处理、返回用户空间之前是否需要调用callback函数，若需要则进入slow_work_pending处理</span><br><span class="line">	ldr	r1, [tsk, #TI_FLAGS]</span><br><span class="line">	tst	r1, #_TIF_WORK_MASK</span><br><span class="line">	bne	slow_work_pending</span><br><span class="line">no_work_pending:</span><br><span class="line">	arch_ret_to_user r1, lr</span><br><span class="line">	ct_user_enter save = 0</span><br><span class="line"></span><br><span class="line">	restore_user_regs fast = 0, offset = 0</span><br><span class="line">ENDPROC(ret_to_user_from_irq)</span><br></pre></td></tr></table></figure>

<p>restore_user_regs 与svc_exit 的逻辑是像似的，即从栈中恢复寄存器，并跳转到被打断的地方继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.macro	restore_user_regs, fast = 0, offset = 0</span><br><span class="line">uaccess_enable r1, isb=0</span><br><span class="line"></span><br><span class="line">mov	r2, sp</span><br><span class="line">ldr	r1, [r2, #\offset + S_PSR]	@ get calling cpsr r1保存了pt_regs中的spsr，也就是发生中断时的CPSR</span><br><span class="line">ldr	lr, [r2, #\offset + S_PC]!	@ get pc lr保存了PC值，同时sp移动到了pt_regs中PC的位置</span><br><span class="line">tst	r1, #PSR_I_BIT | 0x0f </span><br><span class="line">bne	1f</span><br><span class="line">msr	spsr_cxsf, r1			@ save in spsr_svc 赋值给spsr，进行返回用户空间的准备</span><br><span class="line"></span><br><span class="line">ldmdb	r2, &#123;r0 - lr&#125;^			@ get calling r0 - lr</span><br><span class="line"></span><br><span class="line">add	sp, sp, #\offset + PT_REGS_SIZE  @ 将sp_svc恢复到进入中断时的位置</span><br><span class="line">movs	pc, lr				       @ 恢复用户程序执行，并更新cpsr</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>通过本文的学习，理解linux 对于异常处理的核心思想，就是要在内核模式下处理所有异常相关的事务。这里的内核模式，即对应cpu 的管理员模式，每个架构的cpu都有这个模式，这样就不需要care 各个平台各种差异的模式了。只需要在其他异常产生时，保存好上下文，再跳转到对应的内核模式处理即可。</p>
<p>这种思路极大的简化了异常处理的逻辑，使得linux 可以适配更多的架构。</p>
<p>那么下一篇我们就进一步学习linux 如何具体的处理一个中断事务，也就是irq_handler 函数的流程。</p>
<h2 id="六、参考书籍"><a href="#六、参考书籍" class="headerlink" title="六、参考书籍"></a>六、参考书籍</h2><ul>
<li>《arm v7 user program guide》关于寄存器、异常的章节</li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/irq_subsystem/irq_handler.html">Linux kernel的中断子系统之（六）：ARM中断处理过程 (wowotech.net)</a></li>
</ul>
<h2 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h2><p>1、从异常返回时，返回地址的修正：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/lr_fix.png" alt="image-20240316090327044"></p>
<p>2、arm 处理器模式：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/arm_mode.png" alt="image-20240323102618435"></p>
<p>3、arm regs：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/arm_regs.png" alt="image-20240323102815295"></p>
<p>4、异常向量表：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/except_vector.png" alt="image-20240323103011293"></p>
<p>5、cpsr 在进入不同异常模式时，中断的使能：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/cpsr_behavior.png" alt="image-20240323103129402"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/Linux_isr_1/" data-id="cmbcy7rh30010t8mt502odpzd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/Linux_isr_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/Linux_isr_2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.641Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux中断系统（二）中断处理流程"><a href="#Linux中断系统（二）中断处理流程" class="headerlink" title="Linux中断系统（二）中断处理流程"></a>Linux中断系统（二）中断处理流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux 中断系统（一）中，我们已经知道Linux 系统是如何进入与退出中断处理的，那么本文就继续探索具体的中断处理流程，也就是Irq_handler 函数的内容。</p>
<p>在正式学习linux的中断系统之前，首先了解中断的概念。<br>中断的本质就是外部来了一个信号，这个信号表示cpu需要停止执行的程序，优先去处理一些其他的事务，这些事务往往是硬件相关的，可在短时间内完成。在处理完中断事务后，cpu 能继续执行之前的程序。</p>
<p>那么完成上述的流程需要哪些关键步骤，个人认为有以下四点：</p>
<ol>
<li>保存上下文</li>
<li>确定是哪个中断事务</li>
<li>执行中断事务处理函数</li>
<li>恢复上下文</li>
</ol>
<p>其中1、4与上下文相关的部分，在中断系统（一）中，我们已经学习了，而本文就是学习2、3的实现。</p>
<h2 id="一、硬件视图"><a href="#一、硬件视图" class="headerlink" title="一、硬件视图"></a>一、硬件视图</h2><p>首先我们先从硬件视图了解下中断是如何产生的：</p>
<p>如图所示，soc 上有一个GIC 中断控制器，它连接到ARM CPU 的IRQ 引脚，此外还有更多中断控制器，如GOIO、I2C 中断控制器等。这类控制器都有一个特征：收集后级若干中断信号，然后将中断信号上报给前级。</p>
<p>假如中断B发生中断事件，中断信号会一层层传到CPU，此时CPU 进入中断处理流程，这时候就要确定是产生了哪个中断。显然CPU需要逆着硬件中断信号的路径，回溯确定中断B。</p>
<ol>
<li>CPU会先读取GIC Interrupt Acknowledge Register，判断到是中断控制器1的中断，随后调用该中断处理函数。</li>
<li>中断控制器1 的中断处理函数中，会读取GPIO的中断状态寄存器，判断到是中断B的中断，于是调用对应的中断处理函数。</li>
</ol>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_2/irq_mapdrawio.png" alt="irq_mapdrawio"></p>
<h2 id="二、软件视图"><a href="#二、软件视图" class="headerlink" title="二、软件视图"></a>二、软件视图</h2><p>上述步骤可简单的概括为：</p>
<ol>
<li>确定中断id</li>
<li>调用对应的处理函数</li>
</ol>
<p>对于中断B、中断E和中断控制器2来说，他们在各自的中断控制器内的硬件中断号都是2，那么linux 是如何区别这三个中断的？显然使用硬件设定的硬件中断号肯定是不行的。</p>
<p>所以linux 设计了软件中断号来实现对中断信号的表示。linux 定义：在整个系统中，每一个硬件中断信号都有一个唯一的软件中断号，以及其对应的处理函数。例如上图的软件中断号可以是：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_2/irq_mapdrawio.png" alt="irq_mapdrawio"></p>
<p>这其中存在着硬件中断号和软件中断号的映射关系：</p>
<ul>
<li>中断A 的硬件中断号 1 —&gt; 软件中断号3</li>
<li>中断B 的硬件中断号 2 —&gt; 软件中断号4</li>
<li>中断D 的硬件中断号 1 —&gt; 软件中断号7</li>
</ul>
<p>由此我们得出结论：</p>
<p>要想确定一个中断对应的软件中断号我们需要：</p>
<ol>
<li>其所在的中断控制器</li>
<li>其在中断控制器中的硬件中断号</li>
</ol>
<p>上述功能可由 <code>unsigned int irq_find_mapping(struct irq_domain *domain,irq_hw_number_t hwirq)</code>实现，从该函数的入参即可了解他的功能。然后从软件中断号我们就能找到对应的中断处理函数执行。</p>
<h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><p>ok、了解完原理，我们可以快速浏览代码。</p>
<h3 id="3-1、数据结构"><a href="#3-1、数据结构" class="headerlink" title="3.1、数据结构"></a>3.1、数据结构</h3><p>首先从核心数据结构入手，函数代码无非就是围绕着核心数据结构转的。</p>
<p>linux使用irqdesc(定义在include&#x2F;linux&#x2F;irq)来抽象描述一个的中断信号。irqdesc定义如下（简单浏览）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span>  <span class="comment">//作为irq_chip函数指针的参数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;	<span class="comment">//irq状态</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;	<span class="comment">//中断流处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">// IRQ action list 是中断的实际处理函数</span></span><br><span class="line">	......</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>其最重要的成员就是中断处理函数action。</p>
<p>note:irq_desc 有两种组织形式，这里只讨论radix tree类型，即irq_desc 是通过irq_alloc_descs()动态创建的。</p>
<h3 id="3-2、中断处理流程"><a href="#3-2、中断处理流程" class="headerlink" title="3.2、中断处理流程"></a>3.2、中断处理流程</h3><p>接下里我们来看看linux下的中断是如何处理的：</p>
<p>假设中断B作为一个按键，设置为电平触发，当按下按键时，中断B输入为低电平，产生中断信号，中断信号一层层传递到CPU。</p>
<p>当CPU接收到IRQ中断时，会先保存上下文，然后调用 irq_handler（具体过程请参考前文中断系统（一））。我们就从irq_handler 开始分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro	irq_handler</span><br><span class="line">ldr	r1, =handle_arch_irq</span><br><span class="line">mov	r0, sp</span><br><span class="line">adr	lr, BSYM(<span class="number">9997f</span>)</span><br><span class="line">ldr	pc, [r1]</span><br></pre></td></tr></table></figure>

<p>irq_handler会跳转到<code>handle_arch_irq</code>执行。<code>handle_arch_irq</code>是一个全局的函数指针，在GIC初始化时，会被设置指向<code>gic_handle_irq </code>（参考补充5.3）。<code>gic_handle_irq</code>非常简单，首先获取gic对象，循环读取GIC的寄存器,获取中断号,然后调用<code>__handle_domain_irq</code>处理中断，直到gic没有中断挂起。（源码在irq-gic.c）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exception_irq_entry <span class="title function_">gic_handle_irq</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 irqstat, irqnr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> &amp;gic_data[<span class="number">0</span>];</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base = gic_data_cpu_base(gic);  <span class="comment">//获取GIC CPU Interface基地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);<span class="comment">//读取GIC interrupt acknowledge 寄存器，获取硬件中断号</span></span><br><span class="line">		irqnr = irqstat &amp; GICC_IAR_INT_ID_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//irqnr的16-1020号中断是share irq，0-16 是软件中断SGI</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(irqnr &gt;= <span class="number">1020</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (irqnr &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">			smp_rmb();</span><br><span class="line">			this_cpu_write(sgi_intid, irqstat);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//handle_domain_irq会调用__handle_domain_irq，gic-&gt;domain代表GIC中断控制器</span></span><br><span class="line">		handle_domain_irq(gic-&gt;domain, irqnr, regs);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__handle_domain_irq会先设置寄存器，然后进入中断上下文，并通过irq_find_mapping()将硬件中断号hwirq转换成虚拟中断号irq，最后将irq传递给<code>generic_handle_irq</code>继续处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __handle_domain_irq(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> hwirq,</span><br><span class="line">			<span class="type">bool</span> lookup, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);<span class="comment">//TODO 设置寄存器？</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = hwirq;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	irq_enter();<span class="comment">//TODO 进入中断上下文，禁止中断和抢占</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lookup)</span><br><span class="line">		irq = irq_find_mapping(domain, hwirq); <span class="comment">//通过中断控制器domain和硬件中断号hwirq 确定软件中断号irq</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!irq || irq &gt;= nr_irqs)) &#123;</span><br><span class="line">		ack_bad_irq(irq);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		generic_handle_irq(irq);<span class="comment">//根据软件中断号，来处理中断事务</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq_exit();<span class="comment">//退出中断上下文</span></span><br><span class="line">	set_irq_regs(old_regs);<span class="comment">//恢复寄存器</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generic_handle_irq</code>非常简单，首先根据irq找到对应的irq_desc对象，然后调用desc-&gt;handle_irq()进行下一步的中断处理。</p>
<p>那么在这个例子中，这个函数指针指向哪个函数？以IMX6UL为例，我们此时拿到的是GPIO中断控制器的软件中断号，其对应的irq_desc在初始化阶段就完成设置，其handle_irq() 对应的是<code>mx3_gpio_irq_handler()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">generic_handle_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//根据中断号找到irq_desc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);</span><br><span class="line">	generic_handle_irq_desc(irq, desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">generic_handle_irq_desc</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	desc-&gt;handle_irq(desc);<span class="comment">// mx3_gpio_irq_handler(desc)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mx3_gpio_irq_handler</code> 先读取GPIO状态寄存器，得到中断B的硬件中断号2，然后调用<code>irq_find_mapping()</code>将硬件中断号转换成虚拟中断号irq，最后同样调用<code>generic_handle_irq()</code>处理中断。</p>
<p>这一套连招我们在前面也见过，其实就是开头介绍的中断处理两步走：确定中断号，处理中断。</p>
<p>执行完这一步，cpu总算拿到了中断B的软件中断号，终于可以执行中断B的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gpio端口中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mx3_gpio_irq_handler</span><span class="params">(u32 irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 irq_stat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxc_gpio_port</span> *<span class="title">port</span> =</span> irq_get_handler_data(irq);<span class="comment">//获取GPIO对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> =</span> irq_get_chip(irq);</span><br><span class="line"></span><br><span class="line">	chained_irq_enter(chip, desc);</span><br><span class="line">	irq_stat = readl(port-&gt;base + GPIO_ISR) &amp; readl(port-&gt;base + GPIO_IMR);<span class="comment">//读取中断状态</span></span><br><span class="line">	mxc_gpio_irq_handler(port, irq_stat);<span class="comment">//处理GPIO 端口上的中断</span></span><br><span class="line">	chained_irq_exit(chip, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mxc_gpio_irq_handler</span><span class="params">(<span class="keyword">struct</span> mxc_gpio_port *port, u32 irq_stat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">	<span class="keyword">while</span> (irq_stat != <span class="number">0</span>) &#123;  <span class="comment">//循环处理所有pending的中断</span></span><br><span class="line">		<span class="type">int</span> irqoffset = fls(irq_stat) - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (port-&gt;both_edges &amp; (<span class="number">1</span> &lt;&lt; irqoffset))</span><br><span class="line">			mxc_flip_edge(port, irqoffset);</span><br><span class="line">		irq = irq_find_mapping(port-&gt;domain, irqoffset);<span class="comment">//通过GPIO控制器domain和硬件中断号，找到中断B的软件中断号</span></span><br><span class="line">		generic_handle_irq(irq);<span class="comment">//处理该中断</span></span><br><span class="line">		irq_stat &amp;= ~(<span class="number">1</span> &lt;&lt; irqoffset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，中断B的irq_desc-&gt;handle_irq() 函数会是什么呢？这个是GPIO控制器初始化时根据中断触发类型设置的。</p>
<ul>
<li>假如中断B是电平触发，则对应的是handle_level_irq()函数；</li>
<li>假如中断B是边沿触发，则对应的是handle_edge_irq()函数；</li>
<li>……</li>
</ul>
<p>其中自有略微不同的处理方案，但最终他们都会调用 handle_irq_event() 做实际的处理，handle_irq_event() 中比较重要的函数是<code>handle_irq_event_percpu</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">	for_each_action_of_desc(desc, action) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> res;</span><br><span class="line"></span><br><span class="line">		res = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">		<span class="comment">//假如在中断中打开了cpu中断，则在这里会检查并关闭</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ONCE(!irqs_disabled(),<span class="string">&quot;irq %u handler %pS enabled interrupts\n&quot;</span>,</span><br><span class="line">			      irq, action-&gt;handler))</span><br><span class="line">			local_irq_disable();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (res) &#123;  <span class="comment">//根据action-&gt;handler()返回值，进入中断下半部or处理下一个action</span></span><br><span class="line">		<span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">			__irq_wake_thread(desc, action);<span class="comment">//中断线程化处理，唤醒中断线程</span></span><br><span class="line">		<span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">			*flags |= action-&gt;flags;<span class="comment">//中断处理完成</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		retval |= res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__handle_irq_event_percpu 会调用action-&gt;handler()，这里是中断B的处理逻辑，随后根据结果看是否唤醒中断线程（中断下半部）。</p>
<p>在这里，gpio驱动中通过<code>request_irq()</code>设置的中断B的中断处理函数就被执行。</p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>本文我们了解了Linux中通用的中断处理的思想，即为每个中断源创建一个对应的irq_desc，在中断产生后，通过irq_demain和硬件中断号，确定到irq_desc后，执行中断服务函数。</p>
<h2 id="五、补充"><a href="#五、补充" class="headerlink" title="五、补充"></a>五、补充</h2><h3 id="5-1、request-irq"><a href="#5-1、request-irq" class="headerlink" title="5.1、request_irq()"></a>5.1、request_irq()</h3><p>request_irq()是驱动开发过程中经常使用的注册中断回调函数的接口，简单分析下request_irq() 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;	<span class="comment">//中断处理函数</span></span><br><span class="line">	<span class="type">void</span>			*dev_id;	<span class="comment">//用于共享中断中，判断设备驱动</span></span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span>	<span class="comment">//当是共享中断时，irqaction是一个链表，对应多个驱动中断</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;	<span class="comment">//中断线程化的线程入口函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span>	<span class="comment">//中断线程化的线程</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;	<span class="comment">//虚拟中断号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;	<span class="comment">//request_irq 传入的flag</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中断回调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="comment">//检查标志</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">//获取对应irqdesc</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="comment">//检查desc</span></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">//设置默认handler</span></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//申请action</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">//设置action成员</span></span><br><span class="line">	action-&gt;handler = handler;  <span class="comment">//设置中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;  <span class="comment">//中断线程入口</span></span><br><span class="line">	action-&gt;flags = irqflags;  <span class="comment">//中断标志</span></span><br><span class="line">	action-&gt;name = devname;  </span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line">	<span class="comment">//锁住desc</span></span><br><span class="line">	chip_bus_lock(desc);</span><br><span class="line">	<span class="comment">//注册一个irqaction，添加到irq_desc</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line">	<span class="comment">//释放锁</span></span><br><span class="line">	chip_bus_sync_unlock(desc);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(request_threaded_irq);</span><br></pre></td></tr></table></figure>

<p>需要关注的成员：</p>
<ul>
<li>irq_handler_t		handler：中断处理函数</li>
<li>void			* dev_id：用于共享中断中，判断设备驱动</li>
<li>irq_handler_t		thread_fn：中断线程化的线程入口函数</li>
</ul>
<h3 id="5-2、irq-desc初始化"><a href="#5-2、irq-desc初始化" class="headerlink" title="5.2、irq_desc初始化"></a>5.2、irq_desc初始化</h3><p>当linux初始化时，会为每一个中断信号初始化一个irqdesc对象，保存在内核的链表中。当CPU接收到中断时，会找到对应的irqdesc对象去处理中断。本节记录了irq_desc常用的几个API（irqdesc.c）</p>
<p>在irqdesc.c中提供函数 <code>early_irq_init</code> 来初始化irqdesc对象，先确定irq的数量，再创建对应的irq_desc，当然这些irq_desc还未初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//早期中断初始化，主要就是初始化irqdesc</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">early_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//第一个设备节点</span></span><br><span class="line">	<span class="type">int</span> i, initcnt, node = first_online_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//todo 多核处理器相关</span></span><br><span class="line">	init_irq_default_affinity();	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Let arch update nr_irqs and return the nr of preallocated irqs */</span></span><br><span class="line">	<span class="comment">//返回中断的数量 machine_desc-&gt;nr_irqs ? machine_desc-&gt;nr_irqs : NR_IRQS;</span></span><br><span class="line">	initcnt = arch_probe_nr_irqs();</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;NR_IRQS:%d nr_irqs:%d %d\n&quot;</span>, NR_IRQS, nr_irqs, initcnt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将最终的中断数量保存到全局变量nr_irqs</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))</span><br><span class="line">		nr_irqs = IRQ_BITMAP_BITS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))</span><br><span class="line">		initcnt = IRQ_BITMAP_BITS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcnt &gt; nr_irqs)</span><br><span class="line">		nr_irqs = initcnt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化irqdesc</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; initcnt; i++) &#123;</span><br><span class="line">		<span class="comment">//为irq信号分配一个irqdesc并设置默认值</span></span><br><span class="line">		desc = alloc_desc(i, node, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">//设置标志位</span></span><br><span class="line">		set_bit(i, allocated_irqs);</span><br><span class="line">		<span class="comment">//将desc插入irq_desc_tree树或者数组</span></span><br><span class="line">		irq_insert_desc(i, desc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//arch_early_irq_init 是留给特定架构的中断初始化函数。在arm中没有用到</span></span><br><span class="line">	<span class="keyword">return</span> arch_early_irq_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是irq_desc对象的存储有两种形式，一种是使用静态数组，一种是使用RADIX_TREE，动态分配。不同的存放方式导致不同的查找方法。<br>当宏 <code>CONFIG_SPARSE_IRQ</code>定义时，使用RADIX_TREE。</p>
<p>其他API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行irq中断流处理</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_handle_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理domain中的hwirq中断流</span></span><br><span class="line"><span class="type">int</span> __handle_domain_irq(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> hwirq,<span class="type">bool</span> lookup, <span class="keyword">struct</span> pt_regs *regs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请irq_desc</span></span><br><span class="line"><span class="type">int</span> __ref __irq_alloc_descs(<span class="type">int</span> irq, <span class="type">unsigned</span> <span class="type">int</span> from, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">int</span> node,<span class="keyword">struct</span> module *owner);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_free_descs</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> from, <span class="type">unsigned</span> <span class="type">int</span> cnt)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-3、GIC初始化"><a href="#5-3、GIC初始化" class="headerlink" title="5.3、GIC初始化"></a>5.3、GIC初始化</h3><p>一般都是由GIC控制器来产生中断信号给ARM 的IRQ引脚,所以应该是由GIC相关的代码来调用<code>set_handle_irq</code>.</p>
<p>这就需要从GIC的驱动程序中来找到证据: GIC的驱动程序在 driver&#x2F;irqchip&#x2F;irq-gic.c 中,GIC初始化函数的调用流程是：</p>
<p> <code>gic_of_init()-&gt;gic_init_bases()-&gt;set_handle_irq(gic_handle_irq)</code>,可见,handle_arch_irq &#x3D;&#x3D; gic_handle_irq</p>
<h2 id="六、参考博客"><a href="#六、参考博客" class="headerlink" title="六、参考博客"></a>六、参考博客</h2><p><a target="_blank" rel="noopener" href="https://www.twblogs.net/a/5cca2fa2bd9eee1ac2edaf2a">Linux中斷子系統框架流程詳解（基於Kernel 3.16，arm，設備樹） - 台部落 (twblogs.net)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/sort/irq_subsystem">中断子系统 - 蜗窝科技 (wowotech.net)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/Linux_isr_2/" data-id="cmbcy7rh40011t8mt848egq76" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/dma-buf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/dma-buf/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.641Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>传统的驱动间物理内存共享方式无法满足低延迟、低内存占用的要求，物理内存的共享有以下问题：</p>
<ul>
<li>需要借助CPU对物理内存进行拷贝</li>
<li>不同驱动维护各自的内存管理机制，缺乏一个统一的接口<br>例如摄像头产生的图形，需要借助CPU拷贝到GPU的内存再进行处理，摄像头驱动和GPU驱动所使用的物理内存管理接口不一致。<br>上述问题在移动设备、SOC发展过程中，增加了数据处理的延迟以及功耗，需要有一套新的驱动间内存共享机制来解决问题，也就是dmabuf框架。</li>
</ul>
<p>dmabuf 是一套内核不同驱动之间共享物理内存的框架，它提供了通用的API，任何驱动&#x2F;用户都可以使用dmabuf API 去访问物理内存。<br>任何共享都会有传递和同步的问题，对于这两个问题，dmabuf 框架分别提供了对应的思路：</p>
<ul>
<li>传递：dmabuf 借助linux 虚拟文件系统，因为文件可以在进程、线程、用户&#x2F;内核 间传递，将dmabuf 与文件绑定，可以使dmabuf也拥有文件的上述特性。</li>
<li>同步：dmabuf 使用dma fence对设备驱动访问进行同步控制。dma fence支持多个读设备同时访问一个dmabuf，并在读访问完成后，同步通知写设备等，确保dmabuf的数据一致性。</li>
</ul>
<p>他的简单使用场景如下：<br>用户读取h264文件，给GPU解码，最后在显示到屏幕上。</p>
<p><img src="/2025/05/30/hello-world/Linux/dma-buf/dmabuf_1.png" alt="image-20240615230120430"></p>
<p>这里有三个角色：User space app、Kernel space gpu driver、drm driver，假设这三个角色都有访问图形的需求。<br>最基本的软件逻辑是：</p>
<ol>
<li>APP从 <code>dma heap</code>中申请一个dmabuf</li>
<li>APP读取h264文件内容到dmabuf</li>
<li>APP将dmabuf <code>enqueue</code>给GPU driver（通过GPU driver在用户态的接口）</li>
<li>GPU driver向dmabuf插入dma fence，表示这次读</li>
<li>APP将dmabuf <code>enqueue</code>给DRM driver （通过DRM driver在用户态的接口）</li>
<li></li>
</ol>
<p>用户从DRM（显示驱动）申请一个dmabuf，把dmabuf 设置给GPU驱动，并启动GPU将数据输出到dmabuf，GPU输出完成后，再将dmabuf设置到DRM 驱动，完成画面的显示。</p>
<p>在这个过程中通过共享dmabuf的方式，避免了GPU输出数据拷贝到drm frame buff的动作。</p>
<p>如下所示，dmabuf 框架分为用户层和驱动层，用户层可以通过 &#x2F;dev&#x2F;dmabuf_heap&#x2F;xxx节点，从名称为xxx的dma heap 中申请dmabuf。申请到的dmabuf 在用户层的视角就是一个文件，并由fd 标识一个dmabuf。将fd 通过DRM、GPU接口传给驱动，驱动就能共享这个dmabuf。</p>
<p>以下是一个简单的dmabuf 的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd, dmabuf_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_heap_allocation_data</span> <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line"></span><br><span class="line">data.len = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line"><span class="comment">//打开dma heap</span></span><br><span class="line">fd = open(<span class="string">&quot;/dev/dma-heap/xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从dma heap 申请dmabuf</span></span><br><span class="line">ioctl(fd, DMA_HEAP_IOCTL_ALLOC, &amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将dmabuf的fd 设置到gpu进行处理</span></span><br><span class="line">set_dmabuf_to_gpu(data.fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待gpu 输出完毕</span></span><br><span class="line">fds.fd = data.fd;</span><br><span class="line">fds.events = POLLIN | POLLOUT;</span><br><span class="line">poll(fds, <span class="number">1</span>, TIMEOUT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将dmabuf 设置到drm显示</span></span><br><span class="line">set_dmabuf_to_drm(data.fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待显示完成</span></span><br><span class="line">poll(fds, <span class="number">1</span>, TIMEOUT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放dmabuf</span></span><br><span class="line">close(data.fd);</span><br></pre></td></tr></table></figure>


<h2 id="二、dmabuf"><a href="#二、dmabuf" class="headerlink" title="二、dmabuf"></a>二、dmabuf</h2><h2 id="3-1、dmabuf使用场景"><a href="#3-1、dmabuf使用场景" class="headerlink" title="3.1、dmabuf使用场景"></a>3.1、dmabuf使用场景</h2><p>在dmabuf 的使用场景中，有两种驱动：exporter 和 importer。</p>
<ul>
<li>exporter 是dmabuf 的提供者，是实现dma heap的驱动程序，负责dmabuf 对应的物理内存的申请、释放、映射等实现。</li>
<li>importer 是dmabuf的使用者，是使用dmabuf 进行输入输出数据的驱动程序，他不关心dmabuf的申请释放，只需要往dmabuf 里读写数据即可。</li>
</ul>
<p>像上述例子中，DRM驱动首先是exporter，允许用户从dma heap申请内存，又是importer，从dmabuf 中读取数据显示到屏幕。而GPU是纯纯的importer，向dmabuf 中写入数据。</p>
<p>这两种角色的关系如下图所示：</p>
<p><img src="/2025/05/30/hello-world/Linux/dma-buf/dmabuf_2.png" alt="image-20240615175450839"></p>
<p>从上述图可见dma_buf_ops 的实现至关重要。所以接下来我们关注dmabuf是如何被创建的。</p>
<h2 id="3-2、dmabuf的创建"><a href="#3-2、dmabuf的创建" class="headerlink" title="3.2、dmabuf的创建"></a>3.2、dmabuf的创建</h2><p>dmabuf 是如何从dma heap 中被申请出来的？这部分主要是在allocate回调函数实现的，在大部分驱动中，allocate回调函数中会从物理内存中申请内存，并 调用dma_buf_export() 创建一个dmabuf 对象。</p>
<p>所以我们的重点将分析 dma_buf_export() 函数是如何创建一个dmabuf 对象的。</p>
<p>首先还是看dmabuf 的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_buf</span> &#123;</span></span><br><span class="line">	<span class="type">size_t</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>                 <span class="comment">//匿名文件，代表该dmabuf，暴露给用户从而支持跨驱动传输</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">attachments</span>;</span>      <span class="comment">//attachment 链表</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_ops</span> *<span class="title">ops</span>;</span>     <span class="comment">//重要的回调函数</span></span><br><span class="line">	<span class="type">void</span> *vmap_ptr;                    <span class="comment">//dmabuf kernel 地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_resv</span> *<span class="title">resv</span>;</span>             <span class="comment">//保留区，用于存放dma fence对象</span></span><br><span class="line">	<span class="comment">/* poll support */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> poll;            <span class="comment">//等待队列，用于poll</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_poll_cb_t</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dma_fence_cb</span> <span class="title">cb</span>;</span></span><br><span class="line">		<span class="type">wait_queue_head_t</span> *poll;</span><br><span class="line"></span><br><span class="line">		<span class="type">__poll_t</span> active;</span><br><span class="line">	&#125; cb_excl, cb_shared;              <span class="comment">//用于poll、dma fence</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是dma_buf_export() 的简略版，很简单就是根据exp_info 初始化dmabuf对象，并创建一个文件，将dmabuf 与文件绑定起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dma_buf *<span class="title function_">dma_buf_export</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dma_buf_export_info *exp_info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始dmabuf 对象</span></span><br><span class="line">	dmabuf = kzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line">	dmabuf-&gt;priv = exp_info-&gt;priv;</span><br><span class="line">	dmabuf-&gt;ops = exp_info-&gt;ops;</span><br><span class="line">	dmabuf-&gt;size = exp_info-&gt;size;</span><br><span class="line">	dmabuf-&gt;exp_name = exp_info-&gt;exp_name;</span><br><span class="line">	dmabuf-&gt;owner = exp_info-&gt;owner;</span><br><span class="line">	spin_lock_init(&amp;dmabuf-&gt;name_lock);</span><br><span class="line">	init_waitqueue_head(&amp;dmabuf-&gt;poll);</span><br><span class="line">	dmabuf-&gt;cb_excl.poll = dmabuf-&gt;cb_shared.poll = &amp;dmabuf-&gt;poll;</span><br><span class="line">	dmabuf-&gt;cb_excl.active = dmabuf-&gt;cb_shared.active = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!resv) &#123;</span><br><span class="line">		resv = (<span class="keyword">struct</span> dma_resv *)&amp;dmabuf[<span class="number">1</span>];</span><br><span class="line">		dma_resv_init(resv);</span><br><span class="line">	&#125;</span><br><span class="line">	dmabuf-&gt;resv = resv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化file</span></span><br><span class="line">	file = dma_buf_getfile(dmabuf, exp_info-&gt;flags);</span><br><span class="line">	file-&gt;f_mode |= FMODE_LSEEK;</span><br><span class="line">	dmabuf-&gt;file = file;</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;dmabuf-&gt;lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dmabuf-&gt;attachments);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//添加到全局链表</span></span><br><span class="line">	mutex_lock(&amp;db_list.lock);</span><br><span class="line">	list_add(&amp;dmabuf-&gt;list_node, &amp;db_list.head);</span><br><span class="line">	mutex_unlock(&amp;db_list.lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dmabuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、dma-buf-ops"><a href="#3-3、dma-buf-ops" class="headerlink" title="3.3、dma_buf_ops"></a>3.3、dma_buf_ops</h2><p>exporter驱动只关注struct dma_buf_export_info 对象即可，最重要的是struct dma_buf_ops对象的实现，这点需要根据具体的驱动实现。所以下面分析这些回调函数的含义是什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">//判断当前设备是否能够访问dmabuf的物理内存，一些物理内存只能由指定的设备访问如vram。若设备可以访问改物理内存，则返回一个attachment代表此次访问</span></span><br><span class="line">	<span class="type">int</span> (*attach)(<span class="keyword">struct</span> dma_buf *, <span class="keyword">struct</span> dma_buf_attachment *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放之前获取的attachment</span></span><br><span class="line">	<span class="type">void</span> (*detach)(<span class="keyword">struct</span> dma_buf *, <span class="keyword">struct</span> dma_buf_attachment *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//importer 调用这个函数，锁定dmabuf的物理内存，使其不能被迁移</span></span><br><span class="line">	<span class="type">int</span> (*pin)(<span class="keyword">struct</span> dma_buf_attachment *attach);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解锁物理内存</span></span><br><span class="line">	<span class="type">void</span> (*unpin)(<span class="keyword">struct</span> dma_buf_attachment *attach);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将dmabuf的物理内存映射到importer的地址空间，表示importer要开始访问物理内存</span></span><br><span class="line">    <span class="comment">//因为exporter要让所以attach的设备都能访问，所以可能要将物理内存移动到合适的地址，所以函数可能休眠</span></span><br><span class="line">    <span class="comment">//返回一个sg_table，表示物理地址散列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> * (*<span class="title">map_dma_buf</span>)(<span class="keyword">struct</span> <span class="title">dma_buf_attachment</span> *,</span></span><br><span class="line"><span class="class">					 <span class="title">enum</span> <span class="title">dma_data_direction</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除映射并释放sg_table</span></span><br><span class="line">	<span class="type">void</span> (*unmap_dma_buf)(<span class="keyword">struct</span> dma_buf_attachment *,</span><br><span class="line">			      <span class="keyword">struct</span> sg_table *,</span><br><span class="line">			      <span class="keyword">enum</span> dma_data_direction);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放dmabuf，exporter在这个函数释放私有数据</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> dma_buf *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//importer在使用cpu读取dmabuf前，调用该接口让exporter 确保数据在内存上且cpu能读取到正确的数据</span></span><br><span class="line">	<span class="type">int</span> (*begin_cpu_access)(<span class="keyword">struct</span> dma_buf *, <span class="keyword">enum</span> dma_data_direction);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结束cpu 访问</span></span><br><span class="line">	<span class="type">int</span> (*end_cpu_access)(<span class="keyword">struct</span> dma_buf *, <span class="keyword">enum</span> dma_data_direction);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将dmabuf 物理内存map 到用户地址空间</span></span><br><span class="line">	<span class="type">int</span> (*mmap)(<span class="keyword">struct</span> dma_buf *, <span class="keyword">struct</span> vm_area_struct *vma);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将dmabuf 物理内存map到内核地址空间</span></span><br><span class="line">	<span class="type">void</span> *(*vmap)(<span class="keyword">struct</span> dma_buf *);</span><br><span class="line">	<span class="type">void</span> (*vunmap)(<span class="keyword">struct</span> dma_buf *, <span class="type">void</span> *vaddr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dmabuf框架将一个驱动访问物理内存的动作拆分成这么多个步骤，目的就是为了多个设备能共享一个物理内存，而每个设备的访问能力，访问地址空间都可能不一样，这就需要将访问过程细细拆分，协调好每个设备的访问顺序和关系。</p>
<h1 id="四、dma-fence"><a href="#四、dma-fence" class="headerlink" title="四、dma-fence"></a>四、dma-fence</h1><p>dma fence 是用于做同步的。考虑以下场景：</p>
<p>一个dmabuf，先由GPU完成渲染，然后再交给DRM进行显示输出。那么GPU渲染完成后，如何通知DRM进行显示输出呢？也就是GPU和DRM之前如何进行同步？这就需要引入fence用于设备间的同步，fence用于表示一个操作的完成状态，故fence有两个状态，not done和done。</p>
<p>首先GPU在开始渲染操作前，创建一个fence，注册回调函数，将fence添加到dmabuf 中，随后DRM 等待该fence done。当GPU渲染完成中断上来后，会通知fence done。随后DRM线程被唤醒，进行显示操作。</p>
<p>另外，dma fence还需要考虑多设备访问的情况，即可能有多个设备在等待fence完成，那么fence就必须支持多个设备的等待。</p>
<p>那么就先看dma fence的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> *lock;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_fence_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cb_list</span>;</span>  <span class="comment">//回调函数链表，每个等待fence的驱动，都需要注册一个回调节点到该链表，当fence done时，会遍历该链表执行所有驱动的回调函数。</span></span><br><span class="line">		<span class="comment">/* @cb_list replaced by @timestamp on dma_fence_signal() */</span></span><br><span class="line">		<span class="type">ktime_t</span> timestamp;</span><br><span class="line">		<span class="comment">/* @timestamp replaced by @rcu on dma_fence_release() */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	u64 context;</span><br><span class="line">	u64 seqno;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">refcount</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如图所示：GPU线程会在操作dmabuf 前，创建fence，并等待fence完成，同时DRM也会等待该fence完成。当GPU渲染完成中断产生后，会调用fence done，依次唤醒GPU、DRM线程，GPU线程此时就可以继续下一帧图像的渲染，而DRM就可以将已经完成渲染的图像显示到屏幕。</p>
<p><img src="/2025/05/30/hello-world/Linux/dma-buf/dmabuf_3.png" alt="image-20240615224223396"></p>
<p>这个过程中调用的接口有：</p>
<ol>
<li>dma_fence_init()：初始化一个dma fence对象</li>
<li>dma_resv_reserve_shared() ：从dma resv 中保留一个share fence 指针</li>
<li>dma_resv_add_shared_fence()：将dma fence添加到resv 对象</li>
<li>dma_fence_default_wait()：向dma fence注册回调函数dma_fence_default_wait_cb，并睡眠等待dma fence完成</li>
<li>dma_fence_signal()：标志dma fence 完成，并回调dma fence 中的所有回调函数</li>
</ol>
<p>其中有一个叫dma_resv的对象，简单来说dma_resv 是一个存放dma fence的地方，一个dmabuf 可能同时有若干个dma fence，且dma fence还有共享和独占两种。dma_resv可以理解为一块内存区域，专门存放dma fence的，故要将dma fence添加到dmabuf时，要先调用dma_resv_reserve_shared() 预留出dma fence的位置，然后再调用dma_resv_add_shared_fence() 添加到dma resv。</p>
<h1 id="五、poll"><a href="#五、poll" class="headerlink" title="五、poll"></a>五、poll</h1><p>前面所述都是在内核态，但对于用户来说，也希望获取到设备的同步信息。例如在本文一开始的例子中，用户会使用poll 系统调用等待gpu渲染完成。这一切都是由dma_buf_fops来实现的。</p>
<p>在3.2中提到dmabuf的创建中，有一个步骤会创建匿名文件，这个匿名文件就是用于暴露给用户的接口。这个文件代表了一个dmabuf，用户通过该文件的fd可以操作该dmabuf的一些功能，dma_buf_fops是所有dmabuf 共享的file_operations，其中就包括poll的实现。</p>
<p>当用户调用poll 系统调用等待dmabuf时，会遍历dmabuf 上的所有fence，并将回调函数dma_buf_poll_cb注册到每一个fence上，并进入休眠。当有任意一个fence done时，就会唤醒用户线程，从而退出poll。</p>
<h2 id="二、DMA-Heap"><a href="#二、DMA-Heap" class="headerlink" title="二、DMA Heap"></a>二、DMA Heap</h2><p>dma heap 就是一个dmabuf 内存池，让用户可以从内存池中申请dmabuf。其代码主要在dma-heap.c，设备驱动可以创建自己的dma heap，从而提供给用户申请dmabuf。例如DRM驱动可以创建一个DRM dma heap。DRM驱动最重要的就算实现struct dma_heap_ops 对象，这个对象需要实现allocate() 函数，即当用户从dma heap 申请dmabuf 时，DRM驱动要如何分配真实的物理内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_heap_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*allocate)(<span class="keyword">struct</span> dma_heap *heap,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> len,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> fd_flags,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> heap_flags);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_heap</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_heap_ops</span> *<span class="title">ops</span>;</span> <span class="comment">//主要实现申请dmabuf的回调函数</span></span><br><span class="line">	<span class="type">void</span> *priv;</span><br><span class="line">	<span class="type">dev_t</span> heap_devt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">heap_cdev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dma-heap.c 中其他的代码主要是实现一个简单设备驱动，提供接口给用户。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/dma-buf/" data-id="cmbcy7rh40014t8mtb9o8bchy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/kthread" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/kthread/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.641Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内核线程的创建流程"><a href="#内核线程的创建流程" class="headerlink" title="内核线程的创建流程"></a>内核线程的创建流程</h1><p>在驱动开发过程中，我们经常需要使用到内核线程，在一次开发中，遇到一个如下的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">kthread_run(my_thread,data,..);</span><br><span class="line"></span><br><span class="line">kthread_stop(my_thread);</span><br></pre></td></tr></table></figure>

<p>在上述代码中，理想的情况是：my_thread创建完成后，就会马上开始运行，父进程则会阻塞等待my_thread()退出（kthread_stop()会设置my_thread的stop flag，并等待my_thread退出）。但是，实际上有概率发生kthread_stop() 返回-4 的错误，并且my_thread() 线程没有得到执行。</p>
<p>由此决定探索下内核线程的创建流程，其代码主要在kernel&#x2F;kthread.c，kernel&#x2F;sched&#x2F;&#x2F;core.c</p>
<h2 id="一、整体框架"><a href="#一、整体框架" class="headerlink" title="一、整体框架"></a>一、整体框架</h2><p>如图所示，内核线程创建过程有三个对象：</p>
<ol>
<li>父进程：就是创建者</li>
<li>kthreadd()：专门负责创建内核线程的一个特殊的线程</li>
<li>kthread()：所有内核线程的入口函数</li>
</ol>
<p><img src="/2025/05/30/hello-world/Linux/kthread/create_kthread.jpg" alt="内核线程的创建"></p>
<p>本质上就是父进程将函数入口my_thread()、my_data，交给kthreadd()线程去完成真正的创建job，然后父进程会阻塞等待子线程完成创建。而新线程的创建基本都是在kthreadd()线程内完成的。</p>
<h2 id="二、父进程"><a href="#二、父进程" class="headerlink" title="二、父进程"></a>二、父进程</h2><p>分析父进程创建的动作，主要是两个部分：</p>
<ol>
<li>kthread_create()</li>
<li>wake_up_process()</li>
</ol>
<p>我们的分析主要在__kthread_create_on_node()，很简答，创建一个create 对象，放进线程的入口和数据，添加到kthread_create_list 链表，然后唤醒kthreadd()线程，阻塞等待创建。当创建完成后，设置新线程调度器参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __printf(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">kthread_create_on_node</span>(<span class="title">int</span> (*<span class="title">threadfn</span>)(<span class="title">void</span> *<span class="title">data</span>),</span></span><br><span class="line"><span class="class">						    <span class="title">void</span> *<span class="title">data</span>, <span class="title">int</span> <span class="title">node</span>,</span></span><br><span class="line"><span class="class">						    <span class="title">const</span> <span class="title">char</span> <span class="title">namefmt</span>[],</span></span><br><span class="line"><span class="class">						    <span class="title">va_list</span> <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//初始化create 信息</span></span><br><span class="line">	create-&gt;threadfn = threadfn;</span><br><span class="line">	create-&gt;data = data;</span><br><span class="line">	create-&gt;node = node;</span><br><span class="line">	create-&gt;done = &amp;done;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加到链表</span></span><br><span class="line">	list_add_tail(&amp;create-&gt;<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//唤醒kthread线程</span></span><br><span class="line">	wake_up_process(kthreadd_task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待直到新线程创建完成</span></span><br><span class="line">	wait_for_completion(&amp;done);</span><br><span class="line">	</span><br><span class="line">	task = create-&gt;result;</span><br><span class="line">    <span class="comment">//设置新线程的调度方式</span></span><br><span class="line">	sched_setscheduler_nocheck(task, SCHED_NORMAL, &amp;param);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒新线程</span></span><br><span class="line">wake_up_process()</span><br></pre></td></tr></table></figure>

<p>下面重点分析kthread()</p>
<h2 id="三、kthreadd-线程"><a href="#三、kthreadd-线程" class="headerlink" title="三、kthreadd()线程"></a>三、kthreadd()线程</h2><h3 id="3-1、kthreadd"><a href="#3-1、kthreadd" class="headerlink" title="3.1、kthreadd()"></a>3.1、kthreadd()</h3><p>本节最重要的工作就是在kthreadd()线程中。kthreadd 会将kthread_create_list内的create 信息取出，拿来创建新线程，若没有线程需要创建则会一直睡眠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthreadd</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 设置kthreadd为睡眠</span></span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	    <span class="comment">// 如果kthread_create_list 链表为空，说明没有线程需要创建，调度出去</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">			schedule();</span><br><span class="line">        <span class="comment">// 被wake up</span></span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;kthread_create_lock);</span><br><span class="line">		<span class="comment">//检查 kthread_create_list</span></span><br><span class="line">        <span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line"></span><br><span class="line">			create = list_entry(kthread_create_list.next,</span><br><span class="line">					    <span class="keyword">struct</span> kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">			list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">			spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">			<span class="comment">//根据create中的信息创建线程</span></span><br><span class="line">			create_kthread(create);</span><br><span class="line"></span><br><span class="line">			spin_lock(&amp;kthread_create_lock);</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上代码，最主要的线程创建代码就在create_kthread()，create_kthread() 会将kthread() 函数作为新线程的入口地址，将create_info作为函数的参数。这意味着，当新线程创建起来后，首先是执行kthread()函数，在kthread()函数中调用我们设置的my_thread()。</p>
<h3 id="3-2、kernel-clone"><a href="#3-2、kernel-clone" class="headerlink" title="3.2、kernel_clone()"></a>3.2、kernel_clone()</h3><p>直接分析最核心的函数 kernel_clone()，另外再备注下，clone_flag为：CLONE_FS | CLONE_FILES | SIGCHLD | CLONE_VM；</p>
<ul>
<li>CLONE_FS、CLONE_FILES：复制父进程打开的目录，文件</li>
<li>SIGCHLD ：复制父进程的信号处理函数</li>
<li>CLONE_VM：复制父进程的虚拟地址空间。（这就是线程的特性）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_clone</span><span class="params">(<span class="keyword">struct</span> kernel_clone_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 clone_flags = args-&gt;flags;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//前面是一堆对clone_flag参数的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制新的线程</span></span><br><span class="line">	p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(p))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line"></span><br><span class="line">	pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">	nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">		p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">		init_completion(&amp;vfork);</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让新线程进入运行状态</span></span><br><span class="line">	wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">	put_pid(pid);</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1、copy-process"><a href="#3-2-1、copy-process" class="headerlink" title="3.2.1、copy_process()"></a>3.2.1、copy_process()</h4><p>咱们来看最主要的 copy_process()，下面简化这个函数，只取关键部分。总结一句话就是拷贝父进程的task_struct的成员，并对部分成员额外进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对flag 进行一系列检查</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从父进程复制task_struct</span></span><br><span class="line">    p = dup_task_struct(current, node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对task_struct 的成员进行初始化，很多成员涉及非常多其他功能，需要用到时再分析，只需要知道大部分成员在这里初始化</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//初始化调度器相关的成员，并选择和父进程一样的调度器策略</span></span><br><span class="line">	sched_fork(clone_flags, p);</span><br><span class="line">    <span class="comment">// 拷贝打开的文件</span></span><br><span class="line">    copy_files(clone_flags, p);</span><br><span class="line">    <span class="comment">//拷贝文件系统</span></span><br><span class="line">    copy_fs(clone_flags, p);</span><br><span class="line">    <span class="comment">//拷贝信号处理函数</span></span><br><span class="line">    copy_sighand(clone_flags, p);</span><br><span class="line">    copy_signal(clone_flags, p);</span><br><span class="line">    <span class="comment">//拷贝进程地址空间，对于线程来说，不需要独立的地址空间</span></span><br><span class="line">    copy_mm(clone_flags, p);</span><br><span class="line">    copy_namespaces(clone_flags, p);</span><br><span class="line">    copy_io(clone_flags, p);</span><br><span class="line">    <span class="comment">// 拷贝内核栈</span></span><br><span class="line">    copy_thread(clone_flags, args-&gt;<span class="built_in">stack</span>, args-&gt;stack_size, p, args-&gt;tls);</span><br><span class="line">    <span class="comment">//分配一个pid</span></span><br><span class="line">    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children, args-&gt;set_tid,</span><br><span class="line">				args-&gt;set_tid_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后是一些进程关系相关的初始化</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2、wake-up-new-task"><a href="#3-2-2、wake-up-new-task" class="headerlink" title="3.2.2、wake_up_new_task"></a>3.2.2、wake_up_new_task</h4><p>自此，线程的数据结构已经创建完成，但是线程暂时还不能运行，需要有人来将他唤醒运行。wake_up_new_task() 会将新线程设置到run queue，并检查TIF_NEED_RESCHED是否需要抢占当前线程。</p>
<p>note:</p>
<ol>
<li>run queue：每个cpu都有一个run queue，queue里的元素是线程，cpu在调度时，会从run queue中选择合适的线程进行运行。</li>
<li>TIF_NEED_RESCHED：记录在每个线程中的标志位，表示需要立刻调度当前线程。线程特定时机会检查该标志位，若举起则会马上进行线程调度，切换掉当前线程。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf.flags);</span><br><span class="line">	<span class="comment">// 设置新线程为TASK_RUNNING</span></span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程所在的run queue</span></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	post_init_entity_util_avg(p);</span><br><span class="line">	<span class="comment">//将线程放入run queue</span></span><br><span class="line">	activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">	trace_sched_wakeup_new(p);</span><br><span class="line">    <span class="comment">//检查是否需要抢占当前的线程，若需要则会设置线程的TIF_NEED_RESCHED标志位</span></span><br><span class="line">	check_preempt_curr(rq, p, WF_FORK);</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，kernel_clone() 完成了新线程数据结构的创建、并让新线程准备好被调度执行了。现在万事俱备只欠东风，这个东风就是调度时机的到来。</p>
<p>假如此时kthreadd()中没有要新建的线程，那么，kthreadd() 就会主动调用schedule()函数，发起一次线程调度。那么刚刚创建线程大概率就会开始执行。（因为有概率其他优先级更高的线程更快执行）</p>
<h2 id="四、kthread"><a href="#四、kthread" class="headerlink" title="四、kthread"></a>四、kthread</h2><p>假如此时新线程执行，根据第三节所术，新线程的入口函数是kthread()。这是因为所有内核线程在第一次执行时，还需要通知父进程，并停止运行，等待其他线程的wake up。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kthread</span><span class="params">(<span class="type">void</span> *_create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Copy data: it&#x27;s on kthread&#x27;s stack */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> =</span> _create;</span><br><span class="line">	<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">	<span class="type">void</span> *data = create-&gt;data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">self</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	self = kzalloc(<span class="keyword">sizeof</span>(*self), GFP_KERNEL);</span><br><span class="line">	set_kthread_struct(self);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">	done = xchg(&amp;create-&gt;done, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">		kfree(create);</span><br><span class="line">		do_exit(-EINTR);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!self) &#123;</span><br><span class="line">		create-&gt;result = ERR_PTR(-ENOMEM);</span><br><span class="line">		complete(done);</span><br><span class="line">		do_exit(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置my_thread</span></span><br><span class="line">	self-&gt;threadfn = threadfn;</span><br><span class="line">	self-&gt;data = data;</span><br><span class="line">	init_completion(&amp;self-&gt;exited);</span><br><span class="line">	init_completion(&amp;self-&gt;parked);</span><br><span class="line">	current-&gt;vfork_done = &amp;self-&gt;exited;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* OK, tell user we&#x27;re spawned, wait for stop or wakeup */</span></span><br><span class="line">    <span class="comment">//设置进程状态为TASK_UNINTERRUPTIBLE</span></span><br><span class="line">	__set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">	create-&gt;result = current;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Thread is going to call schedule(), do not preempt it,</span></span><br><span class="line"><span class="comment">	 * or the creator may spend more time in wait_task_inactive().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//关闭抢占</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">    <span class="comment">//complete()通知父进程，新的线程已经完成创建</span></span><br><span class="line">	complete(done);</span><br><span class="line">    <span class="comment">//执行调度程序，由于进程状态为TASK_UNINTERRUPTIBLE，故当前线程直接进入休眠</span></span><br><span class="line">	schedule_preempt_disabled();</span><br><span class="line">	<span class="comment">//开启抢占</span></span><br><span class="line">    preempt_enable();</span><br><span class="line"></span><br><span class="line">	ret = -EINTR;</span><br><span class="line">    <span class="comment">//假如设置了KTHREAD_SHOULD_STOP flag，则退出执行my_thread</span></span><br><span class="line">	<span class="keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags)) &#123;</span><br><span class="line">		cgroup_kthread_ready();</span><br><span class="line">		__kthread_parkme(self);</span><br><span class="line">        <span class="comment">//执行my_thread</span></span><br><span class="line">		ret = threadfn(data);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//退出线程</span></span><br><span class="line">	do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新线程调用complete(done)后，执行调度程序，调度器大概率会使父进程继续执行，此时父进程就会从wait_for_completion(&amp;done);处返回。具体参考第二节。随后由父进程的wake_up_process() 来唤醒my_thread()线程执行。</p>
<h2 id="五、问题复盘"><a href="#五、问题复盘" class="headerlink" title="五、问题复盘"></a>五、问题复盘</h2><p>回顾文章开头的问题，当 执行kthread_run(my_thread,data,..);之后，立刻执行kthread_stop()，会概率性出现kthread_stop() 返回-4错误。这是因为kthread_stop()会将KTHREAD_SHOULD_STOP flag举起，并等待线程退出完成。假如在kthread() 还未执行到test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags) 时，kthread_stop()已经将该flag举起，那么就会出现上述错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/kthread/" data-id="cmbcy7rh50015t8mtbsgv4h5h" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Git/sub_repository" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Git/sub_repository/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.640Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，git带子仓库的实现"><a href="#一，git带子仓库的实现" class="headerlink" title="一，git带子仓库的实现"></a>一，git带子仓库的实现</h2><p>遇到<code>“You&#39;ve added another git repository inside your current repository.&quot;</code>问题的同学直接<code>看最后</code></p>
<p><strong>一个git仓库有时候会需要引用另一个仓库，来确保能跟踪到仓库的更新。</strong></p>
<h4 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h4><p>在仓库目录下启动命令行，执行：<br><code>git submodule add url</code> 	url就算要添加的子仓库的地址。执行完成后，目录下会克隆好子仓库，同时会出现一个<code>.gitsubmodules</code>的文件，这个文件保存的是该目录下所有子仓库的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">&quot;log&quot;</span>]	<span class="comment">//子仓库名称</span></span><br><span class="line">	path = <span class="built_in">log</span>		<span class="comment">//子仓库所在目录</span></span><br><span class="line">	url = https:<span class="comment">//gitee.com/killerp/log.git	//子仓库地址</span></span><br></pre></td></tr></table></figure>
<p>然后执行<code>git status</code>可以发现有<code>.gitsubmodules</code>和<code>log</code>需要<code>commit</code>，所以 执行<code>git commit -m &quot;add log&quot;</code>;提交更新。这样一个子仓库就添加完成了。</p>
<h2 id="二-gitignore-实现忽略文件的版本管理"><a href="#二-gitignore-实现忽略文件的版本管理" class="headerlink" title="二 .gitignore 实现忽略文件的版本管理"></a>二 .gitignore 实现忽略文件的版本管理</h2><p>在一个项目中，有一些文件是不需要进行版本管理的，如编译生成的中间文件，临时文件等。这时候可以用<code>.gitignore</code>文件来实现对这些文件的管理忽略。也就是以后<code>git add .</code>和<code>git commit</code>都与<code>.gitignore</code>中指示的文件无关。</p>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p>项目目录下创建<code>.gitignore</code>文件<br>这里介绍一些常用的规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dir/ 忽略整个dir文件夹</span><br><span class="line">*.zip 忽略所有.zip</span><br><span class="line">/dir/file 忽略dir下file文件</span><br></pre></td></tr></table></figure>
<p>创建文件添加规则，例如：忽略了cJSON.h文件。</p>
<p><strong>.gitignore:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON.h</span><br></pre></td></tr></table></figure>
<p><strong>然后执行git add 和 git commit 后，发现.gitignore并未生效。推送到远程仓库中仍然有cJSON.h，这是因为.gitignore只能忽略那些没有被track（跟踪）的文件，cJSON.h文件已经被track了，所以.gitignore对它无效。</strong><br><em><strong>解决办法:执行以下：取消对所有文件的track。</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git commit -m <span class="string">&quot;delete cjson.h&quot;</span></span><br></pre></td></tr></table></figure>
<p>提交commit，仓库就删除了对<code>cJSON.h</code>的管理,最后恢复对其他文件的管理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;release&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>此后所有的git操作均与cJSON.h无关。</strong></p>
<h2 id="三，特殊情况"><a href="#三，特殊情况" class="headerlink" title="三，特殊情况"></a>三，特殊情况</h2><p><strong>当你想加入.gitignore文件对某个文件忽略时，如果你的仓库中带有子仓库，这时候需要注意了。</strong><br>当你按以上步骤执行到<code>git add .</code>时，会出现如下信息：</p>
<p><img src="/2025/05/30/hello-world/Git/sub_repository/19.png" alt="在这里插入图片描述"><br><strong>该信息提示你的仓库中有子仓库,不能直接<code>add</code>。解决办法：执行：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached <span class="built_in">log</span></span><br><span class="line">git submodule add url</span><br></pre></td></tr></table></figure>
<p><strong><code>url</code>是子仓库地址。这两句目的是删除对log的track，然后再添加log到子仓库。最后执行：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;update .gitignore&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>大功告成！你可以试试推送到远程仓库，看看文件是否已被忽略。</strong><br><strong>辛苦打字不容易，点个赞呗。</strong><br><img src="/2025/05/30/hello-world/Git/sub_repository/18.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Git/sub_repository/" data-id="cmbcy7rh3000xt8mtckhgc0cm" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/IMX6/i2c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/IMX6/i2c/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.640Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="i2c的使用以及驱动适配"><a href="#i2c的使用以及驱动适配" class="headerlink" title="i2c的使用以及驱动适配"></a>i2c的使用以及驱动适配</h2><p>学习imx-i2c驱动的编写，首先查看i2c1的设备节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">		fsl,pins = &lt;</span><br><span class="line">			MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">			MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="number">0x4001b8b0</span> </span><br><span class="line">		&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在driver目录下搜索 “fsl,imx6ul-i2c” 和 “fsl,imx21-i2c”，可以找到对应的驱动程序在i2c-imx.c文件中。</p>
<p>i2c的驱动本质上也是一个platform驱动，那么我们就关注 i2c_imx_probe 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">i2c_imx_driver</span> =</span> &#123;</span><br><span class="line">	.probe = i2c_imx_probe,</span><br><span class="line">	.remove = i2c_imx_remove,</span><br><span class="line">	.driver	= &#123;</span><br><span class="line">		.name = DRIVER_NAME,</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.of_match_table = i2c_imx_dt_ids,</span><br><span class="line">		.pm = IMX_I2C_PM,</span><br><span class="line">	&#125;,</span><br><span class="line">	.id_table	= imx_i2c_devtype,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-imx-probe"><a href="#i2c-imx-probe" class="headerlink" title="i2c_imx_probe"></a>i2c_imx_probe</h3><p>负责从设备树中获取资源，做初始化。然后初始化i2c_adapter，以及i2c控制器的时钟、中断函数。为i2c的使用做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在of_match_device数组中找到当前i2c节点对应的元素</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span> of_match_device(i2c_imx_dt_ids,</span><br><span class="line">							   &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    imxi2c_platform_data 就是时钟分频值</span></span><br><span class="line"><span class="comment">    struct imxi2c_platform_data &#123;</span></span><br><span class="line"><span class="comment">	    u32 bitrate; </span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="type">void</span> __iomem *base;</span><br><span class="line">	<span class="type">int</span> irq, ret;</span><br><span class="line">	<span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line">	<span class="comment">//获取节点中interrupts指示的中断号</span></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t get irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取节点中reg指示的内存地址</span></span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//内存地址映射</span></span><br><span class="line">	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line">	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">//获取imx_i2c_hwdata，用于配置i2c寄存器</span></span><br><span class="line">	<span class="keyword">if</span> (of_id)</span><br><span class="line">		i2c_imx-&gt;hwdata = of_id-&gt;data;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)</span><br><span class="line">				platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化i2c_adapter</span></span><br><span class="line">	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line">	i2c_imx-&gt;adapter.owner		= THIS_MODULE;</span><br><span class="line">	i2c_imx-&gt;adapter.algo		= &amp;i2c_imx_algo;  <span class="comment">//重要，I2C底层驱动</span></span><br><span class="line">	i2c_imx-&gt;adapter.dev.parent	= &amp;pdev-&gt;dev;</span><br><span class="line">	i2c_imx-&gt;adapter.nr		= pdev-&gt;id;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.of_node	= pdev-&gt;dev.of_node;</span><br><span class="line">	i2c_imx-&gt;base			= base;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取节点clocks属性值</span></span><br><span class="line">	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_imx-&gt;clk)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t get I2C clock\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(i2c_imx-&gt;clk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//是能时钟</span></span><br><span class="line">	ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t enable I2C clock\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置中断服务函数</span></span><br><span class="line">	ret = devm_request_irq(&amp;pdev-&gt;dev, irq, i2c_imx_isr,</span><br><span class="line">			       IRQF_NO_SUSPEND, pdev-&gt;name, i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t claim irq %d\n&quot;</span>, irq);</span><br><span class="line">		<span class="keyword">goto</span> clk_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化等待队列</span></span><br><span class="line">	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将i2c_imx和i2c_adapter绑定</span></span><br><span class="line">	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置总线速度i2c_imx-&gt;bitrate = 100khz</span></span><br><span class="line">	i2c_imx-&gt;bitrate = IMX_I2C_BIT_RATE;</span><br><span class="line">	ret = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">				   <span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把寄存器清零</span></span><br><span class="line">    <span class="comment">//imx_i2c_write_reg(0,i2c_imx,IMX_I2C_I2CR)</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">			i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//imx_i2c_write_reg(0,i2c_imx,IMX_I2C_I2SR)</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加adapter到i2c框架</span></span><br><span class="line">	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;registration failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> clk_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定pdev和i2c_imx</span></span><br><span class="line">	platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line">    <span class="comment">//关闭时钟</span></span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;claimed irq %d\n&quot;</span>, irq);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;device resources: %pR\n&quot;</span>, res);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;adapter name: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		i2c_imx-&gt;adapter.name);</span><br><span class="line">	dev_info(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;IMX I2C adapter registered\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始dma（no used）</span></span><br><span class="line">	i2c_imx_dma_request(i2c_imx, phy_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* Return OK */</span></span><br><span class="line"></span><br><span class="line">clk_disable:</span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们先关注底层驱动的实现，当i2c_adapter被用于传输数据时，i2c_imx-&gt;adapter.algo 是真正的执行者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">	.master_xfer	= i2c_imx_xfer,  <span class="comment">//完成一组i2c消息的传输</span></span><br><span class="line">	.functionality	= i2c_imx_func,	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的master_xfer 函数负责实现一组i2c消息的传输。</p>
<h3 id="i2c传输时序"><a href="#i2c传输时序" class="headerlink" title="i2c传输时序"></a>i2c传输时序</h3><p>为此，我们先暂时来了解i2c是如何传输数据的，分为写和读两种情况：</p>
<h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><p>写数据就是主机向从机某个地址写入数据，整个过程数据都是一个方向的。如图所示：</p>
<p><img src="/20160427085834756.png" alt="20160427085834756"></p>
<p>主机先发送一个start信号，然后传输设备地址（设备地址是一个7bit的数值，第8位为1表示接下来要读，为0表示接下来要写），由于是写数据，所以第8位是0.然后传输要写入的地址，最后是若干个字节的数据，以及结束信号。</p>
<p>以上的整一个过程，由开始信号到结束信号，在linux中抽象成一个i2c_msg。</p>
<h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>读数据就是主机向从机某个地址读出数据，由于每一次传输只能是单方向的，所以需要主机先写入要读的地址，结束此次传输。再由主机开始一个新的传输，这个数据传输的方向是从机到主机。</p>
<p><img src="/20160427085633471.png" alt="20160427085633471"></p>
<p>所以，具体的过程有两次传输：第一次主机进行写数据，发送完地址后就结束此次传输。第二次传输，由于方向是从机到主机，所以第8位为1，后续是数据，以及结束信号。</p>
<p>以上两次传输，在linux中就对应两个i2c_msg。</p>
<h3 id="i2c-imx-xfer"><a href="#i2c-imx-xfer" class="headerlink" title="i2c_imx_xfer"></a>i2c_imx_xfer</h3><p>i2c_imx_xfer()的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>很简单，就是一个adapter，还有要传输的i2c_msg，i2c_imx_xfer()负责把这些msg全部执行完成。每一个msg就是一个传输过程，就是start到stop信号的这个过程，每一个过程都是单方向的传输。</p>
<p>所以有两个类型的msg，分别是写和读，对应上文提到的i2c时序。一般来说，写是比较简单的，只需要一个msg，在msg中指定从机地址以及数据缓存，数据长度，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_write_regs</span><span class="params">(<span class="keyword">struct</span> mpu6050_dev *dev, <span class="type">unsigned</span> <span class="type">char</span> reg,<span class="type">unsigned</span> <span class="type">char</span> *data,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *) dev-&gt;pri;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;  <span class="comment">//地址</span></span><br><span class="line">    msg.flags = <span class="number">0</span>;</span><br><span class="line">    tmp[<span class="number">0</span>] = reg;  <span class="comment">//要写入的寄存器</span></span><br><span class="line">    <span class="keyword">if</span>(len+<span class="number">1</span> &gt; <span class="number">256</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;tmp[<span class="number">1</span>],data,len);  <span class="comment">//写入的数据</span></span><br><span class="line">    msg.buf = tmp;  </span><br><span class="line">    msg.len = len+<span class="number">1</span>;  <span class="comment">//设置数据长度</span></span><br><span class="line">	<span class="comment">//i2c_imx_xfer()</span></span><br><span class="line">    <span class="keyword">if</span>(i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c write failed\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而读是由两个阶段完成的，首先需要一个写寄存器地址的传输，然后才是读传输，所以需要两个msg：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_read_regs</span><span class="params">(<span class="keyword">struct</span> mpu6050_dev *dev, <span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *) dev-&gt;pri;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//first transfer:send the reg addr</span></span><br><span class="line">    msg[<span class="number">0</span>].addr = client-&gt;addr;</span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;  <span class="comment">//write</span></span><br><span class="line">    msg[<span class="number">0</span>].buf = &amp;reg;</span><br><span class="line">    msg[<span class="number">0</span>].len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//second transfer:recv the reg val</span></span><br><span class="line">    msg[<span class="number">1</span>].addr = client-&gt;addr;</span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;  <span class="comment">//read</span></span><br><span class="line">    msg[<span class="number">1</span>].buf = val;</span><br><span class="line">    msg[<span class="number">1</span>].len = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//start transfer</span></span><br><span class="line">    <span class="keyword">if</span>(i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c rd failed reg=%06x len=%d\n&quot;</span>, reg, len);</span><br><span class="line">        <span class="keyword">return</span> -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_transfer()最后是调用到对应的adapter-&gt;algo-&gt;master_xfer()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_lastmsg = <span class="literal">false</span>;  <span class="comment">//最后的消息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始iic传输</span></span><br><span class="line">	result = i2c_imx_start(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> fail0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行若干消息</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == num - <span class="number">1</span>)</span><br><span class="line">			is_lastmsg = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">             <span class="comment">//不是第一个消息</span></span><br><span class="line">			<span class="comment">//产生一个repeat start信号</span></span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_RSTA;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">             <span class="comment">//若软总线busy，马上返回，说明start信号已经开始；否则，调度程序</span></span><br><span class="line">			result =  i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">goto</span> fail0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//分别处理两种消息</span></span><br><span class="line">		<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">			result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)</span><br><span class="line">				result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				result = i2c_imx_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> fail0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">fail0:</span><br><span class="line">	<span class="comment">//停止i2c传输</span></span><br><span class="line">	i2c_imx_stop(i2c_imx);</span><br><span class="line">	<span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="i2c-imx-start"><a href="#i2c-imx-start" class="headerlink" title="i2c_imx_start"></a>i2c_imx_start</h4><p>设置i2c控制器主机模式，使能中断、发送模式、应答，可以开始i2c传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置好i2c控制器</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_start</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="comment">//获取时钟分频系数</span></span><br><span class="line">	i2c_imx_set_clk(i2c_imx);</span><br><span class="line">	<span class="comment">//使能时钟</span></span><br><span class="line">	result = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	<span class="comment">//设置时钟分频系数</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;ifdr, i2c_imx, IMX_I2C_IFDR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能iic</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待控制器稳定</span></span><br><span class="line">	udelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始i2c传输</span></span><br><span class="line">	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	temp |= I2CR_MSTA;  <span class="comment">//i2c主机模式 产生一个start信号</span></span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//若软总线busy，说明start信号已经产生，马上返回；否则，调度程序</span></span><br><span class="line">	result = i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//正常时result==0</span></span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	i2c_imx-&gt;stopped = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//使能中断、发送模式、使能发送应答、关闭dma</span></span><br><span class="line">	temp |= I2CR_IIEN | I2CR_MTX | I2CR_TXAK;</span><br><span class="line">	temp &amp;= ~I2CR_DMAEN;</span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="i2c-imx-stop"><a href="#i2c-imx-stop" class="headerlink" title="i2c_imx_stop"></a>i2c_imx_stop</h4><p>这个函数用于实现主机的停止传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i2c_imx_stop</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx-&gt;stopped) &#123;</span><br><span class="line">		<span class="comment">//产生stop信号并恢复到默认的slave receive模式</span></span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		temp &amp;= ~(I2CR_MSTA | I2CR_MTX);</span><br><span class="line">		<span class="keyword">if</span> (i2c_imx-&gt;dma)</span><br><span class="line">			temp &amp;= ~I2CR_DMAEN;</span><br><span class="line">		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (is_imx1_i2c(i2c_imx)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This delay caused by an i.MXL hardware bug.</span></span><br><span class="line"><span class="comment">		 * If no (or too short) delay, no &quot;STOP&quot; bit will be generated.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		udelay(i2c_imx-&gt;disable_delay);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//等待传输完成</span></span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx-&gt;stopped) &#123;</span><br><span class="line">        <span class="comment">//若总线空闲，说明stop信号传输完成，退出</span></span><br><span class="line">		i2c_imx_bus_busy(i2c_imx, <span class="number">0</span>);</span><br><span class="line">		i2c_imx-&gt;stopped = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭iic控制器</span></span><br><span class="line">	temp = i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//关闭时钟</span></span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-imx-bus-busy"><a href="#i2c-imx-bus-busy" class="headerlink" title="i2c_imx_bus_busy"></a>i2c_imx_bus_busy</h4><p>调用该函数会出现以下情况：具体的情况在i2c_imx_bus_busy()调用处分析</p>
<ul>
<li><p>总线busy，for_busy&#x3D;1，退出</p>
</li>
<li><p>总线空闲，for_busy&#x3D;1，等待</p>
</li>
<li><p>总线busy，for_busy&#x3D;0，等待 </p>
</li>
<li><p>总线空闲，for_busy&#x3D;0,退出</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_bus_busy</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx, <span class="type">int</span> for_busy)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> orig_jiffies = jiffies;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">		<span class="comment">//检查是否产生仲裁丢失</span></span><br><span class="line">		<span class="keyword">if</span> (temp &amp; I2SR_IAL) &#123;</span><br><span class="line">			temp &amp;= ~I2SR_IAL;</span><br><span class="line">			<span class="comment">//仲裁丢失需要向该位写0</span></span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//总线正在传输数据 且 for_busy =1 退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (for_busy &amp;&amp; (temp &amp; I2SR_IBB))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//总线未在传输数据，且 for_busy = 0 退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (!for_busy &amp;&amp; !(temp &amp; I2SR_IBB))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//500ms等待是否到达</span></span><br><span class="line">		<span class="keyword">if</span> (time_after(jiffies, orig_jiffies + msecs_to_jiffies(<span class="number">500</span>))) &#123;</span><br><span class="line">			dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">				<span class="string">&quot;&lt;%s&gt; I2C bus is busy\n&quot;</span>, __func__);</span><br><span class="line">			<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调度程序</span></span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-imx-write"><a href="#i2c-imx-write" class="headerlink" title="i2c_imx_write"></a>i2c_imx_write</h4><p>实现了一个写传输，时序如下：</p>
<blockquote>
<p>start-&gt;addr-&gt;data-&gt;ack-&gt;data-&gt;ack</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_write</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx, <span class="keyword">struct</span> i2c_msg *msgs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送slave addr</span></span><br><span class="line">	imx_i2c_write_reg(msgs-&gt;addr &lt;&lt; <span class="number">1</span>, i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">	result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	result = i2c_imx_acked(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写数据</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; msgs-&gt;len; i++) &#123;</span><br><span class="line">		imx_i2c_write_reg(msgs-&gt;buf[i], i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">		result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		result = i2c_imx_acked(i2c_imx);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-imx-read"><a href="#i2c-imx-read" class="headerlink" title="i2c_imx_read"></a>i2c_imx_read</h4><p>实现了一个读传输，时序是：</p>
<blockquote>
<p>start-&gt;addr-&gt;ack-&gt;data-&gt;ack-&gt;data-&gt;ack-&gt;data-&gt;ack-&gt;data-&gt;stop</p>
</blockquote>
<p>一般情况下，在一个读传输之前，会有一个写传输，表示要读取的寄存器的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_read</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">bool</span> is_lastmsg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, result;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">    <span class="comment">//这里考虑block_Data=0</span></span><br><span class="line">	<span class="type">int</span> block_data = msgs-&gt;flags &amp; I2C_M_RECV_LEN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将slave地址写入数据寄存器</span></span><br><span class="line">	imx_i2c_write_reg((msgs-&gt;addr &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>, i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">    <span class="comment">//等待地址传输完成</span></span><br><span class="line">	result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	<span class="comment">//检查从机acked</span></span><br><span class="line">	result = i2c_imx_acked(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立总线读取数据</span></span><br><span class="line">	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	temp &amp;= ~I2CR_MTX;  <span class="comment">//设置为接收模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置自动ack</span></span><br><span class="line">	<span class="keyword">if</span> ((msgs-&gt;len - <span class="number">1</span>) || block_data)</span><br><span class="line">		temp &amp;= ~I2CR_TXAK;</span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//从发送切换到接收，需要一个dummy read</span></span><br><span class="line">	imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用dma</span></span><br><span class="line">	<span class="keyword">if</span> (i2c_imx-&gt;dma &amp;&amp; msgs-&gt;len &gt;= DMA_THRESHOLD &amp;&amp; !block_data)</span><br><span class="line">		<span class="keyword">return</span> i2c_imx_dma_read(i2c_imx, msgs, is_lastmsg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取数据</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; msgs-&gt;len; i++) &#123;</span><br><span class="line">		u8 len = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">		result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		<span class="comment">//smbus 协议的第一个字节表示数据长度</span></span><br><span class="line">		<span class="keyword">if</span> ((!i) &amp;&amp; block_data) &#123;</span><br><span class="line">            <span class="comment">//第一个字节表示有效数据长度</span></span><br><span class="line">			len = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">			<span class="keyword">if</span> ((len == <span class="number">0</span>) || (len &gt; I2C_SMBUS_BLOCK_MAX))</span><br><span class="line">				<span class="keyword">return</span> -EPROTO;</span><br><span class="line">            <span class="comment">//增加消息长度</span></span><br><span class="line">			msgs-&gt;len += len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == (msgs-&gt;len - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (is_lastmsg) &#123;</span><br><span class="line">                <span class="comment">//最后一个传输，需要提前关闭i2c</span></span><br><span class="line">                <span class="comment">//关闭 主机模式、发送模式</span></span><br><span class="line">				temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">				temp &amp;= ~(I2CR_MSTA | I2CR_MTX);</span><br><span class="line">				imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">                <span class="comment">//若总线busy等待，总线空闲退出</span></span><br><span class="line">				i2c_imx_bus_busy(i2c_imx, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//标志已经由从机停止传输</span></span><br><span class="line">				i2c_imx-&gt;stopped = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//本次传输结束，但接下来还有新的传输，需要提前切换回发送模式（因为存在延时）</span></span><br><span class="line">				temp = readb(i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">				temp |= I2CR_MTX;  </span><br><span class="line">				writeb(temp, i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == (msgs-&gt;len - <span class="number">2</span>)) &#123;</span><br><span class="line">			<span class="comment">//当接收到最后一个字节数据后不能ac，所以在倒数第二个字节的数据时，需要关闭ack</span></span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_TXAK;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((!i) &amp;&amp; block_data)</span><br><span class="line">			msgs-&gt;buf[<span class="number">0</span>] = len;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            <span class="comment">//读取数据到buf</span></span><br><span class="line">			msgs-&gt;buf[i] =  imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="iic中断"><a href="#iic中断" class="headerlink" title="iic中断"></a>iic中断</h3><p>中断的触发源有：</p>
<ul>
<li>一个字节传输完成，1个起始信号+8个数据信号&#x3D;9个时钟</li>
<li>作为从机时，接收到自己的地址</li>
<li>仲裁丢失</li>
</ul>
<p>这里中断的作用就是判断一个字节的传输是否完成，为i2c_imx_trx_complete()函数提供判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iic中断函数 </span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">i2c_imx_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> dev_id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">//判断中断位是否有效</span></span><br><span class="line">	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">	<span class="keyword">if</span> (temp &amp; I2SR_IIF) &#123;</span><br><span class="line">		<span class="comment">//保存状态寄存器</span></span><br><span class="line">		i2c_imx-&gt;i2csr = temp;</span><br><span class="line">		temp &amp;= ~I2SR_IIF;</span><br><span class="line">        <span class="comment">//清除中断标志</span></span><br><span class="line">		temp |= (i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode &amp; I2SR_IIF);</span><br><span class="line">		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">        <span class="comment">//唤醒队列，即执行i2c_imx_trx_complete</span></span><br><span class="line">		wake_up(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待传输完成</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_trx_complete</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx)</span></span><br><span class="line">&#123;</span><br><span class="line">	wait_event_timeout(i2c_imx-&gt;<span class="built_in">queue</span>, i2c_imx-&gt;i2csr &amp; I2SR_IIF, HZ / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//unlikely(x)表示x中的条件成立的机率较低，用于优化编译器</span></span><br><span class="line">	<span class="comment">//判断是否产生了中断</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(i2c_imx-&gt;i2csr &amp; I2SR_IIF))) &#123;</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; Timeout\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">	&#125;</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; TRX complete\n&quot;</span>, __func__);</span><br><span class="line">	i2c_imx-&gt;i2csr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="platform-框架"><a href="#platform-框架" class="headerlink" title="platform 框架"></a>platform 框架</h2><h3 id="platform-device"><a href="#platform-device" class="headerlink" title="platform_device"></a>platform_device</h3><p>platform_device是从设备树中来的，具体如何来，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010961173/article/details/94297632">设备树和Platform架构–5–platform_device创建_huofengfeihu的博客-CSDN博客_platform_device</a></p>
<p>总结下来就是：</p>
<ul>
<li>内核函数of_platform_default_populate_init, 遍历device_node树, 生成platform_device</li>
<li>并非所有的device_node都会转换为platform_device，该节点必须含有compatible属性</li>
</ul>
<p>关于platform框架的接口定义在include&#x2F;linux&#x2F;platform_device.h。驱动开发者主要使用以下函数来获取设备的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;  <span class="comment">//设备名称</span></span><br><span class="line">	<span class="type">int</span>		id;  <span class="comment">//设备id</span></span><br><span class="line">	<span class="type">bool</span>		id_auto;  <span class="comment">//自动分配id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span>  <span class="comment">//继承基类device</span></span><br><span class="line">	u32		num_resources;  <span class="comment">//设备的资源数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span>  <span class="comment">//设备的资源</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span>  <span class="comment">//用于匹配对应驱动</span></span><br><span class="line">	<span class="type">char</span> *driver_override; <span class="comment">//用于匹配驱动的名称</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MFD cell pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arch specific additions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> platform_get_device_id(pdev)	((pdev)-&gt;id_entry)</span></span><br><span class="line"><span class="comment">//将结构体成员转换成platform_device</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_platform_device(x) container_of((x), struct platform_device, dev)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设备的资源</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *,</span></span><br><span class="line"><span class="params">					      <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//获取设备中断号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//通过属性名称获取资源</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *,</span></span><br><span class="line"><span class="params">						     <span class="type">unsigned</span> <span class="type">int</span>,</span></span><br><span class="line"><span class="params">						     <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="comment">//通过名称获取中断号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_get_irq_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="platform-driver"><a href="#platform-driver" class="headerlink" title="platform_driver"></a>platform_driver</h3><p>platform_driver需要开发者去实现其中的函数指针，注意id_table要与设备树中的compatible属性一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);  <span class="comment">//设备驱动匹配时执行</span></span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">	<span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span>  <span class="comment">//继承基类device_driver</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span>  <span class="comment">//用于和platform_device匹配</span></span><br><span class="line">	<span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_platform_driver(drv)	(container_of((drv), struct platform_driver, \</span></span><br><span class="line"><span class="meta">				 driver))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册platform_driver</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line"><span class="meta">	__platform_driver_register(drv, THIS_MODULE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非热插拔设备，也就是冷设备，在开机时就启动，所以没有匹配过程，需要用platform_driver_probe把驱动peobe()编译到 __init段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_probe(drv, probe) \</span></span><br><span class="line"><span class="meta">	__platform_driver_probe(drv, probe, THIS_MODULE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取pdev-&gt;dev.driver_data</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">platform_get_drvdata</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> dev_get_drvdata(&amp;pdev-&gt;dev);  <span class="comment">//return pdev-&gt;dev.driver_data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置pdev-&gt;dev.driver_data</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">platform_set_drvdata</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	dev_set_drvdata(&amp;pdev-&gt;dev, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/IMX6/i2c/" data-id="cmbcy7rhb001st8mt5ae897nc" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
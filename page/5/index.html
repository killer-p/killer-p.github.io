<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/STM32/ble_debuger_hc-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/STM32/ble_debuger_hc-05/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.647Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>测试项目地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/stm32_ble_debug">https://gitee.com/killerp/stm32_ble_debug</a></p>
<p>串口是我们经常用来输出数据的接口，使用一些蓝牙串口模块，如HC-05能方便的通过蓝牙将串口数据发送到上位机，省去了串口连线到电脑的步骤。</p>
<p><strong>今天分享一个功能强大的APP,蓝牙调试器，它具备以下功能</strong></p>
<ul>
<li><p><strong>发送&#x2F;接收蓝牙串口的数据</strong></p>
</li>
<li><p><strong>自定义蓝牙串口 发送&#x2F;接收数据包格式</strong></p>
</li>
<li><p><strong>支持多种控件：如按键，文本，滑动窗口，坐标轴显示等。</strong></p>
</li>
</ul>
<p><strong>尤其是自定义数据包格式 和 多种可选的控件 是数据处理强大工具！</strong></p>
<p>本次实验基于stm32及HC-05蓝牙串口模块，上位机为安卓手机，蓝牙调试器下载：</p>
<p>应用商店搜索 <code>蓝牙调试器</code>，APP图标见下图：</p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/20210517205508381.png" alt="在这里插入图片描述"></p>
<h2 id="一，设置数据包格式"><a href="#一，设置数据包格式" class="headerlink" title="一，设置数据包格式"></a>一，设置数据包格式</h2><p>APP界面如图所示，设备连接 与 对话模式 都是基操 ，我们直奔主题：<strong>专业调试</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/2021051720591697.jpg" alt="在这里插入图片描述"></p>
<p><strong>首先新建一个工程，暂时取名为demo，我们需要关注 编辑控件 和 通信设置 功能；先进入通信设置，设置我们的数据包格式：</strong></p>
<p>根据自己的数据需求，设置数据包内传输的数据。数据包的格式设置规则如下：</p>
<ul>
<li>起始字节:<code>0xA5</code></li>
<li>原始数据</li>
<li>校验和（原始数据所有字节之和，再取低8bit数据）</li>
<li>结束字节:<code>0x5A</code></li>
</ul>
<p>数据格式支持<code>bool，char，short，int，float</code>四种c语言常用的数据类型，在本次例程中，我将传输char，short，int，float类型的数据。假定我们要发送和接收的数据包格式如下：</p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/2021051721251260.png" alt="在这里插入图片描述"></p>
<p><strong>根据上面的数据包格式，到APP中的发送和接收数据包界面，分别添加一个char,short,int,float的变量;如图：到此我们就完成了数据包格式的设置了。</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/20210517213030362.jpg" alt="在这里插入图片描述"></p>
<h2 id="二，编辑控件"><a href="#二，编辑控件" class="headerlink" title="二，编辑控件"></a>二，编辑控件</h2><p><strong>这里以Y-T一维波形图为例子</strong>，简单介绍控件的设置流程：</p>
<p>点击+，选择Y-T一维波形图，随后弹出下面窗口：</p>
<p><strong>该波形图能同时显示6个通道的数据，Receive表示数据来自接收的数据包，随后是数据类型，最后是链接到上一步中我们创建的变量。</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/20210517213724203.jpg" alt="在这里插入图片描述"></p>
<p>补充：右上角的黄色的齿轮可设置数据接收周期，这个取决于逆串口发送的周期，暂时设置为100ms。同时还能支持控件的移动和缩放等。</p>
<h2 id="三，stm32-串口发送"><a href="#三，stm32-串口发送" class="headerlink" title="三，stm32 串口发送"></a>三，stm32 串口发送</h2><p>蓝牙调试器的设置基本完成了，接下来就是单片机的串口程序设计了，这里以stm32为例子：</p>
<p>简单介绍一下串口的配置：</p>
<ul>
<li><strong>串口波特率：9600</strong></li>
<li><strong>使能DMA发送</strong></li>
<li><strong>使能接收中断</strong></li>
</ul>
<p>这一段代码显示如何组装我们的数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART_TX_LEN 14	<span class="comment">//数据包大小</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> USART_TX_BUF[USART_TX_LEN];	<span class="comment">//数据包缓存区</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x = <span class="number">0x01</span>;	</span><br><span class="line"><span class="type">short</span> y = <span class="number">0x02</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="number">0x03</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">4.5</span>;	</span><br><span class="line"></span><br><span class="line">USART_TX_BUF[<span class="number">0</span>] = <span class="number">0xA5</span>;	</span><br><span class="line">	</span><br><span class="line">USART_TX_BUF[<span class="number">1</span>] = (<span class="type">uint8_t</span>)x;</span><br><span class="line">	</span><br><span class="line">Short_to_Byte(y,&amp;USART_TX_BUF[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">Int_to_Byte(z,&amp;USART_TX_BUF[<span class="number">4</span>]);</span><br><span class="line">	</span><br><span class="line">Float_to_Byte(f,&amp;USART_TX_BUF[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算校验和</span></span><br><span class="line">USART_TX_BUF[<span class="number">12</span>] =(<span class="type">uint8_t</span>) ((USART_TX_BUF[<span class="number">1</span>]+USART_TX_BUF[<span class="number">2</span>]+USART_TX_BUF[<span class="number">3</span>]+USART_TX_BUF[<span class="number">4</span>]+USART_TX_BUF[<span class="number">5</span>]+USART_TX_BUF[<span class="number">6</span>]+USART_TX_BUF[<span class="number">7</span>]+USART_TX_BUF[<span class="number">8</span>]+USART_TX_BUF[<span class="number">9</span>]+USART_TX_BUF[<span class="number">10</span>]+USART_TX_BUF[<span class="number">11</span>])&amp;<span class="number">0xff</span>);</span><br><span class="line">	</span><br><span class="line">USART_TX_BUF[<span class="number">13</span>] = <span class="number">0x5A</span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//通过串口1发送</span></span><br><span class="line">ble_send(USART_TX_BUF,<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时100ms</span></span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>串口发送函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//send data to hc-05</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ble_send</span><span class="params">(<span class="type">uint8_t</span> *data,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_TC)!=SET);	<span class="comment">//wait until tx complete</span></span><br><span class="line">	<span class="keyword">if</span>(!data)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	HAL_UART_Transmit_DMA(&amp;huart1,data,len);	<span class="comment">//Ê¹ÓÃDMAÄ£Ê½·¢ËÍ</span></span><br><span class="line">	<span class="keyword">while</span>(__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_TC)!=SET);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要将short,int,float类型变量转换为字节类型变量，才能通过串口传输，下面函数实现转换功能：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Int_to_Byte</span><span class="params">(<span class="type">int</span> i,<span class="type">uint8_t</span> *byte)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> longdata = <span class="number">0</span>;</span><br><span class="line">	longdata = *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;i;          </span><br><span class="line">	byte[<span class="number">3</span>] = (longdata &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	byte[<span class="number">2</span>] = (longdata &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	byte[<span class="number">1</span>] = (longdata &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	byte[<span class="number">0</span>] = (longdata &amp; <span class="number">0x000000FF</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Float_to_Byte</span><span class="params">(<span class="type">float</span> f,<span class="type">uint8_t</span> *byte)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> longdata = <span class="number">0</span>;</span><br><span class="line">	longdata = *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;f;          </span><br><span class="line">	byte[<span class="number">3</span>] = (longdata &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	byte[<span class="number">2</span>] = (longdata &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	byte[<span class="number">1</span>] = (longdata &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	byte[<span class="number">0</span>] = (longdata &amp; <span class="number">0x000000FF</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Short_to_Byte</span><span class="params">(<span class="type">short</span> s,<span class="type">uint8_t</span> *byte)</span></span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">	byte[<span class="number">1</span>] = (s &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	byte[<span class="number">0</span>] = (s &amp; <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>蓝牙调试器接收界面显示：</p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/20210517231732731.jpg" alt="在这里插入图片描述"></p>
<h2 id="四，stm32-串口接收"><a href="#四，stm32-串口接收" class="headerlink" title="四，stm32 串口接收"></a>四，stm32 串口接收</h2><p>首先，我们在 蓝牙调试器 中添加 <strong>可编辑文本</strong> 控件 来<strong>输入我们要发送的数据</strong>；</p>
<p><strong>本实验中，我们发送一帧数据包给stm32，stm32解析出数据后，对数据进行加法运算并返回到蓝牙调试器。</strong></p>
<p>实现效果如图：</p>
<p>黑色框中显示接收到的数据，绿色框中显示发送的数据；</p>
<blockquote>
<p>对于char 类型+1，short+2,int+3,float+1.1;</p>
<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/20210519101144674.jpg" alt="在这里插入图片描述"><br>stm32使能串口接收中断，并在中断中处理数据：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART_RX_LEN 14</span></span><br><span class="line"><span class="type">uint8_t</span> USART_RX_BUF[USART_RX_LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> option;	<span class="comment">//bit0 indecate weather the msg is recved</span></span><br><span class="line">	<span class="type">char</span> x;</span><br><span class="line">	<span class="type">short</span> y;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">&#125;Ble_Data;</span><br><span class="line"></span><br><span class="line">Ble_Data rec_data;	<span class="comment">//蓝牙接收结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQ_Cb</span><span class="params">(<span class="type">void</span>)</span>                	</span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">uint8_t</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_RXNE)!=RESET))  <span class="comment">//接收中断(接收到的数据必须是0x5a结尾0xa5开头)</span></span><br><span class="line">	&#123;</span><br><span class="line">    HAL_UART_Receive(&amp;huart1,USART_RX_BUF,USART_RX_LEN,<span class="number">100</span>); <span class="comment">//读取串口接收的一字节数据到Res</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//检查包头，包尾</span></span><br><span class="line">		<span class="keyword">if</span>(USART_RX_BUF[<span class="number">0</span>]==<span class="number">0xa5</span> &amp;&amp; USART_RX_BUF[USART_RX_LEN<span class="number">-1</span>]==<span class="number">0x5a</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//检查校验和</span></span><br><span class="line">			err = (<span class="type">uint8_t</span>) ((USART_RX_BUF[<span class="number">1</span>]+USART_RX_BUF[<span class="number">2</span>]+USART_RX_BUF[<span class="number">3</span>]+USART_RX_BUF[<span class="number">4</span>]+USART_RX_BUF[<span class="number">5</span>]+USART_RX_BUF[<span class="number">6</span>]+USART_RX_BUF[<span class="number">7</span>]+USART_RX_BUF[<span class="number">8</span>]+USART_RX_BUF[<span class="number">9</span>]+USART_RX_BUF[<span class="number">10</span>]+USART_RX_BUF[<span class="number">11</span>])&amp;<span class="number">0xff</span>);</span><br><span class="line">			<span class="keyword">if</span>(err!=USART_RX_BUF[<span class="number">12</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//返回错误 数据无效</span></span><br><span class="line">				rec_data.option |=<span class="number">0x00</span>;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//数据有效</span></span><br><span class="line">			rec_data.option |=<span class="number">0x01</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将buff中的字节数据转换成指定类型</span></span><br><span class="line">			rec_data.x = (<span class="type">char</span>)USART_RX_BUF[<span class="number">1</span>];</span><br><span class="line">			rec_data.y = *((<span class="type">short</span> *) (&amp;USART_RX_BUF[<span class="number">2</span>]));</span><br><span class="line">			rec_data.z = *((<span class="type">int</span> *) (&amp;USART_RX_BUF[<span class="number">4</span>]));</span><br><span class="line">			rec_data.f = *((<span class="type">float</span> *) (&amp;USART_RX_BUF[<span class="number">8</span>]));</span><br><span class="line"></span><br><span class="line">		&#125; 		 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/30/hello-world/STM32/ble_debuger_hc-05/20210519102124328.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/STM32/ble_debuger_hc-05/" data-id="cmbcy7rha001ot8mt2rvhcim0" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/STM32/Manony_filter_Posture_Settlement" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/STM32/Manony_filter_Posture_Settlement/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.646Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>姿态解算的目的是得到飞行器在导航坐标系下的欧拉角，同时还要求算法能及时的更新姿态角度数据。</p>
</blockquote>
<p>@[toc]</p>
<h2 id="一，坐标系"><a href="#一，坐标系" class="headerlink" title="一，坐标系"></a>一，坐标系</h2><p>1，导航坐标系&#x2F;地理坐标系：以东边，北边，天上为坐标系正轴建立坐标系，这样的坐标系有助于人类观察飞机。</p>
<p>2，机体坐标系：以飞机自身为坐标系。</p>
<p><strong>飞行器上的姿态传感器读取的数据是在机体坐标系下的数值，必须转换成导航坐标系下的数值才对我们有用。方法是通过旋转机体坐标系，使其与导航坐标系重合。</strong></p>
<h2 id="二-，旋转矩阵"><a href="#二-，旋转矩阵" class="headerlink" title="二 ，旋转矩阵"></a>二 ，旋转矩阵</h2><p><strong>旋转矩阵可用于表示一个旋转，利用旋转矩阵可表示机体坐标系下的向量旋转到导航坐标系下的角度。此角度就是欧拉角；旋转矩阵的推导如下：</strong></p>
<p>其中V‘是旋转后的新向量[x1,y1,z1];<br><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411085122884.jpg" alt="在这里插入图片描述"></p>
<h2 id="三，四元数旋转形式"><a href="#三，四元数旋转形式" class="headerlink" title="三，四元数旋转形式"></a>三，四元数旋转形式</h2><p><strong>四元数也可以用于表示一个旋转，且四元数的计算相比于旋转矩阵更加方便，两者可互补。</strong></p>
<p>向量与四元数密切相关，先从向量的角度看旋转：</p>
<p>三维空间的旋转可看成绕轴u旋转θ角度：</p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411085515881.png" alt="在这里插入图片描述"><br>将向量V和V’分解正交分解成平行于U和垂直于U的两个向量。</p>
<p>主要观察垂直于U的分向量Vt,从上往下看，可得：</p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/2021041108560131.png" alt="在这里插入图片描述"></p>
<p>可得<strong>Vt’&#x3D;Vt×cosθ+(Vt×U)×sinθ</strong></p>
<p>所以新向量<strong>V’&#x3D;Vu+Vt’&#x3D;Vu+(cosθ+U×sinθ)×Vt</strong></p>
<p>令四元数<strong>q&#x3D;(cosθ+U×sinθ)，所以V’&#x3D;Vu+q*Vt</strong></p>
<p><strong>四元数知识：</strong></p>
<blockquote>
<p>四元数q&#x3D;[cosΘ,sinθ×U]，q表示将某个向量V绕向量U旋转θ角度。<br>若v平行是纯四元数，而q&#x3D;[a,bu]，u是单位向量，若v平行平行于u，则q×v平行&#x3D;v平行×q（满足交换律）<br>若v平行是纯四元数，而q&#x3D;[a,bu]，u是单位向量，若v垂直垂直于u，则q×v垂直&#x3D;v垂直×q*</p>
</blockquote>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210517201425487.jpg" alt="在这里插入图片描述"></p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20200911222905105.jpg" alt="在这里插入图片描述"></p>
<p>新的向量V’可由原向量V左乘p，并右乘p的共轭计算。</p>
<p><strong>矩阵的左右乘法规则如下：</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20200911223737583.jpg" alt="在这里插入图片描述"><br><strong>得到四元数的旋转矩阵形式：</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210517200756448.jpg" alt="在这里插入图片描述"></p>
<h2 id="四，计算欧拉角"><a href="#四，计算欧拉角" class="headerlink" title="四，计算欧拉角"></a>四，计算欧拉角</h2><p><strong>四元数矩阵与角度旋转矩阵在数学上是旋转两种不同的表示方式，将两个矩阵的元素一一对应，即可求出角度α，β，γ：</strong><br><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411090255314.jpg" alt="在这里插入图片描述"><br><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210517200707627.jpg" alt="在这里插入图片描述"></p>
<p><strong>两个3*3矩阵里的元素一一对应，可得欧拉角的计算公式：</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411090424452.jpg" alt="在这里插入图片描述"></p>
<h2 id="五，一阶龙格库塔法更新四元数"><a href="#五，一阶龙格库塔法更新四元数" class="headerlink" title="五，一阶龙格库塔法更新四元数"></a>五，一阶龙格库塔法更新四元数</h2><p><strong>以上步骤得到了四元数到欧拉角的计算公式。由于飞行器是动态的，欧拉角的数据需要实时更新，而陀螺仪传感器测量的是机体的角速度，需要使用角速度来更新欧拉角的大小。</strong></p>
<p>方式上是使用一阶龙格库塔法解微分方程，一阶龙格库塔法的方程是：</p>
<blockquote>
<p>y(n+1)&#x3D;y(n)+▲t dy(n)&#x2F;dt;</p>
</blockquote>
<p>设四元数向量Q&#x3D;[a,b,c,d]将Q代入y可得：</p>
<blockquote>
<p>Q(n+1)&#x3D;Q(n)+▲t dQ(n)&#x2F;dt;</p>
</blockquote>
<p>Q是我们通过上面的运算已经计算出来的向量，重点在对Q的时间导数：</p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411090739184.jpg" alt="在这里插入图片描述"></p>
<p><strong>然后根据一阶龙格库塔法，得到四元数的更新方程：</strong></p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411090808818.jpg" alt="在这里插入图片描述"></p>
<h2 id="六，mahony滤波"><a href="#六，mahony滤波" class="headerlink" title="六，mahony滤波"></a>六，mahony滤波</h2><p>理论上只需要陀螺仪读取角速度我们就能获取姿态角，但由于陀螺仪在积分的过程中会积累误差，所以需要用加速度计在水平面上对重力进行比对和补偿，用来修正陀螺仪的垂直误差。</p>
<p>方法是：读取加速度计的数据，并由四元数计算出重力分量，加速度计的数据与重力分量的叉积得到误差，对误差进行比例，积分运算，补偿到角速度中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归一化加速度计数据</span></span><br><span class="line">recipNorm=invSqrt(ax*ax+ay*ay+az*az);</span><br><span class="line">ax*=recipNorm;</span><br><span class="line">ay*=recipNorm;</span><br><span class="line">az*=recipNorm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由四元数计算重力分量</span></span><br><span class="line">vx=<span class="number">2</span>*(b*d-a*c);</span><br><span class="line">vy=<span class="number">2</span>*(a*b+c*d);</span><br><span class="line">vz=<span class="number">2</span>*(a*a+d*d-b*b-c*c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//叉积求误差</span></span><br><span class="line">ex=(ay*vz-az*vy);</span><br><span class="line">ey=(az*vx-ax*vz);</span><br><span class="line">ez=(ax*vy-ay*vx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对误差进行积分运算</span></span><br><span class="line">inte_ex+=ki*ex*t;</span><br><span class="line">inte_ey+=ki*ey*t;</span><br><span class="line">inte_ez+=ki*ez*t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gx,gy,gz即角速度向量</span></span><br><span class="line">gx+=inte_ex;</span><br><span class="line">gy+=inte_ey;</span><br><span class="line">gz+=inte_ez;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对误差进行比例运算</span></span><br><span class="line">gx+=kp*ex;</span><br><span class="line">gy+=kp*ey;</span><br><span class="line">gz+=kp*ez;</span><br></pre></td></tr></table></figure>



<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AASDSADAD/article/details/73080832">一阶龙格库塔法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/warmlayu/p/9937067.html">欧拉角 旋转矩阵</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/21207-iHome/p/6894128.html">四元数与欧拉角</a></p>
<p><img src="/2025/05/30/hello-world/STM32/Manony_filter_Posture_Settlement/20210411090952463.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/STM32/Manony_filter_Posture_Settlement/" data-id="cmbcy7rh9001kt8mt6pjf35p3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/music_player" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/music_player/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.646Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h2><h3 id="一、功能介绍"><a href="#一、功能介绍" class="headerlink" title="一、功能介绍"></a>一、功能介绍</h3><p>本文通过设计一个运行在OpenHarmony上的分布式音乐播放器，来向广大读者展示OpenHarmony的实际应用场景、技术特性以及未来的发展方向，以期有更多的开发者加入OpenHarmony的生态建设中。</p>
<p>本音乐播放器具体可实现音频的播放、暂停、上&#x2F;下一曲、显示歌曲列表。使其与其他设备不一样的是，该应用运行在OpenHarmony3.0 LTS标准系统上，利用系统能力实现了分布式应用流转以及分布式控制功能。</p>
<h3 id="二、程序设计"><a href="#二、程序设计" class="headerlink" title="二、程序设计"></a>二、程序设计</h3><h4 id="2-1、UI设计"><a href="#2-1、UI设计" class="headerlink" title="2.1、UI设计"></a>2.1、UI设计</h4><p>UI界面是应用程序呈现给用户的操作接口，OpenHarmony的UI开发框架针对不同目的和技术背景的开发者提供了两种开发范式，分别是基于JS扩展的类Web开发范式和基于TS扩展的声明式开发范式。</p>
<p>类Web开发范式采用HML、CSS、JavaScript三段式开发方式，使用HML标签文件进行布局搭建，使用CSS文件进行样式描述，使用JavaScript文件进行逻辑处理。这种开发方式使得前端开发者非常容易上手UI界面开发，且相关学习资料较为丰富。故本项目的应用程序就是使用类Web开发范式进行开发。播放器的界面如图所示：</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/music_player/clip_image001.png" alt="image-20220314093740060"></p>
<p>界面内容从上到下分别是：歌曲名称、专辑封面、歌曲进度条和功能按键。歌曲名称与title变量绑定，当title变量修改时，页面上的歌曲文本也随之改变。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.	<span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">2.	    &#123;&#123; title &#125;&#125;</span><br><span class="line">3.	<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>专辑封面：专辑图片与albumSrc变量绑定，设置响应触摸操作onListClick()函数来处理触摸反馈：当点击专辑封面时，弹出歌曲列表。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;album_section&quot;</span>&gt;</span></span><br><span class="line">2.	     <span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">&#x27;rotate_image&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;rotate_album&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; albumSrc &#125;&#125;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;onListClick&quot;</span>&gt;</span></span><br><span class="line">3.	     <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">4.	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>滑动条用于显示歌曲的播放进度，在进度条的首尾放置各放置一个文本，分别显示当前播放时间和歌曲时长，文本分别与currentTimeText、totalTimeText变量绑定来实时更新数值。滑动条用于快速调节设置值，当触摸、拖动进度条滑块时，会触发事件，事件的值就是滑块所占进度条的百分比，事件会被传递到setProgress()函数中进行处理。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;progress_section&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 进度条 --&gt;</span></span><br><span class="line">2.	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;timer&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 文本 --&gt;</span></span><br><span class="line">3.	        <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;progress_time&quot;</span>&gt;</span></span><br><span class="line">4.	            &#123;&#123; currentTimeText &#125;&#125;</span><br><span class="line">5.	        <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">6.	        <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;total_time&quot;</span>&gt;</span></span><br><span class="line">7.	            &#123;&#123; totalTimeText &#125;&#125;</span><br><span class="line">8.	        <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">9.	    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">10.	    <span class="comment">&lt;!-- 滑动条 --&gt;</span></span><br><span class="line">11.	    <span class="tag">&lt;<span class="name">slider</span> <span class="attr">id</span>=<span class="string">&quot;slider&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; currentProgress &#125;&#125;&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;setProgress&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">12.</span>	            <span class="attr">class</span>=<span class="string">&quot;music_slider&quot;</span>/&gt;</span></span><br><span class="line">13.	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在最底层有5个控制按键，分别是接力按键、上一曲、播放&#x2F;暂停、下一曲、同步按键，按键被按下时分别调用各自的函数处理。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;control_section&quot;</span>&gt;</span>   <span class="comment">&lt;!-- 控制按键 --&gt;</span></span><br><span class="line">2.	    <span class="tag">&lt;<span class="name">image</span> <span class="attr">onclick</span>=<span class="string">&quot;onContinueAbilityClick(0)&quot;</span> <span class="attr">src</span>=<span class="string">&quot;share.png&quot;</span>/&gt;</span></span><br><span class="line">3.	    <span class="tag">&lt;<span class="name">image</span> <span class="attr">onclick</span>=<span class="string">&quot;onPreviousClick&quot;</span> <span class="attr">src</span>=<span class="string">&quot;ic_play_previous.svg&quot;</span>/&gt;</span></span><br><span class="line">4.	    <span class="tag">&lt;<span class="name">image</span> <span class="attr">onclick</span>=<span class="string">&quot;onPlayClick&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; btnPlaySrc &#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">5.	    <span class="tag">&lt;<span class="name">image</span> <span class="attr">onclick</span>=<span class="string">&quot;onNextClick&quot;</span> <span class="attr">src</span>=<span class="string">&quot;ic_play_next.svg&quot;</span>/&gt;</span></span><br><span class="line">6.	    <span class="tag">&lt;<span class="name">image</span> <span class="attr">onclick</span>=<span class="string">&quot;onContinueAbilityClick(1)&quot;</span> <span class="attr">src</span>=<span class="string">&quot;copy.png&quot;</span>/&gt;</span></span><br><span class="line">7.	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2、player"><a href="#2-2、player" class="headerlink" title="2.2、player"></a>2.2、player</h4><p>PlayerModel是一个负责音频管理的类，其实现是调用了OpenHarmony的多媒体子系统中的音频组件，多媒体系统的源码位于foundation&#x2F;multimedia，可以实现对音频的加载、播放、暂停和定位进度。根据音频组件的JS API接口指南，来开发应用程序。</p>
<p>首先定义一个类来描述歌曲信息，一个数组来存放歌曲列表:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="keyword">class</span> <span class="title class_">Playlist</span> &#123;</span><br><span class="line"><span class="number">2.</span>	    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="number">3.</span>	    &#125;</span><br><span class="line"><span class="number">4.</span>	    audioFiles = [];</span><br><span class="line"><span class="number">5.</span>	&#125;</span><br><span class="line"><span class="number">6.</span>	<span class="comment">//定义一首歌的属性</span></span><br><span class="line"><span class="number">7.</span>	<span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Song</span> &#123;</span><br><span class="line"><span class="number">8.</span>	    <span class="title function_">constructor</span>(<span class="params">name, fileUri, duration,albumUri</span>) &#123;</span><br><span class="line"><span class="number">9.</span>	        <span class="variable language_">this</span>.<span class="property">name</span> = name;                 <span class="comment">//歌名</span></span><br><span class="line"><span class="number">10.</span>	        <span class="variable language_">this</span>.<span class="property">fileUri</span> = fileUri;           <span class="comment">//音频文件路径</span></span><br><span class="line"><span class="number">11.</span>	        <span class="variable language_">this</span>.<span class="property">duration</span> = duration;         <span class="comment">//歌曲时长</span></span><br><span class="line"><span class="number">12.</span>	        <span class="variable language_">this</span>.<span class="property">albumUri</span> = albumUri;         <span class="comment">//专辑路径</span></span><br><span class="line"><span class="number">13.</span>	    &#125;</span><br><span class="line"><span class="number">14.</span>	&#125;</span><br></pre></td></tr></table></figure>

<p>要播放的音乐就必须有音频文件，这些音频文件被存放在OpenHarmony系统指定目录下:本项目一共使用了三个音频，其存放在 &#x2F;system&#x2F;etc&#x2F; 目录下，其专辑封面存放在 &#x2F;common&#x2F;media&#x2F; 目录下.</p>
<p>音频播放使用的是AudioPlayer的play()函数实现，AudioPlayer是一个非常重要的对象，其定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	  interface <span class="title class_">AudioPlayer</span> &#123;</span><br><span class="line"><span class="number">2.</span>	    <span class="title function_">play</span>(): <span class="keyword">void</span>; <span class="comment">//开始播放音频</span></span><br><span class="line"><span class="number">3.</span>	    <span class="title function_">pause</span>(): <span class="keyword">void</span>; <span class="comment">//暂停播放</span></span><br><span class="line"><span class="number">4.</span>	    <span class="title function_">stop</span>(): <span class="keyword">void</span>; <span class="comment">//停止播放</span></span><br><span class="line"><span class="number">5.</span>	    <span class="title function_">reset</span>(): <span class="keyword">void</span>; <span class="comment">//复位一个playerback</span></span><br><span class="line"><span class="number">6.</span>	    <span class="title function_">seek</span>(<span class="attr">timeMs</span>: number): <span class="keyword">void</span>; <span class="comment">//跳转播放</span></span><br><span class="line"><span class="number">7.</span>	    <span class="title function_">setVolume</span>(<span class="attr">vol</span>: number): <span class="keyword">void</span>; <span class="comment">//设置音量</span></span><br><span class="line"><span class="number">8.</span>	    <span class="title function_">release</span>(): <span class="keyword">void</span>; <span class="comment">//释放音频播放使用的资源</span></span><br><span class="line"><span class="number">9.</span>	    <span class="attr">src</span>: string; <span class="comment">//音频文件的uri</span></span><br><span class="line"><span class="number">10.</span>	    <span class="attr">loop</span>: boolean; <span class="comment">//循环播放</span></span><br><span class="line"><span class="number">11.</span>	    readonly <span class="attr">currentTime</span>: number; <span class="comment">//当前播放进度</span></span><br><span class="line"><span class="number">12.</span>	    readonly <span class="attr">duration</span>: number; <span class="comment">//音频的时长</span></span><br><span class="line"><span class="number">13.</span>	    readonly <span class="attr">state</span>: <span class="title class_">AudioState</span>; <span class="comment">//播放器状态</span></span><br><span class="line"><span class="number">14.</span>	    <span class="comment">//监听播放器的事件，设置回调函数</span></span><br><span class="line"><span class="number">15.</span>	    <span class="title function_">on</span>(<span class="attr">type</span>: <span class="string">&#x27;play&#x27;</span> | <span class="string">&#x27;pause&#x27;</span> | <span class="string">&#x27;stop&#x27;</span> | <span class="string">&#x27;reset&#x27;</span> | <span class="string">&#x27;dataLoad&#x27;</span> | <span class="string">&#x27;finish&#x27;</span> | <span class="string">&#x27;volumeChange&#x27;</span>,          <span class="title function_">callback</span>() =&gt; <span class="keyword">void</span>): <span class="keyword">void</span>;</span><br><span class="line"><span class="number">16.</span>	    <span class="comment">//监听更新事件</span></span><br><span class="line"><span class="number">17.</span>	    <span class="title function_">on</span>(<span class="attr">type</span>: <span class="string">&#x27;timeUpdate&#x27;</span>, <span class="attr">callback</span>: <span class="title class_">Callback</span>&lt;number&gt;): <span class="keyword">void</span>; </span><br><span class="line"><span class="number">18.</span>	    <span class="comment">//监听错误事件</span></span><br><span class="line"><span class="number">19.</span>	    <span class="title function_">on</span>(<span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, <span class="attr">callback</span>: <span class="title class_">ErrorCallback</span>): <span class="keyword">void</span>; </span><br><span class="line"><span class="number">20.</span>	  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于音频文件是存放在磁盘中的，所以需要先将音频文件加载到内存中，所以该函数首先将音频文件加载到内存中，然后将音频数据发送到输出设备。具体使用哪个音频文件，是由AudioPlayer对象中的src成员决定的，该成员表示一个音频文件uri。</p>
<p>所以当我们要播放某个音频时，需要先调用preLoad()函数，该函数先获取要加载的音频文件的路径，判断与当前正在播放的歌曲是否相同，若相同则音频文件已存在于内存中，不需要加载；否则，则通过设置src来准备加载。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/music_player/" data-id="cmbcy7rhq002st8mt6xckda82" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/wlan_hdi" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/wlan_hdi/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.646Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="WLAN-HDI"><a href="#WLAN-HDI" class="headerlink" title="WLAN_HDI"></a>WLAN_HDI</h2><p>关于WLAN HDI的介绍，可见官网文档，其结构可如图所示：</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/wlan_hdi/HkqzI6DTsPQ5GRA.jpg" alt="hdi.png"></p>
<p>WLAN HDI 目的是提供接口给 Wi-Fi Service调用，其提供的功能有：启动&#x2F;关闭WLAN,查看连接状态，注册回调函数，启动wlan扫描等。</p>
<h3 id="一、WILAN-HAL"><a href="#一、WILAN-HAL" class="headerlink" title="一、WILAN HAL"></a>一、WILAN HAL</h3><p>WLAN HAL模块作为HDI的中间层，提供给Wi-Fi service  IWiFi 对象，以及IWiFiSta、IWiFiAp、IWiFiBaseFeature对象来发送和接受WLAN 命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IWiFi</span> &#123;</span></span><br><span class="line">    <span class="comment">//打开hal层和driver的通道</span></span><br><span class="line">    <span class="type">int32_t</span> (*start)(<span class="keyword">struct</span> IWiFi *iwifi);</span><br><span class="line">    <span class="comment">//关闭hal层和driver的通道</span></span><br><span class="line">    <span class="type">int32_t</span> (*stop)(<span class="keyword">struct</span> IWiFi *iwifi);</span><br><span class="line">	<span class="comment">//获取wifi驱动支持的feature</span></span><br><span class="line">    <span class="type">int32_t</span> (*getSupportFeature)(<span class="type">uint8_t</span> *supType, <span class="type">uint32_t</span> size);</span><br><span class="line">	<span class="comment">//获取wifi驱动支持的feature组合</span></span><br><span class="line">    <span class="type">int32_t</span> (*getSupportCombo)(<span class="type">uint64_t</span> *combo, <span class="type">uint32_t</span> size);</span><br><span class="line">    <span class="comment">//创建一个feature</span></span><br><span class="line">    <span class="type">int32_t</span> (*createFeature)(<span class="type">int32_t</span> type, <span class="keyword">struct</span> IWiFiBaseFeature **ifeature);</span><br><span class="line">    <span class="type">int32_t</span> (*getFeatureByIfName)(<span class="type">const</span> <span class="type">char</span> *ifName, <span class="keyword">struct</span> IWiFiBaseFeature **ifeature);</span><br><span class="line">	<span class="comment">//注册回调函数监听 wifi event </span></span><br><span class="line">    <span class="type">int32_t</span> (*registerEventCallback)(CallbackFunc cbFunc, <span class="type">const</span> <span class="type">char</span> *ifName);</span><br><span class="line">    <span class="type">int32_t</span> (*unregisterEventCallback)(CallbackFunc cbFunc, <span class="type">const</span> <span class="type">char</span> *ifName);</span><br><span class="line">    <span class="type">int32_t</span> (*destroyFeature)(<span class="keyword">struct</span> IWiFiBaseFeature *ifeature);</span><br><span class="line">	<span class="comment">//复位芯片驱动程序</span></span><br><span class="line">    <span class="type">int32_t</span> (*resetDriver)(<span class="type">const</span> <span class="type">uint8_t</span> chipId, <span class="type">const</span> <span class="type">char</span> *ifName);</span><br><span class="line">    <span class="comment">//get net device infos.</span></span><br><span class="line">    <span class="type">int32_t</span> (*getNetDevInfo)(<span class="keyword">struct</span> NetDeviceInfoResult *netDeviceInfoResult);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-1、IWiFi"><a href="#1-1、IWiFi" class="headerlink" title="1.1、IWiFi"></a>1.1、IWiFi</h4><p>WifiConstruct用于创建 IWiFi 对象，并对其函数赋值。开发者就可以调用IWiFi对象的方法创建IWiFiSta、IWiFiAp、IWiFiBaseFeature对象。再通过这三个对象发送具体的WIFI命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">WifiConstruct</span><span class="params">(<span class="keyword">struct</span> IWiFi **wifiInstance)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isInited = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IWiFi</span> <span class="title">singleWifiInstance</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isInited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HalMutexInit() != HDF_SUCCESS) &#123;</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s: HalMutexInit failed, line: %d\n&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">            <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给函数赋值</span></span><br><span class="line">        singleWifiInstance.start = Start;</span><br><span class="line">        singleWifiInstance.stop = Stop;</span><br><span class="line">        singleWifiInstance.getSupportFeature = GetSupportFeature;</span><br><span class="line">        singleWifiInstance.getSupportCombo = GetSupportCombo;</span><br><span class="line">        singleWifiInstance.createFeature = CreateFeature;</span><br><span class="line">        singleWifiInstance.getFeatureByIfName = GetFeatureByIfName;</span><br><span class="line">        singleWifiInstance.destroyFeature = DestroyFeature;</span><br><span class="line">        singleWifiInstance.registerEventCallback = HalRegisterEventCallback;</span><br><span class="line">        singleWifiInstance.unregisterEventCallback = HalUnregisterEventCallback;</span><br><span class="line">        singleWifiInstance.resetDriver = ResetDriver;</span><br><span class="line">        singleWifiInstance.getNetDevInfo = GetNetDevInfo;</span><br><span class="line">        InitIWiFiList();</span><br><span class="line">        isInited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*wifiInstance) = &amp;singleWifiInstance;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2、IWiFiBaseFeature"><a href="#1-2、IWiFiBaseFeature" class="headerlink" title="1.2、IWiFiBaseFeature"></a>1.2、IWiFiBaseFeature</h4><p>IWiFiSta、IWiFiAp都是基于IWiFiBaseFeature的扩展，我们以IWiFiSta 为例，了解HAL层是如何发送命令的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IWiFiSta</span> &#123;</span></span><br><span class="line">    <span class="comment">//继承了IWiFiBaseFeature</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IWiFiBaseFeature</span> <span class="title">baseFeature</span>;</span> </span><br><span class="line">    <span class="comment">//扫描指定的mac地址</span></span><br><span class="line">    <span class="type">int32_t</span> (*setScanningMacAddress)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiSta *staFeature, <span class="type">unsigned</span> <span class="type">char</span> *scanMac, <span class="type">uint8_t</span> len);</span><br><span class="line">    <span class="comment">//开始扫描</span></span><br><span class="line">    <span class="type">int32_t</span> (*startScan)(<span class="type">const</span> <span class="type">char</span> *ifName, WifiScan *scan);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IWiFiBaseFeature</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ifName[IFNAME_MAX_LEN];  </span><br><span class="line">    <span class="type">int32_t</span> type;   </span><br><span class="line">	<span class="comment">//获取网卡名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *(*getNetworkIfaceName)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature);</span><br><span class="line">	<span class="comment">//获取feature类型</span></span><br><span class="line">    <span class="type">int32_t</span> (*getFeatureType)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature);</span><br><span class="line">	<span class="comment">//设置mac地址</span></span><br><span class="line">    <span class="type">int32_t</span> (*setMacAddress)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature, <span class="type">unsigned</span> <span class="type">char</span> *mac, <span class="type">uint8_t</span> len);</span><br><span class="line">	<span class="comment">//获取设备mac地址</span></span><br><span class="line">    <span class="type">int32_t</span> (*getDeviceMacAddress)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature, <span class="type">unsigned</span> <span class="type">char</span> *mac, <span class="type">uint8_t</span> len);</span><br><span class="line">	<span class="comment">//获取wifi带宽</span></span><br><span class="line">    <span class="type">int32_t</span> (*getValidFreqsWithBand)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature, <span class="type">int32_t</span> band, <span class="type">int32_t</span> *freqs,</span><br><span class="line">        <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> *num);</span><br><span class="line">	<span class="comment">//设置发送电源</span></span><br><span class="line">    <span class="type">int32_t</span> (*setTxPower)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature, <span class="type">int32_t</span> power);</span><br><span class="line">	<span class="comment">//获取芯片id</span></span><br><span class="line">    <span class="type">int32_t</span> (*getChipId)(<span class="type">const</span> <span class="keyword">struct</span> IWiFiBaseFeature *baseFeature, <span class="type">uint8_t</span> *chipId);</span><br><span class="line">	<span class="comment">//获取网口名称</span></span><br><span class="line">    <span class="type">int32_t</span> (*getIfNamesByChipId)(<span class="type">const</span> <span class="type">uint8_t</span> chipId, <span class="type">char</span> **ifNames, <span class="type">uint32_t</span> *num);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先是创建IWiFiSta，需要调用 IWiFi 对象的createFeature()方法创建，具体的内容就是填充IWiFiSta对象中的方法。</p>
<p>下面就以createFeature()为例，学习feature的函数是如何发送命令到wifi驱动的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createFeature调用CreateFeatureInner</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">CreateFeatureInner</span><span class="params">(<span class="type">int32_t</span> type, <span class="keyword">struct</span> IWiFiBaseFeature **ifeature)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//init feature</span></span><br><span class="line">    ret = InitFeatureByType(type, ifeature);</span><br><span class="line">    ret = FindValidNetwork(type, ifeature);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同类型的feature，调用不同的接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">InitFeatureByType</span><span class="params">(<span class="type">int32_t</span> type, <span class="keyword">struct</span> IWiFiBaseFeature **ifeature)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> PROTOCOL_80211_IFTYPE_AP:</span><br><span class="line">            *ifeature = (<span class="keyword">struct</span> IWiFiBaseFeature *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWiFiAp));</span><br><span class="line">            (<span class="type">void</span>)memset_s(*ifeature, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWiFiAp), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWiFiAp));</span><br><span class="line">            ret = InitApFeature((<span class="keyword">struct</span> IWiFiAp **)ifeature);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PROTOCOL_80211_IFTYPE_STATION:</span><br><span class="line">            *ifeature = (<span class="keyword">struct</span> IWiFiBaseFeature *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWiFiSta));</span><br><span class="line">            (<span class="type">void</span>)memset_s(*ifeature, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWiFiSta), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWiFiSta));</span><br><span class="line">            ret = InitStaFeature((<span class="keyword">struct</span> IWiFiSta **)ifeature);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s: type not support, line: %d&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">            <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先调用InitBaseFeature()来初始化basefeature，再添加IWiFiSta独有的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">InitStaFeature</span><span class="params">(<span class="keyword">struct</span> IWiFiSta **fe)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (InitBaseFeature((<span class="keyword">struct</span> IWiFiBaseFeature **)fe) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: init base feature, line: %d&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    (*fe)-&gt;setScanningMacAddress = SetScanningMacAddress;</span><br><span class="line">    (*fe)-&gt;startScan = StartScan;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完成IWiFiSta，就可以使用其接口来发送WIFI命令。</p>
<p>下面就以startScan命令为例子，加上互斥锁是因为wifi芯片同一时间只能响应一个命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">StartScan</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifName, WifiScan *scan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加互斥锁，不能被其他命令打断执行</span></span><br><span class="line">    HalMutexLock();</span><br><span class="line">    <span class="comment">//StartScanInner()最终调用sbuf_cmd_adapter.c中的WifiCmdScan()</span></span><br><span class="line">    <span class="type">int32_t</span> ret = StartScanInner(ifName, scan);</span><br><span class="line">    HalMutexUnlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StartScanInner()最终调用sbuf_cmd_adapter.c中的WifiCmdScan()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">WifiCmdScan</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifName, WifiScan *scan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">data</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    data = HdfSBufObtainDefaultSize();</span><br><span class="line">    <span class="type">bool</span> isSerializeFailed = <span class="literal">false</span>;</span><br><span class="line">    isSerializeFailed = isSerializeFailed || !HdfSbufWriteString(data, ifName);</span><br><span class="line">    <span class="keyword">if</span> (scan-&gt;bssid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        isSerializeFailed = isSerializeFailed || !HdfSbufWriteBuffer(data, scan-&gt;bssid, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isSerializeFailed = isSerializeFailed || !HdfSbufWriteBuffer(data, scan-&gt;bssid, ETH_ADDR_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    isSerializeFailed =</span><br><span class="line">        isSerializeFailed || !HdfSbufWriteBuffer(data, scan-&gt;ssids, <span class="keyword">sizeof</span>(scan-&gt;ssids[<span class="number">0</span>]) * scan-&gt;numSsids);</span><br><span class="line">    isSerializeFailed = isSerializeFailed || !HdfSbufWriteBuffer(data, scan-&gt;extraIes, scan-&gt;extraIesLen);</span><br><span class="line">    isSerializeFailed =</span><br><span class="line">        isSerializeFailed || !HdfSbufWriteBuffer(data, scan-&gt;freqs, <span class="keyword">sizeof</span>(scan-&gt;freqs[<span class="number">0</span>]) * scan-&gt;numFreqs);</span><br><span class="line">    isSerializeFailed = isSerializeFailed || !HdfSbufWriteUint8(data, scan-&gt;prefixSsidScanFlag);</span><br><span class="line">    isSerializeFailed = isSerializeFailed || !HdfSbufWriteUint8(data, scan-&gt;fastConnectFlag);</span><br><span class="line">    <span class="keyword">if</span> (isSerializeFailed) &#123;</span><br><span class="line">        HILOG_ERROR(LOG_DOMAIN, <span class="string">&quot;%s: Serialize failed!&quot;</span>, __FUNCTION__);</span><br><span class="line">        ret = RET_CODE_FAILURE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//发送命令给WLAN 驱动</span></span><br><span class="line">        ret = SendCmdSync(WIFI_WPA_CMD_SCAN, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HdfSBufRecycle(data);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sbuf_cmd_adapter.c中的函数把所有的WIFI命令封装成sbuf类型，并调用 HDF 驱动的消息机制给 HDF_WIFI驱动发送命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">SendCmdSync</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span> cmd, <span class="keyword">struct</span> HdfSBuf *reqData, <span class="keyword">struct</span> HdfSBuf *respData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret = g_wifiService-&gt;dispatcher-&gt;Dispatch(&amp;g_wifiService-&gt;object, cmd, reqData, respData);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3、Client"><a href="#1-3、Client" class="headerlink" title="1.3、Client"></a>1.3、Client</h4><p>SendCmdSync()函数中使用了 g_wifiService 变量，该变量是 HdfIoService类型，在调用IWiFi的start方法时，会初始化该变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">WifiDriverClientInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (g_wifiService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//绑定 hdfwifi 服务</span></span><br><span class="line">        g_wifiService = HdfIoServiceBind(DRIVER_SERVICE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//注册回调函数</span></span><br><span class="line">    g_wifiDevEventListener.onReceive  = OnWiFiEvents;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了绑定服务，向服务发送消息外，还注册了回调函数OnWiFiEvents()，在该函数中，根据eventId调用不同的函数来处理驱动上报的消息，把消息从sbuf转换成普通的类型数据。（如何注册回调函数看最后）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">OnWiFiEvents</span><span class="params">(<span class="keyword">struct</span> HdfDevEventlistener *listener,<span class="keyword">struct</span> HdfIoService *service, <span class="type">uint32_t</span> eventId, <span class="keyword">struct</span> HdfSBuf *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ifName = HdfSbufReadString(data);</span><br><span class="line">    <span class="comment">//处理不同的wifi事件</span></span><br><span class="line">    <span class="keyword">switch</span> (eventId) &#123;</span><br><span class="line">        <span class="keyword">case</span> WIFI_EVENT_NEW_STA:</span><br><span class="line">            WifiEventNewStaProcess(ifName, eventId, data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WIFI_EVENT_DEL_STA:</span><br><span class="line">            WifiEventDelStaProcess(ifName, eventId, data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以WifiEventNewStaProcess为例子</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">WifiEventNewStaProcess</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifName, <span class="type">uint32_t</span> event, <span class="keyword">struct</span> HdfSBuf *reqData)</span></span><br><span class="line">&#123;</span><br><span class="line">    WifiNewStaInfo staInfo;</span><br><span class="line">    <span class="comment">//提取reqData的数据到staInfo</span></span><br><span class="line">    <span class="keyword">if</span> (!HdfSbufReadInt32(reqData, &amp;staInfo.reassoc)) &#123;</span><br><span class="line">        HILOG_ERROR(LOG_DOMAIN, <span class="string">&quot;%s: fail to get reassoc&quot;</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!HdfSbufReadBuffer(reqData, (<span class="type">const</span> <span class="type">void</span> **)(&amp;staInfo.ie), &amp;staInfo.ieLen)) &#123;</span><br><span class="line">        HILOG_ERROR(LOG_DOMAIN, <span class="string">&quot;%s: fail to get ie&quot;</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!HdfSbufReadBuffer(reqData, (<span class="type">const</span> <span class="type">void</span> **)(&amp;staInfo.macAddr), &amp;len) || (len != ETH_ADDR_LEN)) &#123;</span><br><span class="line">        HILOG_ERROR(LOG_DOMAIN, <span class="string">&quot;%s: fail to get macAddr&quot;</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上报到IWiFi</span></span><br><span class="line">    WifiEventReport(ifName, event, &amp;staInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WifiEventReport()调用HAL 层注册的回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WifiEventReport</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifName, <span class="type">uint32_t</span> event, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="comment">//IWiFi 注册的回调函数保存在g_callbackEventMap</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CALL_BACK_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_callbackEventMap[i] != <span class="literal">NULL</span> &amp;&amp; (<span class="built_in">strcmp</span>(g_callbackEventMap[i]-&gt;ifName, ifName) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (((<span class="number">1</span> &lt;&lt; event) &amp; g_callbackEventMap[i]-&gt;eventType) != <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="comment">//调用回调函数 通知事件的发送</span></span><br><span class="line">            g_callbackEventMap[i]-&gt;onRecFunc(event, data, ifName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、HDI-Service"><a href="#二、HDI-Service" class="headerlink" title="二、HDI Service"></a>二、HDI Service</h3><p>HAL层的上一层是HDI Service，他将WLAN HAL层的IWiFiSta、IWiFiAp、IWiFiBaseFeature封装到一个对象 IWifiInterface 中，使其更方便用户使用。</p>
<p>HDI Service 分为两个部分：</p>
<ul>
<li>Services：作为HDF驱动模块，调用WLAN HAL 提供的对象，并提供服务给IWifiInterface。</li>
<li>IWifiInterface：订阅 HDI Service驱动服务，提供统一接口给用户。</li>
</ul>
<h4 id="2-1、Service"><a href="#2-1、Service" class="headerlink" title="2.1、Service"></a>2.1、Service</h4><p>作为一个HDF驱动模块，他必须有初始化函数，bind函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfDriverEntry</span> <span class="title">g_wlanHdiDriverEntry</span> =</span> &#123;</span><br><span class="line">    .moduleVersion = <span class="number">1</span>,</span><br><span class="line">    .moduleName = <span class="string">&quot;wlan_device&quot;</span>,</span><br><span class="line">    .Bind = HdfWlanHdiDriverBind,</span><br><span class="line">    .Init = HdfWlanHdiDriverInit,</span><br><span class="line">    .Release = HdfWlanHdiDriverRelease,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HDF_INIT(g_wlanHdiDriverEntry);</span><br></pre></td></tr></table></figure>

<p>重点是dispatch()函数的实现：WlanHdiServiceDispatch()</p>
<p>在WlanHdiServiceOnRemoteRequest()中根据命令id调用不同的函数，这些函数最终都会调用WLAN HAL层提供的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">WlanHdiServiceDispatch</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="type">int</span> cmdId,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> HdfSBuf *data, <span class="keyword">struct</span> HdfSBuf *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> WlanHdiServiceOnRemoteRequest(client, cmdId, data, reply);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">WlanHdiServiceOnRemoteRequest</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="type">int</span> cmdId,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> HdfSBuf *data, <span class="keyword">struct</span> HdfSBuf *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (cmdId) &#123;</span><br><span class="line">        <span class="keyword">case</span> WLAN_SERVICE_CONSTRUCT:</span><br><span class="line">            <span class="keyword">return</span> HdiWifiConstruct(client, data, reply);</span><br><span class="line">        <span class="keyword">case</span> WLAN_SERVICE_DECONSTRUCT:</span><br><span class="line">            <span class="keyword">return</span> HdiWifiDeConstruct(client, data, reply);</span><br><span class="line">        <span class="keyword">case</span> WLAN_SERVICE_START:</span><br><span class="line">            <span class="keyword">return</span> WlanServiceStubStart(client, data, reply);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            HDF_LOGW(<span class="string">&quot;SampleServiceDispatch: not support cmd %d&quot;</span>, cmdId);</span><br><span class="line">            <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：WlanServiceStubStart()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">WlanServiceStubStart</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="keyword">struct</span> HdfSBuf *data, <span class="keyword">struct</span> HdfSBuf *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = g_wifi-&gt;start(g_wifi);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2、IWifiInterface"><a href="#2-2、IWifiInterface" class="headerlink" title="2.2、IWifiInterface"></a>2.2、IWifiInterface</h4><p>IWifiInterface对象通过订阅HDI Service驱动服务，把所有的WIFI命令整合到一起，相比直接使用HAL 层接口更加简单方便。</p>
<p>调用HdIWifiInterfaceGet会帮我们创建IWifiInterface对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> IWifiInterface *<span class="title function_">HdIWifiInterfaceGet</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serviceName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HDIServiceManager</span> *<span class="title">serviceMgr</span> =</span> HDIServiceManagerGet();</span><br><span class="line">	<span class="comment">//绑定hdi service</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfRemoteService</span> *<span class="title">remote</span> =</span> serviceMgr-&gt;GetService(serviceMgr, serviceName);</span><br><span class="line">	<span class="comment">//create IWifiInterface</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IWifiInterface</span> *<span class="title">wlanClient</span> =</span> (<span class="keyword">struct</span> IWifiInterface *)OsalMemAlloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> IWifiInterface));</span><br><span class="line">    wlanClient-&gt;remote = remote;</span><br><span class="line">    IwifiConstruct(wlanClient);</span><br><span class="line">    <span class="keyword">return</span> wlanClient;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建IWifiInterface对象</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">IwifiConstruct</span><span class="params">(<span class="keyword">struct</span> IWifiInterface *inst)</span></span><br><span class="line">&#123;</span><br><span class="line">    inst-&gt;construct = WlanConstruct;</span><br><span class="line">    inst-&gt;destruct = WlanDestruct;</span><br><span class="line">	......</span><br><span class="line">    inst-&gt;getNetDevInfo = WlanGetNetDevInfo;</span><br><span class="line">    inst-&gt;startScan = WlanStartScan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IWifiInterface 使用HDF 驱动消息机制 来和service通信，以WlanStart命令为例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">WlanStart</span><span class="params">(<span class="keyword">struct</span> IWifiInterface *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ec = HDF_FAILURE;</span><br><span class="line">    <span class="comment">//创建sbuf</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">data</span> =</span> HdfSBufTypedObtain(SBUF_IPC);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">reply</span> =</span> HdfSBufTypedObtain(SBUF_IPC);</span><br><span class="line">    <span class="comment">//发送WLAN_SERVICE_START命令</span></span><br><span class="line">    ec = WlanProxyCall(self, WLAN_SERVICE_START命令, data, reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">WlanProxyCall</span><span class="params">(<span class="keyword">struct</span> IWifiInterface *self, <span class="type">int32_t</span> id, <span class="keyword">struct</span> HdfSBuf *data, <span class="keyword">struct</span> HdfSBuf *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//给 hdi service驱动服务发送消息</span></span><br><span class="line">    <span class="keyword">return</span> self-&gt;remote-&gt;dispatcher-&gt;Dispatch(self-&gt;remote, id, data, reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、注册WLAN回调函数"><a href="#三、注册WLAN回调函数" class="headerlink" title="三、注册WLAN回调函数"></a>三、注册WLAN回调函数</h3><p>HAL 层提供了回调函数来监听wifi event。具体的实现是在wifi_driver_client.c</p>
<p>HalRegisterEventCallback()实现将onRecFunc函数赋值到全局变量g_callbackEventMap[];</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HalRegisterEventCallback</span><span class="params">(OnReceiveFunc onRecFunc, <span class="type">const</span> <span class="type">char</span> *ifName)</span></span><br><span class="line">&#123;</span><br><span class="line">    HalMutexLock();</span><br><span class="line">    <span class="type">int32_t</span> ret = RegisterEventCallbackInner(onRecFunc, ifName);</span><br><span class="line">    HalMutexUnlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">RegisterEventCallbackInner</span><span class="params">(OnReceiveFunc onRecFunc, <span class="type">const</span> <span class="type">char</span> *ifName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (WifiRegisterEventCallback(onRecFunc, WIFI_KERNEL_TO_HAL_CLIENT, ifName) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: callback function has been registered, line: %d&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">WifiRegisterEventCallback</span><span class="params">(OnReceiveFunc onRecFunc, <span class="type">uint32_t</span> eventType, <span class="type">const</span> <span class="type">char</span> *ifName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CallbackEvent</span> *<span class="title">callbackEvent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CALL_BACK_COUNT; i++) &#123;</span><br><span class="line">        <span class="comment">//checkout event type and ifname</span></span><br><span class="line">        <span class="keyword">if</span> (g_callbackEventMap[i] != <span class="literal">NULL</span> &amp;&amp; g_callbackEventMap[i]-&gt;eventType == eventType &amp;&amp;</span><br><span class="line">            (<span class="built_in">strcmp</span>(g_callbackEventMap[i]-&gt;ifName, ifName) == <span class="number">0</span>) &amp;&amp; g_callbackEventMap[i]-&gt;onRecFunc == onRecFunc) </span><br><span class="line">        &#123;</span><br><span class="line">            HILOG_INFO(LOG_DOMAIN, <span class="string">&quot;%s the onRecFunc has been registered!&quot;</span>, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span> RET_CODE_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//create new callbackEvent</span></span><br><span class="line">    callbackEvent = (<span class="keyword">struct</span> CallbackEvent *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CallbackEvent));</span><br><span class="line">	<span class="comment">//config callbackEvent</span></span><br><span class="line">    callbackEvent-&gt;eventType = eventType;</span><br><span class="line">    <span class="keyword">if</span> (strcpy_s(callbackEvent-&gt;ifName, IFNAMSIZ, ifName) != RET_CODE_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">free</span>(callbackEvent);</span><br><span class="line">        <span class="keyword">return</span> RET_CODE_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    callbackEvent-&gt;onRecFunc = onRecFunc;</span><br><span class="line">    <span class="comment">//add onRecFunc to the g_callbackEventMap[]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CALL_BACK_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_callbackEventMap[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            g_callbackEventMap[i] = callbackEvent;</span><br><span class="line">            <span class="keyword">return</span> RET_CODE_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(callbackEvent);</span><br><span class="line">    HILOG_ERROR(LOG_DOMAIN, <span class="string">&quot;%s fail: register onRecFunc num more than %d!&quot;</span>, __FUNCTION__, MAX_CALL_BACK_COUNT);</span><br><span class="line">    <span class="keyword">return</span> RET_CODE_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>g_callbackEventMap[]是固定长度的数组，其中存放所有wifi事件的回调函数，wifi event的类型定义在wifi_common_cmd.h中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CallbackEvent</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> eventType;   <span class="comment">//eventmap</span></span><br><span class="line">    <span class="type">char</span> ifName[IFNAMSIZ + <span class="number">1</span>];</span><br><span class="line">    OnReceiveFunc onRecFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">CallbackEvent</span> *<span class="title">g_callbackEventMap</span>[<span class="title">MAX_CALL_BACK_COUNT</span>] =</span> &#123;<span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/wlan_hdi/" data-id="cmbcy7rhr002ut8mt05twce2v" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/WLAN_Model" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/WLAN_Model/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.645Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="WIFI-Core"><a href="#WIFI-Core" class="headerlink" title="WIFI Core"></a>WIFI Core</h2><p>在WLAN HDI 的那篇文章中，命令最终被发送到HDF WIFI驱动模块，该驱动的实现就在hdf_wifi_core.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfDriverEntry</span> <span class="title">g_hdfWifiEntry</span> =</span> &#123;</span><br><span class="line">    .moduleVersion = <span class="number">1</span>,</span><br><span class="line">    .Bind = HdfWifiDriverBind,</span><br><span class="line">    .Init = HdfWlanMainInit,</span><br><span class="line">    .Release = HdfWlanDriverRelease,</span><br><span class="line">    .moduleName = <span class="string">&quot;HDF_WIFI&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">HDF_INIT(g_hdfWifiEntry);</span><br></pre></td></tr></table></figure>

<p>WIFI Core 驱动对消息的处理流程如图：</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/WLAN_Model/AIveunOXKjpPF2L.jpg" alt="core.png"></p>
<p>由于WIFI Core所涉及的对象多且复杂，最好先来了解这些对象是如何生成的，再看他们是如何使用。</p>
<h3 id="一、LocalNodeService"><a href="#一、LocalNodeService" class="headerlink" title="一、LocalNodeService"></a>一、LocalNodeService</h3><p>展开宏定义后的LocalNodeService，根据上图可了解到LocalNodeService有三个，分别用于响应base、sta、ap消息，于是就有三个文件对应实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LocalNodeService</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">MessageEngineStatus</span> <span class="title">status</span>;</span>                </span><br><span class="line">    OsalAtomic refCount;                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RemoteService</span> *(*<span class="title">Ref</span>)(<span class="keyword">struct</span> <span class="title">RemoteService</span> * <span class="title">obj</span>);</span> </span><br><span class="line">    <span class="type">void</span> (*Disref)(<span class="keyword">struct</span> RemoteService * obj);          </span><br><span class="line">    <span class="type">void</span> (*Destroy)(<span class="keyword">struct</span> RemoteService * obj);</span><br><span class="line">    <span class="comment">//发送请求消息</span></span><br><span class="line">    <span class="type">void</span> (*ExecRequestMsg)(<span class="type">const</span> <span class="keyword">struct</span> RemoteService *service, MessageContext *context);  </span><br><span class="line">    <span class="comment">//发送响应消息</span></span><br><span class="line">    <span class="type">void</span> (*ExecResponseMsg)(<span class="type">const</span> <span class="keyword">struct</span> RemoteService *service, MessageContext *context);  </span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    ErrorCode (*SendMessage)(<span class="type">const</span> <span class="keyword">struct</span> RemoteService *service, MessageContext *context); </span><br><span class="line">    <span class="type">void</span> (*Shutdown)(<span class="keyword">struct</span> RemoteService * service);   </span><br><span class="line">    <span class="comment">//service类型：base、ap、sta</span></span><br><span class="line">    ServiceId serviceId;    </span><br><span class="line">    <span class="comment">//dispatch用于缓存消息</span></span><br><span class="line">    MessageDispatcher *dispatcher;</span><br><span class="line">    <span class="comment">//响应消息的服务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ServiceDef</span> *<span class="title">mapper</span>;</span></span><br><span class="line">&#125; LocalNodeService;</span><br></pre></td></tr></table></figure>

<p>以sta.c为例子，学习LocalNodeService是如何被创建的：</p>
<p>sta.c中定义了三个MessageDef数组，分别用于处理三种类型的HDI message。例如sta.c中定义了5个成员的数组，用于处理5个具体的sta命令，例如WifiCmdAssoc()是用于响应wifi连接命令的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">MessageDef</span> <span class="title">g_wifiStaFeatureCmds</span>[] =</span> &#123;</span><br><span class="line">    DUEMessage(CMD_STA_CONNECT, WifiCmdAssoc, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_DISCONNECT, WifiCmdDisconnect, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_SCAN, WifiCmdScan, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_ABORT_SCAN, WifiCmdAbortScan, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_SET_SCAN_MAC_ADDR, WifiCmdSetScanningMacAddress, <span class="number">0</span>)</span><br><span class="line">&#125;; 	</span><br></pre></td></tr></table></figure>

<p>同时还要注意到g_wifiStaFeatureCmds下方有一句宏定义：将该宏定义展开，可得到函数CreateServiceSTAService()，该函数创建了一个ServiceDef结构体，并调用InitService()函数.同时在StaInit()在调用该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ServiceDefine(STAService, STA_SERVICE_ID, g_wifiStaFeatureCmds);</span><br><span class="line"><span class="comment">/**               </span></span><br><span class="line"><span class="comment">    Service *CreateServiceSTAService(const ServiceCfg *cfg)                </span></span><br><span class="line"><span class="comment">    &#123;                                                                         </span></span><br><span class="line"><span class="comment">        static struct ServiceDef serviceDef = &#123;                               </span></span><br><span class="line"><span class="comment">            .serviceId = STA_SERVICE_ID,                                          </span></span><br><span class="line"><span class="comment">            .messagesLength = sizeof(g_wifiStaFeatureCmds) / sizeof(struct MessageDef), </span></span><br><span class="line"><span class="comment">            .messages = g_wifiStaFeatureCmds                                            </span></span><br><span class="line"><span class="comment">        &#125;;                                                                    </span></span><br><span class="line"><span class="comment">        return InitService(&amp;serviceDef, cfg);                                 </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">StaInit</span><span class="params">(<span class="keyword">struct</span> WifiFeature *feature)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)feature;</span><br><span class="line">    <span class="keyword">if</span> (g_staService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ServiceCfg cfg = &#123;</span><br><span class="line">            .dispatcherId = DEFAULT_DISPATCHER_ID</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//g_staService = CreateServiceSTAService(&amp;cfg);</span></span><br><span class="line">        g_staService = CreateService(STAService, &amp;cfg);</span><br><span class="line">        <span class="keyword">if</span> (g_staService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InitService()函数在sidecar.c中，其最重要的部分是调用RegistLocalService()，而RegistLocalService简单的调用RegistServiceInner():</p>
<p>该函数的目的是创建LocalNodeService，但创建LocalNodeServic需要使用到MessageNode，这里先暂时不管。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是创建LocalNodeServic</span></span><br><span class="line"><span class="type">static</span> ErrorCode <span class="title function_">RegistServiceInner</span><span class="params">(<span class="type">const</span> NodeId nodeId, <span class="type">const</span> DispatcherId dispatcherId, <span class="keyword">struct</span> ServiceDef *mapper)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDF_STATUS status = OsalMutexTimedLock(&amp;g_routerMutex, HDF_WAIT_FOREVER);</span><br><span class="line">    <span class="comment">//获取default node（非重点）</span></span><br><span class="line">    MessageNode *node = RefMessageNode(nodeId, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    RemoteService *remoteService = <span class="literal">NULL</span>;</span><br><span class="line">    MessageDispatcher *dispatcher = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//获取default dispatcher</span></span><br><span class="line">        dispatcher = RefDispatcherInner(dispatcherId, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//重要：调用CreateLocalNodeService(node,dispatcher, mapper)</span></span><br><span class="line">        remoteService = node-&gt;CreateRemoteService(node, dispatcher, mapper);</span><br><span class="line">        errCode = NotifyAllNodesServiceAdd(nodeId, mapper);</span><br><span class="line">		<span class="comment">//把remoteService添加到g_servicesIndex[]</span></span><br><span class="line">        errCode = DoRegistService(nodeId, dispatcherId, remoteService);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> errCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateLocalNodeService() 创建了LocalNodeService对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RemoteService *<span class="title function_">CreateLocalNodeService</span><span class="params">(MessageNode *node, MessageDispatcher *dispatcher, <span class="keyword">struct</span> ServiceDef *mapper)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//create local node service</span></span><br><span class="line">    LocalNodeService *service = (LocalNodeService *)OsalMemCalloc(<span class="keyword">sizeof</span>(LocalNodeService));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        service-&gt;status = ME_STATUS_RUNNING;</span><br><span class="line">        <span class="comment">//填充函数：处理请求消息</span></span><br><span class="line">        service-&gt;ExecRequestMsg = HandleRequestMessage;</span><br><span class="line">        service-&gt;ExecResponseMsg = HandleResponseMessage;</span><br><span class="line">        service-&gt;SendMessage = SendMessageLocalNode;</span><br><span class="line">        service-&gt;Shutdown = ShutdownLocalService;</span><br><span class="line">        service-&gt;serviceId = mapper-&gt;serviceId;</span><br><span class="line">        <span class="comment">//把sta.c中定义的ServiceDef 赋值给 LocalNodeService</span></span><br><span class="line">        service-&gt;mapper = mapper;</span><br><span class="line">        service-&gt;dispatcher = dispatcher-&gt;Ref(dispatcher);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> (RemoteService *)service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下，调用sta.c，ap.c，wifi_base.c中的初始化函数，就能创建上图所示的LocalNodeService。</strong></p>
<h3 id="二、消息传递流程"><a href="#二、消息传递流程" class="headerlink" title="二、消息传递流程"></a>二、消息传递流程</h3><p>了解了LocalNodeService是如何创建的，我们就能轻松的了解消息的传递流程。</p>
<p>在hdf_wifi_core.c中的HdfWifiDriverBind函数定义了HDF_WIFI驱动所提供的服务,并启动MessageRouter来创建MessageNode，创建dispatch，MessageNode和Dispatch正是我们前面创建LocalNodeService所需要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfWifiDriverBind</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IDeviceIoService</span> <span class="title">wifiService</span> =</span> &#123;</span><br><span class="line">        .object.objectId = <span class="number">1</span>,</span><br><span class="line">        .Dispatch = DispatchToMessage,</span><br><span class="line">    &#125;;</span><br><span class="line">    errCode = StartMessageRouter(MESSAGE_NODE_CONFIG_DEFAULT);</span><br><span class="line">    errCode = EnableDefaultDispatcher();</span><br><span class="line">    dev-&gt;service = &amp;wifiService;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重点关注DispatchToMessage():</p>
<p>该函数定义在sidecar.c中。sidecar.c封装了LocalNodeService，提供接口给HDF_WIFI驱动使用，起到中介的作用。要注意到，驱动的命令是以id+HdfSBuf的形式传递进来的，需要转换成messagecontext。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">DispatchToMessage</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="type">int</span> id, <span class="keyword">struct</span> HdfSBuf *reqData, <span class="keyword">struct</span> HdfSBuf *rspData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//create message</span></span><br><span class="line">    context = CreateMessageContext(RESERVED_SERVICE_ID, serviceId, cmd, reqData);</span><br><span class="line">    context-&gt;rspData = rspData;</span><br><span class="line">    <span class="comment">//从HDI发送过来的是REQ</span></span><br><span class="line">    context-&gt;requestType = MESSAGE_TYPE_SYNC_REQ;</span><br><span class="line">    context-&gt;client = client;</span><br><span class="line">    RemoteService *targetService = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//获取特定的 LocalNodeService</span></span><br><span class="line">        targetService = RefRemoteService(serviceId);</span><br><span class="line">        <span class="comment">//SendMessage就是在LocalNodeService创建时设置的 SendMessageLocalNode()</span></span><br><span class="line">        errCode = targetService-&gt;SendMessage(targetService, context);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendMessage()根据message类型作不同的处理：</p>
<ul>
<li>sync：同步类消息需要马上处理</li>
<li>async：异步类消息由RunDispatcher线程稍后处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ErrorCode <span class="title function_">SendMessageLocalNode</span><span class="params">(<span class="type">const</span> RemoteService *service, MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//MESSAGE_TYPE_SYNC_REQ 来自HDI的同步请求，马上处理并回复</span></span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;crossNode &amp;&amp; context-&gt;requestType == MESSAGE_TYPE_SYNC_REQ) &#123;</span><br><span class="line">        <span class="comment">//处理请求</span></span><br><span class="line">        HandleRequestMessage(service, context);</span><br><span class="line">        <span class="comment">//回复</span></span><br><span class="line">        SetToResponse(context);</span><br><span class="line">        <span class="keyword">return</span> context-&gt;responseStatus;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context-&gt;requestType == MESSAGE_TYPE_SYNC_RSP) &#123;</span><br><span class="line">        <span class="comment">//同步响应，释放信号量？</span></span><br><span class="line">        (<span class="type">void</span>)OsalSemPost(&amp;context-&gt;rspSemaphore);</span><br><span class="line">        <span class="keyword">return</span> ME_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//异步请求，交给dispatch缓存处理</span></span><br><span class="line">        <span class="keyword">return</span> localService-&gt;dispatcher-&gt;AppendMessage(localService-&gt;dispatcher, pri, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandleRequestMessage()获取定义在sta.c、wifi_base.c、ap.c的messageDef，然后指定handler函数，例如：WifiCmdAssoc()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleRequestMessage</span><span class="params">(<span class="type">const</span> RemoteService *service, MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocalNodeService *localNodeService = (LocalNodeService *)service;</span><br><span class="line">	<span class="comment">//根据commandID获取请求对应的messageDef</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MessageDef</span> <span class="title">messageDef</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (localNodeService-&gt;mapper != <span class="literal">NULL</span> &amp;&amp; context-&gt;commandId &lt; localNodeService-&gt;mapper-&gt;messagesLength) &#123;</span><br><span class="line">        messageDef = localNodeService-&gt;mapper-&gt;messages[context-&gt;commandId];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用messageDef的函数处理请求</span></span><br><span class="line">    context-&gt;responseStatus = messageDef.handler((RequestContext *)context, context-&gt;reqData, context-&gt;rspData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>让我们重新回到sta.c中，看看messageDef[]中的handler函数是如何处理消息的。还是以WifiCmdAssoc()为线索：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">WifiCmdAssoc</span><span class="params">(<span class="type">const</span> RequestContext *context, <span class="keyword">struct</span> HdfSBuf *reqData, <span class="keyword">struct</span> HdfSBuf *rspData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WlanConnectParams</span> <span class="title">params</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WifiAssociateParams assoc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netdev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    ifName = HdfSbufReadString(reqData);</span><br><span class="line">    <span class="comment">//设置连接参数</span></span><br><span class="line">    <span class="keyword">if</span> (WifiFillAssocParams(&amp;assoc, reqData) != HDF_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取netdev</span></span><br><span class="line">    <span class="keyword">if</span> ((netdev = NetDeviceGetInstByName(ifName)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s:netdev not found!ifName=%s&quot;</span>, __func__, ifName);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置连接参数</span></span><br><span class="line">    <span class="keyword">if</span> (WifiSetAssocParams(&amp;assoc, netdev, &amp;params) != HDF_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        params.centerFreq = assoc.freq;</span><br><span class="line">		<span class="comment">//开始连接wifi</span></span><br><span class="line">        ret = Connect(netdev, &amp;params);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Connect()使用 chipDriver 对象提供的接口进行连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">Connect</span><span class="params">(<span class="keyword">struct</span> NetDevice *netDev, <span class="keyword">struct</span> WlanConnectParams *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取chip driver</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfChipDriver</span> *<span class="title">chipDriver</span> =</span> GetChipDriver(netDev);</span><br><span class="line">    RETURN_IF_CHIPOPS_NOT_IMPLEMENT(chipDriver-&gt;staOps, Connect);</span><br><span class="line">    <span class="comment">//chip driver 开始连接</span></span><br><span class="line">    <span class="keyword">return</span> chipDriver-&gt;staOps-&gt;Connect(netDev, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此 WIFI Core 的任务就完成了。</p>
<h3 id="三、HDF-WIFI-初始化"><a href="#三、HDF-WIFI-初始化" class="headerlink" title="三、HDF WIFI 初始化"></a>三、HDF WIFI 初始化</h3><p>首先来看HdfWlanMainInit函数，这是驱动的初始化函数，负责生成上图所用到的所有对象。</p>
<p>HDF_WIFI的初始化分为三个部分：</p>
<ul>
<li>HdfWlanGetConfig是获取配置文件的配置信息，暂不分析。</li>
<li>HdfWlanInitProduct：调用InitWifiModule 初始化wifi module（本质是初始化三个LocalNodeService）</li>
<li>HdfWlanScanAndInitThread：初始化硬件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main init process including config, powers, load the factory, and chip init */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfWlanMainInit</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取配置文件的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> (HdfWlanGetConfig(device) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s:HdfWlanGetConfig get wlan config failed!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    rootConfig = HdfWlanGetModuleConfigRoot();</span><br><span class="line">    moduleConfig = &amp;rootConfig-&gt;wlanConfig.moduleConfig;</span><br><span class="line">    <span class="comment">//初始化Modules</span></span><br><span class="line">    <span class="keyword">if</span> (HdfWlanInitProduct(device, moduleConfig) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s:HdfWlanInitProduct failed!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化硬件</span></span><br><span class="line">    <span class="keyword">if</span> (HdfWlanScanAndInitThread(device) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: LoadChipFactoryThread failed, the load process failed!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">HdfWlanInitProduct</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device, <span class="type">const</span> <span class="keyword">struct</span> HdfConfigWlanModuleConfig *config)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_hdfWlanProductData = OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HdfWifiProductData));</span><br><span class="line">    ret = InitWifiModule(&amp;(g_hdfWlanProductData-&gt;module), config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1、HdfWlanInitProduct"><a href="#3-1、HdfWlanInitProduct" class="headerlink" title="3.1、HdfWlanInitProduct"></a>3.1、HdfWlanInitProduct</h4><p>初始化WIFI Module，其根本目的是为了创建三个LocalNodeService，分别是：BASE、STA、AP LocalNodeService</p>
<p>函数调用流程是：InitWifiModule()-&gt;InitFeatures()，其中分别调用BaseInit()、StaInit()、ApInit()来创建LocalNodeService</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">InitFeatures</span><span class="params">(<span class="keyword">struct</span> WifiModule *module)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化 BASE LocalNodeService</span></span><br><span class="line">    ret = BaseInit();</span><br><span class="line">    <span class="comment">//获取 ApFeature、staFeature</span></span><br><span class="line">    module-&gt;feList.fe[HDF_WIFI_FEATURE_AP] = GetWifiApFeature();</span><br><span class="line">    module-&gt;feList.fe[HDF_WIFI_FEATURE_STA] = GetWifiStaFeature();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HDF_WIFI_FEATURE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((module-&gt;moduleConfig.hslConfig-&gt;featureMap &amp; (<span class="number">1</span> &lt;&lt; i)) &amp;&amp; module-&gt;feList.fe[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//调用StaInit() ApInit()</span></span><br><span class="line">            module-&gt;feList.fe[i]-&gt;init(module-&gt;feList.fe[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2、HdfWlanScanAndInitThread"><a href="#3-2、HdfWlanScanAndInitThread" class="headerlink" title="3.2、HdfWlanScanAndInitThread"></a>3.2、HdfWlanScanAndInitThread</h4><p>HdfWlanScanAndInitThread会回调HdfWlanInitThread函数，在其中初始化硬件，如sdio控制器，芯片电源引脚，复位引脚，驱动程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfWlanInitThread</span><span class="params">(<span class="type">void</span> *para)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfDeviceObject</span> *<span class="title">device</span> =</span> (<span class="keyword">struct</span> HdfDeviceObject *)para;</span><br><span class="line">    OsalSleep(initDelaySec);</span><br><span class="line">    devList = HdfWlanGetDeviceList();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; devList-&gt;deviceListSize; i++) &#123;</span><br><span class="line">        <span class="comment">//sdio config</span></span><br><span class="line">        ret = HdfWlanConfigSDIO(devList-&gt;deviceInst[i].bus.busIdx);</span><br><span class="line">        <span class="comment">// init hardware</span></span><br><span class="line">        wlanDevice = ProbeDevice(&amp;(devList-&gt;deviceInst[i]));</span><br><span class="line">        ret = HdfWlanAddDevice(wlanDevice);</span><br><span class="line">        <span class="comment">// Load chip driver</span></span><br><span class="line">        (<span class="type">void</span>)DevSvcManagerClntSubscribeService(wlanDevice-&gt;driverName, callback);</span><br><span class="line">        (<span class="type">void</span>)HdfWifiInitDevice(wlanDevice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HdfWlanInitThread也分为三个部分：</p>
<ul>
<li>HdfWlanConfigSDIO：由驱动开发者实现，配置sdio控制器外设</li>
<li>ProbeDevice：初始化硬件</li>
<li>HdfWifiInitDevice：初始化硬件驱动程序</li>
</ul>
<h5 id="3-2-1、HdfWlanConfigSDIO"><a href="#3-2-1、HdfWlanConfigSDIO" class="headerlink" title="3.2.1、HdfWlanConfigSDIO"></a><strong>3.2.1、HdfWlanConfigSDIO</strong></h5><p>由驱动开发者实现，配置sdio控制器外设，以海思的芯片为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfWlanConfigSDIO</span><span class="params">(<span class="type">uint8_t</span> busId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfConfigWlanRoot</span> *<span class="title">config</span> =</span> HdfWlanGetModuleConfigRoot();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;hi3516dv300&quot;</span>, config-&gt;wlanConfig.hostChipName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigHi3516DV300SDIO(busId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;hi3518ev300&quot;</span>, config-&gt;wlanConfig.hostChipName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigHi3518EV300SDIO(busId);</span><br><span class="line">    &#125;</span><br><span class="line">    HDF_LOGE(<span class="string">&quot;%s: platform chip not supported!&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">ConfigHi3516DV300SDIO</span><span class="params">(<span class="type">uint8_t</span> busId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (busId == <span class="number">2</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: Config Hi3516DV300 SDIO bus %d&quot;</span>, __func__, busId);</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PMC_REG_ADDR_REG0 = <span class="number">0x12090000</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PIN_REG_ADDR_CLK = <span class="number">0x112F0008</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PIN_REG_ADDR_CMD = <span class="number">0x112F000C</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PIN_REG_ADDR_DATA0 = <span class="number">0x112F0010</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PIN_REG_ADDR_DATA1 = <span class="number">0x112F0014</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PIN_REG_ADDR_DATA2 = <span class="number">0x112F0018</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> PIN_REG_ADDR_DATA3 = <span class="number">0x112F001C</span>;</span><br><span class="line"></span><br><span class="line">        REG_SET_BITS(PMC_REG_ADDR_REG0, <span class="number">0x0080</span>);</span><br><span class="line">        REG_WRITE(PIN_REG_ADDR_CLK, <span class="number">0x601</span>);</span><br><span class="line">        REG_WRITE(PIN_REG_ADDR_CMD, <span class="number">0x501</span>);</span><br><span class="line">        REG_WRITE(PIN_REG_ADDR_DATA0, <span class="number">0x501</span>);</span><br><span class="line">        REG_WRITE(PIN_REG_ADDR_DATA1, <span class="number">0x501</span>);</span><br><span class="line">        REG_WRITE(PIN_REG_ADDR_DATA2, <span class="number">0x501</span>);</span><br><span class="line">        REG_WRITE(PIN_REG_ADDR_DATA3, <span class="number">0x501</span>);</span><br><span class="line">        <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HDF_LOGE(<span class="string">&quot;%s: SDIO bus ID %d not supportted!&quot;</span>, __func__, busId);</span><br><span class="line">    <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2、ProbeDevice"><a href="#3-2-2、ProbeDevice" class="headerlink" title="3.2.2、ProbeDevice()"></a><strong>3.2.2、ProbeDevice()</strong></h5><p>初始化 HdfWlanDevice结构体，并调用HdfWlanDevice的方法初始化 硬件wifi芯片，如上电、复位、连接总线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> HdfWlanDevice *<span class="title function_">ProbeDevice</span><span class="params">(<span class="keyword">struct</span> HdfConfigWlanDevInst *deviceConfig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfWlanDevice</span> *<span class="title">device</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    device = (<span class="keyword">struct</span> HdfWlanDevice *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HdfWlanDevice));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//create PowerManage and ResetManage </span></span><br><span class="line">        device-&gt;powers = HdfWlanCreatePowerManager(&amp;deviceConfig-&gt;powers);</span><br><span class="line">        device-&gt;reset = HdfWlanCreateResetManager(&amp;deviceConfig-&gt;reset, deviceConfig-&gt;bootUpTimeOut);</span><br><span class="line">		<span class="comment">//上电</span></span><br><span class="line">        ret = HdfWlanPowerOnProcess(device-&gt;powers);</span><br><span class="line">		<span class="comment">//复位 </span></span><br><span class="line">        ret = HdfWlanResetProcess(device-&gt;reset);</span><br><span class="line">		<span class="comment">//init sdio bus </span></span><br><span class="line">        ret = HdfWlanBusInit(device, &amp;deviceConfig-&gt;bus);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HdfWlanDevice 是来描述所有wlan设备的硬件属性：例如驱动名称，芯片名称、电源、复位、连接到主控的总线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfWlanDevice</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> id;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *driverName;                     <span class="comment">/**&lt; Driver name */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *chipName;                       <span class="comment">/**&lt; Chip name */</span></span><br><span class="line">    <span class="type">uint32_t</span> netIfMap;                          <span class="comment">/**&lt; WLAN device bitmap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfWlanManufacturer</span> <span class="title">manufacturer</span>;</span>    <span class="comment">/**&lt; WLAN device manufacturer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ResetManager</span> *<span class="title">reset</span>;</span>                 <span class="comment">/**&lt; Chip reset management API */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PowerManager</span> *<span class="title">powers</span>;</span>                <span class="comment">/**&lt; Chip power management APIs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BusDev</span> *<span class="title">bus</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ResetManager</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*Reset)(<span class="keyword">struct</span> ResetManager *resetManager);<span class="comment">//Resets the WLAN module using a specified reset manager</span></span><br><span class="line">    <span class="type">int32_t</span> (*Release)(<span class="keyword">struct</span> ResetManager *resetMgr);    <span class="comment">//Releases a specified reset manager.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PowerManager</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*On)(<span class="keyword">struct</span> PowerManager *powerMgr);	<span class="comment">//Powers on the device using a specified power manager.</span></span><br><span class="line">    <span class="type">int32_t</span> (*Off)(<span class="keyword">struct</span> PowerManager *powerMgr);	<span class="comment">//Powers off the device using a specified power manager.</span></span><br><span class="line">    <span class="type">int32_t</span> (*Release)(<span class="keyword">struct</span> PowerManager *powerMgr);	<span class="comment">//Releases power using a specified power manager.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BusDev</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *devBase;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DevOps</span> <span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PrivateData</span> <span class="title">priData</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用HdfWlanCreatePowerManager()会初始化PowerManager，HdfWlanPowerOnProcess 会调用PowerManager-&gt;on()，即HdfWlanChipPowerOn()，通过设置gpio引脚来使能wlan芯片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfWlanChipPowerOn</span><span class="params">(<span class="keyword">struct</span> PowerManager* powerMgr)</span></span><br><span class="line">&#123;</span><br><span class="line">    powerMgrimpl = (<span class="keyword">struct</span> PowerManagerImpl*)powerMgr;</span><br><span class="line">    ret = HdfWlanSinglePowerActive(&amp;powerMgrimpl-&gt;powerDatas.power0);</span><br><span class="line">    ret = HdfWlanSinglePowerActive((<span class="keyword">struct</span> HdfConfigWlanPower*)&amp;powerMgrimpl-&gt;powerDatas.power1);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfWlanSinglePowerActive</span><span class="params">(<span class="keyword">struct</span> HdfConfigWlanPower* powerDate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//set gpio pin</span></span><br><span class="line">    ret = GpioSetDir(powerDate-&gt;gpioId, <span class="number">1</span>);</span><br><span class="line">    OsalMSleep(powerDate-&gt;powerSeqDelay);</span><br><span class="line">    ret = GpioWrite(powerDate-&gt;gpioId, powerDate-&gt;activeLevel);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResetManager的实现也是类似的</p>
<h5 id="3-2-3、HdfWifiInitDevice"><a href="#3-2-3、HdfWifiInitDevice" class="headerlink" title="3.2.3、HdfWifiInitDevice()"></a><strong>3.2.3、HdfWifiInitDevice()</strong></h5><p>获取 HdfChipDriverFactory，并调用其InitChip()方法来初始化芯片硬件，调用HdfWlanInitInterfaces()初始化HdfChipDriver ；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfWifiInitDevice</span><span class="params">(<span class="keyword">struct</span> HdfWlanDevice *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">HdfChipDriverFactory</span> *<span class="title">chipDriverFact</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//获取 HdfChipDriverFactory 管理所有驱动程序</span></span><br><span class="line">    chipDriverFact = HdfWlanGetDriverFactory(device-&gt;driverName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chipDriverFact-&gt;InitChip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化芯片</span></span><br><span class="line">        ret = chipDriverFact-&gt;InitChip(device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建wifi芯片的接口</span></span><br><span class="line">    ret = HdfWlanInitInterfaces(device, chipDriverFact);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HdfChipDriverFactory结构体由硬件厂商实现，其最终目的是为了创建chip driver.</p>
<p><strong>chip driver</strong></p>
<p>HdfWlanInitInterfaces 创建对应芯片的HdfChipDriver ，创建netdevice，调用chipDriver-&gt;init()初始化芯片驱动程序（即由驱动开发者根据具体芯片实现的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfWlanInitInterface</span><span class="params">(<span class="keyword">struct</span> HdfWlanDevice *device, <span class="keyword">struct</span> HdfChipDriverFactory *factory, <span class="type">uint8_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    NetDevice *netDev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfChipDriver</span> *<span class="title">chipDriver</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//创建 chip driver</span></span><br><span class="line">        chipDriver = factory-&gt;Build(device, index);</span><br><span class="line">        <span class="comment">//创建 NetDev </span></span><br><span class="line">        netDev = AllocPlatformNetDevice(device);</span><br><span class="line">        data = GetPlatformData(netDev);</span><br><span class="line">        data-&gt;device = device;</span><br><span class="line">        <span class="comment">//call chipdriver to init the chip</span></span><br><span class="line">        ret = chipDriver-&gt;init(chipDriver, netDev);</span><br><span class="line">        <span class="comment">//将netdev和chip driver 绑定</span></span><br><span class="line">        data-&gt;chipDriver = chipDriver;</span><br><span class="line">        chipDriver = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>HdfChipDriver 是直接操作wifi 芯片硬件的驱动，也必须由驱动厂商实现，其中HdfMac80211BaseOps、HdfMac80211STAOps、HdfMac80211STAOps都需要实现具体的硬件操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfChipDriver</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> type;                          <span class="comment">/**&lt; Chip type */</span></span><br><span class="line">    <span class="type">char</span> name[MAX_WIFI_COMPONENT_NAME_LEN]; <span class="comment">/**&lt; Chip name */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfMac80211BaseOps</span> *<span class="title">ops</span>;</span>         </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfMac80211STAOps</span> *<span class="title">staOps</span>;</span>       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfMac80211STAOps</span> *<span class="title">apOps</span>;</span>        </span><br><span class="line">    <span class="type">void</span> *priv;                             </span><br><span class="line">	<span class="comment">//Initializes a chip driver.</span></span><br><span class="line">    <span class="type">int32_t</span> (*init)(<span class="keyword">struct</span> HdfChipDriver *chipDriver, NetDevice *netDev);</span><br><span class="line">	<span class="comment">//Deinitializes a chip driver.</span></span><br><span class="line">    <span class="type">int32_t</span> (*deinit)(<span class="keyword">struct</span> HdfChipDriver *chipDriver, NetDevice *netDev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfMac80211BaseOps</span> &#123;</span></span><br><span class="line">	<span class="comment">//设置wifi模式</span></span><br><span class="line">    <span class="type">int32_t</span> (*SetMode)(NetDevice *netDev, <span class="keyword">enum</span> WlanWorkMode mode);</span><br><span class="line">	<span class="comment">//添加key</span></span><br><span class="line">    <span class="type">int32_t</span> (*AddKey)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">uint8_t</span> keyIndex, <span class="type">bool</span> pairwise, <span class="type">const</span> <span class="type">uint8_t</span> *macAddr,</span><br><span class="line">        <span class="keyword">struct</span> KeyParams *params);</span><br><span class="line">    <span class="type">int32_t</span> (*DelKey)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">uint8_t</span> keyIndex, <span class="type">bool</span> pairwise, <span class="type">const</span> <span class="type">uint8_t</span> *macAddr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*SetDefaultKey)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">uint8_t</span> keyIndex, <span class="type">bool</span> unicast, <span class="type">bool</span> multicas);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*GetDeviceMacAddr)(NetDevice *netDev, <span class="type">int32_t</span> type, <span class="type">uint8_t</span> *mac, <span class="type">uint8_t</span> len);</span><br><span class="line">    <span class="type">int32_t</span> (*SetMacAddr)(NetDevice *netDev, <span class="type">uint8_t</span> *mac, <span class="type">uint8_t</span> len);</span><br><span class="line">    <span class="type">int32_t</span> (*SetTxPower)(NetDevice *netDev, <span class="type">int32_t</span> power);</span><br><span class="line">	<span class="comment">//获取芯片支持的带宽</span></span><br><span class="line">    <span class="type">int32_t</span> (*GetValidFreqsWithBand)(NetDevice *netDev, <span class="type">int32_t</span> band, <span class="type">int32_t</span> *freqs, <span class="type">uint32_t</span> *num);</span><br><span class="line">	<span class="comment">//获取芯片的能力</span></span><br><span class="line">    <span class="type">int32_t</span> (*GetHwCapability)(NetDevice *netDev, <span class="keyword">struct</span> WlanHwCapability **capability);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*RemainOnChannel)(NetDevice *netDev, WifiOnChannel *onChannel);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*CancelRemainOnChannel)(NetDevice *netDev);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*ProbeReqReport)(NetDevice *netDev, <span class="type">int32_t</span> report);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*AddIf)(NetDevice *netDev, WifiIfAdd *ifAdd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*RemoveIf)(NetDevice *netDev, WifiIfRemove *ifRemove);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*SetApWpsP2pIe)(NetDevice *netDev, WifiAppIe *appIe);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*GetDriverFlag)(<span class="keyword">struct</span> NetDevice *netDev, WifiGetDrvFlags **params);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*SendAction)(<span class="keyword">struct</span> NetDevice *netDev, WifiActionData *actionData);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> (*GetIftype)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">uint8_t</span> *iftype);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>








      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/WLAN_Model/" data-id="cmbcy7rhn002kt8mt9sbr5oet" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/bearpi_pwm_driver" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/bearpi_pwm_driver/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.645Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="小熊派micro-HDF-PWM驱动开发"><a href="#小熊派micro-HDF-PWM驱动开发" class="headerlink" title="小熊派micro HDF PWM驱动开发"></a>小熊派micro HDF PWM驱动开发</h2><p>本文介绍如何在HDF PWM框架中开发stm32mp1的pwm外设。</p>
<p>stm32mp1的大部分外设可以使用st提供的HAL库来开发。hal库是st官网为所有st芯片提供的sdk包，使开发者可以免去操作寄存器的操作，直接使用库函数完成芯片外设的配置。</p>
<p>STM32MP1 HAL库地址：<a target="_blank" rel="noopener" href="https://gitee.com/mirrors_STMicroelectronics/STM32CubeMP1">mirrors_STMicroelectronics&#x2F;STM32CubeMP1 (gitee.com)</a></p>
<p>为了使STM32MP1 的PWM驱动适配到HDF框架，就需要了解PWM框架如何开发，可参考官网文档：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/driver/driver-platform-pwm-develop.md">zh-cn&#x2F;device-dev&#x2F;driver&#x2F;driver-platform-pwm-develop.md · OpenHarmony&#x2F;docs - 码云 - 开源中国 (gitee.com)</a></p>
<p>综上所述，可以将整个开发步骤分三步走：</p>
<p>1、导入STM32HAL库</p>
<p>2、使能HDF PWM驱动</p>
<p>3、编写PWM驱动</p>
<h3 id="1、导入stm32mp1-HAL库文件"><a href="#1、导入stm32mp1-HAL库文件" class="headerlink" title="1、导入stm32mp1 HAL库文件"></a>1、导入stm32mp1 HAL库文件</h3><p>下载HAL库完成后，将HAL库中的以下文件添加到<code>bearpi-micro\device\st\drivers\stm32mp1xx_hal\STM32MP1xx_HAL_Driver</code>的Inc目录中。</p>
<ul>
<li>stm32mp1xx_hal_tim.h</li>
<li>stm32mp1xx_hal_tim_ex.h</li>
<li>stm32mp1xx_hal_dma.h</li>
<li>stm32mp1xx_hal_dma_ex.h</li>
</ul>
<p>将 以下文件添加到<code>bearpi-micro\device\st\drivers\stm32mp1xx_hal\STM32MP1xx_HAL_Driver</code>的Src目录中:</p>
<ul>
<li>stm32mp1xx_hal_tim.c</li>
<li>stm32mp1xx_hal_tim_ex.c</li>
<li>stm32mp1xx_hal_dma.c</li>
<li>stm32mp1xx_hal_dma_ex.c</li>
</ul>
<p>然后将四个源文件加入编译构建体系：编辑<code>bearpi-micro\device\st\drivers\stm32mp1xx_hal\STM32MP1xx_HAL_Driver\BUILD.gn</code></p>
<p>在sources添加如下两项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_tim_ex.c&quot;</span>,</span><br><span class="line"><span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_tim.c&quot;</span>,</span><br><span class="line"><span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_dma_ex.c&quot;</span>,</span><br><span class="line"><span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_dma.c&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>添加后如下所示，这样编译系统就会编译这两个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;//drivers/adapter/khdf/liteos/hdf.gni&quot;</span>)</span><br><span class="line">module_name = <span class="string">&quot;hdf_stm32mp1xx_hal&quot;</span></span><br><span class="line">hdf_driver(module_name) &#123;</span><br><span class="line">  sources = [</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_tim_ex.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_tim.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_dma_ex.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_dma.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/system_stm32mp1xx.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_gpio.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_i2c.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_exti.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_ltdc.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_rcc.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;STM32MP1xx_HAL_Driver/Src/stm32mp1xx_hal_rcc_ex.c&quot;</span>,</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">  include_dirs = [</span><br><span class="line">    <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//device/st/drivers/stm32mp1xx_hal/STM32MP1xx_HAL_Driver/Inc&quot;</span>,</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，还需要配置一个宏定义，来使能TIM，编辑 <code>STM32MP1xx_HAL_Driver\Inc\stm32mp1xx_hal_conf.h</code>，将 <code>HAL_TIM_MODULE_ENABLED</code> 和<code>HAL_DMA_MODULE_ENABLED</code>使能 ，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define HAL_TIM_MODULE_ENABLED   </span></span><br><span class="line"><span class="comment">#define HAL_DMA_MODULE_ENABLED   </span></span><br></pre></td></tr></table></figure>

<p>到此，我们就能使用stm32mp1xx_hal_tim.h 提供的函数来开发PWM驱动。</p>
<h3 id="2、使能HDF-PWM框架"><a href="#2、使能HDF-PWM框架" class="headerlink" title="2、使能HDF PWM框架"></a>2、使能HDF PWM框架</h3><p>由于HDF 框架是在内核中的，需要在内核中使能PWM驱动。</p>
<p>编辑 <code>vendor/bearpi/bearpi_hm_micro/kernel_configs/debug_tee.config</code>，将 <code>LOSCFG_DRIVERS_HDF_PLATFORM_PWM</code>设置为y，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOSCFG_DRIVERS_HDF_PLATFORM_PWM = y</span><br></pre></td></tr></table></figure>

<p>开启该宏之后，就会编译HDF 的PWM框架，就能在驱动中使用PWM框架的pwm_core.h和pwm_if.h。</p>
<h3 id="3、编写驱动代码"><a href="#3、编写驱动代码" class="headerlink" title="3、编写驱动代码"></a>3、编写驱动代码</h3><p>按照官网文档的指示进行编写：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/driver/driver-platform-pwm-develop.md">PWM框架开发</a></p>
<p>同样分为三步走。</p>
<h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><p>一共需要修改两个hcs文件，分别是：device_info.hcs和pwm_config.hcs</p>
<p>首先 编辑<code>st\bearpi_hm_micro\liteos_a\hdf_config\device_info\device_info.hcs</code>增加pwm节点，如下所示：</p>
<p>该节点应该是在 <code>platform :: host</code>节点下创建。其中policy&#x3D;1表示只对内核发布驱动服务，moduleName必须为HDF_PLATFORM_PWM，serviceName必须以HDF_PLATFORM_PWM_开头，后面的数字用来区别不同的pwm外设。</p>
<p>这里我设置为2是因为我使用TIM2作为PWM的源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">device_pwm :: device&#123;</span><br><span class="line">    device0 :: deviceNode&#123;</span><br><span class="line">        policy = 1;</span><br><span class="line">        priority = 12;</span><br><span class="line">        permission = 0777;</span><br><span class="line">        moduleName = <span class="string">&quot;HDF_PLATFORM_PWM&quot;</span>;</span><br><span class="line">        serviceName = <span class="string">&quot;HDF_PLATFORM_PWM_2&quot;</span>;</span><br><span class="line">        deviceMatchAttr = <span class="string">&quot;st_stm32mp157_pwm_2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个配置文件就是自己创建的，在<code>\bearpi_hm_micro\liteos_a\hdf_config\</code>录下创建pwm目录，在目录中创建 pwm_config.hcs，并在其中添加以下内容：</p>
<p>其中PWM的计数频率是1MHZ，在代码中写死，可以修改；physics_register表示TIM的寄存器基地址，根据STM32MP1参考手册可知TIM2的寄存器地址是<code>x40000000</code>寄存器地址范围是0x70。</p>
<p>下面的配置表示：使用TIM2 Channel 1作为PWM输出，周期是1ms，占空比是50%</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root &#123;</span><br><span class="line">    platform &#123;</span><br><span class="line">        pwm_config &#123;</span><br><span class="line">            <span class="comment">//1mhz</span></span><br><span class="line">            template pwm_device &#123;</span><br><span class="line">                Period = <span class="number">1000</span>;	<span class="comment">//1000*0.1us=100us=10khz</span></span><br><span class="line">                Pulse = <span class="number">500</span>; 	<span class="comment">//500</span></span><br><span class="line">                Polarity = <span class="number">0</span>;   <span class="comment">//high</span></span><br><span class="line">                IdleState = <span class="number">0</span>;  <span class="comment">//reset</span></span><br><span class="line">                channel = <span class="number">0</span>;    <span class="comment">//channel_1 PA5</span></span><br><span class="line">                match_attr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                physics_register = <span class="number">0X40000000</span>;</span><br><span class="line">                register_size = <span class="number">0X70</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            device_0X40000000 :: pwm_device &#123;</span><br><span class="line">                match_attr = <span class="string">&quot;st_stm32mp157_pwm_2&quot;</span>;</span><br><span class="line">                num = <span class="number">2</span>;</span><br><span class="line">                physics_register = <span class="number">0X40000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上诉两个文件编辑完成后，在<code>t\bearpi_hm_micro\liteos_a\hdf_config\hdf.hcs</code>添加一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm/pwm_config.hcs&quot;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="2、编写驱动"><a href="#2、编写驱动" class="headerlink" title="2、编写驱动"></a>2、编写驱动</h4><p>在<code>bearpi-micro\device\st\drivers</code>录下新建pwm目录，并创建驱动源文件stm32mp1_pwm.c，以及BUILD.gn</p>
<p>首先定义驱动入口对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义驱动入口的对象，必须为HdfDriverEntry（在hdf_device_desc.h中定义）类型的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfDriverEntry</span> <span class="title">g_pwmDriverEntry</span> =</span> &#123;</span><br><span class="line">    .moduleVersion = <span class="number">1</span>,</span><br><span class="line">    .moduleName = <span class="string">&quot;HDF_PLATFORM_PWM&quot;</span>,	<span class="comment">//必须与device_info.hcs中的字段一样，用于与驱动设备资源匹配</span></span><br><span class="line">    .Bind = HdfPwmDriverBind,</span><br><span class="line">    .Init = HdfPwmDriverInit,</span><br><span class="line">    .Release = HdfPwnDriverRelease,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用HDF_INIT将驱动入口注册到HDF框架中</span></span><br><span class="line">HDF_INIT(g_pwmDriverEntry);</span><br></pre></td></tr></table></figure>

<p>以及自定义一个PWM对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有pwm结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StmPwm</span> &#123;</span></span><br><span class="line">    TIM_HandleTypeDef htim;		<span class="comment">//HAL TIM必须</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PwmDev</span> <span class="title">dev</span>;</span>			<span class="comment">//HDF PWM核心层必须</span></span><br><span class="line">    TIM_OC_InitTypeDef sConfig; <span class="comment">//HAL PWM必须 </span></span><br><span class="line">    <span class="type">uint32_t</span> physics_register;  <span class="comment">//TIM基地址</span></span><br><span class="line">    <span class="type">uint32_t</span> register_size;		<span class="comment">//地址范围</span></span><br><span class="line">    <span class="type">uint32_t</span> channel;			<span class="comment">//pwm channel</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化函数逻辑很简单，就是使用 struct StmPwm 对象中的成员去调用各个库的初始化函数。</p>
<p>首先引入PWM所需的头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm hal库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32mp1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32mp1xx_hal_tim.h&quot;</span></span></span><br><span class="line"><span class="comment">//hdf pwm</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm_core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm_if.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>驱动初始化函数：首先读取上文所配置的信息到StmPwm对象中，然后将PwmDev添加到HDF PWM框架中，这样就能使用HDF PWM框架的功能；最后调用STM32MP1 HAL库函数，初始化TIM2的PWM模式，设置对应的GPIO复用功能，开始输出PWM。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动自身业务初始的接口（设置IO口为输出） HDF框架在加载驱动的时候，会将私有配置信息保存在HdfDeviceObject 中的property里面</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfPwmDriverInit</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    dprintf(<span class="string">&quot;%s enter\r\n&quot;</span>,__func__);</span><br><span class="line"></span><br><span class="line">    RCC_ClkInitTypeDef    clkconfig;</span><br><span class="line">    <span class="type">uint32_t</span>              pFLatency;</span><br><span class="line">    <span class="type">uint32_t</span>              uwTimclock;</span><br><span class="line"></span><br><span class="line">    sp = (<span class="keyword">struct</span> StmPwm *)OsalMemCalloc(<span class="keyword">sizeof</span>(*sp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件</span></span><br><span class="line">    readHcs(device);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取时钟频率</span></span><br><span class="line">    HAL_RCC_GetClockConfig(&amp;clkconfig, &amp;pFLatency);   </span><br><span class="line">    __HAL_RCC_TIM2_CLK_ENABLE();</span><br><span class="line">    uwTimclock = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_TIMG1);</span><br><span class="line">    <span class="comment">//dprintf(&quot; uwTimclock = %d\r\n&quot;,uwTimclock);</span></span><br><span class="line">	<span class="comment">//配置TIM的计数频率为10MHZ</span></span><br><span class="line">    sp-&gt;htim.Init.Prescaler = (<span class="type">uint32_t</span>) ((uwTimclock / <span class="number">10000000U</span>) - <span class="number">1U</span>);    </span><br><span class="line">    sp-&gt;htim.Init.CounterMode = TIM_COUNTERMODE_UP;</span><br><span class="line">    sp-&gt;htim.Init.ClockDivision = <span class="number">0U</span>;</span><br><span class="line">    sp-&gt;htim.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;</span><br><span class="line">    sp-&gt;sConfig.OCMode = TIM_OCMODE_PWM1;</span><br><span class="line">    sp-&gt;sConfig.OCFastMode = TIM_OCFAST_DISABLE;</span><br><span class="line"></span><br><span class="line">    sp-&gt;dev.method = &amp;g_pwmOps;</span><br><span class="line">    sp-&gt;dev.cfg.duty = sp-&gt;sConfig.Pulse;  </span><br><span class="line">    sp-&gt;dev.cfg.period = sp-&gt;htim.Init.Period;    </span><br><span class="line">    sp-&gt;dev.cfg.polarity = sp-&gt;sConfig.OCPolarity;    </span><br><span class="line">    sp-&gt;dev.cfg.status = PWM_ENABLE_STATUS;</span><br><span class="line">    sp-&gt;dev.cfg.number = <span class="number">10000</span>; </span><br><span class="line"></span><br><span class="line">    sp-&gt;dev.busy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加到核心层</span></span><br><span class="line">    <span class="keyword">if</span> (PwmDeviceAdd(device, &amp;(sp-&gt;dev)) != HDF_SUCCESS) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//对TIM2寄存器基地址进行映射</span></span><br><span class="line">    sp-&gt;htim.Instance = (TIM_TypeDef *)OsalIoRemap(sp-&gt;physics_register, sp-&gt;register_size);</span><br><span class="line">    <span class="keyword">if</span> (sp-&gt;htim.Instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dprintf(<span class="string">&quot;error OsalIoRemap for htim \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化PWM寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_TIM_PWM_Init(&amp;sp-&gt;htim) == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        dprintf(<span class="string">&quot;pwm init ok config channel \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HAL_TIM_PWM_ConfigChannel(&amp;sp-&gt;htim, &amp;sp-&gt;sConfig, sp-&gt;channel);</span><br><span class="line">		<span class="comment">//初始化gpio</span></span><br><span class="line">        HAL_TIM_MspPostInit(&amp;sp-&gt;htim);</span><br><span class="line">        <span class="comment">//开始输出PWM</span></span><br><span class="line">        HAL_TIM_PWM_Start(&amp;sp-&gt;htim,sp-&gt;channel);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取上诉配置文件到StmPwm对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取配置文件   pa5 tim2 channel 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readHcs</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    dprintf(<span class="string">&quot;%s enter\r\n&quot;</span>,__func__);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DeviceResourceIface</span> *<span class="title">iface</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    iface = DeviceResourceGetIfaceInstance(HDF_CONFIG_SOURCE);</span><br><span class="line">    <span class="keyword">if</span> (iface == <span class="literal">NULL</span> || iface-&gt;GetUint32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: face is invalid&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;Period&quot;</span>, &amp;sp-&gt;htim.Init.Period, <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;Pulse&quot;</span>, &amp;sp-&gt;sConfig.Pulse, <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;physics_register&quot;</span>, &amp;sp-&gt;physics_register, <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;register_size&quot;</span>, &amp;sp-&gt;register_size, <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;channel&quot;</span>, &amp;sp-&gt;channel, <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;Polarity&quot;</span>, &amp;sp-&gt;sConfig.OCPolarity , <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;IdleState&quot;</span>, &amp;sp-&gt;sConfig.OCIdleState , <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;GetUint32(obj-&gt;property, <span class="string">&quot;IdleState&quot;</span>, &amp;sp-&gt;dev.num , <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read num fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>GPIOA_5 复用为PWM模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化gpio口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_MspPostInit</span><span class="params">(TIM_HandleTypeDef* htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    dprintf(<span class="string">&quot;%s enter\r\n&quot;</span>,__func__);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//gpioa addr</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *gpioa= (<span class="type">unsigned</span> <span class="type">char</span> *)OsalIoRemap(GPIOA_PHYADDR, GPIOA_SIZE);</span><br><span class="line">    <span class="comment">/**TIM2 GPIO Configuration    </span></span><br><span class="line"><span class="comment">    PA5     ------&gt; TIM2_CH1 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_5;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;</span><br><span class="line">    HAL_GPIO_Init((GPIO_TypeDef *)gpioa, &amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到此初始化任务就基本完成，那么HDF PWM框架如何来使用我们的PWM驱动呢？这就要提到 PwmMethod，通过设置PwmMethod的函数，提供接口给PWM框架，主要是提供StmPwmSetConfig。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PwmMethod</span> <span class="title">g_pwmOps</span> =</span> &#123;</span><br><span class="line">    .setConfig = StmPwmSetConfig,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>HDF_PWM框架是通过pwm_if.h文件给内核提供PWM功能的，我们来看pwm_if.h给内核提供了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取pwm句柄</span></span><br><span class="line">DevHandle <span class="title function_">PwmOpen</span><span class="params">(<span class="type">uint32_t</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PwmClose</span><span class="params">(DevHandle handle)</span>;</span><br><span class="line"><span class="comment">//设置pwm周期</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmSetPeriod</span><span class="params">(DevHandle handle, <span class="type">uint32_t</span> period)</span>;</span><br><span class="line"><span class="comment">//设置占空比</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmSetDuty</span><span class="params">(DevHandle handle, <span class="type">uint32_t</span> duty)</span>;</span><br><span class="line"><span class="comment">//设置极性</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmSetPolarity</span><span class="params">(DevHandle handle, <span class="type">uint8_t</span> polarity)</span>;</span><br><span class="line"><span class="comment">//使能pwm</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmEnable</span><span class="params">(DevHandle handle)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmDisable</span><span class="params">(DevHandle handle)</span>;</span><br><span class="line"><span class="comment">//设置pwm</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmSetConfig</span><span class="params">(DevHandle handle, <span class="keyword">struct</span> PwmConfig *config)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmGetConfig</span><span class="params">(DevHandle handle, <span class="keyword">struct</span> PwmConfig *config)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到PWM框架提供给内核设置PWM参数的接口，这些接口最终会调用我们编写的驱动，那么我们的驱动应该如何实现上述的功能？答案就在:StmPwmSetConfig，所有的接口最终都会调用PwmSetConfig()而间接调用我们编写的StmPwmSetConfig()。</p>
<p>在StmPwmSetConfig()中会对config参数进行检查，然后根据config参数去操作PWM外设，具体而言就是调用HAL库的PWM函数去实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给pwm框架注册的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PwmMethod</span> <span class="title">g_pwmOps</span> =</span> &#123;</span><br><span class="line">    .setConfig = StmPwmSetConfig,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设置pwm</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">StmPwmSetConfig</span><span class="params">(<span class="keyword">struct</span> PwmDev *pwm, <span class="keyword">struct</span> PwmConfig *config)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwm-&gt;cfg.polarity != config-&gt;polarity ) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: not support set pwm polarity&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_NOT_SUPPORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;status == PWM_DISABLE_STATUS) &#123;</span><br><span class="line"></span><br><span class="line">        StmPwmDisable();</span><br><span class="line">        <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;polarity != PWM_NORMAL_POLARITY &amp;&amp; config-&gt;polarity != PWM_INVERTED_POLARITY) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: polarity %u is invalid&quot;</span>, __func__, config-&gt;polarity);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;period &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: period %u is not support, min period %u&quot;</span>, __func__, config-&gt;period, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;duty &lt; <span class="number">1</span> || config-&gt;duty &gt; config-&gt;period) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: duty %u is not support, min dutyCycle 1 max dutyCycle %u&quot;</span>,</span><br><span class="line">            __func__, config-&gt;duty, config-&gt;period);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂停pwm，更新配置</span></span><br><span class="line">    StmPwmDisable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwm-&gt;cfg.polarity != config-&gt;polarity) &#123;</span><br><span class="line">        StmPwmSetPolarity( config-&gt;polarity);</span><br><span class="line">    &#125;</span><br><span class="line">    StmPwmSetPeriod( config-&gt;period);</span><br><span class="line">    StmPwmSetDuty( config-&gt;duty);</span><br><span class="line">    <span class="comment">//继续输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;number == <span class="number">0</span>) &#123;</span><br><span class="line">        StmPwmAlwaysOutput();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        StmPwmOutputNumberSquareWaves( config-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HAL库实现配置PWM的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">StmPwmDisable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Stop(&amp;sp-&gt;htim, sp-&gt;channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">StmPwmSetPeriod</span><span class="params">(<span class="type">uint32_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;htim.Init.Period = us;</span><br><span class="line">    TIM_Base_SetConfig(sp-&gt;htim.Instance, &amp;sp-&gt;htim.Init);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">StmPwmSetDuty</span><span class="params">(<span class="type">uint32_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;sConfig.Pulse = us;</span><br><span class="line">    HAL_TIM_PWM_ConfigChannel(&amp;sp-&gt;htim, &amp;sp-&gt;sConfig, sp-&gt;channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">StmPwmSetPolarity</span><span class="params">(<span class="type">uint32_t</span> polarity)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;sConfig.OCPolarity = polarity;</span><br><span class="line">    HAL_TIM_PWM_ConfigChannel(&amp;sp-&gt;htim, &amp;sp-&gt;sConfig, sp-&gt;channel);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">StmPwmAlwaysOutput</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;sp-&gt;htim, sp-&gt;channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">StmPwmOutputNumberSquareWaves</span><span class="params">(<span class="type">uint32_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;sp-&gt;htim, sp-&gt;channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、编写构建脚本"><a href="#3、编写构建脚本" class="headerlink" title="3、编写构建脚本"></a>3、编写构建脚本</h4><p>最后要将我们编写好的驱动文件加入到编译构建系统中：</p>
<p>编辑BUILD.gn：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;//drivers/adapter/khdf/liteos/hdf.gni&quot;</span>)</span><br><span class="line">module_switch = defined(LOSCFG_DRIVERS_HDF_PLATFORM_PWM)</span><br><span class="line">hdf_driver(<span class="string">&quot;hdf_pwm&quot;</span>) &#123;</span><br><span class="line">    sources = [</span><br><span class="line">    <span class="string">&quot;stm32mp1_pwm.c&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    include_dirs = [</span><br><span class="line">     <span class="string">&quot;.&quot;</span> ,</span><br><span class="line">     <span class="string">&quot;//device/st/drivers/stm32mp1xx_hal/STM32MP1xx_HAL_Driver/Inc&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并修改device&#x2F;st&#x2F;drivers&#x2F;BUILD.gn，在dep添加pwm：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">group(<span class="string">&quot;drivers&quot;</span>) &#123;</span><br><span class="line">  deps = [</span><br><span class="line">    <span class="string">&quot;pwm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uart&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iwdg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gpio&quot;</span>,</span><br><span class="line">    <span class="string">&quot;led&quot;</span>,</span><br><span class="line">    <span class="string">&quot;button&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sample&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mem&quot;</span>,</span><br><span class="line">    <span class="string">&quot;stm32mp1xx_hal&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wifi/driver/hi3881&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wifi/driver:hdf_vendor_wifi&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、效果"><a href="#4、效果" class="headerlink" title="4、效果"></a>4、效果</h3><p>完成PWM驱动的编写后，就可以使用<code>bearpi-micro\drivers\framework\include\platform\pwm_if.h</code>里的函数来控制PWM波。如图是使用逻辑分析测量到的GPIOA_5引脚上的PWM信号：</p>
<p>计数频率10MHZ，计数值1000，那么PWM的频率就是10MHZ&#x2F;1000&#x3D;10KHZ：</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/bearpi_pwm_driver/image-20220328211723596.png" alt="image-20220328211723596"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/bearpi_pwm_driver/" data-id="cmbcy7rho002lt8mthzug5x7t" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/dsoftbus_sdk" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/dsoftbus_sdk/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.645Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dsoftbus-sdk"><a href="#dsoftbus-sdk" class="headerlink" title="dsoftbus sdk"></a>dsoftbus sdk</h2><p>架构图</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/dsoftbus_sdk/dsoftbus-architecture_zh.png" alt="dsoftbus-architecture_zh"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/foundation/communication/dsoftbus</span><br><span class="line">├── interfaces            # 接口代码</span><br><span class="line">├── adapter               # 适配层代码</span><br><span class="line">├── core                  # 核心代码</span><br><span class="line">├── sdk                   # 运行业务进程代码</span><br><span class="line">└── components            # 依赖组件代码</span><br></pre></td></tr></table></figure>

<p>组网之前，需先完成设备绑定，绑定流程参见安全子系统中说明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过发布服务，来使手机能发现本设备</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PublishService</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> PublishInfo *info, <span class="type">const</span> IPublishCallback *cb)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发现其他设备的服务</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StartDiscovery</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> SubscribeInfo *info, <span class="type">const</span> IDiscoveryCallback *cb)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>从PublishService入手，来看软总线的实现。在interface目录下，有许多头文件，声明了许多函数给用户使用，例如int PublishService(const char *pkgName, const PublishInfo *info, const IPublishCallback *cb)；</p>
<p>这一部分内容涉及到IPC、服务管理者samgr，在下面可以看到，主要的代码是集中在InitSoftBus，而无论发布服务还是发现动作，都是基于IPC调用来完成，所以必须深入理解IPC。</p>
<p>该函数的定义在sdk目录下，该目录下的代码都是以进程的身份在运行，InitSoftBus函数的调用流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">InitSoftBus</span><br><span class="line">    AddClientPkgName	<span class="comment">//创建PkgNameInfo，并添加到g_pkgNameList</span></span><br><span class="line">    SoftBusTimerInit    <span class="comment">//创建定时器回调HandleTimeoutFun,负责执行g_timerFunList函数数组</span></span><br><span class="line">    ClientModuleInit    <span class="comment">//初始变量：g_configItems、g_observerList、g_busCenterClient</span></span><br><span class="line">        SoftbusConfigInit    <span class="comment">//设置g_configItems</span></span><br><span class="line">        EventClientInit      <span class="comment">//CreateSoftBusList创建一个g_observerList</span></span><br><span class="line">        BusCenterClientInit</span><br><span class="line">            SoftbusGetConfig    <span class="comment">//获取g_configItems[]成员</span></span><br><span class="line">            ListInit()          <span class="comment">//初始化g_busCenterClient的：joinLNNCbList、leaveLNNCbList、nodeStateCbList、timeSyncCbList</span></span><br><span class="line">            BusCenterServerProxyInit    <span class="comment">//通过某种方法请求g_serverProxy，该方法的获取时间是无法确定的，可能是需要远程回答</span></span><br><span class="line">                iUnknown = SAMGR_GetInstance()-&gt;GetDefaultFeatureApi(SOFTBUS_SERVICE);</span><br><span class="line">                <span class="keyword">if</span> (iUnknown == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    SoftBusSleepMs(WAIT_SERVER_READY_INTERVAL);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                iUnknown-&gt;QueryInterface(iUnknown, CLIENT_PROXY_VER, (<span class="type">void</span> **)&amp;g_serverProxy);</span><br><span class="line">        DiscClientInit    <span class="comment">//创建g_discInfo</span></span><br><span class="line">            DiscServerProxyInit    <span class="comment">//代码与BusCenterServerProxyInit一样</span></span><br><span class="line">        TransClientInit    </span><br><span class="line">            g_clientSessionServerList = CreateSoftBusList()    </span><br><span class="line">            TransServerProxyInit	 <span class="comment">//代码与BusCenterServerProxyInit一样</span></span><br><span class="line">            ClientTransChannelInit    <span class="comment">//设置传输通道回调函数</span></span><br><span class="line">                cb = GetClientSessionCb();    <span class="comment">//获取g_sessionCb，定义在client_trans_session_callback.c</span></span><br><span class="line">                TransTdcManagerInit(cb)</span><br><span class="line">                    g_tcpDirectChannelInfoList = CreateSoftBusList();</span><br><span class="line">                    ClientTransTdcSetCallBack(cb)    <span class="comment">//g_sessionCb = cb</span></span><br><span class="line">                    PendingInit(PENDING_TYPE_DIRECT)    <span class="comment">//g_pendingList[type] = CreateSoftBusList()</span></span><br><span class="line">                ClientTransAuthInit(cb)    <span class="comment">//g_sessionCb = *cb;</span></span><br><span class="line">                ClinetTransProxyInit(cb)</span><br><span class="line">                    g_sessionCb = *cb;</span><br><span class="line">                    RegisterTimeoutCallback(SENDFILE_TIMER_FUN,ProxyFileTransTimerProc)    <span class="comment">//g_timerFunList[timerFunId] = callback;</span></span><br><span class="line">                ClientTransUdpMgrInit(cb)    </span><br><span class="line">                    g_sessionCb = cb;</span><br><span class="line">                    g_udpChannelMgrCb = g_udpChannelCb;</span><br><span class="line">                    g_fileListener = CreateSoftBusList();</span><br><span class="line">                    g_udpChannelMgrCb = g_udpChannelCb;</span><br><span class="line">                    g_udpChannelMgr = CreateSoftBusList();    </span><br><span class="line">            ClientTransRegLnnOffline    <span class="comment">//设置组网回调函数</span></span><br><span class="line">                RegNodeDeviceStateCbInner(<span class="string">&quot;trans&quot;</span>, &amp;g_transLnnCb);    <span class="comment">//创建NodeStateCallbackItem，并将g_transLnnCb赋值给item</span></span><br><span class="line">    ClientStubInit</span><br><span class="line">        ServerProxyInit</span><br><span class="line">            HOS_SystemInit    <span class="comment">//SAMGR_Bootstrap</span></span><br><span class="line">            g_serverProxy = GetServerProxy();</span><br><span class="line">        RegisterIpcCallback(ClientIpcInterfaceMsgHandle, <span class="number">0</span>, IPC_WAIT_FOREVER, &amp;clientIdentity, <span class="literal">NULL</span>);</span><br><span class="line">        ClientContextInit    <span class="comment">//创建g_clientCtx</span></span><br><span class="line">        SetClientIdentity(clientIdentity.handle, clientIdentity.token, clientIdentity.cookie, clientIdentity.ipcContext);   <span class="comment">//设置g_clientCtx</span></span><br><span class="line">        RegisterServerDeathCb   </span><br><span class="line">    ClientRegisterService</span><br><span class="line">        GetClientIdentity</span><br><span class="line">        RegisterService</span><br><span class="line">            IpcIoInit</span><br><span class="line">            IpcIoPushString</span><br><span class="line">            IpcIoPushSvc</span><br><span class="line">            g_serverProxy-&gt;Invoke</span><br><span class="line">    </span><br><span class="line">PublishServiceInner</span><br><span class="line">    ServerIpcPublishService</span><br><span class="line">        IpcIoInit</span><br><span class="line">        IpcIoPushString</span><br><span class="line">        IpcIoPushFlatObj</span><br><span class="line">        IpcIoPushString</span><br><span class="line">        g_serverProxy-&gt;Invoke</span><br></pre></td></tr></table></figure>

<p>看看StartDiscovery有什么调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitSoftBus</span><br><span class="line"><span class="title function_">StartDiscoveryInner</span><span class="params">(packageName, info, cb)</span>;</span><br><span class="line">    g_discInfo-&gt;subscribeCb = *cb;</span><br><span class="line">    ServerIpcStartDiscovery</span><br><span class="line">        <span class="title function_">IpcIoInit</span><span class="params">(&amp;request, data, MAX_SOFT_BUS_IPC_LEN, <span class="number">0</span>)</span>;</span><br><span class="line">        IpcIoPushString(&amp;request, pkgName);</span><br><span class="line">        IpcIoPushFlatObj(&amp;request, (<span class="type">void</span>*)&amp;subscribeSerializer, <span class="keyword">sizeof</span>(SubscribeSerializer));</span><br><span class="line">        g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_START_DISCOVERY, &amp;request, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="IPC的使用"><a href="#IPC的使用" class="headerlink" title="IPC的使用"></a>IPC的使用</h3><p>以ipc_lite为例吧，正好是使用小型系统,似乎是提供了一个类似于栈的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* bufferBase;</span><br><span class="line">    <span class="type">size_t</span>* offsetsBase;</span><br><span class="line">    <span class="type">char</span>* bufferCur;</span><br><span class="line">    <span class="type">size_t</span>* offsetsCur;</span><br><span class="line">    <span class="type">size_t</span> bufferLeft;</span><br><span class="line">    <span class="type">size_t</span> offsetsLeft;</span><br><span class="line">    <span class="type">uint32_t</span> flag;</span><br><span class="line">    NDK_DL_LIST ptrFreeList;</span><br><span class="line">&#125; IpcIo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate a IpcIo, providing a stack-allocated working</span></span><br><span class="line"><span class="comment"> * buffer, size of the working buffer, and how many object</span></span><br><span class="line"><span class="comment"> * offset entries to reserve from the buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoInit</span><span class="params">(IpcIo* io, <span class="type">void</span>* data, <span class="type">size_t</span> maxdata, <span class="type">size_t</span> maxobjects)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoInitFromMsg</span><span class="params">(IpcIo* io, <span class="type">const</span> <span class="type">void</span>* msg)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IpcIoAvailable</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="comment">/* Must ensure all the input is valid */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushChar</span><span class="params">(IpcIo* io, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushCharUnaligned</span><span class="params">(IpcIo* io, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushBool</span><span class="params">(IpcIo* io, <span class="type">bool</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushBoolUnaligned</span><span class="params">(IpcIo* io, <span class="type">bool</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushIntptr</span><span class="params">(IpcIo* io, <span class="type">intptr_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUintptr</span><span class="params">(IpcIo* io, <span class="type">uintptr_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt8</span><span class="params">(IpcIo* io, <span class="type">int8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt8Unaligned</span><span class="params">(IpcIo* io, <span class="type">int8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint8</span><span class="params">(IpcIo* io, <span class="type">uint8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint8Unaligned</span><span class="params">(IpcIo* io, <span class="type">uint8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt16</span><span class="params">(IpcIo* io, <span class="type">int16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt16Unaligned</span><span class="params">(IpcIo* io, <span class="type">int16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint16</span><span class="params">(IpcIo* io, <span class="type">uint16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint16Unaligned</span><span class="params">(IpcIo* io, <span class="type">uint16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt32</span><span class="params">(IpcIo* io, <span class="type">int32_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint32</span><span class="params">(IpcIo* io, <span class="type">uint32_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt64</span><span class="params">(IpcIo* io, <span class="type">int64_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint64</span><span class="params">(IpcIo* io, <span class="type">uint64_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushFloat</span><span class="params">(IpcIo* io, <span class="type">float</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushDouble</span><span class="params">(IpcIo* io, <span class="type">double</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushString</span><span class="params">(IpcIo* io, <span class="type">const</span> <span class="type">char</span>* cstr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushFlatObj</span><span class="params">(IpcIo* io, <span class="type">const</span> <span class="type">void</span>* obj, <span class="type">uint32_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushSvc</span><span class="params">(IpcIo* io, <span class="type">const</span> SvcIdentity* svc)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushFd</span><span class="params">(IpcIo* io, <span class="type">uint32_t</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushDataBuff</span><span class="params">(IpcIo* io, <span class="type">const</span> BuffPtr* dataBuff)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushDataBuffWithFree</span><span class="params">(IpcIo* io, <span class="type">const</span> BuffPtr* dataBuff, IpcIoPtrFree ipcIoFree)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoFreeDataBuff</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">IpcIoPopChar</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">IpcIoPopCharUnaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IpcIoPopBool</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IpcIoPopBoolUnaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">intptr_t</span> <span class="title function_">IpcIoPopIntptr</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uintptr_t</span> <span class="title function_">IpcIoPopUintptr</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">IpcIoPopInt8</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">IpcIoPopInt8Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">IpcIoPopUint8</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">IpcIoPopUint8Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">IpcIoPopInt16</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">IpcIoPopInt16Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">IpcIoPopUint16</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">IpcIoPopUint16Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">IpcIoPopInt32</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IpcIoPopUint32</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">IpcIoPopInt64</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">IpcIoPopUint64</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">IpcIoPopFloat</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">IpcIoPopDouble</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint8_t</span>* <span class="title function_">IpcIoPopString</span><span class="params">(IpcIo* io, <span class="type">size_t</span>* sz)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">IpcIoPopFlatObj</span><span class="params">(IpcIo* io, <span class="type">uint32_t</span>* size)</span>;</span><br><span class="line">SvcIdentity* <span class="title function_">IpcIoPopSvc</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">IpcIoPopFd</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line">BuffPtr* <span class="title function_">IpcIoPopDataBuff</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上都好理解，往栈里填充数据后。要如何处理，在以上发现：IClientProxy static IClientProxy *g_serverProxy;这个对象,应该就是通过这个proxy来给服务端发送请求的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_START_DISCOVERY, &amp;request, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>IClientProxy的获取方式很容易看出来就是：通过samgr获取SOFTBUS_SERVICE，和官网的说明是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iUnknown = SAMGR_GetInstance()-&gt;GetDefaultFeatureApi(SOFTBUS_SERVICE);</span><br><span class="line"><span class="keyword">if</span> (iUnknown == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    SoftBusSleepMs(WAIT_SERVER_READY_INTERVAL);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">iUnknown-&gt;QueryInterface(iUnknown, CLIENT_PROXY_VER, (<span class="type">void</span> **)&amp;g_serverProxy);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好家伙，终于找到你的定义了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Defines the client proxy object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This object is used for the IPC with the server. \n</span></span><br><span class="line"><span class="comment"> * If you want to use the same invocation mode as that on the server, create an object inherited</span></span><br><span class="line"><span class="comment"> * from &#123;@code IClientProxy&#125; and implement serialization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 1.0</span></span><br><span class="line"><span class="comment"> * @version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IClientProxy</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Inherites the &lt;b&gt;IUnknown&lt;/b&gt; base class. */</span></span><br><span class="line">    INHERIT_IUNKNOWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Sends an IPC message from the client to the &lt;b&gt;IServerProxy&lt;/b&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This function is used for IPC. \n</span></span><br><span class="line"><span class="comment">     * The passed &lt;b&gt;proxy&lt;/b&gt; is used to obtain the server information. Then, &lt;b&gt;request&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * carries the request message to be sent to the server and processed by the function specified</span></span><br><span class="line"><span class="comment">     * by &lt;b&gt;funcId&lt;/b&gt;. &lt;b&gt;notify&lt;/b&gt; is a callback function used to process the response message. \n</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param proxy Indicates the pointer of the client proxy object.</span></span><br><span class="line"><span class="comment">     * @param funcId Indicates the ID of the function implemented on the server.</span></span><br><span class="line"><span class="comment">     * @param request Indicates the pointer to the serialized request message.</span></span><br><span class="line"><span class="comment">     * @param owner Indicates the receiver (generics type) of the response message.</span></span><br><span class="line"><span class="comment">     * @param notify Indicates the callback function that notifies the client of the response</span></span><br><span class="line"><span class="comment">     * message.</span></span><br><span class="line"><span class="comment">     * @return Returns &lt;b&gt;EC_SUCCESS&lt;/b&gt; if the IPC message is sent successfully; returns other</span></span><br><span class="line"><span class="comment">     * error codes if the message fails to be sent.</span></span><br><span class="line"><span class="comment">     * @since 1.0</span></span><br><span class="line"><span class="comment">     * @version 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*Invoke)(IClientProxy *proxy, <span class="type">int</span> funcId, IpcIo *request, IOwner owner, INotify notify);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我猜测一下，IPC为了实现进程间的函数调用，需要模仿进程内的函数调用，而函数调用会使用到栈，所以IpcIoInit()得到的是一个特俗的栈，这个栈可以跨进程使用，在栈中填入参数，调用IClientProxy()就是类似<br>于函数调用，那么同理，返回值也是跟着栈一起返回，那么进程间如何同步呢？</p>
<p>所以可以猜测 <code>g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_START_DISCOVERY, &amp;request, NULL, NULL);</code></p>
<p>就是调用服务，执行start函数，函数的参数在request，不需要返回值。</p>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>大胆地猜测，sdk目录下的实现应该都不是很复杂，都是通过IPC去调用服务</p>
<p>以OpenSession为例,这次设置了回调函数，在函数里保存了返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClientAddSession</span><br><span class="line">    CreateNewSession</span><br><span class="line">    AddSession</span><br><span class="line">ServerIpcOpenSession</span><br><span class="line">    IpcIoInit</span><br><span class="line">    IpcIoPushString</span><br><span class="line">    g_serverProxy-&gt;Invoke</span><br><span class="line">ClientSetChannelBySessionId</span><br></pre></td></tr></table></figure>


<h3 id="组网"><a href="#组网" class="headerlink" title="组网"></a>组网</h3><p>必须用JoinLNN来分析分析，果然也是使用ipc调用服务端。所以接下来我们将重点分析服务的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">JoinLNN</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, ConnectionAddr *target, OnJoinLNNResult cb)</span>;</span><br><span class="line"></span><br><span class="line">CommonInit</span><br><span class="line"><span class="title function_">JoinLNNInner</span><span class="params">(cb)</span></span><br><span class="line">    <span class="title function_">FindJoinLNNCbItem</span><span class="params">(target, cb)</span></span><br><span class="line">    <span class="title function_">ServerIpcJoinLNN</span><span class="params">(pkgName, target, <span class="keyword">sizeof</span>(*target))</span>;</span><br><span class="line">        IpcIoInit</span><br><span class="line">        IpcIoInit</span><br><span class="line">        g_serverProxy-&gt;Invoke</span><br><span class="line">    <span class="title function_">AddJoinLNNCbItem</span><span class="params">(target, cb)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/dsoftbus_sdk/" data-id="cmbcy7rho002ot8mtgurc4ivz" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/Input_framework_key_base_on_micro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/Input_framework_key_base_on_micro/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.644Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本文介绍如何使用OpenHarmony的Input框架模型，并编写app，在按键事件处理中翻转led灯。</p>
<p>[video(video-sWqlYRUn-1645264627527)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=894148373)(image-https://img-blog.csdnimg.cn/img_convert/555e2b8780fd0b3a68993cee255ddd0f.png)">https://player.bilibili.com/player.html?aid=894148373)(image-https://img-blog.csdnimg.cn/img_convert/555e2b8780fd0b3a68993cee255ddd0f.png)</a>(title-小熊派micro 按键翻转led灯)]</p>
<p>本文目的在于通过学习input框架模型，对openharmony的驱动系统有一个大体的理解。通过本文的学习，应该能够理解如图的驱动框架：<br><img src="/2025/05/30/hello-world/OpenHarmony/Input_framework_key_base_on_micro/ff017c00a13649578cd493c8d032a2e0.png" alt="在这里插入图片描述"></p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>硬件：小熊派micro</p>
<h3 id="KEY驱动程序"><a href="#KEY驱动程序" class="headerlink" title="KEY驱动程序"></a>KEY驱动程序</h3><p>在openharmony中已经完成了key驱动程序的编写。源码在：&#x2F;drivers&#x2F;framework&#x2F;model&#x2F;input&#x2F;driver&#x2F;hdf_key.c，我们需要做的就是在配置文件中增加key节点的配置信息，key驱动程序就能成功加载。</p>
<p>首先看key驱动程序源码，key驱动使用到gpio的接口，了解该部分内容可查看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/122746672">OpenHarmony HDF 按键中断开发基于小熊派hm micro</a></p>
<p>驱动程序入口对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfDriverEntry</span> <span class="title">g_hdfKeyEntry</span> =</span> &#123;</span><br><span class="line">    .moduleVersion = <span class="number">1</span>,</span><br><span class="line">    .moduleName = <span class="string">&quot;HDF_KEY&quot;</span>,</span><br><span class="line">    .Bind = HdfKeyDriverBind,</span><br><span class="line">    .Init = HdfKeyDriverInit,</span><br><span class="line">    .Release = HdfKeyDriverDeInit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HDF_INIT(g_hdfKeyEntry);</span><br></pre></td></tr></table></figure>



<p>主要起作用的是Init函数：其分为两部分，首先根据配置文件读取key的IO管脚、中断模式等信息，然后根据配置初始化gpio，注册中断函数，并注册一个代表key的input_device到input_device_manager。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">HdfKeyDriverInit</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//根据input_config.hcs创建keyCfg</span></span><br><span class="line">    KeyChipCfg *keyCfg = KeyConfigInstance(device);</span><br><span class="line">    <span class="keyword">if</span> (keyCfg == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: instance key config failed&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_MALLOC_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建inputdev，注册到input_manager</span></span><br><span class="line">    <span class="type">int32_t</span> ret = RegisterKeyDevice(keyCfg);</span><br><span class="line">    <span class="keyword">if</span> (ret != HDF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KeyConfigInstance："><a href="#KeyConfigInstance：" class="headerlink" title="KeyConfigInstance："></a>KeyConfigInstance：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建keycfg对象</span></span><br><span class="line"><span class="type">static</span> KeyChipCfg *<span class="title function_">KeyConfigInstance</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyChipCfg *keyCfg = (KeyChipCfg *)OsalMemAlloc(<span class="keyword">sizeof</span>(KeyChipCfg));</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)memset_s(keyCfg, <span class="keyword">sizeof</span>(KeyChipCfg), <span class="number">0</span>, <span class="keyword">sizeof</span>(KeyChipCfg));</span><br><span class="line">    keyCfg-&gt;hdfKeyDev = device; <span class="comment">//保存按键设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取input_config.hcs中的按键配置信息到keycfg</span></span><br><span class="line">    <span class="keyword">if</span> (ParseKeyConfig(device-&gt;property, keyCfg) != HDF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: parse key config failed&quot;</span>, __func__);</span><br><span class="line">        OsalMemFree(keyCfg);</span><br><span class="line">        keyCfg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyCfg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ParseKeyConfig:解析deviceNode的信息，我们需要根据这个函数来编写key的配置信息。见下文</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">ParseKeyConfig</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> DeviceResourceNode *node, KeyChipCfg *config)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DeviceResourceIface</span> *<span class="title">parser</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    parser = DeviceResourceGetIfaceInstance(HDF_CONFIG_SOURCE);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceResourceNode</span> *<span class="title">keyNode</span> =</span> node;</span><br><span class="line">    <span class="type">int32_t</span> ret = parser-&gt;GetString(keyNode, <span class="string">&quot;keyName&quot;</span>, &amp;config-&gt;keyName, <span class="literal">NULL</span>);</span><br><span class="line">    CHECK_PARSER_RET(ret, <span class="string">&quot;GetString&quot;</span>);</span><br><span class="line">    ret = parser-&gt;GetUint8(keyNode, <span class="string">&quot;inputType&quot;</span>, &amp;config-&gt;devType, <span class="number">0</span>);</span><br><span class="line">    CHECK_PARSER_RET(ret, <span class="string">&quot;GetUint8&quot;</span>);</span><br><span class="line">    ret = parser-&gt;GetUint16(keyNode, <span class="string">&quot;gpioNum&quot;</span>, &amp;config-&gt;gpioNum, <span class="number">0</span>);</span><br><span class="line">    CHECK_PARSER_RET(ret, <span class="string">&quot;GetUint32&quot;</span>);</span><br><span class="line">    ret = parser-&gt;GetUint16(keyNode, <span class="string">&quot;irqFlag&quot;</span>, &amp;config-&gt;irqFlag, <span class="number">0</span>);</span><br><span class="line">    CHECK_PARSER_RET(ret, <span class="string">&quot;GetUint8&quot;</span>);</span><br><span class="line">    ret = parser-&gt;GetUint32(keyNode, <span class="string">&quot;debounceTime&quot;</span>, &amp;config-&gt;debounceTime, <span class="number">0</span>); <span class="comment">//好像没使用到</span></span><br><span class="line">    CHECK_PARSER_RET(ret, <span class="string">&quot;GetUint32&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RegisterKeyDevice"><a href="#RegisterKeyDevice" class="headerlink" title="RegisterKeyDevice"></a>RegisterKeyDevice</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建inputDevice并注册到manager</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">RegisterKeyDevice</span><span class="params">(KeyChipCfg *keyCfg)</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyDriver *keyDrv = KeyDriverInstance(keyCfg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化按键中断</span></span><br><span class="line">    <span class="type">int32_t</span> ret = KeyInit(keyDrv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建inputDevice</span></span><br><span class="line">    InputDevice *inputDev = InputDeviceInstance(keyDrv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册输入设备到input_device_manager(使用hdf_input_device_manager.h提供的接口)</span></span><br><span class="line">    ret = RegisterInputDevice(inputDev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>KeyInit就是调用：SetupKeyIrq 设置key中断处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化按键中断(使用gpio_if.h提供的gpio操作方法)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">SetupKeyIrq</span><span class="params">(KeyDriver *keyDrv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> intGpioNum = keyDrv-&gt;keyCfg-&gt;gpioNum;</span><br><span class="line">    <span class="comment">//irqFlag定义参考osal_irq.h</span></span><br><span class="line">    <span class="type">uint16_t</span> irqFlag = keyDrv-&gt;keyCfg-&gt;irqFlag;</span><br><span class="line">    <span class="comment">//设置gpio为输入</span></span><br><span class="line">    <span class="type">int32_t</span> ret = GpioSetDir(intGpioNum, GPIO_DIR_IN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置gpio中断触发模式，中断线程处理模式，中断线程为KeyIrqHandle 参数为keyDrv</span></span><br><span class="line">    ret = GpioSetIrq(intGpioNum, irqFlag | GPIO_IRQ_USING_THREAD, KeyIrqHandle, keyDrv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能中断</span></span><br><span class="line">    ret = GpioEnableIrq(intGpioNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中断处理函数-KeyIrqHandle"><a href="#中断处理函数-KeyIrqHandle" class="headerlink" title="中断处理函数 KeyIrqHandle"></a>中断处理函数 KeyIrqHandle</h4><p>由于调用GpioSetIrq传入的参数是GPIO_IRQ_USING_THREAD，所以KeyIrqHandle是在线程环境中执行的。</p>
<p>在中断线程中，读取IO口电平，通过hdf的事件接口将当前的按键事件上报给应用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按键中断线程处理函数</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">KeyIrqHandle</span><span class="params">(<span class="type">uint16_t</span> intGpioNum, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> gpioValue = <span class="number">0</span>;</span><br><span class="line">    KeyDriver *driver = (KeyDriver *)data;</span><br><span class="line"></span><br><span class="line">    KeyEventData *event = &amp;driver-&gt;eventData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭中断</span></span><br><span class="line">    <span class="type">int32_t</span> ret = GpioDisableIrq(intGpioNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取按键GPIO的值</span></span><br><span class="line">    ret = GpioRead(intGpioNum, &amp;gpioValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前时间戳</span></span><br><span class="line">    <span class="type">uint64_t</span> curTime = OsalGetSysTimeMs();</span><br><span class="line">    <span class="comment">//保存时间戳</span></span><br><span class="line">    driver-&gt;preStatus = gpioValue;</span><br><span class="line">    driver-&gt;timeStamp = curTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gpioValue == GPIO_VAL_LOW)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;definedEvent = INPUT_KEY_DOWN;</span><br><span class="line">        <span class="comment">//上报key事件</span></span><br><span class="line">        input_report_key(driver-&gt;inputdev, KEY_POWER, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gpioValue == GPIO_VAL_HIGH)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;definedEvent = INPUT_KEY_UP;</span><br><span class="line">        input_report_key(driver-&gt;inputdev, KEY_POWER, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步事件（表示一个事件完成）</span></span><br><span class="line">    input_sync(driver-&gt;inputdev);</span><br><span class="line">	<span class="comment">//打开中断</span></span><br><span class="line">    GpioEnableIrq(intGpioNum);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断事件的上报流程如下：</p>
<blockquote>
<p>input_report_key -&gt;PushOnePackage -&gt; HdfDeviceSendEvent</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hdf_device_desc.h:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Sends event messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the driver service invokes this function to send a message, all user-level applications that have registered</span></span><br><span class="line"><span class="comment"> * listeners through &#123;@link HdfDeviceRegisterEventListener&#125; will receive the message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param deviceObject Indicates the pointer to the driver device object.</span></span><br><span class="line"><span class="comment"> * @param id Indicates the ID of the message sending event.</span></span><br><span class="line"><span class="comment"> * @param data Indicates the pointer to the message content sent by the driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Returns &lt;b&gt;0&lt;/b&gt; if the operation is successful; returns a non-zero value otherwise.</span></span><br><span class="line"><span class="comment"> * @since 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfDeviceSendEvent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> HdfDeviceObject *deviceObject, <span class="type">uint32_t</span> id, <span class="type">const</span> <span class="keyword">struct</span> HdfSBuf *data)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="RegisterInputDevice：注册key设备到文件系统"><a href="#RegisterInputDevice：注册key设备到文件系统" class="headerlink" title="RegisterInputDevice：注册key设备到文件系统"></a>RegisterInputDevice：注册key设备到文件系统</h4><p>类似于linux，把驱动程序加入到虚拟文件系统，提供接口给上层应用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册输入设备给输入设备管理器</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RegisterInputDevice</span><span class="params">(InputDevice *inputDev)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//获取信号量</span></span><br><span class="line">    OsalMutexLock(&amp;g_inputManager-&gt;mutex);</span><br><span class="line">    <span class="comment">//分配设备id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册到文件系统</span></span><br><span class="line">    ret = CreateDeviceNode(inputDev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请package的内存,用于上报数据</span></span><br><span class="line">    ret = AllocPackageBuffer(inputDev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加到inputdev链表</span></span><br><span class="line">    AddInputDevice(inputDev);</span><br><span class="line">    <span class="comment">//释放信号量</span></span><br><span class="line">    OsalMutexUnlock(&amp;g_inputManager-&gt;mutex);</span><br><span class="line">    HDF_LOGI(<span class="string">&quot;%s: exit succ, devCount is %d&quot;</span>, __func__, g_inputManager-&gt;devCount);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateDeviceNode就是调用HidRegisterHdfDevice：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册hdf设备到文件系统</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> HdfDeviceObject *<span class="title function_">HidRegisterHdfDevice</span><span class="params">(InputDevice *inputDev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> svcName[SERVICE_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *moduleName = <span class="string">&quot;HDF_HID&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfDeviceObject</span> *<span class="title">hdfDev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> len = (inputDev-&gt;devId &lt; PLACEHOLDER_LIMIT) ? <span class="number">1</span> : PLACEHOLDER_LENGTH;</span><br><span class="line">    <span class="comment">//组装字符串：hdf_input_event0,1,2....</span></span><br><span class="line">    <span class="type">int32_t</span> ret = snprintf_s(svcName, SERVICE_NAME_LEN, <span class="built_in">strlen</span>(<span class="string">&quot;hdf_input_event&quot;</span>) + len, <span class="string">&quot;%s%u&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hdf_input_event&quot;</span>, inputDev-&gt;devId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册到/dev目录</span></span><br><span class="line">    hdfDev = HdfRegisterDevice(moduleName, svcName, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hdfDev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小熊派使用key"><a href="#小熊派使用key" class="headerlink" title="小熊派使用key"></a>小熊派使用key</h4><p>根据小熊派的原理图，可知F1按键的管脚为PG2，对应的IO编号为: PG2 &#x3D; (6 * 16 + 3)-1 &#x3D; 98;</p>
<p>需要修改两个文件：</p>
<ul>
<li>bearpi-micro\device\st\bearpi_hm_micro\liteos_a\hdf_config\device_info\device_info.hcs</li>
<li>D:\VMware\share\bearpi-micro\device\st\bearpi_hm_micro\liteos_a\hdf_config\input\input_config.hcs</li>
</ul>
<p>在device_info.hcs中，在input节点下新增key节点，可仿照device_hdf_touch来创建，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root &#123;</span><br><span class="line">    device_info &#123;        </span><br><span class="line">        input :: host &#123;</span><br><span class="line">			<span class="comment">//按键</span></span><br><span class="line">            device_hdf_key :: device &#123;</span><br><span class="line">                device0 :: deviceNode &#123;</span><br><span class="line">                    policy = <span class="number">2</span>;</span><br><span class="line">                    priority = <span class="number">20</span>;</span><br><span class="line">                    preload = <span class="number">0</span>;</span><br><span class="line">                    permission = <span class="number">0660</span>;</span><br><span class="line">                    moduleName = <span class="string">&quot;HDF_KEY&quot;</span>;</span><br><span class="line">                    serviceName = <span class="string">&quot;hdf_input_event2&quot;</span>;	<span class="comment">//服务名称，HDI由此绑定驱动程序</span></span><br><span class="line">                    deviceMatchAttr = <span class="string">&quot;key_device1&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<p>在input_config.hcs下同样新增key节点如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root &#123;</span><br><span class="line">    input_config &#123;</span><br><span class="line">        keyConfig&#123;</span><br><span class="line">            key0&#123;</span><br><span class="line">                match_attr = <span class="string">&quot;key_device1&quot;</span>;</span><br><span class="line">                keyName = <span class="string">&quot;key0&quot;</span>;</span><br><span class="line">                inputType = <span class="number">1</span>;      <span class="comment">///* 0:touch 1:key 2:keyboard 3:mouse 4:button 5:crown 6:encoder */</span></span><br><span class="line">                gpioNum = <span class="number">98</span>;       <span class="comment">// PG2 = (6 * 16 + 3)-1 = 98; </span></span><br><span class="line">                irqFlag = <span class="number">2</span>;        <span class="comment">//下降沿触发 在osal_irq.h的定义</span></span><br><span class="line">                debounceTime = <span class="number">0</span>;   <span class="comment">//防抖时间 （不需要，有电容消抖）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="HDI驱动接口"><a href="#HDI驱动接口" class="headerlink" title="HDI驱动接口"></a>HDI驱动接口</h3><p>HDI调用了驱动在虚拟文件系统中的节点，再进行一个封装，提供给上层服务或用户。</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/Input_framework_key_base_on_micro/image-20220409093049710.png" alt="image-20220409093049710"></p>
<p>根据上图可知，InputHDI就是由三部分组成的。这三部分分别负责不同的功能。</p>
<ul>
<li>InputManager：管理输入设备，包括输入设备的打开、关闭、设备列表信息获取等；</li>
<li>InputReporter：负责输入事件的上报，包括注册、注销数据上报回调函数等；</li>
<li>InputController：提供input设备的业务控制接口，包括获取器件信息及设备类型、设置电源状态等。</li>
</ul>
<p>我们将精力放在manager以及reporter上，这两个是我们应用程序即将使用到的接口。我们用manager打开key设备，用reporter注册上报回调函数，再回调函数中翻转led。</p>
<h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><p>要使用这三个兄弟，首先要给他们一个妈，先调用**GetInputInterface()**获取input hdi接口对象：</p>
<p>这里创建了两个对象：</p>
<ul>
<li>InstanceInputHdi：三个部分</li>
<li>InitDevManager：对外隐藏了的设备管理器，用于管理所有打开 的设备</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取input hdi接口</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">GetInputInterface</span><span class="params">(IInputInterface **inputInterface)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    IInputInterface *inputHdi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建input hdi接口</span></span><br><span class="line">    inputHdi = InstanceInputHdi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建设备管理器</span></span><br><span class="line">    ret = InitDevManager();</span><br><span class="line"></span><br><span class="line">    *inputInterface = inputHdi;</span><br><span class="line">    HDF_LOGI(<span class="string">&quot;%s: exit succ&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> INPUT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InstanceInputHdi:创建了上述的三个对象，InstanceManagerHdi、InstanceControllerHdi、InstanceReporterHdi都是在实例化对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化接口</span></span><br><span class="line"><span class="type">static</span> IInputInterface *<span class="title function_">InstanceInputHdi</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    IInputInterface *hdi = (IInputInterface *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(IInputInterface));</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)memset_s(hdi, <span class="keyword">sizeof</span>(IInputInterface), <span class="number">0</span>, <span class="keyword">sizeof</span>(IInputInterface));</span><br><span class="line">    <span class="comment">//初始化manager</span></span><br><span class="line">    ret = InstanceManagerHdi(&amp;hdi-&gt;iInputManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化controler</span></span><br><span class="line">    ret = InstanceControllerHdi(&amp;hdi-&gt;iInputController);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化reporter</span></span><br><span class="line">    ret = InstanceReporterHdi(&amp;hdi-&gt;iInputReporter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hdi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，三个兄弟已经被生出来了，现在我们能使用他们的方法了。</p>
<h5 id="OpenInputDevice"><a href="#OpenInputDevice" class="headerlink" title="OpenInputDevice"></a>OpenInputDevice</h5><p>我们要使用key，就需要先“打开”这个设备。其实就是绑定key 驱动提供的服务，绑定的方法是通过HdfIoServiceBind()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定设备提供的服务</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">OpenInputDevice</span><span class="params">(<span class="type">uint32_t</span> devIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfIoService</span> *<span class="title">service</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> serviceName[SERVICE_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//检测下标</span></span><br><span class="line">    <span class="keyword">if</span> (CheckIndex(devIndex) != INPUT_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> INPUT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化节点的字符串</span></span><br><span class="line">    <span class="type">int32_t</span> len = (devIndex &lt; PLACEHOLDER_LIMIT) ? <span class="number">1</span> : PLACEHOLDER_LENGTH;</span><br><span class="line">    ret = snprintf_s(serviceName, SERVICE_NAME_LEN, <span class="built_in">strlen</span>(<span class="string">&quot;hdf_input_event&quot;</span>) + len, <span class="string">&quot;%s%u&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hdf_input_event&quot;</span>, devIndex);</span><br><span class="line">\</span><br><span class="line">    <span class="comment">//通过节点名称绑定驱动服务</span></span><br><span class="line">    service = HdfIoServiceBind(serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加服务到设备管理器</span></span><br><span class="line">    <span class="keyword">if</span> (AddService(devIndex, service) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: add device%d failed&quot;</span>, __func__, devIndex);</span><br><span class="line">        HdfIoServiceRecycle(service);</span><br><span class="line">        <span class="keyword">return</span> INPUT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reporter"><a href="#reporter" class="headerlink" title="reporter"></a>reporter</h4><p>现在我们可以使用key设备了，要读取key上报的事件，就需要调用**RegisterReportCallback()**注册上报回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建listener</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> HdfDevEventlistener *<span class="title function_">EventListenerInstance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfDevEventlistener</span> *<span class="title">listener</span> =</span> (<span class="keyword">struct</span> HdfDevEventlistener *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HdfDevEventlistener));</span><br><span class="line">    (<span class="type">void</span>)memset_s(listener, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> HdfDevEventlistener), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> HdfDevEventlistener));</span><br><span class="line">    <span class="comment">//接收回调函数</span></span><br><span class="line">    listener-&gt;onReceive = EventListenerCallback;</span><br><span class="line">    <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册设备上报回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">RegisterReportCallback</span><span class="params">(<span class="type">uint32_t</span> devIndex, InputEventCb *callback)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceInfoNode *pos = <span class="literal">NULL</span>;</span><br><span class="line">    DeviceInfoNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    InputDevManager *manager = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取设备管理器</span></span><br><span class="line">    GET_MANAGER_CHECK_RETURN(manager);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;manager-&gt;mutex);</span><br><span class="line">    DLIST_FOR_EACH_ENTRY_SAFE(pos, next, &amp;manager-&gt;devList, DeviceInfoNode, node) &#123;</span><br><span class="line">        <span class="comment">//遍历输入设备链表</span></span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;payload.devIndex != devIndex) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HdfDevEventlistener</span> *<span class="title">listener</span> =</span> EventListenerInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听设备上报的事件，当设备调用 HdfDeviceSendEvent()发送事件时，listener被回调</span></span><br><span class="line">        <span class="keyword">if</span> (HdfDeviceRegisterEventListener(pos-&gt;service, listener) != INPUT_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">free</span>(listener);</span><br><span class="line">            pthread_mutex_unlock(&amp;manager-&gt;mutex);</span><br><span class="line">            <span class="keyword">return</span> INPUT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">        manager-&gt;evtCallbackNum++;</span><br><span class="line">        <span class="comment">//绑定回调函数到DeviceInfoNode</span></span><br><span class="line">        pos-&gt;eventCb = callback;</span><br><span class="line">        <span class="comment">//绑定listener到DeviceInfoNode</span></span><br><span class="line">        pos-&gt;listener = listener;</span><br><span class="line">        pthread_mutex_unlock(&amp;manager-&gt;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INPUT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;manager-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INPUT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当设备调用 HdfDeviceSendEvent()发送事件时，listener被回调。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//驱动服务事件的统一回调</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">EventListenerCallback</span><span class="params">(<span class="keyword">struct</span> HdfDevEventlistener *listener, <span class="keyword">struct</span> HdfIoService *service,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> id, <span class="keyword">struct</span> HdfSBuf *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)listener;</span><br><span class="line">    (<span class="type">void</span>)id;</span><br><span class="line">    <span class="type">int32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> len = <span class="number">0</span>;</span><br><span class="line">    EventPackage *pkgs[MAX_EVENT_PKG_NUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    DeviceInfoNode *pos = <span class="literal">NULL</span>;</span><br><span class="line">    DeviceInfoNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    InputDevManager *manager = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">NULL</span> || data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: invalid param&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> INPUT_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取设备管理器</span></span><br><span class="line">    manager = GetDevManager();</span><br><span class="line">    <span class="keyword">if</span> (manager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: get manager failed&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> INPUT_NULL_PTR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= MAX_EVENT_PKG_NUM) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取pkgs数据到data</span></span><br><span class="line">        <span class="keyword">if</span> (!HdfSbufReadBuffer(data, (<span class="type">const</span> <span class="type">void</span> **)&amp;pkgs[count], &amp;len)) &#123;</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s: sbuf read finished&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkgs[count] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历输入设备列表</span></span><br><span class="line">    DLIST_FOR_EACH_ENTRY_SAFE(pos, next, &amp;manager-&gt;devList, DeviceInfoNode, node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;service == service) &#123;</span><br><span class="line">            <span class="comment">//匹配成功，调用用户注册的回调函数 （在本例子中是KeyIrqHandle）</span></span><br><span class="line">            pos-&gt;eventCb-&gt;EventPkgCallback((<span class="type">const</span> EventPackage **)pkgs, count, pos-&gt;payload.devIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INPUT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="编写应用程序"><a href="#编写应用程序" class="headerlink" title="编写应用程序"></a>编写应用程序</h3><p>应用程序的代码很简单，就是调用HDI提供的函数。（如何编写应用程序可查看小熊派led程序教程）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input_reporter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_io_service_if.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;osal_time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_INDEX 2   <span class="comment">//hdf_input_event2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DEFAULT_VALUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SERVICE <span class="string">&quot;hdf_led&quot;</span></span></span><br><span class="line">IInputInterface *g_inputInterface;</span><br><span class="line">InputEventCb g_callback;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfIoService</span> *<span class="title">LedService</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> led_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">SendEvent</span><span class="params">(<span class="keyword">struct</span> HdfIoService *service,<span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//使用HdfSBufObtainDefaultSize申请内存，这种类型的内存才能用于和驱动程序交换数据</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">send_buf</span> =</span> HdfSBufObtainDefaultSize();</span><br><span class="line">        <span class="keyword">if</span>(send_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;send_buf fail\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">reply</span> =</span> HdfSBufObtainDefaultSize();</span><br><span class="line">        <span class="keyword">if</span>(reply == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;reply fail\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据写入send_buf</span></span><br><span class="line">        <span class="keyword">if</span> (!HdfSbufWriteUint8(send_buf, data))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write send_buf fail\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/* 通过Dispatch发送数据到驱动，同时驱动会将数据写入reply */</span></span><br><span class="line">		<span class="type">int</span> ret = service-&gt;dispatcher-&gt;Dispatch(&amp;service-&gt;object, LED_WRITE_READ, send_buf, reply);</span><br><span class="line">        <span class="keyword">if</span>(ret != HDF_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Dispatch fail\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> replyData = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//读取reply的数据</span></span><br><span class="line">        <span class="keyword">if</span> (!HdfSbufReadInt32(reply, &amp;replyData))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;fail to get service call reply!\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//回收内存</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    HdfSBufRecycle(send_buf);</span><br><span class="line">    HdfSBufRecycle(reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义数据上报的回调函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ReportEventPkgCallback</span><span class="params">(<span class="type">const</span> EventPackage **pkgs, <span class="type">uint32_t</span> count,<span class="type">uint32_t</span> devIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pkgs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ReportEventPkgCallback: recv pkgs count = %d,devIndex = %d\r\n&quot;</span>,count,devIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="comment">//pkgs[0] = 0x1, 0x74,1 pkgs[1] = 0x1,0x74,0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pkgs[%d] = 0x%x, 0x%x, %d\r\n&quot;</span>, i, pkgs[i]-&gt;type, pkgs[i]-&gt;code, pkgs[i]-&gt;value);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">	led_status == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	SendEvent(LedService,led_status);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LedService = HdfIoServiceBind(LED_SERVICE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED_Init();</span><br><span class="line">    <span class="type">int</span> ret = GetInputInterface(&amp;g_inputInterface);</span><br><span class="line">    <span class="keyword">if</span> (ret != INPUT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: get input interfaces failed, ret = %d&quot;</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开特定的input设备 hdf_input_event2*/</span></span><br><span class="line">    ret = g_inputInterface-&gt;iInputManager-&gt;OpenInputDevice(KEY_INDEX);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: open input device failed, ret = %d&quot;</span>, __func__, ret);</span><br><span class="line"> 	    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 给特定的input设备注册数据上报回调函数 */</span></span><br><span class="line">    g_callback.EventPkgCallback = ReportEventPkgCallback;</span><br><span class="line">   </span><br><span class="line">    ret  = g_inputInterface-&gt;iInputReporter-&gt;RegisterReportCallback(KEY_INDEX, &amp;g_callback);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: register callback failed, ret: %d&quot;</span>, __FUNCTION__, ret);</span><br><span class="line">	    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: running for testing, pls touch the panel now&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OsalMSleep(<span class="number">500</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注销特定input设备上的回调函数 */</span></span><br><span class="line">    ret  = g_inputInterface-&gt;iInputReporter-&gt;UnregisterReportCallback(KEY_INDEX);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: unregister callback failed, ret: %d&quot;</span>, __FUNCTION__, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭特定的input设备 */</span></span><br><span class="line">    ret = g_inputInterface-&gt;iInputManager-&gt;CloseInputDevice(KEY_INDEX);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: close device failed, ret: %d&quot;</span>, __FUNCTION__, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意BUILD.gn也需要添加一些头文件路径，依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;//build/lite/config/component/lite_component.gni&quot;</span>)</span><br><span class="line"></span><br><span class="line">executable(<span class="string">&quot;hello_world_lib&quot;</span>)&#123;</span><br><span class="line">    output_name = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line">    sources = [ <span class="string">&quot;hello.c&quot;</span> ]</span><br><span class="line">    include_dirs = [</span><br><span class="line">    <span class="string">&quot;//drivers/framework/ability/sbuf/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/osal&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/posix/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/utils&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/config&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/peripheral/input/hal/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/peripheral/input/interfaces/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//third_party/FreeBSD/sys/dev/evdev&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    defines = [</span><br><span class="line">            <span class="string">&quot;__USER__&quot;</span>,</span><br><span class="line">            <span class="string">&quot;__HDMI_SUPPORT__&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    cflags_c = [</span><br><span class="line">            <span class="string">&quot;-Wall&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-Wextra&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-Werror&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-fsigned-char&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-fno-common&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-fno-strict-aliasing&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    ldflags = []</span><br><span class="line">    deps = [</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/manager:hdf_core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/platform:hdf_platform&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/posix:hdf_posix_osal&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/peripheral/input/hal:hdi_input&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    public_deps = [ <span class="string">&quot;//third_party/bounds_checking_function:libsec_shared&quot;</span> ]</span><br><span class="line">&#125;</span><br><span class="line">lite_component(<span class="string">&quot;my_app&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    features = [</span><br><span class="line">        <span class="string">&quot;:hello_world_lib&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/Input_framework_key_base_on_micro/" data-id="cmbcy7rhl002et8mta5gy4dd9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/2.dsoftbus_sdk" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/2.dsoftbus_sdk/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.644Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dsoftbus-sdk"><a href="#dsoftbus-sdk" class="headerlink" title="dsoftbus sdk"></a>dsoftbus sdk</h2><p>从上一篇文章看，要调用软总线服务提供的接口，貌似是一件比较麻烦的事，需要获取服务，然后调用Invoke函数。显然这样不方便开发，于是在communication\dsoftbus\sdk目录中提供了很多函数，这些函数把上述的操作都封装好，然后提供一个简单的函数接口给其他进程使用，这就是dsoftbus sdk。</p>
<p>那么dsoftbus sdk提供了那些接口给用户程序调用呢？答案在interface目录下，可以看到interface目录下有bus_center（组网）、discovery（设备发现）、transport（传输）的接口。下面以发现为例来了解sdk如何将获取软总线服务、调用服务接口完成封装。</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/2.dsoftbus_sdk/image-20220513131346659.png" alt="image-20220513131346659"></p>
<p>我们以interfaces\kits\discovery\discovery_service.h里的startDiscovery函数为例来了解softbus sdk的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 订阅指定的服务，会返回远程设备的信息</span></span><br><span class="line"><span class="comment"> * 设备由subscribeId和pkgName指定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkgName 应用包名</span></span><br><span class="line"><span class="comment"> * @param info 指定订阅的服务的信息</span></span><br><span class="line"><span class="comment"> * @param cb 订阅成功回调函数，可以获取远程设备的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StartDiscovery</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> SubscribeInfo *info, <span class="type">const</span> IDiscoveryCallback *cb)</span>;</span><br></pre></td></tr></table></figure>

<p>StartDiscovery的函数调用流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InitSoftBus(packageName)</span><br><span class="line">StartDiscoveryInner(packageName, info, cb);</span><br><span class="line">    g_discInfo-&gt;subscribeCb = *cb;  <span class="comment">//保存回调函数</span></span><br><span class="line">    ServerIpcStartDiscovery(packageName, info);  </span><br></pre></td></tr></table></figure>

<p>很明显将StartDiscovery分为InitSoftBus()和StartDiscoveryInner()两个部分，本文就从这两个部分入手来介绍softbus sdk。</p>
<h3 id="InitSoftBus"><a href="#InitSoftBus" class="headerlink" title="InitSoftBus"></a>InitSoftBus</h3><p>InitSoftBus()的调用流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">InitSoftBus(pkgName)-&gt;            <span class="comment">//初始化软总线</span></span><br><span class="line">    AddClientPkgName(pkgName)	<span class="comment">//创建PkgNameInfo，并添加到g_pkgNameList</span></span><br><span class="line">    SoftBusTimerInit()  </span><br><span class="line">    ClientModuleInit()-&gt;    </span><br><span class="line">        SoftbusConfigInit()    <span class="comment">//设置软总线的最大数据</span></span><br><span class="line">        EventClientInit()      <span class="comment">//创建g_observerList 用于事件回调</span></span><br><span class="line">        BusCenterClientInit()  <span class="comment">//获取软总线服务代理，见下文 BusCenterServerProxyInit</span></span><br><span class="line">        DiscClientInit()     <span class="comment">//获取软总线服务代理</span></span><br><span class="line">        TransClientInit()-&gt;    <span class="comment">//获取软总线服务代理</span></span><br><span class="line">            TransServerProxyInit()	 </span><br><span class="line">            ClientTransChannelInit()-&gt;    <span class="comment">//设置所有传输通道的回调函数</span></span><br><span class="line">                cb = GetClientSessionCb();    <span class="comment">//获取g_sessionCb，client_trans_session_callback.c</span></span><br><span class="line">                TransTdcManagerInit(cb)  <span class="comment">//设置tdc通道回调</span></span><br><span class="line">                ClientTransAuthInit(cb)  <span class="comment">//设置认证通道回调</span></span><br><span class="line">                ClinetTransProxyInit(cb)  <span class="comment">//设置代理回调</span></span><br><span class="line">                ClientTransUdpMgrInit(cb)   <span class="comment">//udp回调啥的     </span></span><br><span class="line">            ClientTransRegLnnOffline()    <span class="comment">//设置组网回调函数</span></span><br><span class="line">    ClientStubInit()-&gt;</span><br><span class="line">        ServerProxyInit()-&gt;</span><br><span class="line">            HOS_SystemInit()    <span class="comment">//若软总线服务没启动、可以在此启动</span></span><br><span class="line">            g_serverProxy = GetServerProxy();  <span class="comment">//获取软总线服务代理</span></span><br><span class="line">        <span class="comment">//注册ipc客户端回调函数ClientIpcInterfaceMsgHandle</span></span><br><span class="line">        RegisterIpcCallback(ClientIpcInterfaceMsgHandle, <span class="number">0</span>, IPC_WAIT_FOREVER, &amp;clientIdentity, <span class="literal">NULL</span>);</span><br><span class="line">        ClientContextInit()    <span class="comment">//创建g_clientCtx</span></span><br><span class="line">        SetClientIdentity(clientIdentity...);   <span class="comment">//根据clientIdentity设置g_clientCtx</span></span><br><span class="line">        RegisterServerDeathCb()  <span class="comment">//设置服务销毁回调函数   </span></span><br><span class="line">    ClientRegisterService()    <span class="comment">//调用软总线服务的MANAGE_REGISTER_SERVICE</span></span><br><span class="line">        GetClientIdentity(&amp;svcId.handle, &amp;svcId.token, &amp;svcId.cookie, &amp;svcId.ipcCtx)</span><br><span class="line">        RegisterService(pkgName, &amp;svcId) </span><br><span class="line">            IpcIoPushString(&amp;request, name);</span><br><span class="line">            IpcIoPushSvc(&amp;request, &amp;svc);</span><br><span class="line">            g_serverProxy-&gt;Invoke(g_serverProxy, MANAGE_REGISTER_SERVICE, &amp;request, &amp;ret,ClientSimpleResultCb)</span><br></pre></td></tr></table></figure>

<p>这个函数本质上就是设置很多回调函数，然后获取软总线服务的代理，最后调用服务的MANAGE_REGISTER_SERVICE接口，完成软总线服务的注册。</p>
<h4 id="BusCenterServerProxyInit"><a href="#BusCenterServerProxyInit" class="headerlink" title="BusCenterServerProxyInit"></a>BusCenterServerProxyInit</h4><p>初始化g_serverProxy，获取软总线服务的代理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">BusCenterServerProxyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//g_serverProxy已初始化完成，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (g_serverProxy != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_INFO, <span class="string">&quot;server proxy has initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_INFO, <span class="string">&quot;bus center start get server proxy&quot;</span>);</span><br><span class="line">    <span class="type">int32_t</span> proxyInitCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始获取服务</span></span><br><span class="line">    <span class="keyword">while</span> (g_serverProxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//超时判断</span></span><br><span class="line">        proxyInitCount++;</span><br><span class="line">        <span class="keyword">if</span> (proxyInitCount == WAIT_SERVER_READY_INTERVAL_COUNT) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_ERROR, <span class="string">&quot;bus center get server proxy error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取soft bus服务 异步的操作</span></span><br><span class="line">        IUnknown *iUnknown = SAMGR_GetInstance()-&gt;GetDefaultFeatureApi(SOFTBUS_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (iUnknown == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            SoftBusSleepMs(WAIT_SERVER_READY_INTERVAL);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取服务接口 CLIENT_PROXY_VER 到 g_serverProxy</span></span><br><span class="line">        <span class="type">int32_t</span> ret = iUnknown-&gt;QueryInterface(iUnknown, CLIENT_PROXY_VER, (<span class="type">void</span> **)&amp;g_serverProxy);</span><br><span class="line">        <span class="keyword">if</span> (ret != EC_SUCCESS || g_serverProxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_ERROR, <span class="string">&quot;QueryInterface failed [%d]&quot;</span>, ret);</span><br><span class="line">            SoftBusSleepMs(WAIT_SERVER_READY_INTERVAL);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_INFO, <span class="string">&quot;bus center get server proxy ok&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StartDiscovery"><a href="#StartDiscovery" class="headerlink" title="StartDiscovery"></a>StartDiscovery</h3><p>ServerIpcStartDiscovery 是最终的函数，在初始化完成软总线后，它完成了对软总线服务的ServerStartDiscovery函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ServerIpcStartDiscovery</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> SubscribeInfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_INFO, <span class="string">&quot;start discovery ipc client push.&quot;</span>);</span><br><span class="line">	<span class="comment">//准备ipc调用的参数</span></span><br><span class="line">    <span class="type">uint8_t</span> data[MAX_SOFT_BUS_IPC_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    IpcIo request = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化参数内存</span></span><br><span class="line">    IpcIoInit(&amp;request, data, MAX_SOFT_BUS_IPC_LEN, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//第一个参数：pkgName</span></span><br><span class="line">    IpcIoPushString(&amp;request, pkgName);</span><br><span class="line">    <span class="comment">//因为info不是基本数据类型，而是一个结构体，所系要将info序列化，才能作为参数</span></span><br><span class="line">    DiscSerializer serializer = &#123;</span><br><span class="line">        .dataLen = info-&gt;dataLen,</span><br><span class="line">        .freq = info-&gt;freq,</span><br><span class="line">        .medium = info-&gt;medium,</span><br><span class="line">        .mode = info-&gt;mode,</span><br><span class="line">        .id.subscribeId = info-&gt;subscribeId</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    SubscribeSerializer subscribeSerializer = &#123;</span><br><span class="line">        .commonSerializer = serializer,</span><br><span class="line">        .isSameAccount = info-&gt;isSameAccount,</span><br><span class="line">        .isWakeRemote = info-&gt;isWakeRemote</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//第二个参数：subscribeSerializer</span></span><br><span class="line">    IpcIoPushFlatObj(&amp;request, (<span class="type">void</span>*)&amp;subscribeSerializer, <span class="keyword">sizeof</span>(SubscribeSerializer));</span><br><span class="line">    <span class="comment">//第三个参数：capability</span></span><br><span class="line">    IpcIoPushString(&amp;request, info-&gt;capability);</span><br><span class="line">    <span class="comment">//第四个参数：capabilityData</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;dataLen != <span class="number">0</span>) &#123;</span><br><span class="line">        IpcIoPushString(&amp;request, (<span class="type">const</span> <span class="type">char</span> *)(info-&gt;capabilityData));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步调用g_serverProxy-&gt;Invoke，就是调用软总线服务的接口</span></span><br><span class="line">    <span class="comment">//其实质就是调用ServerStartDiscovery(origin, request, NULL);</span></span><br><span class="line">    <span class="type">int32_t</span> ans = g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_START_DISCOVERY, &amp;request, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_ERROR, <span class="string">&quot;start discovery invoke failed[%d].&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么，通过ipc调用，ServerStartDiscovery就得到执行，它首先提取出参数，然后根据参数内容开始发现服务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">ServerStartDiscovery</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *origin, IpcIo *req, IpcIo *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;start discovery ipc server pop.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *capabilityData = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//获取第一个参数pkgName</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pkgName = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">    <span class="comment">//获取第二个参数info</span></span><br><span class="line">    SubscribeSerializer *info = (SubscribeSerializer *)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;ipc pop is null.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取第三个参数capability </span></span><br><span class="line">    <span class="type">char</span> *capability = (<span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;commonSerializer.dataLen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取第四个参数capabilityData</span></span><br><span class="line">        capabilityData = (<span class="type">unsigned</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复info</span></span><br><span class="line">    SubscribeInfo subscribeInfo = &#123;</span><br><span class="line">        .capability = capability,</span><br><span class="line">        .capabilityData = capabilityData,</span><br><span class="line">        .dataLen = info-&gt;commonSerializer.dataLen,</span><br><span class="line">        .freq = info-&gt;commonSerializer.freq,</span><br><span class="line">        .medium = info-&gt;commonSerializer.medium,</span><br><span class="line">        .mode = info-&gt;commonSerializer.mode,</span><br><span class="line">        .subscribeId = info-&gt;commonSerializer.id.subscribeId,</span><br><span class="line">        .isSameAccount = info-&gt;isSameAccount,</span><br><span class="line">        .isWakeRemote = info-&gt;isWakeRemote</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//从origin获取uid用于判断权限</span></span><br><span class="line">    <span class="type">int32_t</span> callingUid = GetCallingUid(origin);</span><br><span class="line">    <span class="keyword">if</span> (!CheckDiscPermission(callingUid, pkgName)) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;publish service no permission.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续的服务发现流程</span></span><br><span class="line">    <span class="type">int32_t</span> ret = DiscIpcStartDiscovery(pkgName, &amp;subscribeInfo);</span><br><span class="line">    <span class="keyword">if</span> (ret != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;start discovery failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个例子中，我们了解到了sdk如何封装了对软总线服务的使用，以及IPC的使用方法。</p>
<h3 id="PublishService"><a href="#PublishService" class="headerlink" title="PublishService"></a>PublishService</h3><p>同样的，我们看interfaces\kits\discovery\discovery_service.h里的<code>int PublishService(const char *pkgName, const PublishInfo *info, const IPublishCallback *cb);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InitSoftBus(pkgName)</span><br><span class="line">PublishServiceInner(packageName, info, cb)-&gt;</span><br><span class="line">    ServerIpcPublishService(packageName,info)-&gt;</span><br><span class="line">        IpcIoPushString(&amp;request, pkgName);</span><br><span class="line">        IpcIoPushFlatObj(&amp;request, (<span class="type">void</span>*)&amp;publishSerializer, <span class="keyword">sizeof</span>(PublishSerializer));</span><br><span class="line">        IpcIoPushString(&amp;request, info-&gt;capability);</span><br><span class="line">        IpcIoPushString(&amp;request, (<span class="type">const</span> <span class="type">char</span> *)(info-&gt;capabilityData));</span><br><span class="line">        g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_PUBLISH_SERVICE, &amp;request, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>可见也是类似的，先初始化软总线，然后通过ipc调用软总线的服务接口。</p>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>IPC是进程间通信的一种方式，它的本质就是共享内存，将不同进程的一块虚拟地址空间映射到同一块物理内存，对这个物理内存的读写只需要一次复制。</p>
<p>IPC的介绍可参考<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/communication_ipc_lite">communication_ipc_lite: Inter-process communication | 轻量级进程间通信IPC (gitee.com)</a></p>
<p>IPC的能力包括 进程间通信和数据的序列化，进程间通信由samgr完成封装，即我们前面介绍的服务框架。数据序列化的代码在<code>foundation\communication\ipc_lite\interfaces\kits\serializer.h</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类似于栈的结构体 用于传递进程间函数调用的参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* bufferBase;</span><br><span class="line">    <span class="type">size_t</span>* offsetsBase;</span><br><span class="line">    <span class="type">char</span>* bufferCur;</span><br><span class="line">    <span class="type">size_t</span>* offsetsCur;</span><br><span class="line">    <span class="type">size_t</span> bufferLeft;</span><br><span class="line">    <span class="type">size_t</span> offsetsLeft;</span><br><span class="line">    <span class="type">uint32_t</span> flag;</span><br><span class="line">    NDK_DL_LIST ptrFreeList;</span><br><span class="line">&#125; IpcIo;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoInit</span><span class="params">(IpcIo* io, <span class="type">void</span>* data, <span class="type">size_t</span> maxdata, <span class="type">size_t</span> maxobjects)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoInitFromMsg</span><span class="params">(IpcIo* io, <span class="type">const</span> <span class="type">void</span>* msg)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IpcIoAvailable</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="comment">/* Must ensure all the input is valid */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushChar</span><span class="params">(IpcIo* io, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushCharUnaligned</span><span class="params">(IpcIo* io, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushBool</span><span class="params">(IpcIo* io, <span class="type">bool</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushBoolUnaligned</span><span class="params">(IpcIo* io, <span class="type">bool</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushIntptr</span><span class="params">(IpcIo* io, <span class="type">intptr_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUintptr</span><span class="params">(IpcIo* io, <span class="type">uintptr_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt8</span><span class="params">(IpcIo* io, <span class="type">int8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt8Unaligned</span><span class="params">(IpcIo* io, <span class="type">int8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint8</span><span class="params">(IpcIo* io, <span class="type">uint8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint8Unaligned</span><span class="params">(IpcIo* io, <span class="type">uint8_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt16</span><span class="params">(IpcIo* io, <span class="type">int16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt16Unaligned</span><span class="params">(IpcIo* io, <span class="type">int16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint16</span><span class="params">(IpcIo* io, <span class="type">uint16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint16Unaligned</span><span class="params">(IpcIo* io, <span class="type">uint16_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt32</span><span class="params">(IpcIo* io, <span class="type">int32_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint32</span><span class="params">(IpcIo* io, <span class="type">uint32_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushInt64</span><span class="params">(IpcIo* io, <span class="type">int64_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushUint64</span><span class="params">(IpcIo* io, <span class="type">uint64_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushFloat</span><span class="params">(IpcIo* io, <span class="type">float</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushDouble</span><span class="params">(IpcIo* io, <span class="type">double</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushString</span><span class="params">(IpcIo* io, <span class="type">const</span> <span class="type">char</span>* cstr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushFlatObj</span><span class="params">(IpcIo* io, <span class="type">const</span> <span class="type">void</span>* obj, <span class="type">uint32_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushSvc</span><span class="params">(IpcIo* io, <span class="type">const</span> SvcIdentity* svc)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushFd</span><span class="params">(IpcIo* io, <span class="type">uint32_t</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushDataBuff</span><span class="params">(IpcIo* io, <span class="type">const</span> BuffPtr* dataBuff)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoPushDataBuffWithFree</span><span class="params">(IpcIo* io, <span class="type">const</span> BuffPtr* dataBuff, IpcIoPtrFree ipcIoFree)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IpcIoFreeDataBuff</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">IpcIoPopChar</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">IpcIoPopCharUnaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IpcIoPopBool</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IpcIoPopBoolUnaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">intptr_t</span> <span class="title function_">IpcIoPopIntptr</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uintptr_t</span> <span class="title function_">IpcIoPopUintptr</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">IpcIoPopInt8</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">IpcIoPopInt8Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">IpcIoPopUint8</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">IpcIoPopUint8Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">IpcIoPopInt16</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">IpcIoPopInt16Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">IpcIoPopUint16</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">IpcIoPopUint16Unaligned</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">IpcIoPopInt32</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IpcIoPopUint32</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">IpcIoPopInt64</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">IpcIoPopUint64</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">IpcIoPopFloat</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">IpcIoPopDouble</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">uint8_t</span>* <span class="title function_">IpcIoPopString</span><span class="params">(IpcIo* io, <span class="type">size_t</span>* sz)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">IpcIoPopFlatObj</span><span class="params">(IpcIo* io, <span class="type">uint32_t</span>* size)</span>;</span><br><span class="line">SvcIdentity* <span class="title function_">IpcIoPopSvc</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">IpcIoPopFd</span><span class="params">(IpcIo* io)</span>;</span><br><span class="line">BuffPtr* <span class="title function_">IpcIoPopDataBuff</span><span class="params">(IpcIo* io)</span>;</span><br></pre></td></tr></table></figure>

<p>可以把IpcIo理解成一个栈，以上的函数都是控制数据入栈和出栈的操作，这个就跟函数调用很类似。</p>
<p>构建完成IpcIo这样一个栈后，接下来就是确定要执行的函数，这里就是使用samgr提供的进程间通信方法，如下：</p>
<p>把request这个IpcIo，发送给软总线进程的SERVER_START_DISCOVERY接口函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_serverProxy-&gt;Invoke(g_serverProxy, SERVER_START_DISCOVERY, &amp;request, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>通过本文应该能理解dsoftbus sdk如何调用软总线服务提供的接口，了解ipc的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/2.dsoftbus_sdk/" data-id="cmbcy7rhm002ft8mth5ld1ftl" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/WLAN_Guide" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/WLAN_Guide/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.644Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="WLAN-Model"><a href="#WLAN-Model" class="headerlink" title="WLAN Model"></a>WLAN Model</h2><p>本系列文章准备深入了解OpenHarmony的WLAN驱动模型，由于WLAN驱动模型非常庞大，我尝试根据WIFI 驱动模型的设计特点来给整个模式分模块进行介绍，本文是本系列文章的导读。</p>
<p>学习OpenHarmony的最好途径就是从官网的文档入手，我们可查看官网对于WLAN驱动模型的介绍：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/driver/driver-peripherals-external-des.md">zh-cn&#x2F;device-dev&#x2F;driver&#x2F;driver-peripherals-external-des.md · OpenHarmony&#x2F;docs - 码云 - 开源中国 (gitee.com)</a></p>
<h3 id="前提必读"><a href="#前提必读" class="headerlink" title="前提必读"></a>前提必读</h3><p>OpenHarmony WIFI 驱动模型是基于 HDF 驱动框架开发的，需要先理解 HDF 驱动开发框架，才能来学习WIFI 驱动模型。HDF 驱动的介绍：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/driver/driver-hdf-overview.md">https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/driver/driver-hdf-overview.md</a></p>
<p>计算机技术是为了解决实际问题而产生，而我们学习WIFI驱动框架，就需要知道这个软件技术是为了解决什么问题。答案可在官网找到：</p>
<p>首先WIFI 驱动模型的基本功能就是提供给上层WLAN能力：</p>
<blockquote>
<p>HDI层开发人员可根据WLAN模块提供的向上统一接口获取如下能力：建立&#x2F;关闭WLAN热点、扫描、关联WLAN热点等。</p>
</blockquote>
<p>其次，提供给驱动开发人员接口：</p>
<blockquote>
<p>各WLAN厂商驱动开发人员可根据WLAN模块提供的向下统一接口适配各自的驱动代码.</p>
</blockquote>
<p>最后是模型的优点：</p>
<blockquote>
<p>基于OpenHarmony驱动框架的WLAN驱动模型，可实现跨操作系统迁移，自适应器件差异，模块化拼装编译等功能。</p>
</blockquote>
<h3 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h3><p>WIFI是一种无线传输技术，一般由WIFI芯片实现，通过SDIO或USB接口等与主控芯片连接。WIFI芯片与主控有两种通信通路：命令和数据。数据和命令以分时复用的方式使用SDIO总线。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>命令有三种：base，station，ap。</p>
<p>base命令包括：电源、复位等。</p>
<p>station命令包括扫描，连接等。</p>
<p>ap命令包括建立热点，获取连接状态等。</p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>数据包含接受和发送，WIFI是网络设备，其数据需要经过网络协议栈处理，例如LWIP协议栈。</p>
<p>协议栈的数据最终通过SDIO发送到WIFI芯片，WIFI芯片的网络数据也是通过SDIO最终输入到协议栈。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在代码上就可以分为命令和数据两个部分。</p>
<p>命令部分又可以分为三类，分别以feature的方式来命名：</p>
<ul>
<li>base feature</li>
<li>sta feature</li>
<li>ap feature</li>
</ul>
<p>这三个概念会贯穿命令传输的通路。</p>
<p>数据通路主要是实现与网络协议栈的适配对接。</p>
<h4 id="具体框架"><a href="#具体框架" class="headerlink" title="具体框架"></a>具体框架</h4><p>由于OpenHarmony的驱动框架采用的是C语言面向对象的编程方法，所以在学习中也尽量使用面向对象的方法来入手。着重理解各个对象之间的调用关系，以及对象的创建方法。</p>
<p>下图所示是WLAN 命令通路：</p>
<p><img src="/2025/05/30/hello-world/OpenHarmony/WLAN_Guide/wifi_cmd.png" alt="wifi_cmd"></p>
<p>以hdf_wifi_core.c为界，可将通路分为两部分：HDI 层和核心层。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/WLAN_Guide/" data-id="cmbcy7rhm002ht8mtcmdi4bmg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
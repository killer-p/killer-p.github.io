<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/ESP32/esp32_get_time" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/esp32_get_time/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.657Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]<br>与<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/109502203">esp32获取天气数据</a>的流程类似的，我们从另一个网站获取时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_URL <span class="string">&quot;https://api.uukit.com/time&quot;</span>	<span class="comment">//api接口</span></span></span><br></pre></td></tr></table></figure>
<p>我们对其接口发起请求，返回结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;timestamp&quot;</span>: <span class="number">1616556071</span>,</span><br><span class="line">        <span class="string">&quot;microtime&quot;</span>: <span class="number">1616556071.259844</span>,</span><br><span class="line">        <span class="string">&quot;gmt&quot;</span>: <span class="string">&quot;2021-03-24 03:21:11&quot;</span>,</span><br><span class="line">        <span class="string">&quot;utc&quot;</span>: <span class="string">&quot;2021-03-24T03:21:11Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;timezone&quot;</span>: <span class="string">&quot;Shanghai&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;req_id&quot;</span>: <span class="string">&quot;3b853233236df4a63608&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码实现对该接口的请求，并使用cjson解析出时间信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">config.url = TIME_URL;  <span class="comment">//设置url，请求方式</span></span><br><span class="line">config.method = HTTP_METHOD_GET;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start connect to url = %s\r\n&quot;</span>,config.url);</span><br><span class="line">client = esp_http_client_init(&amp;config);</span><br><span class="line">esp_http_client_perform(client);    <span class="comment">//发起http连接</span></span><br><span class="line">esp_http_client_close(client);</span><br><span class="line">esp_http_client_cleanup(client);</span><br><span class="line"></span><br><span class="line">cJSON *root = cJSON_Parse(http_data);   <span class="comment">//解析返回的时间json数据</span></span><br><span class="line"><span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *time = cJSON_GetObjectItem(root,<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    time = cJSON_GetObjectItem(time, <span class="string">&quot;gmt&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *t = cJSON_GetStringValue(time);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;time error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;time = %s&quot;</span>,t);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strncpy</span>(str_time, t, <span class="number">25</span>);   <span class="comment">//将字符串复制到str_time</span></span><br><span class="line"></span><br><span class="line">    cJSON_Delete(root);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/esp32_get_time/" data-id="cmbcy7rgy000lt8mt737gdkd8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/rust/rust编程语言" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/rust/rust%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.245Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文记录了《The Rust Programming Language》的学习笔记，关键知识点。</p>
<h2 id="Enums-和-Pattern-Match"><a href="#Enums-和-Pattern-Match" class="headerlink" title="Enums 和 Pattern Match"></a>Enums 和 Pattern Match</h2><p>enums give you a way of saying a value is one of a possible set of values。<br>枚举比C语言的枚举强大很多，枚举值是一个变量，变量可以存放不同类型的数据。对于rust 枚举来说，同一个枚举类型内的变量，可以存放不同的数据结构。<br>例如ip地址：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">get_addr</span>(&amp;<span class="keyword">Self</span>) &#123;</span><br><span class="line">		<span class="comment">// --snip--</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rust没有NULL关键字，没有空指针，rust 使用 emum Option<T> {None, Some}来作为NULL的替代品。通常用于函数返回值，表示函数返回值是否有效。<br>Option<T> 这个非常有意思，他可以表示万物。None表示无，Some(T)表示有，“有”的内容就是T。需要使用match语法来提取内容T<br>match语法与C语言的switch类似</p>
<h2 id="package，crates，modules"><a href="#package，crates，modules" class="headerlink" title="package，crates，modules"></a>package，crates，modules</h2><p>A <em>crate</em> is the smallest amount of code that the Rust compiler considers at a time。类似于C语言的可执行文件&#x2F;so库。目标文件</p>
<p>A <em>package</em> is a bundle of one or more crates that provides a set of functionality. A package contains a <em>Cargo.toml</em> file that describes how to build those crates。<br>A package can contain as many binary crates as you like, but at most only one library crate</p>
<p><em>Modules</em> let us organize code within a crate for readability and easy reuse.</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="数组vector"><a href="#数组vector" class="headerlink" title="数组vector"></a>数组vector</h3><p>使用vector + enum 的方式，可以实现在vector 内，所有成员都是同一个enum类型，但是enum 类型的成员可以是不同的数据类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>rust字符串是由UTF-8编码的，每一个字符是两个字节，不能使用index的方式来访问string的内容。使用 chars()方法获取字符，使用bytes()方法获取一个字节数据。<br>format! 宏类似println! 宏，只是不会输出到std out。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/rust/rust%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" data-id="cmbcy7ri0003qt8mtaoukdxra" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/luckfox/操作备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/luckfox/%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.240Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-rockchip830-linux-uclibcgnueabihf-</span><br><span class="line"><span class="built_in">export</span> PATH=/home/prx/project/luckfox-pico/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin:<span class="variable">$PATH</span></span><br><span class="line">make luckfox_rv1106_linux_defconfig</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<h2 id="adb-连接"><a href="#adb-连接" class="headerlink" title="adb 连接"></a>adb 连接</h2><h3 id="windows开启openssh-server"><a href="#windows开启openssh-server" class="headerlink" title="windows开启openssh server"></a>windows开启openssh server</h3><p>这里的目的是为了能在vscode 中使用window 的adb</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 OpenSSH 服务器</span></span><br><span class="line">Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0</span><br><span class="line"><span class="comment"># 启动服务并设置开机自启</span></span><br><span class="line">Start-Service sshd</span><br><span class="line">Set-Service -Name sshd -StartupType Automatic</span><br><span class="line">New-NetFirewallRule -Name <span class="string">&quot;OpenSSH-Server&quot;</span> -DisplayName <span class="string">&quot;OpenSSH Server (SSHD)&quot;</span> -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22</span><br></pre></td></tr></table></figure>
<h3 id="adb-调试"><a href="#adb-调试" class="headerlink" title="adb 调试"></a>adb 调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>
<h2 id="在虚拟机中连接板子"><a href="#在虚拟机中连接板子" class="headerlink" title="在虚拟机中连接板子"></a>在虚拟机中连接板子</h2><p>官网wiki是在windows中使用RNDIS与板子进行网络连接。其实在虚拟机中也可以做到，具体步骤如下：</p>
<ol>
<li>将USB设备连接到vmware station：编辑-&gt;首选项-&gt;USB-&gt;将设备连接到前台虚拟机</li>
<li>使用以下脚本进行连接：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">sudo</span> ip addr add 172.32.0.100/24 dev enx928af7795b4f</span><br><span class="line">    <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> enx928af7795b4f up</span><br><span class="line">    ssh root@172.32.0.93</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>同样的也可以使用adb进行连接</li>
</ol>
<h3 id="脚本记录每次操作"><a href="#脚本记录每次操作" class="headerlink" title="脚本记录每次操作"></a>脚本记录每次操作</h3><p>使用脚本记录每次操作，以后使用过程中可以随时通过脚本快速进行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/luckfox/%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cmbcy7rhs002zt8mt8x6mcqxw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/uboot_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/uboot_2/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.237Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">run_main_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SANDBOX</span></span><br><span class="line">        sandbox_main_loop_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* main_loop() can return to retry autoboot, if so just run it again */</span></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">                main_loop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop:"></a>main_loop:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We come here after U-Boot is initialised and ready to process commands */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">        bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, <span class="string">&quot;main_loop&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VERSION_VARIABLE</span></span><br><span class="line">        env_set(<span class="string">&quot;ver&quot;</span>, version_string);  <span class="comment">/* set version variable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_VERSION_VARIABLE */</span></span></span><br><span class="line"></span><br><span class="line">        cli_init();			<span class="comment">//初始化命令行界面 cli = cmd line interface</span></span><br><span class="line"></span><br><span class="line">        run_preboot_environment_command();	<span class="comment">//执行环境变量preboot的内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_UPDATE_TFTP)</span></span><br><span class="line">        update_tftp(<span class="number">0UL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);		<span class="comment">//tftp更新</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_UPDATE_TFTP */</span></span></span><br><span class="line"></span><br><span class="line">        s = bootdelay_process();			<span class="comment">//s = *bootcmd，同时获取bootdelay的值</span></span><br><span class="line">        <span class="keyword">if</span> (cli_process_fdt(&amp;s))			<span class="comment">//由设备树更新bootcmd，并决定是否进入secure boot</span></span><br><span class="line">                cli_secure_boot_cmd(s);</span><br><span class="line"></span><br><span class="line">        autoboot_command(s);				<span class="comment">//s = bootcmd的内容</span></span><br><span class="line"></span><br><span class="line">        cli_loop();</span><br><span class="line">        panic(<span class="string">&quot;No CLI available&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>cli_init()，common&#x2F;cli.c中实现了uboot命令行的许多功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cli_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUSH_PARSER</span></span><br><span class="line">        u_boot_hush_start();	<span class="comment">//hush是一个命令行解析器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HUSH_INIT_VAR)</span></span><br><span class="line">        hush_init_var();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="run-preboot-environment-command"><a href="#run-preboot-environment-command" class="headerlink" title="run_preboot_environment_command();"></a>run_preboot_environment_command();</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_preboot_environment_command</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREBOOT</span></span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">        p = env_get(<span class="string">&quot;preboot&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_AUTOBOOT_KEYED</span></span><br><span class="line">                <span class="type">int</span> prev = disable_ctrlc(<span class="number">1</span>);    <span class="comment">/* disable Control C checking */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">			   <span class="comment">//运行命令行列表preboot</span></span><br><span class="line">                run_command_list(p, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_AUTOBOOT_KEYED</span></span><br><span class="line">                disable_ctrlc(prev);    <span class="comment">/* restore Control C checking */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_PREBOOT */</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="bootdelay-process"><a href="#bootdelay-process" class="headerlink" title="bootdelay_process();"></a>bootdelay_process();</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">bootdelay_process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *s;</span><br><span class="line">        <span class="type">int</span> bootdelay;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOOTCOUNT_LIMIT</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bootcount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bootlimit = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_BOOTCOUNT_LIMIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOOTCOUNT_LIMIT</span></span><br><span class="line">        bootcount = bootcount_load();</span><br><span class="line">        bootcount++;</span><br><span class="line">        bootcount_store(bootcount);</span><br><span class="line">        env_set_ulong(<span class="string">&quot;bootcount&quot;</span>, bootcount);</span><br><span class="line">        bootlimit = env_get_ulong(<span class="string">&quot;bootlimit&quot;</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_BOOTCOUNT_LIMIT */</span></span></span><br><span class="line"></span><br><span class="line">        s = env_get(<span class="string">&quot;bootdelay&quot;</span>);</span><br><span class="line">        bootdelay = s ? (<span class="type">int</span>)simple_strtol(s, <span class="literal">NULL</span>, <span class="number">10</span>) : CONFIG_BOOTDELAY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">        bootdelay = fdtdec_get_config_int(gd-&gt;fdt_blob, <span class="string">&quot;bootdelay&quot;</span>,</span><br><span class="line">                        bootdelay);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        debug(<span class="string">&quot;### main_loop entered: bootdelay=%d\n\n&quot;</span>, bootdelay);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MENU_SHOW)</span></span><br><span class="line">        bootdelay = menu_show(bootdelay);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        bootretry_init_cmd_timeout();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_POST</span></span><br><span class="line">        <span class="keyword">if</span> (gd-&gt;flags &amp; GD_FLG_POSTFAIL) &#123;</span><br><span class="line">                s = env_get(<span class="string">&quot;failbootcmd&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_POST */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOOTCOUNT_LIMIT</span></span><br><span class="line">        <span class="keyword">if</span> (bootlimit &amp;&amp; (bootcount &gt; bootlimit)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Warning: Bootlimit (%u) exceeded. Using altbootcmd.\n&quot;</span>,</span><br><span class="line">                       (<span class="type">unsigned</span>)bootlimit);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SUNXI_SWITCH_SYSTEM</span></span><br><span class="line">                <span class="keyword">if</span> (!sunxi_damage_switch_system()) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Damage switching succeeded, now reset the system!\n&quot;</span>);</span><br><span class="line">                        reset_cpu(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        s = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">return</span> s;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                s = env_get(<span class="string">&quot;altbootcmd&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_BOOTCOUNT_LIMIT */</span></span></span><br><span class="line">                s = env_get(<span class="string">&quot;bootcmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        process_fdt_options(gd-&gt;fdt_blob);</span><br><span class="line">        stored_bootdelay = bootdelay;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>cli_process_fdt()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cli_process_fdt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **cmdp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Allow the fdt to override the boot command */</span></span><br><span class="line">        <span class="type">char</span> *env = fdtdec_get_config_string(gd-&gt;fdt_blob, <span class="string">&quot;bootcmd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (env)</span><br><span class="line">                *cmdp = env;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the bootsecure option was chosen, use secure_boot_cmd().</span></span><br><span class="line"><span class="comment">         * Always use &#x27;env&#x27; in this case, since bootsecure requres that the</span></span><br><span class="line"><span class="comment">         * bootcmd was specified in the FDT too.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> fdtdec_get_config_int(gd-&gt;fdt_blob, <span class="string">&quot;bootsecure&quot;</span>, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="autoboot-command"><a href="#autoboot-command" class="headerlink" title="autoboot_command();"></a>autoboot_command();</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">autoboot_command</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">        debug(<span class="string">&quot;### main_loop: bootcmd=\&quot;%s\&quot;\n&quot;</span>, s ? s : <span class="string">&quot;&lt;UNDEFINED&gt;&quot;</span>);</span><br><span class="line">		<span class="comment">//进入autoboot倒计时__abortboot</span></span><br><span class="line">        <span class="keyword">if</span> (stored_bootdelay != <span class="number">-1</span> &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)</span></span><br><span class="line">                <span class="type">int</span> prev = disable_ctrlc(<span class="number">1</span>);    <span class="comment">/* disable Control C checking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                run_command_list(s, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)</span></span><br><span class="line">                disable_ctrlc(prev);    <span class="comment">/* restore Control C checking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MENUKEY</span></span><br><span class="line">        <span class="keyword">if</span> (menukey == CONFIG_MENUKEY) &#123;</span><br><span class="line">                s = env_get(<span class="string">&quot;menucmd&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (s)</span><br><span class="line">                        run_command_list(s, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_MENUKEY */</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __abortboot(<span class="type">int</span> bootdelay)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">abort</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> ts;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MENUPROMPT</span></span><br><span class="line">        <span class="built_in">printf</span>(CONFIG_MENUPROMPT);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hit any key to stop autoboot: %2d &quot;</span>, bootdelay);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check if key already pressed</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (tstc()) &#123;   <span class="comment">/* we got a key press   */</span></span><br><span class="line">                <span class="type">char</span> input;</span><br><span class="line">                input = getc();  <span class="comment">/* consume input       */</span></span><br><span class="line">                <span class="keyword">if</span> (input == <span class="string">&#x27;s&#x27;</span> || input == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                        <span class="built_in">puts</span>(<span class="string">&quot;\b\b\b 0&quot;</span>);</span><br><span class="line">                        <span class="built_in">abort</span> = <span class="number">1</span>;      <span class="comment">/* don&#x27;t auto boot      */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sunxi_get_uboot_shell() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">abort</span> = <span class="number">1</span>;</span><br><span class="line">                bootdelay = <span class="number">0</span>;</span><br><span class="line">                sunxi_set_uboot_shell(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((bootdelay &gt; <span class="number">0</span>) &amp;&amp; (!<span class="built_in">abort</span>)) &#123;</span><br><span class="line">                --bootdelay;</span><br><span class="line">                <span class="comment">/* delay 1000 ms */</span></span><br><span class="line">                ts = get_timer(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tstc()) &#123;   <span class="comment">/* we got a key press   */</span></span><br><span class="line">                                <span class="built_in">abort</span>  = <span class="number">1</span>;     <span class="comment">/* don&#x27;t auto boot      */</span></span><br><span class="line">                                bootdelay = <span class="number">0</span>;  <span class="comment">/* no more delay        */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_MENUKEY</span></span><br><span class="line">                                menukey = getc();</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">                                (<span class="type">void</span>) getc();  <span class="comment">/* consume input        */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        udelay(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">while</span> (!<span class="built_in">abort</span> &amp;&amp; get_timer(ts) &lt; <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b\b\b%2d &quot;</span>, bootdelay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        putc(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">update_tftp</span><span class="params">(ulong addr, <span class="type">char</span> *interface, <span class="type">char</span> *devstring)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *filename, *env_addr, *fit_image_name;</span><br><span class="line">        ulong update_addr, update_fladdr, update_size;</span><br><span class="line">        <span class="type">int</span> images_noffset, ndepth, noffset;</span><br><span class="line">        <span class="type">bool</span> update_tftp_dfu;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">void</span> *fit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interface == <span class="literal">NULL</span> &amp;&amp; devstring == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                update_tftp_dfu = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interface &amp;&amp; devstring) &#123;</span><br><span class="line">                update_tftp_dfu = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Interface: %s and devstring: %s not supported!\n&quot;</span>,</span><br><span class="line">                      interface, devstring);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* use already present image */</span></span><br><span class="line">        <span class="keyword">if</span> (addr)</span><br><span class="line">                <span class="keyword">goto</span> got_update_file;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Auto-update from TFTP: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the file name of the update file */</span></span><br><span class="line">        filename = env_get(UPDATE_FILE_ENV);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed, env. variable &#x27;%s&#x27; not found\n&quot;</span>,</span><br><span class="line">                                                        UPDATE_FILE_ENV);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;trying update file &#x27;%s&#x27;\n&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get load address of downloaded update file */</span></span><br><span class="line">        env_addr = env_get(<span class="string">&quot;loadaddr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (env_addr)</span><br><span class="line">                addr = simple_strtoul(env_addr, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                addr = CONFIG_UPDATE_LOAD_ADDR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (update_load(filename, CONFIG_UPDATE_TFTP_MSEC_MAX,</span><br><span class="line">                                        CONFIG_UPDATE_TFTP_CNT_MAX, addr)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t load update file, aborting auto-update\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">got_update_file:</span><br><span class="line">        fit = (<span class="type">void</span> *)addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fit_check_format((<span class="type">void</span> *)fit)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Bad FIT format of the update file, aborting &quot;</span></span><br><span class="line">                                                        <span class="string">&quot;auto-update\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process updates */</span></span><br><span class="line">        images_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);</span><br><span class="line"></span><br><span class="line">        ndepth = <span class="number">0</span>;</span><br><span class="line">        noffset = fdt_next_node(fit, images_noffset, &amp;ndepth);</span><br><span class="line">        <span class="keyword">while</span> (noffset &gt;= <span class="number">0</span> &amp;&amp; ndepth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ndepth != <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">goto</span> next_node;</span><br><span class="line"></span><br><span class="line">                fit_image_name = (<span class="type">char</span> *)fit_get_name(fit, noffset, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Processing update &#x27;%s&#x27; :&quot;</span>, fit_image_name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!fit_image_verify(fit, noffset)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error: invalid update hash, aborting\n&quot;</span>);</span><br><span class="line">                        ret = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">goto</span> next_node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (update_fit_getparams(fit, noffset, &amp;update_addr,</span><br><span class="line">                                        &amp;update_fladdr, &amp;update_size)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error: can&#x27;t get update parameteres, &quot;</span></span><br><span class="line">                                                                <span class="string">&quot;aborting\n&quot;</span>);</span><br><span class="line">                        ret = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">goto</span> next_node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!update_tftp_dfu) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (update_flash(update_addr, update_fladdr,</span><br><span class="line">                                         update_size)) &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;Error: can&#x27;t flash update, aborting\n&quot;</span>);</span><br><span class="line">                                ret = <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">goto</span> next_node;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fit_image_check_type(fit, noffset,</span><br><span class="line">                                                IH_TYPE_FIRMWARE)) &#123;</span><br><span class="line">                        ret = dfu_tftp_write(fit_image_name, update_addr,</span><br><span class="line">                                             update_size, interface, devstring);</span><br><span class="line">                        <span class="keyword">if</span> (ret)</span><br><span class="line">                                <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">next_node:</span><br><span class="line">                noffset = fdt_next_node(fit, noffset, &amp;ndepth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="cli-c"><a href="#cli-c" class="headerlink" title="cli.c"></a>cli.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2000</span></span><br><span class="line"><span class="comment"> * Wolfgang Denk, DENX Software Engineering, wd@denx.de.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Add to readline cmdline-editing by</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2005</span></span><br><span class="line"><span class="comment"> * JinHua Luo, GuangDong Linux Center, &lt;luo.jinhua@gd-linux.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cli.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cli_hush.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fdtdec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMDLINE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Run a command using the selected parser.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param cmd	Command to run</span></span><br><span class="line"><span class="comment"> * @param flag	Execution flags (CMD_FLAG_...)</span></span><br><span class="line"><span class="comment"> * @return 0 on success, or != 0 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">run_command</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_HUSH_PARSER</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cli_run_command can return 0 or 1 for success, so clean up</span></span><br><span class="line"><span class="comment">	 * its result.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cli_simple_run_command(cmd, flag) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> hush_flags = FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; CMD_FLAG_ENV)</span><br><span class="line">		hush_flags |= FLAG_CONT_ON_NEWLINE;</span><br><span class="line">	<span class="keyword">return</span> parse_string_outer(cmd, hush_flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Run a command using the selected parser, and check if it is repeatable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param cmd	Command to run</span></span><br><span class="line"><span class="comment"> * @param flag	Execution flags (CMD_FLAG_...)</span></span><br><span class="line"><span class="comment"> * @return 0 (not repeatable) or 1 (repeatable) on success, -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">run_command_repeatable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_HUSH_PARSER</span></span><br><span class="line">	<span class="keyword">return</span> cli_simple_run_command(cmd, flag);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * parse_string_outer() returns 1 for failure, so clean up</span></span><br><span class="line"><span class="comment">	 * its result.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (parse_string_outer(cmd,</span><br><span class="line">			       FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_CMDLINE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行多个命令eg： bootcmd=nand read.jffs2 0x30007FC0 kernel;bootm 0x30007FC0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">run_command_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> len, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> need_buff = <span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> *buff = (<span class="type">char</span> *)cmd;	<span class="comment">/* cast away const */</span></span><br><span class="line">	<span class="type">int</span> rcode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">		len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUSH_PARSER</span></span><br><span class="line">		<span class="comment">/* hush will never change our string */</span></span><br><span class="line">		need_buff = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">/* the built-in parser will change our string if it sees \n */</span></span><br><span class="line">		need_buff = <span class="built_in">strchr</span>(cmd, <span class="string">&#x27;\n&#x27;</span>) != <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (need_buff) &#123;</span><br><span class="line">		buff = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!buff)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>(buff, cmd, len);	<span class="comment">//复制nand read.jffs2 0x30007FC0 kernel;bootm 0x30007FC0</span></span><br><span class="line">		buff[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//解析命令行</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function will overwrite any \n it sees with a \0, which</span></span><br><span class="line"><span class="comment">	 * is why it can&#x27;t work with a const char *. Here we are making</span></span><br><span class="line"><span class="comment">	 * using of internal knowledge of this function, to avoid always</span></span><br><span class="line"><span class="comment">	 * doing a malloc() which is actually required only in a case that</span></span><br><span class="line"><span class="comment">	 * is pretty rare.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcode = cli_simple_run_command_list(buff, flag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (need_buff)</span><br><span class="line">		<span class="built_in">free</span>(buff);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_RUN)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_run</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> CMD_RET_USAGE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">		<span class="type">char</span> *arg;</span><br><span class="line"></span><br><span class="line">		arg = env_get(argv[i]);</span><br><span class="line">		<span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;## Error: \&quot;%s\&quot; not defined\n&quot;</span>, argv[i]);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (run_command(arg, flag | CMD_FLAG_ENV) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IS_ENABLED(OF_CONTROL)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cli_process_fdt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **cmdp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Allow the fdt to override the boot command */</span></span><br><span class="line">	<span class="type">char</span> *env = fdtdec_get_config_string(gd-&gt;fdt_blob, <span class="string">&quot;bootcmd&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (env)</span><br><span class="line">		*cmdp = env;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the bootsecure option was chosen, use secure_boot_cmd().</span></span><br><span class="line"><span class="comment">	 * Always use &#x27;env&#x27; in this case, since bootsecure requres that the</span></span><br><span class="line"><span class="comment">	 * bootcmd was specified in the FDT too.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> fdtdec_get_config_int(gd-&gt;fdt_blob, <span class="string">&quot;bootsecure&quot;</span>, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Runs the given boot command securely.  Specifically:</span></span><br><span class="line"><span class="comment"> * - Doesn&#x27;t run the command with the shell (run_command or parse_string_outer),</span></span><br><span class="line"><span class="comment"> *   since that&#x27;s a lot of code surface that an attacker might exploit.</span></span><br><span class="line"><span class="comment"> *   Because of this, we don&#x27;t do any argument parsing--the secure boot command</span></span><br><span class="line"><span class="comment"> *   has to be a full-fledged u-boot command.</span></span><br><span class="line"><span class="comment"> * - Doesn&#x27;t check for keypresses before booting, since that could be a</span></span><br><span class="line"><span class="comment"> *   security hole; also disables Ctrl-C.</span></span><br><span class="line"><span class="comment"> * - Doesn&#x27;t allow the command to return.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Upon any failures, this function will drop into an infinite loop after</span></span><br><span class="line"><span class="comment"> * printing the error message to console.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cli_secure_boot_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMDLINE</span></span><br><span class="line">	<span class="type">cmd_tbl_t</span> *cmdtp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;## Error: Secure boot command not specified\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Disable Ctrl-C just in case some command is used that checks it. */</span></span><br><span class="line">	disable_ctrlc(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find the command directly. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMDLINE</span></span><br><span class="line">	cmdtp = find_cmd(cmd);</span><br><span class="line">	<span class="keyword">if</span> (!cmdtp) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;## Error: \&quot;%s\&quot; not defined\n&quot;</span>, cmd);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Run the command, forcing no flags and faking argc and argv. */</span></span><br><span class="line">	rc = (cmdtp-&gt;cmd)(cmdtp, <span class="number">0</span>, <span class="number">1</span>, (<span class="type">char</span> **)&amp;cmd);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	rc = board_run_command(cmd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Shouldn&#x27;t ever return from boot command. */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;## Error: \&quot;%s\&quot; returned (code %d)\n&quot;</span>, cmd, rc);</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Not a whole lot to do here.  Rebooting won&#x27;t help much, since we&#x27;ll</span></span><br><span class="line"><span class="comment">	 * just end up right back here.  Just loop.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hang();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_IS_ENABLED(OF_CONTROL) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cli_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUSH_PARSER</span></span><br><span class="line">	parse_file_outer();</span><br><span class="line">	<span class="comment">/* This point is never reached */</span></span><br><span class="line">	<span class="keyword">for</span> (;;);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMDLINE)</span></span><br><span class="line">	cli_simple_loop();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;## U-Boot command line is disabled. Please enable CONFIG_CMDLINE\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_HUSH_PARSER*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cli_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUSH_PARSER</span></span><br><span class="line">	u_boot_hush_start();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HUSH_INIT_VAR)</span></span><br><span class="line">	hush_init_var();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="cli-simple-c"><a href="#cli-simple-c" class="headerlink" title="cli_simple.c"></a>cli_simple.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2000</span></span><br><span class="line"><span class="comment"> * Wolfgang Denk, DENX Software Engineering, wd@denx.de.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Add to readline cmdline-editing by</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2005</span></span><br><span class="line"><span class="comment"> * JinHua Luo, GuangDong Linux Center, &lt;luo.jinhua@gd-linux.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bootretry.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cli.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PARSER	0	<span class="comment">/* set to 1 to debug */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug_parser(fmt, args...)		\</span></span><br><span class="line"><span class="meta">	debug_cond(DEBUG_PARSER, fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cli_simple_parse_line</span><span class="params">(<span class="type">char</span> *line, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nargs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	debug_parser(<span class="string">&quot;%s: \&quot;%s\&quot;\n&quot;</span>, __func__, line);</span><br><span class="line">	<span class="keyword">while</span> (nargs &lt; CONFIG_SYS_MAXARGS) &#123;</span><br><span class="line">		<span class="comment">/* skip any white space */</span></span><br><span class="line">		<span class="keyword">while</span> (isblank(*line))</span><br><span class="line">			++line;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*line == <span class="string">&#x27;\0&#x27;</span>) &#123;	<span class="comment">/* end of line, no more args	*/</span></span><br><span class="line">			argv[nargs] = <span class="literal">NULL</span>;</span><br><span class="line">			debug_parser(<span class="string">&quot;%s: nargs=%d\n&quot;</span>, __func__, nargs);</span><br><span class="line">			<span class="keyword">return</span> nargs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		argv[nargs++] = line;	<span class="comment">/* begin of argument string	*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find end of string */</span></span><br><span class="line">		<span class="keyword">while</span> (*line &amp;&amp; !isblank(*line))</span><br><span class="line">			++line;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*line == <span class="string">&#x27;\0&#x27;</span>) &#123;	<span class="comment">/* end of line, no more args	*/</span></span><br><span class="line">			argv[nargs] = <span class="literal">NULL</span>;</span><br><span class="line">			debug_parser(<span class="string">&quot;parse_line: nargs=%d\n&quot;</span>, nargs);</span><br><span class="line">			<span class="keyword">return</span> nargs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*line++ = <span class="string">&#x27;\0&#x27;</span>;		<span class="comment">/* terminate current arg	 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;** Too many args (max. %d) **\n&quot;</span>, CONFIG_SYS_MAXARGS);</span><br><span class="line"></span><br><span class="line">	debug_parser(<span class="string">&quot;%s: nargs=%d\n&quot;</span>, __func__, nargs);</span><br><span class="line">	<span class="keyword">return</span> nargs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cli_simple_process_macros</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *input, <span class="type">char</span> *output)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c, prev;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *varname_start = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> inputcnt = <span class="built_in">strlen</span>(input);</span><br><span class="line">	<span class="type">int</span> outputcnt = CONFIG_SYS_CBSIZE;</span><br><span class="line">	<span class="type">int</span> state = <span class="number">0</span>;		<span class="comment">/* 0 = waiting for &#x27;$&#x27;  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1 = waiting for &#x27;(&#x27; or &#x27;&#123;&#x27; */</span></span><br><span class="line">	<span class="comment">/* 2 = waiting for &#x27;)&#x27; or &#x27;&#125;&#x27; */</span></span><br><span class="line">	<span class="comment">/* 3 = waiting for &#x27;&#x27;&#x27;  */</span></span><br><span class="line">	<span class="type">char</span> __maybe_unused *output_start = output;</span><br><span class="line"></span><br><span class="line">	debug_parser(<span class="string">&quot;[PROCESS_MACROS] INPUT len %zd: \&quot;%s\&quot;\n&quot;</span>, <span class="built_in">strlen</span>(input),</span><br><span class="line">		     input);</span><br><span class="line"></span><br><span class="line">	prev = <span class="string">&#x27;\0&#x27;</span>;		<span class="comment">/* previous character   */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (inputcnt &amp;&amp; outputcnt) &#123;</span><br><span class="line">		c = *input++;</span><br><span class="line">		inputcnt--;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (state != <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="comment">/* remove one level of escape characters */</span></span><br><span class="line">			<span class="keyword">if</span> ((c == <span class="string">&#x27;\\&#x27;</span>) &amp;&amp; (prev != <span class="string">&#x27;\\&#x27;</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (inputcnt-- == <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				prev = c;</span><br><span class="line">				c = *input++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:	<span class="comment">/* Waiting for (unescaped) $    */</span></span><br><span class="line">			<span class="keyword">if</span> ((c == <span class="string">&#x27;\&#x27;&#x27;</span>) &amp;&amp; (prev != <span class="string">&#x27;\\&#x27;</span>)) &#123;</span><br><span class="line">				state = <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((c == <span class="string">&#x27;$&#x27;</span>) &amp;&amp; (prev != <span class="string">&#x27;\\&#x27;</span>)) &#123;</span><br><span class="line">				state++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				*(output++) = c;</span><br><span class="line">				outputcnt--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:	<span class="comment">/* Waiting for (        */</span></span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">				state++;</span><br><span class="line">				varname_start = input;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				state = <span class="number">0</span>;</span><br><span class="line">				*(output++) = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">				outputcnt--;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (outputcnt) &#123;</span><br><span class="line">					*(output++) = c;</span><br><span class="line">					outputcnt--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:	<span class="comment">/* Waiting for )        */</span></span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">				<span class="type">int</span> i;</span><br><span class="line">				<span class="type">char</span> envname[CONFIG_SYS_CBSIZE], *envval;</span><br><span class="line">				<span class="comment">/* Varname # of chars */</span></span><br><span class="line">				<span class="type">int</span> envcnt = input - varname_start - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Get the varname */</span></span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; envcnt; i++)</span><br><span class="line">					envname[i] = varname_start[i];</span><br><span class="line">				envname[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Get its value */</span></span><br><span class="line">				envval = env_get(envname);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Copy into the line if it exists */</span></span><br><span class="line">				<span class="keyword">if</span> (envval != <span class="literal">NULL</span>)</span><br><span class="line">					<span class="keyword">while</span> ((*envval) &amp;&amp; outputcnt) &#123;</span><br><span class="line">						*(output++) = *(envval++);</span><br><span class="line">						outputcnt--;</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="comment">/* Look for another &#x27;$&#x27; */</span></span><br><span class="line">				state = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:	<span class="comment">/* Waiting for &#x27;        */</span></span><br><span class="line">			<span class="keyword">if</span> ((c == <span class="string">&#x27;\&#x27;&#x27;</span>) &amp;&amp; (prev != <span class="string">&#x27;\\&#x27;</span>)) &#123;</span><br><span class="line">				state = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				*(output++) = c;</span><br><span class="line">				outputcnt--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		prev = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (outputcnt)</span><br><span class="line">		*output = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*(output - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	debug_parser(<span class="string">&quot;[PROCESS_MACROS] OUTPUT len %zd: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		     <span class="built_in">strlen</span>(output_start), output_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARNING:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We must create a temporary copy of the command since the command we get</span></span><br><span class="line"><span class="comment"> * may be the result from env_get(), which returns a pointer directly to</span></span><br><span class="line"><span class="comment"> * the environment data, which may change magicly when the command we run</span></span><br><span class="line"><span class="comment"> * creates or modifies environment variables (like &quot;bootp&quot; does).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//执行命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cli_simple_run_command</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> cmdbuf[CONFIG_SYS_CBSIZE];	<span class="comment">/* working copy of cmd		*/</span></span><br><span class="line">	<span class="type">char</span> *token;			<span class="comment">/* start of token in cmdbuf	*/</span></span><br><span class="line">	<span class="type">char</span> *sep;			<span class="comment">/* end of token (separator) in cmdbuf */</span></span><br><span class="line">	<span class="type">char</span> finaltoken[CONFIG_SYS_CBSIZE];</span><br><span class="line">	<span class="type">char</span> *str = cmdbuf;</span><br><span class="line">	<span class="type">char</span> *argv[CONFIG_SYS_MAXARGS + <span class="number">1</span>];	<span class="comment">/* NULL terminated	*/</span></span><br><span class="line">	<span class="type">int</span> argc, inquotes;</span><br><span class="line">	<span class="type">int</span> repeatable = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	debug_parser(<span class="string">&quot;[RUN_COMMAND] cmd[%p]=\&quot;&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">if</span> (DEBUG_PARSER) &#123;</span><br><span class="line">		<span class="comment">/* use puts - string may be loooong */</span></span><br><span class="line">		<span class="built_in">puts</span>(cmd ? cmd : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;\&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	clear_ctrlc();		<span class="comment">/* forget any previous Control C */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cmd || !*cmd)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* empty command */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(cmd) &gt;= CONFIG_SYS_CBSIZE) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;## Command too long!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//复制下命令字符串、有的字符串可能直接来自环境变量</span></span><br><span class="line">	<span class="built_in">strcpy</span>(cmdbuf, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Process separators and check for invalid</span></span><br><span class="line"><span class="comment">	 * repeatable commands</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	debug_parser(<span class="string">&quot;[PROCESS_SEPARATORS] %s\n&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">while</span> (*str) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Find separator, or string end</span></span><br><span class="line"><span class="comment">		 * Allow simple escape of &#x27;;&#x27; by writing &quot;\;&quot;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (inquotes = <span class="number">0</span>, sep = str; *sep; sep++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*sep == <span class="string">&#x27;\&#x27;&#x27;</span>) &amp;&amp;</span><br><span class="line">			    (*(sep - <span class="number">1</span>) != <span class="string">&#x27;\\&#x27;</span>))</span><br><span class="line">				inquotes = !inquotes;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!inquotes &amp;&amp;</span><br><span class="line">			    (*sep == <span class="string">&#x27;;&#x27;</span>) &amp;&amp;	<span class="comment">/* separator		*/</span></span><br><span class="line">			    (sep != str) &amp;&amp;	<span class="comment">/* past string start	*/</span></span><br><span class="line">			    (*(sep - <span class="number">1</span>) != <span class="string">&#x27;\\&#x27;</span>))	<span class="comment">/* and NOT escaped */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Limit the token to data between separators</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		token = str;</span><br><span class="line">		<span class="keyword">if</span> (*sep) &#123;</span><br><span class="line">			str = sep + <span class="number">1</span>;	<span class="comment">/* start of command for next pass */</span></span><br><span class="line">			*sep = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			str = sep;	<span class="comment">/* no more commands for next pass */</span></span><br><span class="line">		&#125;</span><br><span class="line">		debug_parser(<span class="string">&quot;token: \&quot;%s\&quot;\n&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* find macros in this token and replace them */</span></span><br><span class="line">		cli_simple_process_macros(token, finaltoken);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Extract arguments */</span></span><br><span class="line">        <span class="comment">//提取参数</span></span><br><span class="line">		argc = cli_simple_parse_line(finaltoken, argv);</span><br><span class="line">		<span class="keyword">if</span> (argc == <span class="number">0</span>) &#123;</span><br><span class="line">			rc = <span class="number">-1</span>;	<span class="comment">/* no command at all */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//执行命令</span></span><br><span class="line">		<span class="keyword">if</span> (cmd_process(flag, argc, argv, &amp;repeatable, <span class="literal">NULL</span>))</span><br><span class="line">			rc = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Did the user stop this? */</span></span><br><span class="line">		<span class="keyword">if</span> (had_ctrlc())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* if stopped then not repeatable */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc ? rc : repeatable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cli_simple_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> lastcommand[CONFIG_SYS_CBSIZE + <span class="number">1</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* Saw enough of a valid command to</span></span><br><span class="line"><span class="comment">			 * restart the timeout.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bootretry_reset_cmd_timeout();</span><br><span class="line">		&#125;</span><br><span class="line">		len = cli_readline(CONFIG_SYS_PROMPT);</span><br><span class="line"></span><br><span class="line">		flag = <span class="number">0</span>;	<span class="comment">/* assume no special flags for now */</span></span><br><span class="line">		<span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">			strlcpy(lastcommand, console_buffer,</span><br><span class="line">				CONFIG_SYS_CBSIZE + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">			flag |= CMD_FLAG_REPEAT;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOOT_RETRY_TIME</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="comment">/* -2 means timed out, retry autoboot</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;\nTimed out waiting for command\n&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_RESET_TO_RETRY</span></span><br><span class="line">			<span class="comment">/* Reinit board to run initialization code again */</span></span><br><span class="line">			do_reset(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">			<span class="keyword">return</span>;		<span class="comment">/* retry autoboot */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&lt;INTERRUPT&gt;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rc = run_command_repeatable(lastcommand, flag);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* invalid command or not repeatable, forget it */</span></span><br><span class="line">			lastcommand[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cli_simple_run_command_list</span><span class="params">(<span class="type">char</span> *cmd, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *line, *next;</span><br><span class="line">	<span class="type">int</span> rcode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Break into individual lines, and execute each line; terminate on</span></span><br><span class="line"><span class="comment">	 * error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	next = cmd;</span><br><span class="line">	line = cmd;</span><br><span class="line">	<span class="keyword">while</span> (*next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*next == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">			*next = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="comment">/* run only non-empty commands */</span></span><br><span class="line">			<span class="keyword">if</span> (*line) &#123;</span><br><span class="line">				debug(<span class="string">&quot;** exec: \&quot;%s\&quot;\n&quot;</span>, line);</span><br><span class="line">                	<span class="comment">//执行命令</span></span><br><span class="line">				<span class="keyword">if</span> (cli_simple_run_command(line, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					rcode = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			line = next + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rcode == <span class="number">0</span> &amp;&amp; *line)</span><br><span class="line">		rcode = (cli_simple_run_command(line, <span class="number">0</span>) &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="cmd-process"><a href="#cmd-process" class="headerlink" title="cmd_process"></a>cmd_process</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">cmd_tbl_t</span> *<span class="title function_">find_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">cmd_tbl_t</span> *start = ll_entry_start(<span class="type">cmd_tbl_t</span>, cmd);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = ll_entry_count(<span class="type">cmd_tbl_t</span>, cmd);</span><br><span class="line">        <span class="keyword">return</span> find_cmd_tbl(cmd, start, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="type">command_ret_t</span> <span class="title function_">cmd_process</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> *repeatable, ulong *ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">command_ret_t</span> <span class="title">rc</span> =</span> CMD_RET_SUCCESS;</span><br><span class="line">        <span class="type">cmd_tbl_t</span> *cmdtp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Look up command in command table */</span></span><br><span class="line">        cmdtp = find_cmd(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (cmdtp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27; - try &#x27;help&#x27;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* found - check max args */</span></span><br><span class="line">        <span class="keyword">if</span> (argc &gt; cmdtp-&gt;maxargs)</span><br><span class="line">                rc = CMD_RET_USAGE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_BOOTD)</span></span><br><span class="line">        <span class="comment">/* avoid &quot;bootd&quot; recursion */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmdtp-&gt;cmd == do_bootd) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag &amp; CMD_FLAG_BOOTD) &#123;</span><br><span class="line">                        <span class="built_in">puts</span>(<span class="string">&quot;&#x27;bootd&#x27; recursion detected\n&quot;</span>);</span><br><span class="line">                        rc = CMD_RET_FAILURE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        flag |= CMD_FLAG_BOOTD;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If OK so far, then do the command */</span></span><br><span class="line">        <span class="keyword">if</span> (!rc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticks)</span><br><span class="line">                        *ticks = get_timer(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">                rc = cmd_call(cmdtp, flag, argc, argv);	<span class="comment">//(cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);</span></span><br><span class="line">                <span class="keyword">if</span> (ticks)</span><br><span class="line">                        *ticks = get_timer(*ticks);</span><br><span class="line">                *repeatable &amp;= cmdtp-&gt;repeatable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc == CMD_RET_USAGE)</span><br><span class="line">                rc = cmd_usage(cmdtp);	<span class="comment">//打印帮助信息</span></span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="find-cmd-tbl"><a href="#find-cmd-tbl" class="headerlink" title="find_cmd_tbl"></a>find_cmd_tbl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* find command table entry for a command */</span></span><br><span class="line"><span class="type">cmd_tbl_t</span> *<span class="title function_">find_cmd_tbl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">cmd_tbl_t</span> *table, <span class="type">int</span> table_len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMDLINE</span></span><br><span class="line">        <span class="type">cmd_tbl_t</span> *cmdtp;</span><br><span class="line">        <span class="type">cmd_tbl_t</span> *cmdtp_temp = table;  <span class="comment">/* Init value */</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> n_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cmd)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Some commands allow length modifiers (like &quot;cp.b&quot;);</span></span><br><span class="line"><span class="comment">         * compare command name only until first dot.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        len = ((p = <span class="built_in">strchr</span>(cmd, <span class="string">&#x27;.&#x27;</span>)) == <span class="literal">NULL</span>) ? <span class="built_in">strlen</span> (cmd) : (p - cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (cmdtp = table; cmdtp != table + table_len; cmdtp++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmd, cmdtp-&gt;name, len) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (len == <span class="built_in">strlen</span>(cmdtp-&gt;name))</span><br><span class="line">                                <span class="keyword">return</span> cmdtp;   <span class="comment">/* full match */</span></span><br><span class="line"></span><br><span class="line">                        cmdtp_temp = cmdtp;     <span class="comment">/* abbreviated command ? */</span></span><br><span class="line">                        n_found++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n_found == <span class="number">1</span>) &#123;                     <span class="comment">/* exactly one match */</span></span><br><span class="line">                <span class="keyword">return</span> cmdtp_temp;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_CMDLINE */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">/* not found or ambiguous command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="bootcmd"><a href="#bootcmd" class="headerlink" title="bootcmd"></a>bootcmd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootcmd=run setargs_mmc boot_normal</span><br></pre></td></tr></table></figure>

<p>设置kernel启动的参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setargs_mmc=setenv  bootargs earlyprintk=<span class="variable">$&#123;earlyprintk&#125;</span> clk_ignore_unused initcall_debug=<span class="variable">$&#123;initcall_debug&#125;</span> console=<span class="variable">$&#123;console&#125;</span> loglevel=<span class="variable">$&#123;loglevel&#125;</span> root=<span class="variable">$&#123;mmc_root&#125;</span>  init=<span class="variable">$&#123;init&#125;</span> partitions=<span class="variable">$&#123;partitions&#125;</span> cma=<span class="variable">$&#123;cma&#125;</span> snum=<span class="variable">$&#123;snum&#125;</span> mac_addr=<span class="variable">$&#123;mac&#125;</span> wifi_mac=<span class="variable">$&#123;wifi_mac&#125;</span> bt_mac=<span class="variable">$&#123;bt_mac&#125;</span> selinux=<span class="variable">$&#123;selinux&#125;</span> specialstr=<span class="variable">$&#123;specialstr&#125;</span> gpt=1</span><br></pre></td></tr></table></figure>



<p>从flash读取内核镜像到内存、并跳转到内核</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_normal=sunxi_flash <span class="built_in">read</span> 45000000 boot;bootm 45000000</span><br></pre></td></tr></table></figure>



<p>boot_normal命令有两个子命令：</p>
<ul>
<li>从flash中的boot分区读取kernel镜像到内存的0x45000000地址；</li>
<li>从内存0x45000000处启动内核</li>
</ul>
<h4 id="do-sunxi-flash"><a href="#do-sunxi-flash" class="headerlink" title="do_sunxi_flash"></a>do_sunxi_flash</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_sunxi_flash</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">disk_partition_t</span> info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ulong load_addr;</span><br><span class="line">	ulong load_size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *cmd;</span><br><span class="line">	<span class="type">char</span> *part_name;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* at least four arguments please */</span></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">goto</span> usage;</span><br><span class="line">	<span class="comment">//ARGV[1] = read ARGV[2] = 45000000 ARGV[3] = boot (ARGV[5] = SIZE)</span></span><br><span class="line">	cmd       = argv[<span class="number">1</span>];</span><br><span class="line">	part_name = argv[<span class="number">3</span>];</span><br><span class="line">	<span class="comment">//解析参数</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmd, <span class="string">&quot;read&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;read&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">		load_addr = (ulong)simple_strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">		<span class="keyword">if</span> (argc == <span class="number">5</span>)</span><br><span class="line">			load_size = (ulong)simple_strtoul(argv[<span class="number">4</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">		env_set(<span class="string">&quot;boot_from_partion&quot;</span>, part_name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> usage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	desc = blk_get_devnum_by_typename(<span class="string">&quot;sunxi_flash&quot;</span>, <span class="number">0</span>);	<span class="comment">//获取块设备描述符</span></span><br><span class="line">	<span class="keyword">if</span> (desc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	ret = sunxi_flash_try_partition(desc, part_name, &amp;info);	<span class="comment">//part_get_info(desc, i, info); 获取分区信息</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	pr_msg(<span class="string">&quot;partinfo: name %s, start 0x%lx, size 0x%lx\n&quot;</span>, info.name,</span><br><span class="line">	       info.start, info.size);</span><br><span class="line">    <span class="comment">//读取flash中的内核到内存指定地址</span></span><br><span class="line">	<span class="keyword">return</span> sunxi_flash_read_part(desc, &amp;info, load_addr, load_size);</span><br><span class="line"></span><br><span class="line">usage:</span><br><span class="line">	<span class="keyword">return</span> cmd_usage(cmdtp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(sunxi_flash, <span class="number">6</span>, <span class="number">1</span>, do_sunxi_flash, <span class="string">&quot;sunxi_flash sub-system&quot;</span>,</span><br><span class="line">	   <span class="string">&quot;sunxi_flash read mem_addr part_name [size]\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="part-get-info"><a href="#part-get-info" class="headerlink" title="part_get_info"></a>part_get_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">part_get_info</span><span class="params">(<span class="keyword">struct</span> blk_desc *dev_desc, <span class="type">int</span> part,</span></span><br><span class="line"><span class="params">                       <span class="type">disk_partition_t</span> *info)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_BLOCK_DEVICE</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">part_driver</span> *<span class="title">drv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IS_ENABLED(PARTITION_UUIDS)</span></span><br><span class="line">        <span class="comment">/* The common case is no UUID support */</span></span><br><span class="line">        info-&gt;uuid[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PARTITION_TYPE_GUID</span></span><br><span class="line">        info-&gt;type_guid[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        drv = part_driver_lookup_type(dev_desc);</span><br><span class="line">        <span class="keyword">if</span> (!drv) &#123;</span><br><span class="line">                debug(<span class="string">&quot;## Unknown partition table type %x\n&quot;</span>,</span><br><span class="line">                      dev_desc-&gt;part_type);</span><br><span class="line">                <span class="keyword">return</span> -EPROTONOSUPPORT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!drv-&gt;get_info) &#123;</span><br><span class="line">                PRINTF(<span class="string">&quot;## Driver %s does not have the get_info() method\n&quot;</span>,</span><br><span class="line">                       drv-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drv-&gt;get_info(dev_desc, part, info) == <span class="number">0</span>) &#123;		<span class="comment">//part_get_info_extended</span></span><br><span class="line">                PRINTF(<span class="string">&quot;## Valid %s partition found ##\n&quot;</span>, drv-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HAVE_BLOCK_DEVICE */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> part_driver *<span class="title function_">part_driver_lookup_type</span><span class="params">(<span class="keyword">struct</span> blk_desc *dev_desc)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">part_driver</span> *<span class="title">drv</span> =</span></span><br><span class="line">                ll_entry_start(<span class="keyword">struct</span> part_driver, part_driver);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n_ents = ll_entry_count(<span class="keyword">struct</span> part_driver, part_driver);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">part_driver</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev_desc-&gt;part_type == PART_TYPE_UNKNOWN) &#123;</span><br><span class="line">                <span class="keyword">for</span> (entry = drv; entry != drv + n_ents; entry++) &#123;</span><br><span class="line">                        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">                        ret = entry-&gt;test(dev_desc);</span><br><span class="line">                        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                                dev_desc-&gt;part_type = entry-&gt;part_type;</span><br><span class="line">                                <span class="keyword">return</span> entry;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (entry = drv; entry != drv + n_ents; entry++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dev_desc-&gt;part_type == entry-&gt;part_type)</span><br><span class="line">                                <span class="keyword">return</span> entry;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Not found */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="sunxi-flash-read-part"><a href="#sunxi-flash-read-part" class="headerlink" title="sunxi_flash_read_part"></a>sunxi_flash_read_part</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sunxi_flash_read_part</span><span class="params">(<span class="keyword">struct</span> blk_desc *desc, <span class="type">disk_partition_t</span> *info,</span></span><br><span class="line"><span class="params">				 ulong buffer, ulong load_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	u32 rbytes, rblock, testblock;</span><br><span class="line">	u32 start_block;</span><br><span class="line">	u8 *addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">andr_img_hdr</span> *<span class="title">fb_hdr</span>;</span></span><br><span class="line">	<span class="type">image_header_t</span> *uz_hdr;</span><br><span class="line"></span><br><span class="line">	addr	= (<span class="type">void</span> *)buffer;</span><br><span class="line">	start_block = (uint)info-&gt;start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取第一块数据</span></span><br><span class="line">	testblock = SUNXI_FLASH_READ_FIRST_SIZE / <span class="number">512</span>;</span><br><span class="line">	ret       = blk_dread(desc, start_block, testblock, (u_char *)buffer);</span><br><span class="line">	<span class="keyword">if</span> (ret != testblock) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fb_hdr = (<span class="keyword">struct</span> andr_img_hdr *)addr;	<span class="comment">//fb_hdr = first block header addr</span></span><br><span class="line">	uz_hdr = (<span class="type">image_header_t</span> *)addr;</span><br><span class="line">    <span class="comment">//是否指定了加载内核的大小。一般是没指定</span></span><br><span class="line">	<span class="keyword">if</span> (load_size)</span><br><span class="line">		rbytes = load_size;</span><br><span class="line">    <span class="comment">//比较内核首部的magic，并计算需要读取的数据大小</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(fb_hdr-&gt;magic, ANDR_BOOT_MAGIC, <span class="number">8</span>)) &#123;</span><br><span class="line">		rbytes = android_image_get_end(fb_hdr) - (ulong)fb_hdr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*secure boot img may attached with an embbed cert*/</span></span><br><span class="line">		rbytes += sunxi_boot_image_get_embbed_cert_len(fb_hdr);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (image_check_magic(uz_hdr))</span><br><span class="line">		rbytes = image_get_data_size(uz_hdr) + image_get_header_size();</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		debug(<span class="string">&quot;bad boot image magic, maybe not a boot.img?\n&quot;</span>);</span><br><span class="line">		rbytes = info-&gt;size * <span class="number">512</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算需要读取的块数量</span></span><br><span class="line">	rblock = (rbytes + <span class="number">511</span>) / <span class="number">512</span> - testblock;</span><br><span class="line">	start_block += testblock;</span><br><span class="line">	addr += SUNXI_FLASH_READ_FIRST_SIZE;	<span class="comment">//跳过一段地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取接下来的全部数据</span></span><br><span class="line">	ret = blk_dread(desc, start_block, rblock, (u_char *)addr);</span><br><span class="line">	ret = (ret == rblock) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;sunxi flash read :offset %x, %d bytes %s\n&quot;</span>, (u32)info-&gt;start,</span><br><span class="line">	      rbytes, ret == <span class="number">0</span> ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="do-bootm"><a href="#do-bootm" class="headerlink" title="do_bootm"></a>do_bootm</h3><p>bootm命令会调用do_bootm函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> relocated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!relocated) &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* relocate names of sub-command table */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(cmd_bootm_sub); i++)</span><br><span class="line">			cmd_bootm_sub[i].name += gd-&gt;reloc_off;</span><br><span class="line"></span><br><span class="line">		relocated = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//安卓的boot需要校验os</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SUNXI_ANDROID_BOOT</span></span><br><span class="line">	<span class="keyword">if</span> (sunxi_android_boot(env_get(<span class="string">&quot;boot_from_partion&quot;</span>),</span><br><span class="line">			       simple_strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>))) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全启动相关</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SUNXI_SECURE_BOOT</span></span><br><span class="line">	<span class="comment">/* verify image before booting in secure boot*/</span></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;securemode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_SUNXI_PART_VERIFY</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sunxi_image_verify_pattern_st</span> <span class="title">verify_pattern</span> =</span> &#123;</span><br><span class="line">			<span class="number">0x1000</span>, <span class="number">0x100000</span>, <span class="number">-1</span></span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">//签名校验一些指定的东西？？</span></span><br><span class="line">		<span class="keyword">if</span> (sunxi_verify_partion(&amp;verify_pattern, <span class="string">&quot;rootfs&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_SUNXI_PART_VERIFY*/</span></span></span><br><span class="line">		<span class="comment">//对内核签名认证</span></span><br><span class="line">		<span class="keyword">if</span> (sunxi_verify_os(simple_strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>),</span><br><span class="line">				    env_get(<span class="string">&quot;boot_from_partion&quot;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_SUNXI_SECURE_BOOT*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_SUNXI_ANDROID_BOOT*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_SUNXI_INITRD_ROUTINE</span></span><br><span class="line">	sunxi_update_initrd(simple_strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* determine if we have a sub command 这里一般没有子命令*/</span></span><br><span class="line">	argc--; argv++;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">char</span> *endp;</span><br><span class="line"></span><br><span class="line">		simple_strtoul(argv[<span class="number">0</span>], &amp;endp, <span class="number">16</span>);</span><br><span class="line">		<span class="comment">/* endp pointing to NULL means that argv[0] was just a</span></span><br><span class="line"><span class="comment">		 * valid number, pass it along to the normal bootm processing</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If endp is &#x27;:&#x27; or &#x27;#&#x27; assume a FIT identifier so pass</span></span><br><span class="line"><span class="comment">		 * along for normal processing.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Right now we assume the first arg should never be &#x27;-&#x27;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((*endp != <span class="number">0</span>) &amp;&amp; (*endp != <span class="string">&#x27;:&#x27;</span>) &amp;&amp; (*endp != <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">			<span class="keyword">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);</span><br><span class="line">	&#125;</span><br><span class="line">	update_bootargs();</span><br><span class="line">    <span class="comment">//调用do_bootm_states根据states来启动内核</span></span><br><span class="line">	<span class="keyword">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |</span><br><span class="line">		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |</span><br><span class="line">		BOOTM_STATE_LOADOS |</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SUNXI_INITRD_ROUTINE</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line">		BOOTM_STATE_RAMDISK |</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_PPC) || defined(CONFIG_MIPS)</span></span><br><span class="line">		BOOTM_STATE_OS_CMDLINE |</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class="line">		BOOTM_STATE_OS_GO, &amp;images, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bootm_maybe_autostart</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">const</span> <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ep = env_get(<span class="string">&quot;autostart&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ep &amp;&amp; !<span class="built_in">strcmp</span>(ep, <span class="string">&quot;yes&quot;</span>)) &#123;</span><br><span class="line">		<span class="type">char</span> *local_args[<span class="number">2</span>];</span><br><span class="line">		local_args[<span class="number">0</span>] = (<span class="type">char</span> *)cmd;</span><br><span class="line">		local_args[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Automatic boot of image at addr 0x%08lX ...\n&quot;</span>, load_addr);</span><br><span class="line">		<span class="keyword">return</span> do_bootm(cmdtp, <span class="number">0</span>, <span class="number">1</span>, local_args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="do-bootm-states"><a href="#do-bootm-states" class="headerlink" title="do_bootm_states"></a>do_bootm_states</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_states</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">		    <span class="type">int</span> states, <span class="type">bootm_headers_t</span> *images, <span class="type">int</span> boot_progress)</span></span><br><span class="line">&#123;</span><br><span class="line">	boot_os_fn *boot_fn;</span><br><span class="line">	ulong iflag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>, need_boot_fn;</span><br><span class="line"></span><br><span class="line">	images-&gt;state |= states;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Work through the states and see how far we get. We stop on</span></span><br><span class="line"><span class="comment">	 * any error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">//初始images结构体</span></span><br><span class="line">	<span class="keyword">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class="line">		ret = bootm_start(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析kernel首部数据</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class="line">		ret = bootm_find_os(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER))</span><br><span class="line">		ret = bootm_find_other(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Load the OS */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) &#123;</span><br><span class="line">		ulong load_end;</span><br><span class="line"></span><br><span class="line">		iflag = bootm_disable_interrupts();</span><br><span class="line">		ret = bootm_load_os(images, &amp;load_end, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			<span class="comment">//lmb保留内存</span></span><br><span class="line">			lmb_reserve(&amp;images-&gt;lmb, images-&gt;os.load,</span><br><span class="line">				    (load_end - images-&gt;os.load));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret &amp;&amp; ret != BOOTM_ERR_OVERLAP)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_OVERLAP)</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Relocate the ramdisk 重定位ramdisk*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) &#123;</span><br><span class="line">		ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class="line"></span><br><span class="line">		ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class="line">			rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);</span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">			env_set_hex(<span class="string">&quot;initrd_start&quot;</span>, images-&gt;initrd_start);</span><br><span class="line">			env_set_hex(<span class="string">&quot;initrd_end&quot;</span>, images-&gt;initrd_end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IMAGE_ENABLE_OF_LIBFDT &amp;&amp; defined(CONFIG_LMB)</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) &#123;</span><br><span class="line">        <span class="comment">//将fdt设置为reverse</span></span><br><span class="line">		boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class="line">        <span class="comment">//重定位fdt到lmb</span></span><br><span class="line">		ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class="line">					&amp;images-&gt;ft_len);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* From now on, we need the OS boot function */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">//获取特定os的boot函数：do_bootm_linux</span></span><br><span class="line">	boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class="line">	need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |</span><br><span class="line">			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |</span><br><span class="line">			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);</span><br><span class="line">	<span class="keyword">if</span> (boot_fn == <span class="literal">NULL</span> &amp;&amp; need_boot_fn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iflag)</span><br><span class="line">			enable_interrupts();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: booting os &#x27;%s&#x27; (%d) is not supported\n&quot;</span>,</span><br><span class="line">		       genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//跳转到内核</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call various other states that are not generally used */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SILENT_CONSOLE) &amp;&amp; !defined(CONFIG_SILENT_U_BOOT_ONLY)</span></span><br><span class="line">		<span class="keyword">if</span> (images-&gt;os.os == IH_OS_LINUX)</span><br><span class="line">			fixup_silent_linux();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="comment">/* Pretend to run the OS, then run a user command */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		<span class="type">char</span> *cmd_list = env_get(<span class="string">&quot;fakegocmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line">		<span class="keyword">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class="line">			ret = run_command_list(cmd_list, <span class="number">-1</span>, flag);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for unsupported subcommand. */</span></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;subcommand not supported\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now run the OS! We hope this doesn&#x27;t return */</span></span><br><span class="line">	<span class="comment">//跳转到内核do_bootm_linux()</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))</span><br><span class="line">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Deal with any fallout */</span></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (iflag)</span><br><span class="line">		enable_interrupts();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == BOOTM_ERR_UNIMPLEMENTED)</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_RESET)</span><br><span class="line">		do_reset(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="bootm-find-os"><a href="#bootm-find-os" class="headerlink" title="bootm_find_os"></a>bootm_find_os</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析kernel首部 得到kernel的类型、压缩类型、加载地址、入口地址等信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bootm_find_os</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">			 <span class="type">char</span> * <span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *os_hdr;</span><br><span class="line">	<span class="type">bool</span> ep_found = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get kernel image header, start address and length */</span></span><br><span class="line">	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,</span><br><span class="line">			&amp;images, &amp;images.os.image_start, &amp;images.os.image_len);</span><br><span class="line">	<span class="keyword">if</span> (images.os.image_len == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;ERROR: can&#x27;t get kernel image!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get image parameters */</span></span><br><span class="line">	<span class="keyword">switch</span> (genimg_get_format(os_hdr)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IMAGE_FORMAT_LEGACY)</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_LEGACY:</span><br><span class="line">		images.os.type = image_get_type(os_hdr);</span><br><span class="line">		images.os.comp = image_get_comp(os_hdr);</span><br><span class="line">		images.os.os = image_get_os(os_hdr);</span><br><span class="line"></span><br><span class="line">		images.os.end = image_get_image_end(os_hdr);</span><br><span class="line">		images.os.load = image_get_load(os_hdr);</span><br><span class="line">		images.os.arch = image_get_arch(os_hdr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IMAGE_ENABLE_FIT</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_FIT:</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_type(images.fit_hdr_os,</span><br><span class="line">				       images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.type)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t get image type!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_TYPE);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_comp(images.fit_hdr_os,</span><br><span class="line">				       images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.comp)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t get image compression!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_COMPRESSION);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_os(images.fit_hdr_os, images.fit_noffset_os,</span><br><span class="line">				     &amp;images.os.os)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t get image OS!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_OS);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_arch(images.fit_hdr_os,</span><br><span class="line">				       images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.arch)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t get image ARCH!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		images.os.end = fit_get_end(images.fit_hdr_os);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_load(images.fit_hdr_os, images.fit_noffset_os,</span><br><span class="line">				       &amp;images.os.load)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t get image load address!\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_LOADADDR);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ANDROID_BOOT_IMAGE</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_ANDROID:</span><br><span class="line">		images.os.type = IH_TYPE_KERNEL;</span><br><span class="line">		images.os.comp = IH_COMP_NONE;</span><br><span class="line">		images.os.os = IH_OS_LINUX;</span><br><span class="line"></span><br><span class="line">		images.os.end = android_image_get_end(os_hdr);</span><br><span class="line">		images.os.load = android_image_get_kload(os_hdr);</span><br><span class="line">		images.ep = images.os.load;</span><br><span class="line">		ep_found = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;ERROR: unknown image format type!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we have a valid setup.bin, we will use that for entry (x86) */</span></span><br><span class="line">	<span class="keyword">if</span> (images.os.arch == IH_ARCH_I386 ||</span><br><span class="line">	    images.os.arch == IH_ARCH_X86_64) &#123;</span><br><span class="line">		ulong len;</span><br><span class="line"></span><br><span class="line">		ret = boot_get_setup(&amp;images, IH_ARCH_I386, &amp;images.ep, &amp;len);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Could not find a valid setup.bin for x86\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Kernel entry point is the setup.bin */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images.legacy_hdr_valid) &#123;</span><br><span class="line">		images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IMAGE_ENABLE_FIT</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images.fit_uname_os) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		ret = fit_image_get_entry(images.fit_hdr_os,</span><br><span class="line">					  images.fit_noffset_os, &amp;images.ep);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Can&#x27;t get entry point property!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ep_found) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Could not find kernel entry point!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (images.os.type == IH_TYPE_KERNEL_NOLOAD) &#123;</span><br><span class="line">		images.os.load = images.os.image_start;</span><br><span class="line">		images.ep += images.os.load;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	images.os.start = map_to_sysmem(os_hdr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="bootm-load-os"><a href="#bootm-load-os" class="headerlink" title="bootm_load_os"></a>bootm_load_os</h4><p>将镜像解压到加载地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bootm_load_os</span><span class="params">(<span class="type">bootm_headers_t</span> *images, <span class="type">unsigned</span> <span class="type">long</span> *load_end,</span></span><br><span class="line"><span class="params">			 <span class="type">int</span> boot_progress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">image_info_t</span> os = images-&gt;os;</span><br><span class="line">	ulong load = os.load;</span><br><span class="line">	ulong blob_start = os.start;</span><br><span class="line">	ulong blob_end = os.end;</span><br><span class="line">	ulong image_start = os.image_start;</span><br><span class="line">	ulong image_len = os.image_len;</span><br><span class="line">	ulong flush_start = ALIGN_DOWN(load, ARCH_DMA_MINALIGN);</span><br><span class="line">	ulong flush_len = *load_end - load;</span><br><span class="line">	<span class="type">bool</span> no_overlap;</span><br><span class="line">	<span class="type">void</span> *load_buf, *image_buf;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	load_buf = map_sysmem(load, <span class="number">0</span>);</span><br><span class="line">	image_buf = map_sysmem(os.image_start, image_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将镜像解压到加载地址</span></span><br><span class="line">	err = bootm_decomp_image(os.comp, load, os.image_start, os.type,</span><br><span class="line">				 load_buf, image_buf, image_len,</span><br><span class="line">				 CONFIG_SYS_BOOTM_LEN, load_end);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flush_start &lt; load)</span><br><span class="line">		flush_len += load - flush_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//刷新flash</span></span><br><span class="line">	flush_cache(flush_start, ALIGN(flush_len, ARCH_DMA_MINALIGN));</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;   kernel loaded at 0x%08lx, end = 0x%08lx\n&quot;</span>, load, *load_end);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查加载的内核</span></span><br><span class="line">	no_overlap = (os.comp == IH_COMP_NONE &amp;&amp; load == image_start);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!no_overlap &amp;&amp; (load &lt; blob_end) &amp;&amp; (*load_end &gt; blob_start)) &#123;</span><br><span class="line">		debug(<span class="string">&quot;images.os.start = 0x%lX, images.os.end = 0x%lx\n&quot;</span>,</span><br><span class="line">		      blob_start, blob_end);</span><br><span class="line">		debug(<span class="string">&quot;images.os.load = 0x%lx, load_end = 0x%lx\n&quot;</span>, load,</span><br><span class="line">		      *load_end);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check what type of image this is. */</span></span><br><span class="line">		<span class="keyword">if</span> (images-&gt;legacy_hdr_valid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (image_get_type(&amp;images-&gt;legacy_hdr_os_copy)</span><br><span class="line">					== IH_TYPE_MULTI)</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">&quot;WARNING: legacy format multi component image overwritten\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> BOOTM_ERR_OVERLAP;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;ERROR: new format image overwritten - must RESET the board to recover\n&quot;</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);</span><br><span class="line">			<span class="keyword">return</span> BOOTM_ERR_RESET;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="do-bootm-linux"><a href="#do-bootm-linux" class="headerlink" title="do_bootm_linux"></a>do_bootm_linux</h4><p>linux内核启动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_linux</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">		   <span class="type">bootm_headers_t</span> *images)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* No need for those on ARM */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class="line">		boot_prep_linux(images);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		boot_jump_linux(images, flag);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	boot_prep_linux(images);</span><br><span class="line">	boot_jump_linux(images, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="boot-jump-linux"><a href="#boot-jump-linux" class="headerlink" title="boot_jump_linux"></a>boot_jump_linux</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查机器id、将设备树地址通过r2传递给kernel、并跳转kernel或smc调用等</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_jump_linux</span><span class="params">(<span class="type">bootm_headers_t</span> *images, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> machid = gd-&gt;bd-&gt;bi_arch_number;</span><br><span class="line">	<span class="type">void</span> (*kernel_entry)(<span class="type">int</span> zero, <span class="type">int</span> arch, uint params);</span><br><span class="line">	<span class="type">char</span> *s;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r2;</span><br><span class="line">	<span class="type">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line">	u32 ARM_SVC_RUNNSOS = <span class="number">0x8000ff04</span>;</span><br><span class="line"></span><br><span class="line">	kernel_entry = (<span class="type">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>, uint))images-&gt;ep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查机器id</span></span><br><span class="line">	s = env_get(<span class="string">&quot;machid&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (strict_strtoul(s, <span class="number">16</span>, &amp;machid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			debug(<span class="string">&quot;strict_strtoul failed!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Using machid 0x%lx from environment\n&quot;</span>, machid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;## Transferring control to Linux (at address %08lx)&quot;</span> \</span><br><span class="line">		<span class="string">&quot;...\n&quot;</span>, (ulong) kernel_entry);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将设备树地址通过r2传递给kernel</span></span><br><span class="line">	<span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len) &#123;</span><br><span class="line">		r2 = CONFIG_SUNXI_FDT_ADDR;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span>*)r2, images-&gt;ft_addr, images-&gt;ft_len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r2 = gd-&gt;bd-&gt;bi_boot_params;</span><br><span class="line">	debug(<span class="string">&quot;## Linux machid: %08lx, FDT addr: %08lx\n&quot;</span>, machid, r2);</span><br><span class="line">	announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!fake) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sunxi_probe_secure_monitor())   <span class="comment">//从uboot首部得知是否有monitor</span></span><br><span class="line">			sunxi_smc_call_atf(ARM_SVC_RUNNSOS,(ulong)kernel_entry, (ulong)r2,  <span class="number">1</span>); <span class="comment">//__sunxi_smc_call(arg0, arg1, arg2, arg3); 触发smc系统调用</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			kernel_entry(<span class="number">0</span>, machid, r2);    <span class="comment">//跳转到kernel代码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="boot-prep-linux"><a href="#boot-prep-linux" class="headerlink" title="boot_prep_linux"></a>boot_prep_linux</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将bootargs的内容传递给内核</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_prep_linux</span><span class="params">(<span class="type">bootm_headers_t</span> *images)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *commandline = env_get(<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_LIBFDT</span></span><br><span class="line">		debug(<span class="string">&quot;using: FDT\n&quot;</span>);</span><br><span class="line">        <span class="comment">//将设备树重定位到lmb内存</span></span><br><span class="line">		<span class="keyword">if</span> (image_setup_linux(images)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;FDT creation failed! hanging...&quot;</span>);</span><br><span class="line">			hang();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BOOTM_ENABLE_TAGS) &#123;</span><br><span class="line">		debug(<span class="string">&quot;using: ATAGS\n&quot;</span>);</span><br><span class="line">		setup_start_tag(gd-&gt;bd);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_SERIAL_TAG)</span><br><span class="line">			setup_serial_tag(&amp;params);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_CMDLINE_TAG)</span><br><span class="line">			setup_commandline_tag(gd-&gt;bd, commandline);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_REVISION_TAG)</span><br><span class="line">			setup_revision_tag(&amp;params);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_MEMORY_TAGS)</span><br><span class="line">			setup_memory_tags(gd-&gt;bd);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_INITRD_TAG) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * In boot_ramdisk_high(), it may relocate ramdisk to</span></span><br><span class="line"><span class="comment">			 * a specified location. And set images-&gt;initrd_start &amp;</span></span><br><span class="line"><span class="comment">			 * images-&gt;initrd_end to relocated ramdisk&#x27;s start/end</span></span><br><span class="line"><span class="comment">			 * addresses. So use them instead of images-&gt;rd_start &amp;</span></span><br><span class="line"><span class="comment">			 * images-&gt;rd_end when possible.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (images-&gt;initrd_start &amp;&amp; images-&gt;initrd_end) &#123;</span><br><span class="line">				setup_initrd_tag(gd-&gt;bd, images-&gt;initrd_start,</span><br><span class="line">						 images-&gt;initrd_end);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images-&gt;rd_start &amp;&amp; images-&gt;rd_end) &#123;</span><br><span class="line">				setup_initrd_tag(gd-&gt;bd, images-&gt;rd_start,</span><br><span class="line">						 images-&gt;rd_end);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		setup_board_tags(&amp;params);</span><br><span class="line">		setup_end_tag(gd-&gt;bd);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;FDT and ATAGS support not compiled in - hanging\n&quot;</span>);</span><br><span class="line">		hang();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="image-setup-linux"><a href="#image-setup-linux" class="headerlink" title="image_setup_linux"></a>image_setup_linux</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LMB</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">image_setup_linux</span><span class="params">(<span class="type">bootm_headers_t</span> *images)</span></span><br><span class="line">&#123;</span><br><span class="line">        ulong of_size = images-&gt;ft_len;</span><br><span class="line">        <span class="type">char</span> **of_flat_tree = &amp;images-&gt;ft_addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lmb</span> *<span class="title">lmb</span> =</span> &amp;images-&gt;lmb;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT)</span><br><span class="line">            	<span class="comment">//将设备树的内存设为保留段</span></span><br><span class="line">                boot_fdt_add_mem_rsv_regions(lmb, *of_flat_tree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IMAGE_BOOT_GET_CMDLINE) &#123;</span><br><span class="line">                ret = boot_get_cmdline(lmb, &amp;images-&gt;cmdline_start,</span><br><span class="line">                                &amp;images-&gt;cmdline_end);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        <span class="built_in">puts</span>(<span class="string">&quot;ERROR with allocation of cmdline\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_SUNXI_FDT_ADDR)</span></span><br><span class="line">        <span class="comment">/*manually relocated, pass*/</span></span><br><span class="line">        <span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT) &#123;</span><br><span class="line">            	<span class="comment">//将fdt重定位到lmb</span></span><br><span class="line">                ret = boot_relocate_fdt(lmb, of_flat_tree, &amp;of_size);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; of_size) &#123;</span><br><span class="line">                ret = image_setup_libfdt(images, *of_flat_tree, of_size, lmb);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LMB */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="sunxi-android-boot"><a href="#sunxi-android-boot" class="headerlink" title="sunxi_android_boot"></a>sunxi_android_boot</h4><p>安卓启动需要验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sunxi_android_boot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *image_name, ulong os_load_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">        uint count              = <span class="number">0</span>;</span><br><span class="line">        uint wait_for_power_key = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (gd-&gt;securemode) &#123;</span><br><span class="line">                <span class="comment">/* ORANGE, indicating a device may be freely modified.</span></span><br><span class="line"><span class="comment">                 * Device integrity is left to the user to verify out-of-band.</span></span><br><span class="line"><span class="comment">                 * The bootloader displays a warning to the user before allowing</span></span><br><span class="line"><span class="comment">                 * the boot process to continue.*/</span></span><br><span class="line">                <span class="keyword">if</span> (gd-&gt;lockflag == SUNXI_UNLOCKED) &#123;</span><br><span class="line">                        env_set(<span class="string">&quot;verifiedbootstate&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">                        pr_msg(<span class="string">&quot;Your device software can&#x27;t be checked for corruption.\n&quot;</span>);</span><br><span class="line">                        pr_msg(<span class="string">&quot;Please lock the bootloader.\n&quot;</span>);</span><br><span class="line">                        sunxi_bmp_display(<span class="string">&quot;orange_warning.bmp&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SUNXI_AVB</span></span><br><span class="line">                        android_vbmeta_avb_verify(<span class="string">&quot;unlocked&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (axp_probe_key()) &#123;</span><br><span class="line">                                        <span class="comment">/* PAUSE BOOT */</span></span><br><span class="line">                                        pr_msg(<span class="string">&quot;pause boot,shutdown machine\n&quot;</span>);</span><br><span class="line">                                        sunxi_board_shutdown();</span><br><span class="line">                                &#125;</span><br><span class="line">                                mdelay(<span class="number">1000</span>);</span><br><span class="line">                                count++;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>);</span><br><span class="line">                        <span class="keyword">if</span> (gd-&gt;chargemode != <span class="number">1</span>) &#123;</span><br><span class="line">                                pr_msg(<span class="string">&quot;orange state:start to display bootlogo\n&quot;</span>);</span><br><span class="line">                                sunxi_bmp_display(<span class="string">&quot;bootlogo.bmp&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> ret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SUNXI_AVB</span></span><br><span class="line">                        ret = sunxi_verify_os(os_load_addr, image_name);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                        <span class="keyword">if</span> (!android_vbmeta_avb_verify(<span class="string">&quot;locked&quot;</span>)) &#123;</span><br><span class="line">                                ret = sunxi_verify_os(os_load_addr, image_name);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">struct</span> andr_img_hdr *fb_hdr = (<span class="keyword">struct</span> andr_img_hdr *)os_load_addr;</span><br><span class="line">                                <span class="type">uint8_t</span> *vb_meta_data;</span><br><span class="line">                                <span class="type">size_t</span> vb_len;</span><br><span class="line">                                ulong total_len;</span><br><span class="line">                                ret = sunxi_avb_read_vbmeta_data(&amp;vb_meta_data,</span><br><span class="line">                                                                 &amp;vb_len);</span><br><span class="line">                                <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                                        total_len =</span><br><span class="line">                                                android_image_get_end(fb_hdr) -</span><br><span class="line">                                                (ulong)fb_hdr;</span><br><span class="line">                                        ret = verify_image_by_vbmeta(</span><br><span class="line">                                                image_name,</span><br><span class="line">                                                (<span class="type">uint8_t</span> *)os_load_addr,</span><br><span class="line">                                                total_len, vb_meta_data,</span><br><span class="line">                                                vb_len);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        pr_error(</span><br><span class="line">                                                <span class="string">&quot;read vbmeta data for verification failed\n&quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="built_in">free</span>(vb_meta_data);</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_SUNXI_AVB*/</span></span></span><br><span class="line">                        <span class="comment">/* YELLOW, indicating the boot partition has been verified using the</span></span><br><span class="line"><span class="comment">                         * embedded certificate, and the signature is valid. The bootloader</span></span><br><span class="line"><span class="comment">                         * displays a warning and the fingerprint of the public key before</span></span><br><span class="line"><span class="comment">                         * allowing the boot process to continue.*/</span></span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(env_get(<span class="string">&quot;verifiedbootstate&quot;</span>), <span class="string">&quot;yellow&quot;</span>)) &#123;</span><br><span class="line">                                pr_msg(<span class="string">&quot;Your device has loaded a different operating system.\n&quot;</span>);</span><br><span class="line">                                pr_msg(<span class="string">&quot;stop booting until the power key is pressed\n&quot;</span>);</span><br><span class="line">                                sunxi_bmp_display(<span class="string">&quot;yellow_pause_warning.bmp&quot;</span>);</span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (axp_probe_key()) &#123;</span><br><span class="line">                                                <span class="comment">/* PAUSE BOOT */</span></span><br><span class="line">                                                pr_msg(<span class="string">&quot;pause boot,waiting for press power key again\n&quot;</span>);</span><br><span class="line">                                                sunxi_bmp_display(</span><br><span class="line">                                                        <span class="string">&quot;yellow_continue_warning.bmp&quot;</span>);</span><br><span class="line">                                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                                        <span class="keyword">if</span> (axp_probe_key()) &#123;</span><br><span class="line">                                                                <span class="comment">/* CONTINUE BOOT */</span></span><br><span class="line">                                                                wait_for_power_key =</span><br><span class="line">                                                                        <span class="number">0</span>;</span><br><span class="line">                                                                <span class="comment">/* timeout,continue to bootup */</span></span><br><span class="line">                                                                count = <span class="number">5</span>;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                &#125; <span class="keyword">while</span> (wait_for_power_key);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        mdelay(<span class="number">1000</span>);</span><br><span class="line">                                        count++;</span><br><span class="line">                                &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>);</span><br><span class="line">                                <span class="keyword">if</span> (gd-&gt;chargemode != <span class="number">1</span>) &#123;</span><br><span class="line">                                        pr_msg(<span class="string">&quot;yellow state:start to display bootlogo\n&quot;</span>);</span><br><span class="line">                                        sunxi_bmp_display(<span class="string">&quot;bootlogo.bmp&quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">/* GREEN, indicating a full chain of trust extending from the</span></span><br><span class="line"><span class="comment">                                 * bootloader to verified partitions, including the bootloader,</span></span><br><span class="line"><span class="comment">                                 * boot partition, and all verified partitions.*/</span></span><br><span class="line">                                env_set(<span class="string">&quot;verifiedbootstate&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* RED, indicating the device has failed verification. The bootloader</span></span><br><span class="line"><span class="comment">                         * displays an error and stops the boot process.*/</span></span><br><span class="line">                        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                                pr_msg(<span class="string">&quot;boota: verify the %s failed\n&quot;</span>,</span><br><span class="line">                                       image_name);</span><br><span class="line">                                env_set(<span class="string">&quot;verifiedbootstate&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">                                pr_msg(<span class="string">&quot;Your device is corrupt.It can&#x27;t be truseted and will not boot.\n&quot;</span>);</span><br><span class="line">                                sunxi_bmp_display(<span class="string">&quot;red_warning.bmp&quot;</span>);</span><br><span class="line">                                mdelay(<span class="number">30000</span>);</span><br><span class="line">                                sunxi_board_shutdown();</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sunxi-verify-os"><a href="#sunxi-verify-os" class="headerlink" title="sunxi_verify_os"></a>sunxi_verify_os</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对内核进行签名认证</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sunxi_verify_os</span><span class="params">(ulong os_load_addr, <span class="type">const</span> <span class="type">char</span> *cert_name)</span></span><br><span class="line">&#123;</span><br><span class="line">        ulong total_len = <span class="number">0</span>;</span><br><span class="line">        ulong sign_data, sign_len;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">andr_img_hdr</span> *<span class="title">fb_hdr</span> =</span> (<span class="keyword">struct</span> andr_img_hdr *)os_load_addr;</span><br><span class="line"></span><br><span class="line">        total_len += fb_hdr-&gt;page_size;</span><br><span class="line">        total_len += ALIGN(fb_hdr-&gt;kernel_size, fb_hdr-&gt;page_size);</span><br><span class="line">        <span class="keyword">if</span> (fb_hdr-&gt;second_size)</span><br><span class="line">                total_len += ALIGN(fb_hdr-&gt;second_size, fb_hdr-&gt;page_size);</span><br><span class="line">        <span class="keyword">if</span> (fb_hdr-&gt;ramdisk_size)</span><br><span class="line">                total_len += ALIGN(fb_hdr-&gt;ramdisk_size, fb_hdr-&gt;page_size);</span><br><span class="line">        <span class="keyword">if</span> (fb_hdr-&gt;recovery_dtbo_size)</span><br><span class="line">                total_len +=</span><br><span class="line">                        ALIGN(fb_hdr-&gt;recovery_dtbo_size, fb_hdr-&gt;page_size);</span><br><span class="line">        <span class="keyword">if</span> (fb_hdr-&gt;dtb_size)</span><br><span class="line">                total_len += ALIGN(fb_hdr-&gt;dtb_size, fb_hdr-&gt;page_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;total_len=%ld\n&quot;</span>, total_len);</span><br><span class="line">    	<span class="comment">//对内核进行签名认证</span></span><br><span class="line">        <span class="keyword">if</span> (android_image_get_signature(fb_hdr, &amp;sign_data, &amp;sign_len))	<span class="comment">//从头部取得签名数据</span></span><br><span class="line">                ret = sunxi_verify_embed_signature((<span class="type">void</span> *)os_load_addr,</span><br><span class="line">                                                   (<span class="type">unsigned</span> <span class="type">int</span>)total_len,</span><br><span class="line">                                                   cert_name, (<span class="type">void</span> *)sign_data,</span><br><span class="line">                                                   sign_len);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                ret = sunxi_verify_signature((<span class="type">void</span> *)os_load_addr,</span><br><span class="line">                                             (<span class="type">unsigned</span> <span class="type">int</span>)total_len,</span><br><span class="line">                                             cert_name);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="update-tftp"><a href="#update-tftp" class="headerlink" title="update_tftp"></a>update_tftp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//update_tftp(0,NULL,NULL)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update_tftp</span><span class="params">(ulong addr, <span class="type">char</span> *interface, <span class="type">char</span> *devstring)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *filename, *env_addr, *fit_image_name;</span><br><span class="line">        ulong update_addr, update_fladdr, update_size;</span><br><span class="line">        <span class="type">int</span> images_noffset, ndepth, noffset;</span><br><span class="line">        <span class="type">bool</span> update_tftp_dfu;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">void</span> *fit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interface == <span class="literal">NULL</span> &amp;&amp; devstring == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                update_tftp_dfu = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interface &amp;&amp; devstring) &#123;</span><br><span class="line">                update_tftp_dfu = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Interface: %s and devstring: %s not supported!\n&quot;</span>,</span><br><span class="line">                      interface, devstring);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* use already present image */</span></span><br><span class="line">        <span class="keyword">if</span> (addr)</span><br><span class="line">                <span class="keyword">goto</span> got_update_file;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Auto-update from TFTP: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the file name of the update file */</span></span><br><span class="line">        filename = env_get(UPDATE_FILE_ENV);	<span class="comment">//UPDATE_FILE_ENV=updatefile</span></span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;failed, env. variable &#x27;%s&#x27; not found\n&quot;</span>,</span><br><span class="line">                                                        UPDATE_FILE_ENV);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;trying update file &#x27;%s&#x27;\n&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get load address of downloaded update file */</span></span><br><span class="line">        env_addr = env_get(<span class="string">&quot;loadaddr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (env_addr)</span><br><span class="line">                addr = simple_strtoul(env_addr, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                addr = CONFIG_UPDATE_LOAD_ADDR;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使用tft协议从网络下载更新文件到指定地址</span></span><br><span class="line">        <span class="keyword">if</span> (update_load(filename, CONFIG_UPDATE_TFTP_MSEC_MAX,</span><br><span class="line">                                        CONFIG_UPDATE_TFTP_CNT_MAX, addr)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t load update file, aborting auto-update\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">got_update_file:</span><br><span class="line">        fit = (<span class="type">void</span> *)addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fit_check_format((<span class="type">void</span> *)fit)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Bad FIT format of the update file, aborting &quot;</span></span><br><span class="line">                                                        <span class="string">&quot;auto-update\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process updates */</span></span><br><span class="line">        images_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);</span><br><span class="line"></span><br><span class="line">        ndepth = <span class="number">0</span>;</span><br><span class="line">        noffset = fdt_next_node(fit, images_noffset, &amp;ndepth);</span><br><span class="line">        <span class="keyword">while</span> (noffset &gt;= <span class="number">0</span> &amp;&amp; ndepth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ndepth != <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">goto</span> next_node;</span><br><span class="line"></span><br><span class="line">                fit_image_name = (<span class="type">char</span> *)fit_get_name(fit, noffset, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Processing update &#x27;%s&#x27; :&quot;</span>, fit_image_name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!fit_image_verify(fit, noffset)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error: invalid update hash, aborting\n&quot;</span>);</span><br><span class="line">                        ret = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">goto</span> next_node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (update_fit_getparams(fit, noffset, &amp;update_addr,</span><br><span class="line">                                        &amp;update_fladdr, &amp;update_size)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error: can&#x27;t get update parameteres, &quot;</span></span><br><span class="line">                                                                <span class="string">&quot;aborting\n&quot;</span>);</span><br><span class="line">                        ret = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">goto</span> next_node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!update_tftp_dfu) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (update_flash(update_addr, update_fladdr,</span><br><span class="line">                                         update_size)) &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;Error: can&#x27;t flash update, aborting\n&quot;</span>);</span><br><span class="line">                                ret = <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">goto</span> next_node;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fit_image_check_type(fit, noffset,</span><br><span class="line">                                                IH_TYPE_FIRMWARE)) &#123;</span><br><span class="line">                        ret = dfu_tftp_write(fit_image_name, update_addr,</span><br><span class="line">                                             update_size, interface, devstring);</span><br><span class="line">                        <span class="keyword">if</span> (ret)</span><br><span class="line">                                <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">next_node:</span><br><span class="line">                noffset = fdt_next_node(fit, noffset, &amp;ndepth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/uboot_2/" data-id="cmbcy7rh8001gt8mt7ba237jn" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/kmalloc" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/kmalloc/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.236Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/kmalloc/" data-id="cmbcy7rh60018t8mt25y1ftu9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/page allocator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/page%20allocator/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.236Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>物理内存管理最大的难题就是处理内存碎片，在Linux内核中，页面是管理物理内存的基本单位。<br>内存碎片有两种：</p>
<ol>
<li>空闲内存离散的分布在内存各个角落，虽然总的空闲内存大小足够，但无法凑出一块足够大的内存</li>
<li>用户申请3个page的页面，但实际上分配了4个page，导致一个page没有被使用，浪费。</li>
</ol>
<p>Linux必须使用一套算法来减少页面的碎片问题，同时在实现上也要尽量快速高效，因为页面的申请释放在操作系统中的使用频率非常高，会非常影响性能。</p>
<h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><p>在解决内存碎片问题上，Linux主要采用以下思路：</p>
<ul>
<li>伙伴系统算法</li>
<li>内存规整</li>
<li>内存回收</li>
<li>OOM 机制<br>通过上述方式减缓内存碎片的效应。</li>
</ul>
<h3 id="2-1、伙伴系统算法"><a href="#2-1、伙伴系统算法" class="headerlink" title="2.1、伙伴系统算法"></a>2.1、伙伴系统算法</h3><p>伙伴系统算法核心的思想是：维护若干个内存池，内存池的大小为2^n。</p>
<p>用户申请page时，只能从这些内存池中申请固定大小的page。虽然会有一定内存的浪费，但是这个算法的优点是在释放page时，能较容易的找到 ”伙伴“页面，从而将小内存合并到大内存。</p>
<p>例如用户申请3个page，那么会page allocator实际上会分配4个page，有一个page被浪费掉了。但是只要用户释放了page，且”伙伴页面“也在空闲链表，那么立刻就可以合并。<br>内存合并的条件很容易达成，所以能高效避免内存碎片化。</p>
<p>n的取值为：0,1,2,3,4,5,6,7,8,9,10。<br>对应的page数量为：1,2,4,8,16,32,64,128,256,512,1024；<br>即最大1024个page，最小1个page。</p>
<h3 id="2-2-2、内存规整"><a href="#2-2-2、内存规整" class="headerlink" title="2.2.2、内存规整"></a>2.2.2、内存规整</h3><p>伙伴系统算法有一个缺陷就是要求必须两个伙伴都处于空闲，但是当内存紧张且又需要大块内存时，可能无法合并成一个大内存。<br>例如，用户申请8个page，但是伙伴系统里只有4个连续空闲page，而且其伙伴不在空闲链表，虽然其他地方有空闲页面，但是因为隔离太远，无法合并，最终申请失败。</p>
<p>内存规整可以解决这个问题，利用页面迁移的机制，将伙伴page的内容复制到其他空闲页面，并更新页面，tlb，将伙伴page 释放会空闲链表，以支持合并成8个连续空闲page。</p>
<h3 id="2-2-3、内存回收"><a href="#2-2-3、内存回收" class="headerlink" title="2.2.3、内存回收"></a>2.2.3、内存回收</h3><p>当空闲页面不足够时，会将一些不重要的页面进行回收。例如文件缓存页面，这些页面是在读文件&#x2F;写文件时产生的，将这些不常用的页面回收，可以增加空闲页面数量，以满足页面申请。</p>
<h3 id="2-2、page分类"><a href="#2-2、page分类" class="headerlink" title="2.2、page分类"></a>2.2、page分类</h3><p>通过将不同用途的page进行分类，可以尽量减少内存碎片。<br>具体的page 迁移类型有以下几种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	<span class="comment">// 不可以移动的page，例如kmalloc申请的内存</span></span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	<span class="comment">//可移动的page，如文件page，用户进程的堆栈</span></span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	<span class="comment">//可回收的page，如文件page</span></span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	<span class="comment">//cma page是预留一块连续物理内存，当没有连续物理内存需求时，可以从这里申请，但是当有需求时，需要使用page 迁移，将cma page恢复</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line">	<span class="comment">//在per pcu page缓存的page，大小固定是1个page</span></span><br><span class="line">	MIGRATE_PCPTYPES,</span><br><span class="line">	<span class="comment">//高优先级、不可睡眠等待的page</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如将 MIGRATE_MOVABLE 的page 都集中放在一起，在内存规整时，就可以很方便的迁移这些page。若在 MIGRATE_MOVABLE 的page中混入几个 MIGRATE_UNMOVABLE 的page，那么这些钉子户就会死死的钉在那些page，无法移动，使得最终的page无法凑成一个大的连续内存。</p>
<h2 id="三、API接口"><a href="#三、API接口" class="headerlink" title="三、API接口"></a>三、API接口</h2><p>接下来分析page allocator 里的初始化、申请、释放接口。<br>page allocator里的page 最开始是哪里来的，申请的时候会如何考虑优化性能，释放的时候如何尽量合并。</p>
<h3 id="3-1、初始化page-allocator"><a href="#3-1、初始化page-allocator" class="headerlink" title="3.1、初始化page allocator"></a>3.1、初始化page allocator</h3><p>内核在start_kernel() 里完成页表的建立后，就开始初始化page allocator。<br>首先我们要了解管理page 的比较重要的数据结构：<code>pg_data_t、zone、page</code>.<br>这些数据结构的关系如图所示：<br>![[page_allocator.drawio.png]]</p>
<p>这些数据结构在start_kernel()的时候就首先初始化完成了。</p>
<p>在start_kernel() 的paging_init()阶段里，通过调用 free_area_init() 初始化上述数据结构。<br>![[Pasted image 20250405223406.png]]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">free_area_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *max_zone_pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn, end_pfn;</span><br><span class="line">	<span class="type">int</span> i, nid, zone;</span><br><span class="line">	<span class="type">bool</span> descending;</span><br><span class="line"></span><br><span class="line">	start_pfn = find_min_pfn_with_active_regions();</span><br><span class="line">	descending = arch_has_descending_max_zone_pfns();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印一些ZONE的地址信息到uart，我们经常可以看到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化每一个内存节点，对于UMA系统来说，只有一个内存节点</span></span><br><span class="line">	for_each_online_node(nid) &#123;</span><br><span class="line">		<span class="type">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line">		<span class="comment">//这里会初始化上述所有数据结构体，包括mem_map[]数组，该数组的成员是struct page，物理内存的每一个页面都有一个struct page记录其状态信息</span></span><br><span class="line">		free_area_init_node(nid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在这里初始化mem_map里的每一个struct page</span></span><br><span class="line">	memmap_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个问题，当前slub allocator还未初始化，我们不能使用kmalloc() 去申请内存，所以这里的pg_data_t 对象是一个全局变量。而mem_map[]数组的内存是使用memblock 接口申请的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">free_area_init_node</span><span class="params">(<span class="type">int</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取全局pg_data_t 变量</span></span><br><span class="line">	<span class="type">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end_pfn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历memblock里所有memory类型的内存，得到pfn范围</span></span><br><span class="line">	get_pfn_range_for_nid(nid, &amp;start_pfn, &amp;end_pfn);</span><br><span class="line"></span><br><span class="line">	pgdat-&gt;node_id = nid;</span><br><span class="line">	pgdat-&gt;node_start_pfn = start_pfn;</span><br><span class="line">	pgdat-&gt;per_cpu_nodestats = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//通过pfn计算得到该内存节点所有的page数量</span></span><br><span class="line">	calculate_node_totalpages(pgdat, start_pfn, end_pfn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过memblock申请mem_map[]数组，假如有64M,64M / 4k = 16 * 1024个page，那么就需要申请 16 * 1024 * sizeof(struct page)的数组</span></span><br><span class="line">	alloc_node_mem_map(pgdat);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化zone对象</span></span><br><span class="line">	free_area_init_core(pgdat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后还需要在 memmap_init()中，会遍历所有页面，初始化每一个struct page对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __meminit <span class="title function_">memmap_init_zone</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">int</span> nid, <span class="type">unsigned</span> <span class="type">long</span> zone,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> start_pfn, <span class="type">unsigned</span> <span class="type">long</span> zone_end_pfn,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> meminit_context context,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> vmem_altmap *altmap, <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//遍历所有pfn</span></span><br><span class="line">	<span class="keyword">for</span> (pfn = start_pfn; pfn &lt; end_pfn; ) &#123;</span><br><span class="line">		<span class="comment">//拿到mem_map[]对应的struct page</span></span><br><span class="line">		page = pfn_to_page(pfn);</span><br><span class="line">		<span class="comment">//初始化一些变量</span></span><br><span class="line">		__init_single_page(page, pfn, zone, nid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将所有page初始化为MIGRATE_MOVABLE</span></span><br><span class="line">		<span class="comment">//这样可以避免MIGRATE_UNMOVABLE的page 分布在内存各个地方</span></span><br><span class="line">		<span class="comment">//后续申请时，可以将page的类型转换成MIGRATE_UNMOVABLE</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ALIGNED(pfn, pageblock_nr_pages)) &#123;</span><br><span class="line">			set_pageblock_migratetype(page, migratetype);</span><br><span class="line">			cond_resched();</span><br><span class="line">		&#125;</span><br><span class="line">		pfn++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK、数据结构初始化完成后，就可以往page allocator里添加pages，后续的内存申请就从page allocator里进行。这里内核使用__free_pages_memory() 将page 从memblock 移交给page allocator。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init __free_pages_memory(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> end)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> order;</span><br><span class="line">	<span class="comment">//遍历所有pfn</span></span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		<span class="comment">//确保order不会超过 MAX_ORDER - 1</span></span><br><span class="line">		order = min(MAX_ORDER - <span class="number">1UL</span>, __ffs(start));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//确保order 也不要超过end</span></span><br><span class="line">		<span class="keyword">while</span> (start + (<span class="number">1UL</span> &lt;&lt; order) &gt; end)</span><br><span class="line">			order--;</span><br><span class="line">		<span class="comment">//释放start-&gt; start + 2^order 的内存到page allocator</span></span><br><span class="line">		<span class="comment">//初始化完成后，大部分page 都在order比较大的链表里</span></span><br><span class="line">		memblock_free_pages(pfn_to_page(start), start, order);</span><br><span class="line">		<span class="comment">//移动start 直到遍历完所有pfn</span></span><br><span class="line">		start += (<span class="number">1UL</span> &lt;&lt; order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memblock_free_pages 会调用 __free_pages_ok() 将page 释放到page allocator里。这里先不关心 __free_pages_ok的实现。</p>
<p>现在page allocator 里已经有page管理，可以提供申请服务了。</p>
<h3 id="3-2、申请page"><a href="#3-2、申请page" class="headerlink" title="3.2、申请page"></a>3.2、申请page</h3><p>在内核中，申请page 的地方有很多，需要确保性能，同时又要避免碎片化。所以申请page需要区别使用场景，需求。<br>但总得来说，申请page 的思路主要是：如果有空闲的page，就直接申请。否则，通过内存规整、页面回收、OOM机制增加可用页面，再重新进行申请。</p>
<p>page alloc 的实现入口在 <code>__alloc_pages_nodemask()</code>，根据上述思路可将page alloc 分为两个部分：快车道和慢车道。<br>![[page_allocator.alloc.drawio.png]]</p>
<h4 id="3-2-1、快车道"><a href="#3-2-1、快车道" class="headerlink" title="3.2.1、快车道"></a>3.2.1、快车道</h4><p>即当前free area里有足够的空闲页面可供申请，直接从free area里拿到所需的page。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="comment">//默认 watermark 标志为low，</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="comment">//保存申请的一些上下文信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">	alloc_mask = gfp_mask;</span><br><span class="line">	<span class="comment">//初始化申请上下文，包括zone、migratetye等</span></span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一开始，我们需要避免碎片化申请，若申请失败，我们再消除ALLOC_NOFRAGMENT</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//快车道：从free area中获取page，若获取成功就直接返回</span></span><br><span class="line">	page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//慢车道：做内存规整、内存回收等来获取新的空闲页面，再分配page</span></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快车道的实现在<code>get_page_from_freelist()</code>，会从指定的zone-&gt;free_area 里申请page。<br>同时为了避免碎片化，会尽量在同一类型的migrate type里申请page，只有在申请不到page的情况下，才会跨migrate type申请page。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">						<span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">//ALLOC_NOFRAGMENT 表示尽量避免碎片化申请</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">	<span class="comment">//preferred_zoneref 表示最希望从哪个zone申请</span></span><br><span class="line">	z = ac-&gt;preferred_zoneref;</span><br><span class="line">	<span class="comment">//遍历所有的zone，找到最佳的一个zone来进行分配</span></span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//比较order和zone水位线，来判断zone 是否有足够的页面进行申请</span></span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">				       gfp_mask)) &#123;</span><br><span class="line">			<span class="comment">//触发直接回收内存、在这里我的arm32 没有实现这个函数，返回NODE_RECLAIM_NOSCAN</span></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">		<span class="comment">//找到合适的zone后，使用rmqueue从伙伴系统申请page</span></span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">		<span class="keyword">if</span> (page) &#123;</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line">			<span class="keyword">return</span> page;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实在没有分配到，那么我们就不关心碎片化的影响，重新申请</span></span><br><span class="line">	<span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rmqueue() 会真正从page allocator 里返回page。由于大部分申请都是一个page，所以在这里有做一个优化：<br>page allocator 为每一个cpu 都设置一个缓存池，每个缓存池里page都是1页大小。<br>当申请1个page时，会从per cpu page里申请，这样可以避免访问全局的free_area，造成竞争繁忙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//若申请一个page则从per cpu page 缓存里快速申请一个page</span></span><br><span class="line">	<span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line">		page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">				       migratetype, alloc_flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//否则需要从全局的zone里申请page，故需要关闭本地中断，锁住zone</span></span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//从zone的对应migrate type里申请page，大部分情况会走到__rmqueue()</span></span><br><span class="line">		<span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">			page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			<span class="keyword">if</span> (migratetype == MIGRATE_MOVABLE &amp;&amp; alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">				page = __rmqueue_cma(zone, order, migratetype,</span><br><span class="line">						     alloc_flags);</span><br><span class="line">			<span class="keyword">if</span> (!page)</span><br><span class="line">				page = __rmqueue(zone, order, migratetype,</span><br><span class="line">						 alloc_flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就分析最常见的情况：</p>
<ol>
<li>从指定migrate type 申请page失败后，会尝试从其他migrate type 申请</li>
<li>从其他migrate type 申请时，为避免碎片化，会申请最大order的page block。然后将page block移动到所需的migrate type 链表。</li>
<li>例如：我们初始化时所有page 都是 MIGRATE_MOVABLE 类型。当需要MIGRATE_UNMOVABLE 类型的page时，就需要从MIGRATE_MOVABLE 链表里偷过来。为了避免碎片化，当然要从order&#x3D;9 里偷。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">						<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span>	</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">//先尝试从指定migrate type中申请page</span></span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若申请失败，则从zone里其他type 的free area中申请</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page) &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">						  alloc_flags))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从其他migrate type 中申请page</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line">__rmqueue_fallback(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order, <span class="type">int</span> start_migratetype,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> min_order = order;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了避免碎片化，将min_order设为MAX_ORDER - 1。</span></span><br><span class="line">	<span class="comment">//从其他migrate type中申请page时，越大的order越能避免碎片化，因为小内存往往是导致碎片化的凶手。</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NOFRAGMENT)</span><br><span class="line">		min_order = pageblock_order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从MAX_ORDER - 1开始到min_order，遍历其他migrate type的free_list</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = MAX_ORDER - <span class="number">1</span>; current_order &gt;= min_order;</span><br><span class="line">				--current_order) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line">				start_migratetype, <span class="literal">false</span>, &amp;can_steal);</span><br><span class="line">		<span class="keyword">if</span> (fallback_mt == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//若有空闲的page block，我们就去找一个最合适的page block</span></span><br><span class="line">		<span class="keyword">if</span> (!can_steal &amp;&amp; start_migratetype == MIGRATE_MOVABLE</span><br><span class="line">					&amp;&amp; current_order &gt; order)</span><br><span class="line">			<span class="keyword">goto</span> find_smallest;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> do_steal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//现在我们已经确定其他migrate type 链表可以满足我们的需求</span></span><br><span class="line">	<span class="comment">//所以现在重新遍历free area，找到最合适的migrate type链表</span></span><br><span class="line">find_smallest:</span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER;</span><br><span class="line">							current_order++) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line">				start_migratetype, <span class="literal">false</span>, &amp;can_steal);</span><br><span class="line">		<span class="keyword">if</span> (fallback_mt != <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">do_steal:</span><br><span class="line">	<span class="comment">//确定了要从fallback_mt 里“偷”page，现在开始偷</span></span><br><span class="line">	page = get_page_from_free_area(area, fallback_mt);</span><br><span class="line">	<span class="comment">//偷的代码：</span></span><br><span class="line">	steal_suitable_fallback(zone, page, alloc_flags, start_migratetype,</span><br><span class="line">								can_steal);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下快车道的申请逻辑就是：尽量从指定的migrate type list里申请，若申请不到，再考虑从其他type list里申请。</p>
<p>假如其他type list 也没有空闲的page了，那么就只能走慢车道去申请page。</p>
<h4 id="3-2-2、慢车道"><a href="#3-2-2、慢车道" class="headerlink" title="3.2.2、慢车道"></a>3.2.2、慢车道</h4><p>进入慢车道大概率是以下原因：</p>
<ol>
<li>空闲page 不足了</li>
<li>空闲page虽然满足，但由于碎片化，凑不出所需要的连续内存</li>
</ol>
<p>慢车道主要是通过内存规整和内存回收机制，来把蛋糕做大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">restart:</span><br><span class="line">	<span class="comment">//唤醒kswap线程去异步的做内存回收</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一次尝试申请page</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若不能直接回收，直接返回失败</span></span><br><span class="line">	<span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接进行内存回收</span></span><br><span class="line">	page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">							&amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接进行内存规整</span></span><br><span class="line">	page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">					compact_priority, &amp;compact_result);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//触发oom 机制，kill 掉一个进程，成功释放内存会设置did_some_progress</span></span><br><span class="line">	page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//oom 成功释放了内存，重新尝试申请page</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">		no_progress_loops = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、释放page"><a href="#3-3、释放page" class="headerlink" title="3.3、释放page"></a>3.3、释放page</h3><p>释放page 主要通过 free_the_page() 函数进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_the_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (order == <span class="number">0</span>)		<span class="comment">//释放一个page时，先放回per pcu page</span></span><br><span class="line">		free_unref_page(page);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__free_pages_ok(page, order, FPI_NONE);  <span class="comment">//否则放回free list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20250405223506.png]]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/page%20allocator/" data-id="cmbcy7rh6001bt8mtg7woai7e" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/slub allocator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/slub%20allocator/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.236Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>虽然Linux内核有了 [[page allocator]] 可以高效的申请、释放page，但在内核代码中，我们更多的是使用<code>kmalloc()、kfree()</code> 等接口去申请、释放程序运行所需的数据结构。</p>
<p>也就是说内核有申请小内存的需求（小于1 page），而且这些内存需求种类多、场景也比较复杂，在进程、中断上下文都可能涉及。所以对allocator的性能、适应性要求很高。同时还要尽量能避免碎片化影响。这仅靠page allocator无法满足，需要slub allocator 提供小内存的申请释放。</p>
<h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><p>slub allocator的思路与page allocator 类似，采用内存池的方式来管理内存。<br>因为内核经常需要动态申请内存，为程序运行所需的数据结构生成对象，所以内核slub allocator 里管理的内存池称为cache，每一个cache有若干个固定大小的对象，内核会维护常用的几个cache。</p>
<p>同时为了提高效率，会为每个cpu 创建本地的本地cache，避免多核间的资源竞争。</p>
<h2 id="三、API-接口"><a href="#三、API-接口" class="headerlink" title="三、API 接口"></a>三、API 接口</h2><p>在slub allocator 中，有以下主要的数据结构，他们的关系如图所示：</p>
<ul>
<li>kmem_cache：表示一个指定大小的cache</li>
<li>kmem_cache_cpu：表示每个CPU上的cache</li>
<li>kmem_cache_node：cache 里对应的page，对象object都是从page 里申请的。</li>
</ul>
<h3 id="3-1、初始化kmalloc-cache"><a href="#3-1、初始化kmalloc-cache" class="headerlink" title="3.1、初始化kmalloc cache"></a>3.1、初始化kmalloc cache</h3><p>在内核中程序运行时所需的数据结构，通常是用<code>kmalloc()</code>申请来的。</p>
<p>内核为kmalloc 维护了以下cache：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">	INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如当需要申请10个字节的内存时，会从 object size&#x3D;16的cache中申请，所以虽然用户只申请10个字节，但实际分配给了16字节的内存。</p>
<p>slub allocator 的初始化时在 <code>kmem_cache_init()</code> 里实现的，其思路是：</p>
<ol>
<li>首先创建一个 cache，其类型是 <code>kmem_cache</code> 、<code>kmem_cache_node</code>本身</li>
<li>从<code>kmem_cache</code> cache里申请<code>kmem_cache</code>，作为kmalloc 不同size的cache。<br>这里有一点拗口，<code>kmem_cache</code> 本身也属于内核的数据结构，所有要首先为他创建cache，才能从这个cache 里申请 <code>kmem_cache</code>。也就是缓存类型的缓存。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">kmem_cache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义两个静态的kmem_cache对象</span></span><br><span class="line">	<span class="type">static</span> __initdata <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> <span class="title">boot_kmem_cache</span>,</span></span><br><span class="line"><span class="class">		<span class="title">boot_kmem_cache_node</span>;</span></span><br><span class="line"></span><br><span class="line">	kmem_cache_node = &amp;boot_kmem_cache_node;</span><br><span class="line">	kmem_cache = &amp;boot_kmem_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化 kmem_cache_node 这个cache，完成后就可以申请struct kmem_cache_node对象</span></span><br><span class="line">	create_boot_cache(kmem_cache_node, <span class="string">&quot;kmem_cache_node&quot;</span>,</span><br><span class="line">		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node), SLAB_HWCACHE_ALIGN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//slab_state 标记了slub allocator 初始化的不同阶段</span></span><br><span class="line">	<span class="comment">//PARTIAL 表示可以申请struct kmem_cache_node对象</span></span><br><span class="line">	slab_state = PARTIAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化 kmem_cache 这个cache，完成后就可以申请struct kmem_cache 对象</span></span><br><span class="line">	create_boot_cache(kmem_cache, <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">			offsetof(<span class="keyword">struct</span> kmem_cache, node) +</span><br><span class="line">				nr_node_ids * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node *),</span><br><span class="line">		       SLAB_HWCACHE_ALIGN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为boot_kmem_cache、boot_kmem_cache_node是initdata，会被释放掉</span></span><br><span class="line">	<span class="comment">//所以这里会从 cache:kmem_cache 里申请两个struct kmem_cache 对象，并拷贝boot_kmem_cache、boot_kmem_cache_node两个对象。这样boot_kmem_cache、boot_kmem_cache_node就可以安全的释放掉。</span></span><br><span class="line">	kmem_cache = bootstrap(&amp;boot_kmem_cache);</span><br><span class="line">	kmem_cache_node = bootstrap(&amp;boot_kmem_cache_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建kmalloc cache</span></span><br><span class="line">	setup_kmalloc_cache_index_table();</span><br><span class="line">	create_kmalloc_caches(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化阶段，内核就完成了cache:kmem_cache、cache:boot_kmem_cache_node、kmalloc cache的创建。</p>
<h3 id="3-2、kmalloc"><a href="#3-2、kmalloc" class="headerlink" title="3.2、kmalloc"></a>3.2、kmalloc</h3><p>kmalloc 的思路是：</p>
<ol>
<li>找到申请的size 最合适的kmalloc cache</li>
<li>从该kmalloc cache 里申请object</li>
<li>假如该cache 本地freelist 有空闲的object，返回该object</li>
<li>走慢车道，从其他地方申请object</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据size找到对应的cache</span></span><br><span class="line">	s = kmalloc_slab(size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从指定cache中分配内存</span></span><br><span class="line">	ret = slab_alloc(s, flags, _RET_IP_, size);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//slab_alloc() 会直接调用slab_alloc_node()</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">		<span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">		c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	&#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPTION) &amp;&amp;</span><br><span class="line">		 unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line"></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取本地cpu freelist 的object</span></span><br><span class="line">	object = c-&gt;freelist;</span><br><span class="line">	page = c-&gt;page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若object为空、page为空、节点不匹配，则通过__slab_alloc()申请object，为慢车道</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!object || !page || !node_match(page, node))) &#123;</span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//freelist有空闲object，拿走当前object，并更新freelist，此处为快车道</span></span><br><span class="line">		<span class="type">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">				s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">				object, tid,</span><br><span class="line">				next_object, next_tid(tid)))) &#123;</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		prefetch_freepointer(s, next_object);</span><br><span class="line">		stat(s, ALLOC_FASTPATH);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慢车道的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *__slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在关闭本地中断的环境下，调用___slab_alloc()处理慢车道</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	p = ___slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line">	page = c-&gt;page;</span><br><span class="line">	<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">		<span class="comment">//若本地cache 没有拥有一个页面，说明是刚初始化完成，第一次申请object</span></span><br><span class="line">		<span class="comment">//直接跳转到 new_slab 处申请新的page</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">			     !node_state(node, N_NORMAL_MEMORY)))</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">//从本地</span></span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">	freelist = get_freelist(s, page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">		c-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">		stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line">load_freelist:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">	 * page is pointing to the page from which the objects are obtained.</span></span><br><span class="line"><span class="comment">	 * That page must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!c-&gt;page-&gt;frozen);</span><br><span class="line">	c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">		page = c-&gt;page = slub_percpu_partial(c);</span><br><span class="line">		slub_set_percpu_partial(c, page);</span><br><span class="line">		stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freelist = new_slab_objects(s, gfpflags, node, &amp;c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!freelist)) &#123;</span><br><span class="line">		slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page = c-&gt;page;</span><br><span class="line">	<span class="keyword">if</span> (likely(!kmem_cache_debug(s) &amp;&amp; pfmemalloc_match(page, gfpflags)))</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only entered in the debug case */</span></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">			!alloc_debug_processing(s, page, freelist, addr))</span><br><span class="line">		<span class="keyword">goto</span> new_slab;	<span class="comment">/* Slab failed checks. Next slab needed */</span></span><br><span class="line"></span><br><span class="line">	deactivate_slab(s, page, get_freepointer(s, freelist), c);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="3-3、kfree"><a href="#3-3、kfree" class="headerlink" title="3.3、kfree"></a>3.3、kfree</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/slub%20allocator/" data-id="cmbcy7rh7001dt8mtd57h1fzb" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/systemd_PPP_online" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/systemd_PPP_online/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.236Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>本文介绍使用systemd的服务功能，实现开机执行ppp拨号脚本</p>
</blockquote>
<h2 id="1、编辑unit"><a href="#1、编辑unit" class="headerlink" title="1、编辑unit"></a>1、编辑unit</h2><p>编写unit配置文件，实现开机拨号上网。</p>
<p>配置文件如下：其路径为&#x2F;etc&#x2F;systemd&#x2F;system</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=auto_quectel </span><br><span class="line"></span><br><span class="line">[Service] </span><br><span class="line">Type=simple </span><br><span class="line">WorkingDirectory=/etc/init.d/ </span><br><span class="line">ExecStartPre=systemctl restart systemd-networkd ExecStart=/etc/init.d/auto_ppp.sh </span><br><span class="line">KillMode=control-group </span><br><span class="line">KillSignal=SIGKILL </span><br><span class="line">RemainAfterExit=yes </span><br><span class="line">Restart=on-failure </span><br><span class="line"></span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>Type&#x3D;simple指定从ExecStart启动主进程；</p>
<p>ExecStart指定启动进程的命令；</p>
<p>RemainAfterExit表示auto_quectel.sh退出后，auto_quectel.service仍被保留；</p>
<p>KillMode表示杀死服务的程度：</p>
<ul>
<li>control-group：杀死服务的所有进程</li>
<li>process：只杀主进程</li>
<li>mixed：主进程收到SIGTERM,子进程收到SIGKILL</li>
<li>none：不杀进程，执行服务的stop命令</li>
</ul>
<p>Restart字段可设置以下值：</p>
<ul>
<li>no：退出后不重启</li>
<li>on-success：正常退出时才会重启</li>
<li>on-failure：非正常退出时，才会重启</li>
<li>on-watechdog：超时退出才重启</li>
<li>on-abnormal：只有被信号终止和超时才重启</li>
<li>always：不管啥原因，总是重启</li>
</ul>
<p><strong>WantedBy&#x3D;multi-user.target将auto_ppp.service复制到multi-user.target.wants目录下，由于default.target是multi-user.target，故开机默认启动multi-user.target，所以auto_ppp.service也会被启动；</strong></p>
<p><strong>multi-user.target配置文件如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=Multi-User System </span><br><span class="line">Documentation=man:systemd.special(<span class="number">7</span>) </span><br><span class="line">Requires=basic.target </span><br><span class="line">Conflicts=rescue.service rescue.target </span><br><span class="line">After=basic.target rescue.service rescue.target </span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Require：要求basic.target也要同时启动</p>
</li>
<li><p>Conflict：要求不能与rescue 同时运行</p>
</li>
<li><p>After：要求在basic.target rescue.service rescue.target执行完成后才开始执行</p>
</li>
<li><p>AllowIsolate&#x3D;yes 允许使用systemctl isolate命令切换到multi-user.target</p>
</li>
</ul>
<h2 id="2、编辑ppp拨号脚本"><a href="#2、编辑ppp拨号脚本" class="headerlink" title="2、编辑ppp拨号脚本"></a>2、编辑ppp拨号脚本</h2><p>在上面中，auto_ppp服务的启动命令是&#x2F;etc&#x2F;init.d&#x2F;auto_ppp.sh脚本，由我们来编辑该脚本实现拨号上网。</p>
<p>在该脚本中，每隔5秒会执行一次，每次执行会检查LTE模块是否正常被识别，并虚拟出ttyUSB设备，检查ppp拨号脚本，获取当前ppp连接状态并决定是否进行ppp拨号，最后会将ppp0网口添加到路由表中，其metric固定为120；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">sleep</span> 5 	</span><br><span class="line">    <span class="comment">#check /dev/ttyUSB3 </span></span><br><span class="line">    modem=`lsusb | grep <span class="string">&quot;LTE modem&quot;</span>` usb=`<span class="built_in">ls</span> /dev | grep ttyUSB3`  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$&#123;usb&#125;</span>&quot;</span> == <span class="string">&quot;x&quot;</span> ];<span class="keyword">then</span> 	</span><br><span class="line">        <span class="built_in">continue</span> </span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#check quectel-ppp </span></span><br><span class="line">    <span class="keyword">if</span> [ ! -f <span class="string">&quot;/etc/ppp/peers/quectel-ppp&quot;</span> ];<span class="keyword">then</span> 	</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;/etc/ppp/peers/quectel-pp not found&quot;</span> 	</span><br><span class="line">        <span class="built_in">continue</span> </span><br><span class="line">    <span class="keyword">fi</span> 	</span><br><span class="line"></span><br><span class="line">    <span class="comment">#check ppp status </span></span><br><span class="line">    ppp_status=`ifconfig | grep ppp0 | awk &#123;<span class="string">&#x27;print $1&#x27;</span>&#125;` </span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$&#123;ppp_status&#125;</span>&quot;</span> == <span class="string">&quot;x&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">     	<span class="comment">#ppp not connect 	</span></span><br><span class="line">        pppd call quectel-ppp &amp; 	 	</span><br><span class="line">        <span class="built_in">sleep</span> 5 	</span><br><span class="line">        <span class="built_in">continue</span> </span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">    </span><br><span class="line">    route=`route -n | grep ppp0 | grep 120`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$&#123;route&#125;</span>&quot;</span> == <span class="string">&quot;x&quot;</span> ];<span class="keyword">then</span> 	</span><br><span class="line">        route add default dev ppp0 metric 120 </span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure>


<h2 id="三、开启ppp服务自启动"><a href="#三、开启ppp服务自启动" class="headerlink" title="三、开启ppp服务自启动"></a>三、开启ppp服务自启动</h2><p>可在命令行通过以下命令，管理服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开机自启动 systemctl enable auto_quectel  </span><br><span class="line"># 关闭开机自启动 systemctl disable auto_quectel  </span><br><span class="line"># 查看服务状态 systemctl status auto_quectel</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/systemd_PPP_online/" data-id="cmbcy7rh7001et8mtdolr2r2f" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/systemd_brief" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/systemd_brief/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.236Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>systemd是linux系统第一个运行的进程，用来创建系统的守护进程来管理整个linux系统。systemd取代init的一个优势就是他集合了丰富的功能，同时支持并行启动守护进程，使用起来方便。可以理解为systemd初始化整个系统所需的资源。</p>
</blockquote>
<p>@[toc]</p>
<h2 id="一、systemd-基本命令"><a href="#一、systemd-基本命令" class="headerlink" title="一、systemd 基本命令"></a>一、systemd 基本命令</h2><p>通过命令控制systemd来管理系统的服务。</p>
<h3 id="1、systemctl"><a href="#1、systemctl" class="headerlink" title="1、systemctl"></a>1、systemctl</h3><p>systemctl是最基本的一个命令，可用于管理系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重启系统 $ sudo systemctl reboot </span><br><span class="line"># 关闭系统，切断电源 $ sudo systemctl poweroff </span><br><span class="line"># CPU停止工作 $ sudo systemctl halt </span><br><span class="line"># 暂停系统 $ sudo systemctl suspend </span><br><span class="line"># 让系统进入冬眠状态 $ sudo systemctl hibernate </span><br><span class="line"># 让系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep </span><br><span class="line"># 启动进入救援状态（单用户状态） $ sudo systemctl rescue</span><br></pre></td></tr></table></figure>



<h3 id="2、systemd-analyze"><a href="#2、systemd-analyze" class="headerlink" title="2、systemd-analyze"></a>2、systemd-analyze</h3><p>systemd-analyze用于分析系统启动守护进程所耗费的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看启动耗时 $ systemd-analyze                                                                                       </span><br><span class="line"># 查看每个服务的启动耗时 $ systemd-analyze blame </span><br><span class="line"># 显示瀑布状的启动过程流 $ systemd-analyze critical-chain </span><br><span class="line"># 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>



<h2 id="二、Unit"><a href="#二、Unit" class="headerlink" title="二、Unit"></a>二、Unit</h2><p>Systemd 可以管理的系统资源。不同的资源统称为 Unit（单位）。</p>
<h3 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h3><p>Unit有12种：</p>
<ul>
<li>service：系统服务</li>
<li>target：多个unit构成的一个组</li>
<li>mount：文件系统挂载点</li>
<li>automount：自动挂载点</li>
<li>path：文件或路径</li>
<li>scope：不是由systemd启动的外部进程</li>
<li>slice：进程组</li>
<li>socket：进程间通信的socket</li>
<li>swap：swap文件</li>
<li>timer：定时器</li>
<li>device：硬件设备</li>
</ul>
<h3 id="2、unit管理"><a href="#2、unit管理" class="headerlink" title="2、unit管理"></a>2、unit管理</h3><p>最常用的unit管理命令：</p>
<ul>
<li>systemctl start unit</li>
<li>systemctl stop unit</li>
<li>systemctl restart unit</li>
<li>systemctl reload unit(重新加载unit的配置文件)</li>
<li>systemctl kill unit(杀死unit的所有进程)</li>
<li>systemctl daemon-reload(重新加载所有修改过的配置文件)</li>
</ul>
<h3 id="3、依赖、顺序"><a href="#3、依赖、顺序" class="headerlink" title="3、依赖、顺序"></a>3、依赖、顺序</h3><p>Unit 之间存在依赖关系：若A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<ul>
<li>want：表示弱依赖，若一个弱依赖的服务异常关闭，本服务不受影响</li>
<li>require：表示强依赖，若一个强依赖的服务异常关闭，本服务也要关闭</li>
<li>after：本服务要在之后执行</li>
<li>before：本服务要在之前执行</li>
</ul>
<p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p>
<h2 id="三、Unit配置文件"><a href="#三、Unit配置文件" class="headerlink" title="三、Unit配置文件"></a>三、Unit配置文件</h2><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，真正的配置文件存放在&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;目录下</p>
<h3 id="【Uint】区块"><a href="#【Uint】区块" class="headerlink" title="【Uint】区块"></a>【Uint】区块</h3><p><code>[Unit]</code>区块用来定义 Unit 的内容，配置与其他 Unit 的依赖、启动顺序关系。它的主要字段如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Description：简短描述 Documentation：文档地址 Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败 Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败 BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行 Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</span><br></pre></td></tr></table></figure>



<h3 id="【Install】区块"><a href="#【Install】区块" class="headerlink" title="【Install】区块"></a>【Install】区块</h3><p>定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中 RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中 Alias：当前 Unit 可用于启动的别名 Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</span><br></pre></td></tr></table></figure>



<h3 id="【Service】区块"><a href="#【Service】区块" class="headerlink" title="【Service】区块"></a>【Service】区块</h3><p>Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type：定义启动时的进程行为。它有以下几种值。 Type=simple：默认值，执行ExecStart指定的命令，启动主进程 Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出 Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行 Type=dbus：当前服务通过D-Bus启动 Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行 Type=idle：若有其他任务执行完毕，当前服务才会运行 ExecStart：启动当前服务的命令 ExecStartPre：启动当前服务之前执行的命令 ExecStartPost：启动当前服务之后执行的命令 ExecReload：重启当前服务时执行的命令 ExecStop：停止当前服务时执行的命令 ExecStopPost：停止当其服务之后执行的命令 RestartSec：自动重启当前服务间隔的秒数 Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数 Environment：指定环境变量 RemainAfterExit：unit的进程退出后，unit资源保留下来 </span><br></pre></td></tr></table></figure>



<h2 id="四、Target"><a href="#四、Target" class="headerlink" title="四、Target"></a>四、Target</h2><p>systemd管理的Unit很多，一个个启动很麻烦，用target来帮助系统大量启动Unit。Target 就是一个 Unit 组，包含许多 Unit。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p>
<p>systemd启动的第一个target为default.target，他是一个软链接，能指向multi-user.target或graphical.target.（用户控制）</p>
<p>graphical.target启动了图形界面所需的服务，包括了multi-user.target.</p>
<p>systemd启动的服务流程可从官网提供的流程图了解：<br><a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup">https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前系统的所有 Target $ systemctl list-unit-files --type=target </span><br><span class="line"># 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target </span><br><span class="line"># 查看启动时的默认 Target $ systemctl get-default </span><br><span class="line"># 设置启动时的默认 Target $ sudo systemctl set-default multi-user.target </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/systemd_brief/" data-id="cmbcy7rh8001ft8mtf81pa3mf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/task" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/task/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.236Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="创建新task"><a href="#创建新task" class="headerlink" title="创建新task"></a>创建新task</h3><h4 id="kernel-clone"><a href="#kernel-clone" class="headerlink" title="kernel_clone"></a>kernel_clone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_clone</span><span class="params">(<span class="keyword">struct</span> kernel_clone_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 clone_flags = args-&gt;flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">pid_t</span> nr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//复制进程</span></span><br><span class="line">	p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line"></span><br><span class="line">	pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">	nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果是vfork，则初始化completion对象，在新进程执行exec()之后，completion会被设置完成</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">		p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">		init_completion(&amp;vfork);</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//唤醒新进程</span></span><br><span class="line">	wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待新进程完成exec()调用</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">			ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	put_pid(pid);</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/task/" data-id="cmbcy7rh8001ht8mtd4b49yui" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/12/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
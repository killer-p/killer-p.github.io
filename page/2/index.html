<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/other/openvpn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/other/openvpn/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.657Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!--
 * @Author: your name
 * @Date: 2021-11-02 23:39:34
 * @LastEditTime: 2021-11-02 23:39:34
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: \smart_controlc:\Users\prx\Desktop\openvpn介绍.md
-->
<p>@[toc]</p>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1、vpn概念"><a href="#1、vpn概念" class="headerlink" title="1、vpn概念"></a>1、vpn概念</h2><p>vpn即虚拟专有网络。是一种对局域网的模拟。</p>
<p>将互联网上网络主机使用加密的隧道连接成一个私网，私网内的主机之间通信具有加密性，私网中的主机会获得一个在该私网中的虚拟ip地址，通过该虚拟ip地址就能与私网内的主机安全通信。</p>
<h2 id="2、vpn应用场景"><a href="#2、vpn应用场景" class="headerlink" title="2、vpn应用场景"></a>2、vpn应用场景</h2><p>vpn经常用于员工远程访问公司内网，公司内网中有服务器，只有在内网中的主机能够访问该服务器，出差的员工想通过远程访问服务器，就需要将笔记本电脑与公司服务器组成一个私网，由于这个私网是跨越在互联网之上的，所以使用vpn来组织私网。任何员工只要接入该vpn，就能远程访问公司服务器。</p>
<h2 id="3、openvpn概述"><a href="#3、openvpn概述" class="headerlink" title="3、openvpn概述"></a>3、openvpn概述</h2><p>openvpn2.x是使用OpenSSL实现虚拟专用网络的软件，因此他具备了OpenSSL提供的所有安全服务（身份认证，数据加密，数据完整性校验），并可以运行在不同主流的操作系统中。</p>
<p>openvpn 工作于 服务器&#x2F;客户端 模式，服务器的作用类似于局域网内的网关，负责在各个客户端之间转发数据消息。</p>
<h2 id="4、openvpn工作原理"><a href="#4、openvpn工作原理" class="headerlink" title="4、openvpn工作原理"></a>4、openvpn工作原理</h2><p>openvpn进程运行在用户空间，负责对数据进行加密封装&#x2F;解密解封等，不需要修改系统内核，通过在系统中创建的一个虚拟网卡，字符驱动程序来与系统内核进行通信。</p>
<p>虚拟网卡是openvpn实现功能的一个重要设备，用户空间的openvpn进程通过字符驱动来与虚拟网卡通信，虚拟网卡则通过路由转发与操作系统的协议栈通信。虚拟网卡在此作为openvpn进程与系统协议栈通信的媒介。</p>
<p>如图是Openvpn通信原理图：<br><img src="/2025/05/30/hello-world/other/openvpn/5b3cd956bcc4485ebeec7d07a54eef78.png"></p>
<p>每个步骤的详细内容：</p>
<p>​     由客户端APP发送数据为例</p>
<ol>
<li>APP发送目的地址为虚拟ip的UDP&#x2F;TCP 报文到socket接口</li>
<li>socket将报文传递到ip层</li>
<li>ip层将数据转发到虚拟网卡</li>
<li>虚拟网卡将报文传递给设备驱动</li>
<li>Openvpn进程对报文加密，生成数字签名，并将原始报文封装到一个新的UDP&#x2F;TCP报文中。远程IP即服务器公网IP，端口号默认1194</li>
<li>Openvpn将新报文通过socket发送</li>
<li>socket将新报文传递到ip层路由</li>
<li>ip层将新报文转发到物理网卡</li>
<li>物理网卡将新报文发送到服务器网卡<br>以下是服务器主机：</li>
<li>物理网卡将新报文传递到ip层</li>
<li>ip层将新报文传递给socket</li>
<li>socket根据端口号（1194）将新报文传递给Openvpn进程</li>
<li>Openvpn进程使用密钥对数据进行解密，校验，提取原始报文，并写入设备驱动</li>
<li>设备驱动将原始报文传递给虚拟网卡</li>
<li>虚拟网卡将原始报文发送到ip层</li>
<li>ip层将原始报文传递给socket</li>
<li>socket根据原始报文中的端口号，传递给对应的APP</li>
</ol>
<h2 id="5、虚拟网卡"><a href="#5、虚拟网卡" class="headerlink" title="5、虚拟网卡"></a>5、虚拟网卡</h2><p>用户程序通过字符设备驱动向虚拟网卡读取&#x2F;写入数据，虚拟网卡调用网卡驱动将数据读取&#x2F;写入tcp&#x2F;ip协议栈中。虚拟网和物理网卡一样，拥有自己的ip地址和网关。</p>
<p>openvpn的虚拟网卡支持tun和tap两种模式</p>
<ul>
<li>tun：一个虚拟的点对点的ip连接，通过字符设备驱动读取到的数据为ip数据包</li>
<li>tap：一个以太网适配器，通过字符设备驱动读取到的数据包含物理帧头，该模式可以传输以太网帧。</li>
</ul>
<p><img src="/2025/05/30/hello-world/other/openvpn/eb64e6b7781846c4b6554d6d426e7721.png" alt="在这里插入图片描述"></p>
<h2 id="6、虚拟地址"><a href="#6、虚拟地址" class="headerlink" title="6、虚拟地址"></a>6、虚拟地址</h2><p>openvpn服务端配置一个虚拟的ip池，如10.8.0.0&#x2F;24，每一个连接的客户端都会被分配一个虚拟的ip地址，服务端成为客户端在虚拟网络10.8.0.0&#x2F;24上的网关，这样客户端与服务端就构成了一个星型的网络。</p>
<p>客户端在虚拟网络10.8.0.0&#x2F;24上的通信都需要经过服务端来进行路由转发。可通过修改子网掩码，使ip地址池可用ip增加。</p>
<p>openvpn为了兼容tap-win32，windows系统，会为每一个客户端分配四个ip地址；故当使用10.8.0.0&#x2F;24网段时，虽然有256个可用的ip地址，但由于每个vpn占用4个ip地址，故仅能同时给64个vpn分配ip；</p>
<p>若在vpn中不存在windows系统，则可修改ip的分配方式。每个vpn只占用一个ip，可为客户端提供：10.8.0.2-→10.8.0.253的连续ip地址。</p>
<p>在server配置文件中，加入命令，开启此功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topology subnet</span><br></pre></td></tr></table></figure>



<h1 id="二、安装openvpn"><a href="#二、安装openvpn" class="headerlink" title="二、安装openvpn"></a>二、安装openvpn</h1><p>硬件环境：虚拟机 Ubuntu18</p>
<p>软件环境：openvpn</p>
<h2 id="1、安装openvpn"><a href="#1、安装openvpn" class="headerlink" title="1、安装openvpn"></a>1、安装openvpn</h2><p>在Ubuntu命令行中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openvpn</span><br></pre></td></tr></table></figure>



<p>完成openvpn的安装，安装完成的openvpn可执行程序在 &#x2F;usr&#x2F;sbin&#x2F;openvpn，程序工作目录在&#x2F;etc&#x2F;openvpn</p>
<h2 id="2、安装easy-rsa"><a href="#2、安装easy-rsa" class="headerlink" title="2、安装easy-rsa"></a>2、安装easy-rsa</h2><p>证书的生成需要使用easy-rsa。从github中下载easy-rsa2.0：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/OpenVPN/easy-rsa-old/archive/refs/heads/master.zip</span><br></pre></td></tr></table></figure>





<p>解压文件到目录&#x2F;etc&#x2F;openvpn下</p>
<h1 id="三、配置证书"><a href="#三、配置证书" class="headerlink" title="三、配置证书"></a>三、配置证书</h1><p>证书的生成是用easy-rsa来实现的。</p>
<h2 id="1、CA证书"><a href="#1、CA证书" class="headerlink" title="1、CA证书"></a>1、CA证书</h2><p>OpenVPN支持双向认证。客户端和服务端的证书需要有ca机构签名。ca机构用ca证书给其他证书签名，ca证书是根本的。</p>
<p>修改&#x2F;etc&#x2F;openvpn&#x2F;easy-rsa&#x2F;vars文件里的 KEY_COUNTRY, KEY_PROVINCE, KEY_CITY, KEY_ORG, and KEY_EMAIL参数 并将当前目录下的openssl-1.0.0.cnf 重命名为openssl.cnf 并执行下列命令生成CA文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ./vars ./clean-all ./build-ca</span><br></pre></td></tr></table></figure>


<p>输入相应的参数：</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/0569abb14cc84a6abb8e1ba440c34ec5.png"></p>
<h2 id="2、服务端证书和私钥"><a href="#2、服务端证书和私钥" class="headerlink" title="2、服务端证书和私钥"></a>2、服务端证书和私钥</h2><p>执行 .&#x2F;build-key-server server 签发服务端证书和私钥：</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/aec06cc7442940c1b9bfb367580efb64.png"></p>
<h2 id="3、客户端证书和私钥"><a href="#3、客户端证书和私钥" class="headerlink" title="3、客户端证书和私钥"></a>3、客户端证书和私钥</h2><p>生成3个客户端证书密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key client_1 ./build-key client_2 ./build-key client_3</span><br></pre></td></tr></table></figure>

<p>下图提示是否对证书进行签名，输入y确认签名，即可生成可使用的客户端证书</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/4804d95d7de64ebf9d377eb1a8138901.png" alt="在这里插入图片描述"></p>
<h2 id="4、Diffie-Hellman-参数文件"><a href="#4、Diffie-Hellman-参数文件" class="headerlink" title="4、Diffie Hellman 参数文件"></a>4、Diffie Hellman 参数文件</h2><p>diffie hellman参数文件用于在安全的情况下，协商密钥，执行以下语句生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure>



<h2 id="5、生成ta-key"><a href="#5、生成ta-key" class="headerlink" title="5、生成ta.key"></a>5、生成ta.key</h2><p>使用tls-auth加密udp数据包，需要一个共享密钥来校验SSL握手报文，执行以下命令生成该密钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret ta.key</span><br></pre></td></tr></table></figure>





<p>至此，所需的证书和密钥就生成完毕了。生成的证书文件放在keys文件夹下。如图</p>
<p>将client1.crt,client.key,ca.crt,ta.key通过安全的途径复制到客户端1主机中。</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/04ae536c65134e6281237b2cf9cbf4a4.png" alt="在这里插入图片描述"></p>
<h1 id="四、配置openvpn"><a href="#四、配置openvpn" class="headerlink" title="四、配置openvpn"></a>四、配置openvpn</h1><p>openvpn的配置信息主要是由配置文件中的命令来设置的，可从github中下载实例配置文件client.conf，server.conf</p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/OpenVPN/openvpn">https://github.com/OpenVPN/openvpn</a></strong></p>
<h2 id="1、桥接或路由"><a href="#1、桥接或路由" class="headerlink" title="1、桥接或路由"></a>1、桥接或路由</h2><p>一般的vpn都会选择工作在路由模式，只需要经过简单的设置就能实现vpn的功能。路由模式下，客户端之间处于同一虚拟私网中，接受发送的数据包都是ip数据包；虚拟网卡使用tun</p>
<p>openvpn还支持桥接模式，该模式下，接入vpn的客户端之间不仅处于同一局域网中，还处于同一以太网中，此时的客户端接收发送的数据包是以太网数据包。该模式下配置较复杂。虚拟网卡使用tap</p>
<h2 id="2、确定虚拟子网"><a href="#2、确定虚拟子网" class="headerlink" title="2、确定虚拟子网"></a>2、确定虚拟子网</h2><p>确定虚拟网络的网段地址，需要注意子网的网段最好不要与客户端或服务端本地的网段重叠，局域网网段如下图，推荐使用10.8.0.0&#x2F;24网段。</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/a88b059a22ee40a09dd92e29293ac30f.png" alt="在这里插入图片描述"></p>
<h2 id="3、快速搭建vpn"><a href="#3、快速搭建vpn" class="headerlink" title="3、快速搭建vpn"></a>3、快速搭建vpn</h2><p>为了快速建立一个vpn，只需要修改服务端和客户端配置文件中的以下几项：</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>在server.conf中修改ca证书，server证书和私钥，dh的路径如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ca /etc/openvpn/easy-rsa-old/2.0/keys/ca.crt </span><br><span class="line">cert  /etc/openvpn/easy-rsa-old/2.0/keys/server.crt </span><br><span class="line">key  /etc/openvpn/easy-rsa-old/2.0/keys/server.key    </span><br><span class="line">dh  /etc/openvpn/easy-rsa-old/2.0/keys/dh2048.pem</span><br></pre></td></tr></table></figure>



<p>确定VPN的虚拟网段，服务端主机的VPN ip为10.8.0.1</p>
<p>修改ta.key证书的地址 在服务端需要设置参数为0</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 10.8.0.0 255.255.255.0  tls-auth /etc/openvpn/ta.key 0 </span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>类似于服务端，在client.conf修改ca证书，server证书和密钥，dh路径如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ca /etc/openvpn/easy-rsa-old/2.0/keys/ca.crt </span><br><span class="line">cert  /etc/openvpn/easy-rsa-old/2.0/keys/server.crt </span><br><span class="line">key  /etc/openvpn/easy-rsa-old/2.0/keys/server.key</span><br></pre></td></tr></table></figure>



<p>修改ta.key证书的地址 在客户端需要设置参数为1，指定remote 中的服务端的公网ip地址：（例如服务端的公网ip为192.168.3.1）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tls-auth /etc/openvpn/ta.key 1  remote 192.168.3.1 1194</span><br></pre></td></tr></table></figure>



<p>至此，配置文件编写完成。</p>
<h1 id="五、启动openvpn"><a href="#五、启动openvpn" class="headerlink" title="五、启动openvpn"></a>五、启动openvpn</h1><h2 id="1、启动openvpn-server"><a href="#1、启动openvpn-server" class="headerlink" title="1、启动openvpn server"></a>1、启动openvpn server</h2><p>在server.conf 目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn server.conf</span><br></pre></td></tr></table></figure>


<p>打印信息如下：表示server建立成功</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/3ed89d4c4d5148d7b67a139eff9d7ea4.png" alt="在这里插入图片描述"></p>
<h2 id="2、启动openvpn-client"><a href="#2、启动openvpn-client" class="headerlink" title="2、启动openvpn client"></a>2、启动openvpn client</h2><p>在server.conf 目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn client.conf</span><br></pre></td></tr></table></figure>

<p>客户端验证成功，打印信息如下：</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/85cb14a5b8ac451fb4ef09ada068eacf.png" alt="在这里插入图片描述"></p>
<p><img src="/2025/05/30/hello-world/other/openvpn/ebe8beafc83e4698a1d9c198ea335432.png" alt="在这里插入图片描述"></p>
<h2 id="3、server-和-client-在vpn中互ping"><a href="#3、server-和-client-在vpn中互ping" class="headerlink" title="3、server 和 client 在vpn中互ping"></a>3、server 和 client 在vpn中互ping</h2><p>从上面可知client在vpn中的ip为10.8.0.14，在server中启动新的命令行，ping 10.8.0.14 成功收到反馈</p>
<p>在客户端机器中ping 10.8.0.1 服务端主机，成功反馈。</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/37c027247ed642f09e418da9684d0119.png" alt="在这里插入图片描述"></p>
<p><img src="/2025/05/30/hello-world/other/openvpn/1b80a6bb204846c083a5a6a91a1c0e75.png" alt="在这里插入图片描述"></p>
<h1 id="六、其他配置"><a href="#六、其他配置" class="headerlink" title="六、其他配置"></a>六、其他配置</h1><h2 id="1、设置开机自动启动"><a href="#1、设置开机自动启动" class="headerlink" title="1、设置开机自动启动"></a>1、设置开机自动启动</h2><p>要开启此功能，必须使用rpm或deb包安装openvpn，用这种方式安装openvpn会生成一个初始化脚本，该脚本会扫面&#x2F;etc&#x2F;openvpn&#x2F;下的所有.conf文件，并启动对应的vpn进程。</p>
<h2 id="2、控制openvpn进程的方式"><a href="#2、控制openvpn进程的方式" class="headerlink" title="2、控制openvpn进程的方式"></a>2、控制openvpn进程的方式</h2><h3 id="a、使用信号量"><a href="#a、使用信号量" class="headerlink" title="a、使用信号量"></a>a、使用信号量</h3><p>使用writepid命令将openvpn经常的pid写入一个文件中，用户程序就能根据pid发送信号量来控制openvpn进程。</p>
<h3 id="b、在运行中修改配置文件"><a href="#b、在运行中修改配置文件" class="headerlink" title="b、在运行中修改配置文件"></a>b、在运行中修改配置文件</h3><p>openvpn支持在进程运行时修改部分配置文件：</p>
<ul>
<li>client-config-dir – 命令指出客户端配置文件的路径，每次客户端连接时，openvpn会扫描该目录并找对应的配置文件。在openvpn运行时，修改该目录的配置文件，旧的客户端连接不会被影响，若要更新某个特定的客户端连接，就要让客户端先断开再重新连接。</li>
<li>crl-verify – 指定一个证书撤销文件，用于撤销客户端的证书，修改他不会影响已经建立连接的客户端。</li>
</ul>
<h3 id="c、输出日志文件"><a href="#c、输出日志文件" class="headerlink" title="c、输出日志文件"></a>c、输出日志文件</h3><p>openvpn server中一行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status openvpn-status.log</span><br></pre></td></tr></table></figure>


<p>表示vpn每一分钟会将已连接的客户端列表打印到文件openvpn-status.log中。</p>
<h3 id="d、用户管理接口"><a href="#d、用户管理接口" class="headerlink" title="d、用户管理接口"></a>d、用户管理接口</h3><p>openvpn提供一个强大的管理接口来管理openvpn客户端或服务端进程。</p>
<p>openvpn通过监听一个ip和端口上的tcp连接来开启该接口，开发者通过一个telnet来连接该接口，由于这个tcp连接过程是没有经过任何加密的，所以建议将监听建立在localhost或者在vpn网段，以增加安全性</p>
<p>在openvpn sever配置文件中使用命令：管理接口监听在本地7505端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management localhost 7505  <span class="comment"># 若要支持vpn客户端连接上管理接口后输入密码认证，则需要添加命令 --management-client-auth</span></span><br></pre></td></tr></table></figure>


<p>该接口支持的命令文档：<a target="_blank" rel="noopener" href="https://openvpn.net/community-resources/management-interface/">https://openvpn.net/community-resources/management-interface/</a></p>
<p>常用命令：</p>
<ul>
<li>bytecount -n：当n&gt;0，管理接口每隔n秒打印带宽使用情况。n&#x3D;0关闭功能</li>
<li>exit&#x2F;quit：推出会话</li>
<li>killer：杀死一个client对象，命令后面跟着客户端的ip地址和端口，或common name</li>
<li>log：开启或关闭日志输出</li>
<li>pid：显示vpn进程pid</li>
<li>status：显示已连接 的客户端列表</li>
</ul>
<h2 id="3、扩展服务端的子网"><a href="#3、扩展服务端的子网" class="headerlink" title="3、扩展服务端的子网"></a>3、扩展服务端的子网</h2><p>场景：客户端除了与服务端本身通信外，还希望与服务端所在子网的主机通信。假设服务端所在的子网为192.168.137.0&#x2F;24，vpn虚拟子网为10.8.0.0&#x2F;24.</p>
<p>client发送数据，到达server，再由server将数据包在子网192.168.137.0&#x2F;24内转发到App_server主机。</p>
<p>App_server以正常方式处理该数据包，发送到路由器，路由器根据路由表（需要设置）转发到达openvpn server，openvpn server对数据包进行检查并重新封装，通过vpn隧道发送到client。</p>
<p>note：在网关路由中添加一条路由规则，将目的ip为10.8.0.0&#x2F;24的数据路由到openvpn server。</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/a8670adb212046d8a94436f8ca770b70.png" alt="在这里插入图片描述"></p>
<h2 id="4、扩展客户端的子网"><a href="#4、扩展客户端的子网" class="headerlink" title="4、扩展客户端的子网"></a>4、扩展客户端的子网</h2><p>类似的，假设客户端client2是一个网关，其子网为192.168.137.0&#x2F;24，vpn网络为10.8.0.0&#x2F;24，客户端子网中的主机要与服务端或服务端所在子网的主机通信。</p>
<p>首先确保192.168.137.0&#x2F;24没有与接入vpn的其他网络网段冲突。</p>
<p>在server的配置文件中指定客户端配置文件的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-config-dir ccd</span><br></pre></td></tr></table></figure>



<p>在ccd路径下创建client2文件，输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iroute 192.168.137.0 255.255.255.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个操作告诉vpn server ：发往192.168.137.0&#x2F;24的数据包 需要转发到client2.</p>
<p>在server.conf中添加命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route 192.168.137.0 255.255.255.0</span><br></pre></td></tr></table></figure>




<p>这个操作告诉虚拟网卡将 发往192.168.137.0&#x2F;24的数据包 传递给openvpn进程，由openvpn对数据包重新封装发送到client_2。</p>
<p><strong>同时在server 网关中添加路由规则，路由192.168.137.0&#x2F;24的数据包到server</strong></p>
<p><img src="/2025/05/30/hello-world/other/openvpn/0d85ce44ce454c139f58fbc2e85c55c7.png" alt="在这里插入图片描述"></p>
<p>若想要192.168.137.0&#x2F;24子网内的主机能与vpn中其他客户端通信，则在server.conf中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-to-client push <span class="string">&quot;route 192.168.137.0 255.255.255.0&quot;</span></span><br></pre></td></tr></table></figure>


<p>这个命令向所有客户端广播192.168.137.0&#x2F;24这个子网，表示该子网连接到vpn网络中。</p>
<h2 id="5、推送DNS服务器地址"><a href="#5、推送DNS服务器地址" class="headerlink" title="5、推送DNS服务器地址"></a>5、推送DNS服务器地址</h2><p>openvpn server 能给所有客户端推送DHCP选项，比如DNS服务器的地址。</p>
<p>假设DNS服务器的地址是10.8.0.3 ，在server.conf中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push <span class="string">&quot;dhcp-option DNS 10.8.0.3&quot;</span></span><br></pre></td></tr></table></figure>

<p>当客户端运行在linux系统中，需要设置脚本来将server 推送的dns保存到配置文件&#x2F;etc&#x2F;resolv.conf 中。</p>
<p>在客户端主机上创建&#x2F;etc&#x2F;openvpn&#x2F;client.up脚本文件，该文件内容可由仓库例程&#x2F;contrib&#x2F;pull-resolv-conf&#x2F;client.up参考。然后给与脚本执行权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x /etc/openvpn/client.up</span><br></pre></td></tr></table></figure>



<p>在客户端配置文件client.conf中添加该脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up /etc/openvpn/client.up</span><br></pre></td></tr></table></figure>

<p>当客户端连接到服务端时，会收到服务端推送的选项，openvpn client进程会将这些选项保存在环境变量foreign_option_{n}中，然后在客户端执行&#x2F;etc&#x2F;openvpn&#x2F;client.up脚本，脚本会提取环境变量foreign_option_{n}并在&#x2F;etc&#x2F;resolv.conf中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 10.8.0.3</span><br></pre></td></tr></table></figure>

<p>流程图如下：</p>
<p><img src="/2025/05/30/hello-world/other/openvpn/7073bccd8311428f82cebf554571576d.png" alt="在这里插入图片描述"></p>
<h2 id="6、客户端访问控制"><a href="#6、客户端访问控制" class="headerlink" title="6、客户端访问控制"></a>6、客户端访问控制</h2><p>应用场景：限制客户端A只能与vpn server通信，而不能跟其他客户端B,C,D通信。而超级客户端Y则能跟任何vpn内主机通信。</p>
<p>分为两个部分：</p>
<p>a，区分客户端。</p>
<p>b，设置服务端的防火墙规则。</p>
<h3 id="a、区分客户端"><a href="#a、区分客户端" class="headerlink" title="a、区分客户端"></a>a、区分客户端</h3><p>假设超级客户端的虚拟ip网段为10.8.2.0&#x2F;24，其他客户端的虚拟ip为10.8.0.0&#x2F;24网段。</p>
<p>在server.conf中设置vpn的虚拟ip网段为10.8.0.0&#x2F;24，并支持路由到10.8.2.0&#x2F;24</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 10.8.0.0 255.255.255.0 <span class="comment"># server接受来自10.8.2.0/24的数据包 route 10.8.2.0 255.255.255.0</span></span><br></pre></td></tr></table></figure>

<p>修改ccd目录下的客户端配置文件，给特定的超级客户端分配特定的ip地址:</p>
<p>ip地址的设置有一定的要求，具体见文档<a target="_blank" rel="noopener" href="https://openvpn.net/community-resources/how-to/">https://openvpn.net/community-resources/how-to/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># determining-whether-to-use-a-routed-or-bridged-vpn </span></span><br><span class="line">ifconfig-push 10.8.2.1 10.8.2.2</span><br></pre></td></tr></table></figure>

<p>超级客户端连接上vpn后，其虚拟ip地址是10.8.2.1.其他客户端的虚拟ip为10.8.0.0&#x2F;24网段。</p>
<h3 id="b、设置防火墙"><a href="#b、设置防火墙" class="headerlink" title="b、设置防火墙"></a>b、设置防火墙</h3><p>设置openvpn server所在机器的防火墙的转发规则，使普通客户端的报文只能输入到server，超级客户端的报文能正常转发给普通客户端。</p>
<p>首先修改server.conf中虚拟网卡的编号为dev tun0，以便在防火墙规则中引用他</p>
<p>修改linux防火墙规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅允许其他客户端访问server 10.8.0.1(源地址是10.8.0.0/24,目的地址不是10.8.0.1的数据包，会被防火墙丢弃) </span></span><br><span class="line">iptables -A FORWARD -i tun0 -s 10.8.0.0/24 -d !10.8.0.1 -j DROP  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许超级客户端访问10.8.0.0/24所有主机(源地址是10.8.0.0/24,目的地址是10.8.0.0/24的数据包，会被转发) </span></span><br><span class="line">iptables -A FORWARD -i tun0 -s 10.8.2.1 -d 10.8.0.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure>

<h2 id="7、通过http代理连接openvpn"><a href="#7、通过http代理连接openvpn" class="headerlink" title="7、通过http代理连接openvpn"></a>7、通过http代理连接openvpn</h2><p>由于http代理使用tcp协议，所以在客户端和服务端的配置文件中都需要将proto命令设置为tcp。</p>
<p>openvpn支持三个代理认证方式：</p>
<ul>
<li>无代理认证</li>
<li>用户名&#x2F;密码代理认证</li>
<li>NTLM代理认证</li>
</ul>
<p>在客户端配置文件中添加代理服务器的地址及认证方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行输入用户名密码 </span></span><br><span class="line">http-proxy 192.168.4.1 1080 stdin basic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在passfile文件存放用户名/密码 </span></span><br><span class="line">http-proxy 192.168.4.1 1080 passfile</span><br></pre></td></tr></table></figure>






<h2 id="8、负载均衡"><a href="#8、负载均衡" class="headerlink" title="8、负载均衡"></a>8、负载均衡</h2><p>负载均衡是在高并发的情况下，将请求合理的分配到不同的服务器进程中。这就要求运行多个openvpn server进程，无论是在一个主机上还是在多个不同主机上。</p>
<h3 id="a、客户端配置"><a href="#a、客户端配置" class="headerlink" title="a、客户端配置"></a>a、客户端配置</h3><p>客户端只需要在remote指令中指出多个服务器的地址和端口即可。</p>
<h3 id="b、服务端"><a href="#b、服务端" class="headerlink" title="b、服务端"></a>b、服务端</h3><p>当多个服务端运行在同一台机器时，使用同一份配置文件，只需要修改端口号。</p>
<p>当多个服务端运行在不同机器时，要确保每个机器上有相同的客户端证书和认证方式。</p>
<p>多个openvpn服务器必须各自拥有唯一的虚拟ip地址。</p>
<h2 id="9、撤销客户端证书"><a href="#9、撤销客户端证书" class="headerlink" title="9、撤销客户端证书"></a>9、撤销客户端证书</h2><p>撤销客户端证书意味着客户端不能使用该证书完成客户端认证。</p>
<p>首先，在easy-rsa路径下，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ./vars ./revoke-full client</span><br></pre></td></tr></table></figure>

<p>该命令会在keys目录下生成一个crl.pem文件，需要将该文件放到openvpn server可访问的路径，并在server配置文件中加入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crl-verify crl.pem</span><br></pre></td></tr></table></figure>

<p>当有新的连接进入vpn时，所有客户端会与该文件比较，匹配的客户端将会被强制断开连接。</p>
<h2 id="10、使用脚本和环境变量二次开发"><a href="#10、使用脚本和环境变量二次开发" class="headerlink" title="10、使用脚本和环境变量二次开发"></a>10、使用脚本和环境变量二次开发</h2><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>openvpn支持用户自定义脚本，以在openvpn运行过程中执行脚本。在openvpn配置文件中加入以下命令以注册脚本，当相应条件满足时，openvpn就会执行对应脚本。</p>
<ul>
<li>up：在TCP&#x2F;UDP套接字绑定后并打开tun之后执行、</li>
<li>tls-verify：有一个不信任的远程对端时执行</li>
<li>ipchange：在连接后或服务器ip发生改变后执行</li>
<li>client-connect：在服务器端，一个客户端认证后执行</li>
<li>route-up：在连接完成后执行</li>
<li>client-disconnect：客户端断开连接后执行</li>
<li>down：tcp&#x2F;udp，tun&#x2F;tap关闭后执行</li>
<li>learn-address：ipv4地址或mac地址被添加到openvpn server路由表时执行</li>
<li>auth-user-pass-verify：客户端连接并还未认证时执行</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>openvpn运行过程会设置环境变量，传递给脚本使用。环境变量一旦被设置，会一直保持直到被覆盖或重启。环境变量是以一个客户端为对象的，每个客户端都有各自独立的环境变量。</p>
<h2 id="11、全局vpn"><a href="#11、全局vpn" class="headerlink" title="11、全局vpn"></a>11、全局vpn</h2><p>若想让客户端的所有ip报文都通过vpn通道传输，则可以在客户端中设置命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push <span class="string">&quot;redirect-gateway def1&quot;</span></span><br></pre></td></tr></table></figure>

<p>客户端会将所有ip报文发送到服务端，服务端需要把报文转发到互联网，可使用NAT或http代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用防火墙对源地址为10.8.0.0/24的报文转发到eth0网口 </span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>客户端发送的DNS请求也会经过服务端，服务端需要接受请求，并把DNS服务器的地址推送给客户端，来替换他们原本的DNS服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push <span class="string">&quot;dhcp-option DNS 10.8.0.1&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：客户端需要周期性与DHCP服务器通信以获取ip地址，redirect-gateway命令可能使客户端长度无法与DHCP正常通信而丢失ip</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/other/openvpn/" data-id="cmbcy7rhz003mt8mt4p0lfbx4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_mm_heap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_mm_heap/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.656Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，内存堆简介"><a href="#一，内存堆简介" class="headerlink" title="一，内存堆简介"></a>一，内存堆简介</h2><p>lwip使用内存堆进行动态内存分配，弥补了内存池的缺点。</p>
<p><strong>内存堆的灵活性表现在，每个内存块的大小是可以随意变化的，每次用户申请内存时，都会从内存堆中寻找第一个长度不小于所需大小的内存块，然后将该内存块裁剪合适后，将剩余的内存组成新的内存块返回内存堆中。</strong></p>
<p>回收内存块时，若其前后的内存块也处于空闲，则可将多个内存块合并成一个大内存块。防止内存的碎片化。</p>
<p>一开始的内存堆就是一个大的内存块，经过不断的申请和释放后，可能呈现出如下的局面，所以<strong>在使用时要遵循“申请，释放，申请，释放”。</strong></p>
<h2 id="二，内存堆数据结构"><a href="#二，内存堆数据结构" class="headerlink" title="二，内存堆数据结构"></a>二，内存堆数据结构</h2><p><strong>内存块结构体就是一个双向的链表，这个链表在内存上也是连续的。其中next和prev表示的是相对首地址的偏移量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem</span> &#123;</span></span><br><span class="line">  <span class="type">mem_size_t</span> next;	<span class="comment">//下一个内存块</span></span><br><span class="line">  <span class="type">mem_size_t</span> prev;	<span class="comment">//上一个内存块</span></span><br><span class="line">  <span class="type">u8_t</span> used;	<span class="comment">//是否被使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/30/hello-world/lwip/lwip_mm_heap/202102252338553.png" alt="在这里插入图片描述"></p>
<p>此外还有几个全局变量：</p>
<p><strong>ram_heap是内存堆的真实内存，MEM_SIZE_ALIGNED由用户定义内存堆总大小。SIZEOF_STRUCT_MEM指mem结构体的大小，MEM_ALIGNMENT是为了字节对齐。为什么SIZEOF_STRUCT_MEM要乘以2？因为在初始的内存堆中有两个内存块，分别在首尾，但尾部的内存块标志为used，这样做是方便了分配，回收代码的编写</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">u8_t</span> ram_heap[MEM_SIZE_ALIGNED + (<span class="number">2</span>*SIZEOF_STRUCT_MEM) + MEM_ALIGNMENT];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">u8_t</span> *ram;<span class="comment">//指向内存堆对齐后的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">ram_end</span>;</span><span class="comment">//指向最后一个内存块</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">lfree</span>;</span><span class="comment">//指向最低地址的可用内存块</span></span><br></pre></td></tr></table></figure>

<h2 id="三，内存堆实现函数"><a href="#三，内存堆实现函数" class="headerlink" title="三，内存堆实现函数"></a>三，内存堆实现函数</h2><h3 id="1，内存堆初始化"><a href="#1，内存堆初始化" class="headerlink" title="1，内存堆初始化"></a>1，内存堆初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">mem</span>;</span></span><br><span class="line"></span><br><span class="line">  ram = (<span class="type">u8_t</span> *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);  <span class="comment">//内存堆对齐</span></span><br><span class="line">  <span class="comment">//初始化内存堆的头部，初始内存堆只有一个空闲的内存块</span></span><br><span class="line">  mem = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)ram;</span><br><span class="line">  mem-&gt;next = MEM_SIZE_ALIGNED; <span class="comment">//MEM_SIZE_ALIGNED是内存堆对齐后的总大小，这里表示该内存的next是内存堆末尾</span></span><br><span class="line">  mem-&gt;prev = <span class="number">0</span>;<span class="comment">//prev指向自己</span></span><br><span class="line">  mem-&gt;used = <span class="number">0</span>;<span class="comment">//未使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化内存堆末尾</span></span><br><span class="line">  ram_end = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[MEM_SIZE_ALIGNED]; <span class="comment">//末尾地址</span></span><br><span class="line">  ram_end-&gt;used = <span class="number">1</span>;  <span class="comment">//末尾不可使用</span></span><br><span class="line">  ram_end-&gt;next = MEM_SIZE_ALIGNED;<span class="comment">//next和prev指向自己</span></span><br><span class="line">  ram_end-&gt;prev = MEM_SIZE_ALIGNED;</span><br><span class="line"></span><br><span class="line">  lfree = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)ram;<span class="comment">//低地址可用内存块就是第一个内存</span></span><br><span class="line"></span><br><span class="line">  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);<span class="comment">//设置内存堆分配统计量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建信号量</span></span><br><span class="line">  <span class="keyword">if</span>(sys_mutex_new(&amp;mem_mutex) != ERR_OK) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;failed to create mem_mutex&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的过程就是给内存堆创建了两个内存块，并初始化全局变量ram,ram_end,lfree，以及信号量（使用信号量是因为内存堆是全局数组）<br><img src="/2025/05/30/hello-world/lwip/lwip_mm_heap/20210225235447251.png" alt="在这里插入图片描述"></p>
<h3 id="2-内存申请"><a href="#2-内存申请" class="headerlink" title="2,内存申请"></a>2,内存申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mem_malloc</span><span class="params">(<span class="type">mem_size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">mem_size_t</span> ptr, ptr2;<span class="comment">//相对ram的偏移量</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span><span class="comment">//新的内存块</span></span><br><span class="line"></span><br><span class="line">  LWIP_MEM_ALLOC_DECL_PROTECT();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//申请的内存大小也要字节对齐</span></span><br><span class="line">  size = LWIP_MEM_ALIGN_SIZE(size);</span><br><span class="line">  <span class="comment">//size必须满足最小条件</span></span><br><span class="line">  <span class="keyword">if</span>(size &lt; MIN_SIZE_ALIGNED) &#123;</span><br><span class="line">    size = MIN_SIZE_ALIGNED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//size不能太大</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; MEM_SIZE_ALIGNED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sys_mutex_lock(&amp;mem_mutex); <span class="comment">//请求信号量</span></span><br><span class="line">  LWIP_MEM_ALLOC_PROTECT();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从lfree开始遍历men链表，直到找到第一个不小于size大小的内存块</span></span><br><span class="line">    <span class="keyword">for</span> (ptr = (<span class="type">mem_size_t</span>)((<span class="type">u8_t</span> *)lfree - ram); ptr &lt; MEM_SIZE_ALIGNED - size;</span><br><span class="line">         ptr = ((<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[ptr])-&gt;next) &#123;</span><br><span class="line">      mem = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[ptr];  <span class="comment">//获取当前内存块</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//(mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM))表示内存块可用空间。若可用空间&gt;=size，说明这个内存块适合；</span></span><br><span class="line">      <span class="keyword">if</span> ((!mem-&gt;used) &amp;&amp;</span><br><span class="line">          (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size) &#123;</span><br><span class="line">        <span class="comment">//MIN_SIZE_ALIGNED一个内存块的最小空间；</span></span><br><span class="line">        <span class="comment">//若mem的可用空间减去size后，其空间还能作为一个内存块存在，则裁剪出新的内存块，并插入链表</span></span><br><span class="line">        <span class="keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) &#123;</span><br><span class="line">          <span class="comment">//计算新的内存块偏移</span></span><br><span class="line">          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;</span><br><span class="line">          <span class="comment">//初始化新内存块，插入mem后</span></span><br><span class="line">          mem2 = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[ptr2];</span><br><span class="line">          mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">          mem2-&gt;next = mem-&gt;next;</span><br><span class="line">          mem2-&gt;prev = ptr;</span><br><span class="line">          <span class="comment">//更新mem</span></span><br><span class="line">          mem-&gt;next = ptr2;</span><br><span class="line">          mem-&gt;used = <span class="number">1</span>;<span class="comment">//标记已使用</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//若mem2的next不是最后一个内存块</span></span><br><span class="line">          <span class="keyword">if</span> (mem2-&gt;next != MEM_SIZE_ALIGNED) &#123;</span><br><span class="line">            <span class="comment">//则将mem2的next的prev指向mem2，因为最后一个内存块的prev必须指向自己</span></span><br><span class="line">            ((<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[mem2-&gt;next])-&gt;prev = ptr2;  </span><br><span class="line">          &#125;</span><br><span class="line">          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//直接把mem返回</span></span><br><span class="line">          mem-&gt;used = <span class="number">1</span>;</span><br><span class="line">          MEM_STATS_INC_USED(used, mem-&gt;next - (<span class="type">mem_size_t</span>)((<span class="type">u8_t</span> *)mem - ram));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若mem是lfree，则需要更新lfree</span></span><br><span class="line">        <span class="keyword">if</span> (mem == lfree) &#123;</span><br><span class="line">          <span class="comment">//遍历mem之后的内存块更新lfree</span></span><br><span class="line">          <span class="keyword">while</span> (lfree-&gt;used &amp;&amp; lfree != ram_end) &#123;</span><br><span class="line">            LWIP_MEM_ALLOC_UNPROTECT();</span><br><span class="line">            <span class="comment">/* prevent high interrupt latency... */</span></span><br><span class="line">            LWIP_MEM_ALLOC_PROTECT();</span><br><span class="line">            lfree = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[lfree-&gt;next];</span><br><span class="line">          &#125;</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;mem_malloc: !lfree-&gt;used&quot;</span>, ((lfree == ram_end) || (!lfree-&gt;used)));</span><br><span class="line">        &#125;</span><br><span class="line">        LWIP_MEM_ALLOC_UNPROTECT();</span><br><span class="line">        sys_mutex_unlock(&amp;mem_mutex);<span class="comment">//释放信号量</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">u8_t</span> *)mem + SIZEOF_STRUCT_MEM; <span class="comment">//返回内存块可用地址</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  MEM_STATS_INC(err); <span class="comment">//分配内存失败</span></span><br><span class="line">  LWIP_MEM_ALLOC_UNPROTECT();</span><br><span class="line">  sys_mutex_unlock(&amp;mem_mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个函数的主要逻辑就是从lfree开始寻找合适的内存块，若内存块足够大，则从内存块中分出一个新的mem2，并将该mem插入链表，最后返回所需要的内存地址。这样能提高内存利用率。</strong></p>
<h3 id="3，内存释放"><a href="#3，内存释放" class="headerlink" title="3，内存释放"></a>3，内存释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_free</span><span class="params">(<span class="type">void</span> *rmem)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">mem</span>;</span></span><br><span class="line">  LWIP_MEM_FREE_DECL_PROTECT();</span><br><span class="line">  <span class="comment">//检查指针</span></span><br><span class="line">  <span class="keyword">if</span> (rmem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查指针超出内存堆范围</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u8_t</span> *)rmem &lt; (<span class="type">u8_t</span> *)ram || (<span class="type">u8_t</span> *)rmem &gt;= (<span class="type">u8_t</span> *)ram_end) &#123;</span><br><span class="line">    SYS_ARCH_DECL_PROTECT(lev);</span><br><span class="line">    SYS_ARCH_PROTECT(lev);</span><br><span class="line">    MEM_STATS_INC(illegal);</span><br><span class="line">    SYS_ARCH_UNPROTECT(lev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LWIP_MEM_FREE_PROTECT();</span><br><span class="line">  mem = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)((<span class="type">u8_t</span> *)rmem - SIZEOF_STRUCT_MEM); <span class="comment">//获取内存块对应起始地址</span></span><br><span class="line">  mem-&gt;used = <span class="number">0</span>;<span class="comment">//消除标记</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否需要更新lfree</span></span><br><span class="line">  <span class="keyword">if</span> (mem &lt; lfree) &#123;</span><br><span class="line">    <span class="comment">/* the newly freed struct is now the lowest */</span></span><br><span class="line">    lfree = mem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MEM_STATS_DEC_USED(used, mem-&gt;next - (<span class="type">mem_size_t</span>)(((<span class="type">u8_t</span> *)mem - ram)));</span><br><span class="line">  </span><br><span class="line">  plug_holes(mem);  <span class="comment">//合并前后内存块</span></span><br><span class="line">  LWIP_MEM_FREE_UNPROTECT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数非常简单，<strong>主要是plug_holes(mem);实现了空闲内存的合并。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">plug_holes</span><span class="params">(<span class="keyword">struct</span> mem *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">nmem</span>;</span> <span class="comment">//next内存块</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem</span> *<span class="title">pmem</span>;</span> <span class="comment">//prev内存块</span></span><br><span class="line"></span><br><span class="line">  nmem = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[mem-&gt;next]; <span class="comment">//获取下一个内存块</span></span><br><span class="line">  <span class="comment">//若 mem和nmem都不是最后一个内存块且nmen未使用</span></span><br><span class="line">  <span class="keyword">if</span> (mem != nmem &amp;&amp; nmem-&gt;used == <span class="number">0</span> &amp;&amp; (<span class="type">u8_t</span> *)nmem != (<span class="type">u8_t</span> *)ram_end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lfree == nmem) &#123;</span><br><span class="line">      lfree = mem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将mem和nmem合并</span></span><br><span class="line">    mem-&gt;next = nmem-&gt;next;</span><br><span class="line">    ((<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[nmem-&gt;next])-&gt;prev = (<span class="type">mem_size_t</span>)((<span class="type">u8_t</span> *)mem - ram);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pmem = (<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[mem-&gt;prev];<span class="comment">//获取上一个内存块</span></span><br><span class="line">  <span class="comment">//pmem未使用，则合并mem和pmem</span></span><br><span class="line">  <span class="keyword">if</span> (pmem != mem &amp;&amp; pmem-&gt;used == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lfree == mem) &#123;</span><br><span class="line">      lfree = pmem;</span><br><span class="line">    &#125;</span><br><span class="line">    pmem-&gt;next = mem-&gt;next;</span><br><span class="line">    ((<span class="keyword">struct</span> mem *)(<span class="type">void</span> *)&amp;ram[mem-&gt;next])-&gt;prev = (<span class="type">mem_size_t</span>)((<span class="type">u8_t</span> *)pmem - ram);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/30/hello-world/lwip/lwip_mm_heap/20210226004849547.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_mm_heap/" data-id="cmbcy7rhx003ft8mtezmn6cd2" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_mm_pool" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_mm_pool/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.656Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，lwip内存池简介"><a href="#一，lwip内存池简介" class="headerlink" title="一，lwip内存池简介"></a>一，lwip内存池简介</h2><p>c语言的动态内存分配，会造成内存碎片，lwip使用内存池这样的结构来解决该问题。因为网络数据传输需要经常动态分配内存。</p>
<p>lwip的内存池按照用户给出的结构体，把一段连续的内存切分成一个个大小相同的内存区域（大小为结构体大小）。当使用动态内存分配时，会为用户分配一个内存块，释放时也会将整个内存块的回收。</p>
<p>这种动态内存分配方法的优点是速度快，缺点是pool中的内存可能没被利用，会造成一定的浪费。故适合用来为固定大小的数据结构分配内存，提供空间利用。<br><img src="/2025/05/30/hello-world/lwip/lwip_mm_pool/20210225195925835.png" alt="在这里插入图片描述"></p>
<h2 id="二，内存池的数据结构"><a href="#二，内存池的数据结构" class="headerlink" title="二，内存池的数据结构"></a>二，内存池的数据结构</h2><p><strong>lwip的内存池结构体非常简单，是个单向的链表，每种类型的pool维持一条单向链表。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memp</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">memp</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>lwip内存池所使用的内存其实就是一个全局数组，其定义如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存池的真正内存区域</span></span><br><span class="line"><span class="type">static</span> <span class="type">u8_t</span> memp_memory[MEM_ALIGNMENT - <span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lwip/memp_std.h&quot;</span></span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>需要关注的是这个数组的大小是在编译的时候才会被确定。<strong>这个数组大小的计算公式如下</strong></p>
<blockquote>
<p>pool_a的大小 × pool_a的数量 + pool_b的大小 × pool_b的数量 + pool_b的大小 × pool_b的数量 +…….+MEM_ALIGNMENT -1</p>
</blockquote>
<p>在<code>lwip/memp_std.h</code>中有各种类型的pool的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_RAW</span></span><br><span class="line">LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> raw_pcb),        <span class="string">&quot;RAW_PCB&quot;</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p>当编译器执行时，这些宏被展开成类似如下：</p>
<blockquote>
<p>+MEMP_NUM_RAW_PCB * MEMP_ALIGN_SIZE(sizeof(struct raw_pcb))<br>这就对应了“pool_a的大小 × pool_a的数量”，所有宏展开后就成为上面的公式，也就是所需的内存池的总大小。</p>
</blockquote>
<p>另外还有一些变量以类似的形式被编译器编译：</p>
<p><strong>memp_sizes[MEMP_MAX]数组存放了各种类型pool的大小。MEMP_MAX&#x3D;pool种类。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">u16_t</span> memp_sizes[MEMP_MAX] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lwip/memp_std.h&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>memp_num[MEMP_MAX]数组存放了各种类型pool的数量。MEMP_MAX&#x3D;pool种类。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">u16_t</span> memp_num[MEMP_MAX] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LWIP_MEMPOOL(name,num,size,desc)  (num),</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lwip/memp_std.h&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">memp</span> *<span class="title">memp_tab</span>[<span class="title">MEMP_MAX</span>];</span>	<span class="comment">//用数组保存了各种类型pool链的第一个空闲块</span></span><br></pre></td></tr></table></figure>
<h2 id="三，内存管理函数"><a href="#三，内存管理函数" class="headerlink" title="三，内存管理函数"></a>三，内存管理函数</h2><h3 id="1，初始化函数"><a href="#1，初始化函数" class="headerlink" title="1，初始化函数"></a>1，初始化函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">memp</span> *<span class="title">memp</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将所有内存池初始化为0</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MEMP_MAX; ++i) &#123;</span><br><span class="line">    MEMP_STATS_AVAIL(used, i, <span class="number">0</span>);</span><br><span class="line">    MEMP_STATS_AVAIL(max, i, <span class="number">0</span>);</span><br><span class="line">    MEMP_STATS_AVAIL(err, i, <span class="number">0</span>);</span><br><span class="line">    MEMP_STATS_AVAIL(avail, i, memp_num[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  memp = (<span class="keyword">struct</span> memp *)LWIP_MEM_ALIGN(memp_memory);  <span class="comment">//获取内存池首地址</span></span><br><span class="line">  <span class="comment">//将内存池分配成不同类型的pool</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MEMP_MAX; ++i) &#123;</span><br><span class="line">    memp_tab[i] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; memp_num[i]; ++j) &#123;</span><br><span class="line">      memp-&gt;next = memp_tab[i];</span><br><span class="line">      memp_tab[i] = memp;</span><br><span class="line">      memp = (<span class="keyword">struct</span> memp *)(<span class="type">void</span> *)((<span class="type">u8_t</span> *)memp + MEMP_SIZE + memp_sizes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始完成后的内存池如图，<strong>不同类型的pool其实是在一片连续的内存memp_memory 上</strong>。<br><img src="/2025/05/30/hello-world/lwip/lwip_mm_pool/6686.jpeg" alt="在这里插入图片描述"></p>
<h3 id="2，内存分配函数"><a href="#2，内存分配函数" class="headerlink" title="2，内存分配函数"></a>2，内存分配函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memp_malloc</span><span class="params">(<span class="type">memp_t</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">memp</span> *<span class="title">memp</span>;</span></span><br><span class="line">  </span><br><span class="line">  SYS_ARCH_DECL_PROTECT(old_level);<span class="comment">//临界保护</span></span><br><span class="line">  SYS_ARCH_PROTECT(old_level);</span><br><span class="line"></span><br><span class="line">  memp = memp_tab[type];  <span class="comment">//获取指定类型的pool链、</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (memp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    memp_tab[type] = memp-&gt;next;  <span class="comment">//更新空闲内存块</span></span><br><span class="line"></span><br><span class="line">    MEMP_STATS_INC_USED(used, type);  <span class="comment">//pool使用记录</span></span><br><span class="line">    memp = (<span class="keyword">struct</span> memp*)(<span class="type">void</span> *)((<span class="type">u8_t</span>*)memp + MEMP_SIZE); <span class="comment">//调节memp地址，这里的MEMP_SIZE为0，所以不变</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MEMP_STATS_INC(err, type);</span><br><span class="line">  &#125;</span><br><span class="line">  SYS_ARCH_UNPROTECT(old_level);<span class="comment">//退出保护</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> memp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个函数申请pool时，从指定类型pool链中取出一个空闲的内存块，并返回地址。</p>
<h3 id="3，释放内存"><a href="#3，释放内存" class="headerlink" title="3，释放内存"></a>3，释放内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memp_free</span><span class="params">(<span class="type">memp_t</span> type, <span class="type">void</span> *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">memp</span> *<span class="title">memp</span>;</span></span><br><span class="line">  SYS_ARCH_DECL_PROTECT(old_level);	</span><br><span class="line">	<span class="comment">//判断释放的内存是否空指针</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  memp = (<span class="keyword">struct</span> memp *)(<span class="type">void</span> *)((<span class="type">u8_t</span>*)mem - MEMP_SIZE);	<span class="comment">//MEMP_SIZE为0</span></span><br><span class="line"></span><br><span class="line">  SYS_ARCH_PROTECT(old_level);<span class="comment">//临界保护</span></span><br><span class="line"></span><br><span class="line">  MEMP_STATS_DEC(used, type); <span class="comment">//used置位0</span></span><br><span class="line">  </span><br><span class="line">  memp-&gt;next = memp_tab[type];<span class="comment">//将内存块插入链表 </span></span><br><span class="line">  memp_tab[type] = memp;</span><br><span class="line"></span><br><span class="line">  SYS_ARCH_UNPROTECT(old_level);<span class="comment">//退出临界保护</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放内存时只需要将pool重归链表。<br><strong>内存池的分配方式总体上就比较简单，在lwip中使用内存池的常常是固定大小的结构体，如udp控制块，tcp控制块等。</strong><br><img src="/2025/05/30/hello-world/lwip/lwip_mm_pool/20210226004849547.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_mm_pool/" data-id="cmbcy7rhx003gt8mt0qug9mvp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_netif" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_netif/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.656Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p>以太网通信中，硬件层的实现是靠网卡，每个网卡都有ip地址，mac地址，最大传输包长度，输入输出功能，。lwip使用netif来描述这些网卡，并将网卡的输入输出数据传递给ip层。<br><img src="/2025/05/30/hello-world/lwip/lwip_netif/20210226113710108.png" alt="在这里插入图片描述"></p>
<h2 id="二，源码分析"><a href="#二，源码分析" class="headerlink" title="二，源码分析"></a>二，源码分析</h2><p>首先是网口的结构体，结合上图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netif</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个网口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">ip_addr_t</span> ip_addr;  <span class="comment">//网口ip地址</span></span><br><span class="line">  <span class="type">ip_addr_t</span> netmask;  <span class="comment">//网口子网掩码，用来判断ip是否处于同一网络</span></span><br><span class="line">  <span class="type">ip_addr_t</span> gw; <span class="comment">//网关地址，若目的ip不在同一网络，则将报文发送给网关</span></span><br><span class="line"></span><br><span class="line">  netif_input_fn input; <span class="comment">//网口调用该函数将数据包传递给ip层</span></span><br><span class="line"></span><br><span class="line">  netif_output_fn output; <span class="comment">//ip层调用该函数将数据包传递给网口</span></span><br><span class="line"></span><br><span class="line">  netif_linkoutput_fn linkoutput; <span class="comment">//网口调用该函数将数据包传递给以太网驱动</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *state;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_DHCP</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_DHCP */</span></span></span><br><span class="line">  <span class="type">u16_t</span> mtu;  <span class="comment">//最大数据包长度</span></span><br><span class="line">  <span class="type">u8_t</span> hwaddr_len;  <span class="comment">//硬件地址长度</span></span><br><span class="line">  <span class="type">u8_t</span> hwaddr[NETIF_MAX_HWADDR_LEN];<span class="comment">//硬件地址</span></span><br><span class="line">  <span class="type">u8_t</span> flags; <span class="comment">//网口的状态 属性控制位</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">2</span>]; <span class="comment">//网口名称</span></span><br><span class="line">  <span class="type">u8_t</span> num; <span class="comment">//网口的编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IGMP</span></span><br><span class="line">  netif_igmp_mac_filter_fn igmp_mac_filter;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IGMP */</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>netif的初始化函数为netif_add()；这个函数实际上就是用获取到的ip地址等填充netif结构体，并将网卡的初始化和输入函数赋值到netif中，调用网卡初始化函数初始化网卡，并将netif插入链表。初始化和输入函数是由网卡的驱动者提供的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> netif *</span><br><span class="line"><span class="title function_">netif_add</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="type">ip_addr_t</span> *ipaddr, <span class="type">ip_addr_t</span> *netmask,</span></span><br><span class="line"><span class="params">  <span class="type">ip_addr_t</span> *gw, <span class="type">void</span> *state, netif_init_fn init, netif_input_fn input)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">u8_t</span> netifnum = <span class="number">0</span>; <span class="comment">//静态变量：网口编号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//重置网口地址</span></span><br><span class="line">  ip_addr_set_zero(&amp;netif-&gt;ip_addr);</span><br><span class="line">  ip_addr_set_zero(&amp;netif-&gt;netmask);</span><br><span class="line">  ip_addr_set_zero(&amp;netif-&gt;gw);</span><br><span class="line">  </span><br><span class="line">  netif-&gt;flags = <span class="number">0</span>;</span><br><span class="line">  netif-&gt;dhcp = <span class="literal">NULL</span>;</span><br><span class="line">  netif-&gt;igmp_mac_filter = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  netif-&gt;state = state;</span><br><span class="line">  netif-&gt;num = netifnum++;  <span class="comment">//新编号</span></span><br><span class="line">  netif-&gt;input = input; <span class="comment">//添加ip层输入函数</span></span><br><span class="line"></span><br><span class="line">  netif_set_addr(netif, ipaddr, netmask, gw);<span class="comment">//设置网口的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用初始化函数，初始化硬件</span></span><br><span class="line">  <span class="keyword">if</span> (init(netif) != ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将网口插入链表头</span></span><br><span class="line">  netif-&gt;next = netif_list;</span><br><span class="line">  netif_list = netif;</span><br><span class="line">  snmp_inc_iflist();</span><br><span class="line">  <span class="keyword">return</span> netif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是在添加网口的ip地址时，会检查是否有tcp连接绑定在之前的网口上，若有则需要将该tcp连接终止，因为网口的ip地址修改将导致tcp连接断开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置网口ip地址</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">netif_set_ipaddr</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="type">ip_addr_t</span> *ipaddr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//新的ipaddr与之前的ip不一样，需要更新tcp控制块</span></span><br><span class="line">  <span class="keyword">if</span> ((ip_addr_cmp(ipaddr, &amp;(netif-&gt;ip_addr))) == <span class="number">0</span>) &#123;</span><br><span class="line">    pcb = tcp_active_pcbs;  <span class="comment">//正常的tcp连接链表</span></span><br><span class="line">    <span class="keyword">while</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//判断是否有tcp绑定到当前网口的ip上。若有则终止tcp</span></span><br><span class="line">      <span class="keyword">if</span> (ip_addr_cmp(&amp;(pcb-&gt;local_ip), &amp;(netif-&gt;ip_addr)))</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">next</span> =</span> pcb-&gt;next;<span class="comment">//将pcb从链表删除</span></span><br><span class="line">        tcp_abort(pcb);</span><br><span class="line">        pcb = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pcb = pcb-&gt;next;  <span class="comment">//检查下一个tcp</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查处于listen状态的tcp</span></span><br><span class="line">    <span class="keyword">for</span> (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != <span class="literal">NULL</span>; lpcb = lpcb-&gt;next) &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">//若tcp绑定到当前网口，则更新tcp的ip信息，此时无tcp连接</span></span><br><span class="line">      <span class="keyword">if</span> ((!(ip_addr_isany(&amp;(lpcb-&gt;local_ip)))) &amp;&amp;</span><br><span class="line">          (ip_addr_cmp(&amp;(lpcb-&gt;local_ip), &amp;(netif-&gt;ip_addr)))) &#123;</span><br><span class="line">        ip_addr_set(&amp;(lpcb-&gt;local_ip), ipaddr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  ip_addr_set(&amp;(netif-&gt;ip_addr), ipaddr); <span class="comment">//设置网口ip</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三，示例"><a href="#三，示例" class="headerlink" title="三，示例"></a>三，示例</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/113997147">以stm32为例，netif在移植中的作用</a><br><img src="/2025/05/30/hello-world/lwip/lwip_netif/20210226004849547.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_netif/" data-id="cmbcy7rhx003ht8mtfs7y85if" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_pbuf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_pbuf/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.656Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>lwip使用pbuf对数据进行发送与接收，灵活的pbuf结构体使得数据在不同网络层之间传输时可以减少内存的开销，内存复制所占用的时间，一切都是为了节约内存，增加数据在不同层之间传递的速度。</p>
</blockquote>
<h2 id="一，数据在tcp-ip层中的传递"><a href="#一，数据在tcp-ip层中的传递" class="headerlink" title="一，数据在tcp&#x2F;ip层中的传递"></a>一，数据在tcp&#x2F;ip层中的传递</h2><p>数据如何从tcp层一层层传递到最底层的物理层并发送出去呢？</p>
<p>应用层需要发送的数据传递到tcp层时，tcp层给数据添加首部数据，tcp层传递给ip层时，ip层将tcp层的所有数据（payload和首部数据）当成发送的数据，并给这份数据添加首部，这样一层层传递下去，如图：<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/2020121313384068.jpg" alt="在这里插入图片描述"></p>
<h2 id="二，认识pbuf结构体"><a href="#二，认识pbuf结构体" class="headerlink" title="二，认识pbuf结构体"></a>二，认识pbuf结构体</h2><p>为了更好的描述以上的数据传递过程，pbuf他来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">next</span>;</span>	<span class="comment">//指向下一个pbuf</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *payload;  <span class="comment">//指向buff中的真实数据</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> tot_len;  <span class="comment">//该len与其后所有pbuf的len</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">u16_t</span> len;  <span class="comment">//payload中数据长度，不包括首部</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> type;</span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> ref;  <span class="comment">//buffer被引用次数，包括next</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>1，pbuf结构体很简单，他支持单向链表，其核心是payload指针，该指针指向真实的数据起始地址，而payload前面的有一段长度为offset的偏移内存，这个内存是用于存放数据的首部的；这点与第一节所述一样。</strong></p>
<p>PBUF_RAM 示意图：<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213112657928.png" alt="在这里插入图片描述"><br>对于不同网络层的pbuf，其首部的数据也是不同的，所以其对应的pbuf中offset的长度也是不一样。</p>
<p>例如：tcp报文中，固定首部通常是20个字节，还有4*n的选项字段和填充字段，所以tcp层的pbuf中，offset的最小值是20，其后payload指向tcp的数据。</p>
<p><strong>2，len表示的是payload数据的长度，也就是不包括首部。</strong></p>
<p><strong>3，tot_len：表示当前pbuf和后面所有pbuf的len之和。</strong></p>
<p><strong>3，flag是记录pbuf的一些标志。其值如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** indicates this packet&#x27;s data should be immediately passed to the application */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_PUSH      0x01U <span class="comment">//立即发送</span></span></span><br><span class="line"><span class="comment">/** indicates this is a custom pbuf: pbuf_free calls pbuf_custom-&gt;custom_free_function()</span></span><br><span class="line"><span class="comment">    when the last reference is released (plus custom PBUF_RAM cannot be trimmed) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_IS_CUSTOM 0x02U</span></span><br><span class="line"><span class="comment">/** indicates this pbuf is UDP multicast to be looped back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_MCASTLOOP 0x04U <span class="comment">//udp多播返回</span></span></span><br><span class="line"><span class="comment">/** indicates this pbuf was received as link-level broadcast */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_LLBCAST   0x08U <span class="comment">//链路层的广播</span></span></span><br><span class="line"><span class="comment">/** indicates this pbuf was received as link-level multicast */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_LLMCAST   0x10U <span class="comment">//链路层的多播</span></span></span><br><span class="line"><span class="comment">/** indicates this pbuf includes a TCP FIN flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_TCP_FIN   0x20U <span class="comment">//tcp挥手标志</span></span></span><br></pre></td></tr></table></figure>

<p><strong>4，ref：表示该pbuf被外部引用的次数，也包括被上一个pbuf的next引用的情况，该变量用于防止在释放pbuf后导致内存读取错误。</strong></p>
<p><strong>5，由于payload指向的内存的性质不同，导致了pbuf的类型不同，pbuf的类型可用分为四种：在理解pbuf时，将pbuf结构体与payload指向的内存分开思考。</strong></p>
<blockquote>
<p>PBUF_RAM, 用于发送，pbuf和payload在连续的内存上<br>PBUF_ROM, pbuf在内存中，payload在外存<br>PBUF_REF, pbuf来自内存池，payload是其他程序段分配的内存，所以payload可能会被修改，发送时要复制payload;<br>PBUF_POOL， 用于接收，使用内存池分配。pbuf和payload在同一内存，pool内存大小是固定的，所以实际情况可能是多个pbuf连在一起。</p>
</blockquote>
<p>PBUF_POOL示意图：<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213134210324.png" alt="在这里插入图片描述"><br>PBUF_REF与PBUF_ROM 示意图<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213134249515.png" alt="在这里插入图片描述"></p>
<h2 id="二，创建一个pbuf"><a href="#二，创建一个pbuf" class="headerlink" title="二，创建一个pbuf"></a>二，创建一个pbuf</h2><p>通过pbuf_alloc()创建一个pbuf，要创建一个pbuf，需要知道三个参数：</p>
<p>1，这个pbuf所在的网络层，以此来确定offset的值，上层的offset不仅要为自己的首部留出空间，而且还需要为下层的首部留出空间，所以层级越高，offset越大。</p>
<p>2，存放数据的大小<br>3，pbuf的类型</p>
<p>代码如下，参考注释和第二节的各种类型的示意图，理解代码逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个pbuf</span></span><br><span class="line"><span class="comment">//layer：网络层</span></span><br><span class="line"><span class="comment">//length：数据长度</span></span><br><span class="line"><span class="comment">//type：buffer类型</span></span><br><span class="line">pbuf_alloc(pbuf_layer layer, <span class="type">u16_t</span> length, pbuf_type type)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> offset; <span class="comment">//payload在buffer的偏移</span></span><br><span class="line">  <span class="type">s32_t</span> rem_len; <span class="comment">/* remaining length */</span></span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_alloc(length=%&quot;</span>U16_F<span class="string">&quot;)\n&quot;</span>, length));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* determine header offset */</span></span><br><span class="line">  <span class="comment">//根据层级不同，计算不同的偏移空间，越高的层偏移越大</span></span><br><span class="line">  <span class="keyword">switch</span> (layer) &#123;</span><br><span class="line">  <span class="keyword">case</span> PBUF_TRANSPORT:</span><br><span class="line">    <span class="comment">/* add room for transport (often TCP) layer header */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;	</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_IP:</span><br><span class="line">    <span class="comment">/* add room for IP layer header */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_LINK:</span><br><span class="line">    <span class="comment">/* add room for link layer header */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_RAW_TX:</span><br><span class="line">    <span class="comment">/* add room for encapsulating link layer headers (e.g. 802.11) */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_RAW:</span><br><span class="line">    <span class="comment">/* no offset (e.g. RX buffers or chain successors) */</span></span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: bad pbuf layer&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用不同类型的内存，内存分配代码不同</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> PBUF_POOL: <span class="comment">//通过内存池分配，可能需要若干个pool</span></span><br><span class="line">    <span class="comment">/* allocate head of pbuf chain into p */</span></span><br><span class="line">    p = (<span class="keyword">struct</span> pbuf *)memp_malloc(MEMP_PBUF_POOL); <span class="comment">//先分配第一个pool</span></span><br><span class="line">    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_alloc: allocated pbuf %p\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      PBUF_POOL_IS_EMPTY();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置相关成员的值</span></span><br><span class="line">    p-&gt;type = type;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make the payload pointer point &#x27;offset&#x27; bytes into pbuf data memory */</span></span><br><span class="line">    <span class="comment">//移动payload在offset之后</span></span><br><span class="line">    p-&gt;payload = LWIP_MEM_ALIGN((<span class="type">void</span> *)((<span class="type">u8_t</span> *)p + (SIZEOF_STRUCT_PBUF + offset)));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: pbuf p-&gt;payload properly aligned&quot;</span>,</span><br><span class="line">            ((<span class="type">mem_ptr_t</span>)p-&gt;payload % MEM_ALIGNMENT) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* the total length of the pbuf chain is the requested size */</span></span><br><span class="line">    p-&gt;tot_len = length;</span><br><span class="line">    <span class="comment">/* set the length of the first pbuf in the chain */</span></span><br><span class="line">    <span class="comment">//计算第一个pbuf的payload长度：若length小于一个pool，则就是length，否则就是（pool长度-偏移）</span></span><br><span class="line">    p-&gt;len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;check p-&gt;payload + p-&gt;len does not overflow pbuf&quot;</span>,</span><br><span class="line">                ((<span class="type">u8_t</span>*)p-&gt;payload + p-&gt;len &lt;=</span><br><span class="line">                 (<span class="type">u8_t</span>*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT&quot;</span>,</span><br><span class="line">      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) &gt; <span class="number">0</span> );</span><br><span class="line">    <span class="comment">/* set reference count (needed here in case we fail) */</span></span><br><span class="line">    p-&gt;ref = <span class="number">1</span>;	<span class="comment">//引用次数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now allocate the tail of the pbuf chain */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remember first pbuf for linkage in next iteration */</span></span><br><span class="line">    r = p;	<span class="comment">//保存第一个pbuf指针</span></span><br><span class="line">    <span class="comment">/* remaining length to be allocated */</span></span><br><span class="line">    rem_len = length - p-&gt;len;  <span class="comment">//还需要分配的长度</span></span><br><span class="line">    <span class="comment">/* any remaining pbufs to be allocated? */</span></span><br><span class="line">    <span class="comment">//还要再分配pool，直到满足所需内存，除第一个pbuf外，其他pbuf不需要offset预留空间给首部\</span></span><br><span class="line"><span class="comment">      以下pbuf以链表组织在第一个pbuf后</span></span><br><span class="line">    <span class="keyword">while</span> (rem_len &gt; <span class="number">0</span>) &#123; </span><br><span class="line">      q = (<span class="keyword">struct</span> pbuf *)memp_malloc(MEMP_PBUF_POOL);</span><br><span class="line">      <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PBUF_POOL_IS_EMPTY();</span><br><span class="line">        <span class="comment">/* free chain so far allocated */</span></span><br><span class="line">        pbuf_free(p);</span><br><span class="line">        <span class="comment">/* bail out unsuccessfully */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置pbuf的字段</span></span><br><span class="line">      q-&gt;type = type;</span><br><span class="line">      q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">      q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">/* make previous pbuf point to this pbuf */</span></span><br><span class="line">      r-&gt;next = q;	<span class="comment">//将pbuf与前面的pbuf连接 </span></span><br><span class="line">      <span class="comment">/* set total length of this pbuf and next in chain */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;rem_len &lt; max_u16_t&quot;</span>, rem_len &lt; <span class="number">0xffff</span>);</span><br><span class="line">      q-&gt;tot_len = (<span class="type">u16_t</span>)rem_len;</span><br><span class="line">      <span class="comment">/* this pbuf length is pool size, unless smaller sized tail */</span></span><br><span class="line">      q-&gt;len = LWIP_MIN((<span class="type">u16_t</span>)rem_len, PBUF_POOL_BUFSIZE_ALIGNED); <span class="comment">//!不是第一个pbuf，不需要偏移</span></span><br><span class="line">      q-&gt;payload = (<span class="type">void</span> *)((<span class="type">u8_t</span> *)q + SIZEOF_STRUCT_PBUF);  <span class="comment">//payload只需要移动固定SIZEOF_STRUCT_PBUF个字节</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: pbuf q-&gt;payload properly aligned&quot;</span>,</span><br><span class="line">              ((<span class="type">mem_ptr_t</span>)q-&gt;payload % MEM_ALIGNMENT) == <span class="number">0</span>);</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;check p-&gt;payload + p-&gt;len does not overflow pbuf&quot;</span>,</span><br><span class="line">                  ((<span class="type">u8_t</span>*)p-&gt;payload + p-&gt;len &lt;=</span><br><span class="line">                   (<span class="type">u8_t</span>*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));</span><br><span class="line">      q-&gt;ref = <span class="number">1</span>; <span class="comment">//被next引用</span></span><br><span class="line">      <span class="comment">/* calculate remaining length to be allocated */</span></span><br><span class="line">      rem_len -= q-&gt;len; </span><br><span class="line">      <span class="comment">/* remember this pbuf for linkage in next iteration */</span></span><br><span class="line">      r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* end of chain */</span></span><br><span class="line">    <span class="comment">/*r-&gt;next = NULL;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_RAM:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//分配的内存=pbuf结构体大小+偏移大小+真实数据大小</span></span><br><span class="line">      <span class="type">mem_size_t</span> alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* bug #50040: Check for integer overflow when calculating alloc_len */</span></span><br><span class="line">      <span class="comment">//检验alloc_len（u16）是否溢出</span></span><br><span class="line">      <span class="keyword">if</span> (alloc_len &lt; LWIP_MEM_ALIGN_SIZE(length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* If pbuf is to be allocated in RAM, allocate memory for it. */</span></span><br><span class="line">      p = (<span class="keyword">struct</span> pbuf*)mem_malloc(alloc_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Set up internal structure of the pbuf. */</span></span><br><span class="line">    <span class="comment">//初始化pbuf成员</span></span><br><span class="line">    p-&gt;payload = LWIP_MEM_ALIGN((<span class="type">void</span> *)((<span class="type">u8_t</span> *)p + SIZEOF_STRUCT_PBUF + offset)); </span><br><span class="line">    p-&gt;len = p-&gt;tot_len = length;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: pbuf-&gt;payload properly aligned&quot;</span>,</span><br><span class="line">           ((<span class="type">mem_ptr_t</span>)p-&gt;payload % MEM_ALIGNMENT) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">/* pbuf references existing (non-volatile static constant) ROM payload? */</span></span><br><span class="line">  <span class="keyword">case</span> PBUF_ROM:</span><br><span class="line">  <span class="comment">/* pbuf references existing (externally allocated) RAM payload? */</span></span><br><span class="line">  <span class="keyword">case</span> PBUF_REF:</span><br><span class="line">    <span class="comment">/* only allocate memory for the pbuf structure */</span></span><br><span class="line">    p = (<span class="keyword">struct</span> pbuf *)memp_malloc(MEMP_PBUF);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,</span><br><span class="line">                  (<span class="string">&quot;pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n&quot;</span>,</span><br><span class="line">                  (type == PBUF_ROM) ? <span class="string">&quot;ROM&quot;</span> : <span class="string">&quot;REF&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* caller must set this field properly, afterwards */</span></span><br><span class="line">    p-&gt;payload = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;len = p-&gt;tot_len = length;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;type = type;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: erroneous type&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* set reference count */</span></span><br><span class="line">  p-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* set flags */</span></span><br><span class="line">  p-&gt;flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_alloc(length=%&quot;</span>U16_F<span class="string">&quot;) == %p\n&quot;</span>, length, (<span class="type">void</span> *)p));</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三，释放pbuf"><a href="#三，释放pbuf" class="headerlink" title="三，释放pbuf"></a>三，释放pbuf</h2><p>释放pbuf需要注意pbuf被引用的次数。</p>
<p>当pbuf的ref成员为0时，则可以被释放，其后的pbuf会被判断是否需要被释放。若ref&gt;0,则将ref-1并退出；具体的释放方式是通过调用内存释放函数进行释放，代码及注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">u8_t</span></span><br><span class="line"><span class="title function_">pbuf_free</span><span class="params">(<span class="keyword">struct</span> pbuf *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u16_t</span> type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">u8_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line">    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,</span><br><span class="line">      (<span class="string">&quot;pbuf_free(p == NULL) was called.\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_free(%p)\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line"></span><br><span class="line">  PERF_START;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pbuf_free: sane type&quot;</span>,</span><br><span class="line">    p-&gt;type == PBUF_RAM || p-&gt;type == PBUF_ROM ||</span><br><span class="line">    p-&gt;type == PBUF_REF || p-&gt;type == PBUF_POOL);</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>;  <span class="comment">//记录被释放的pbuf数量</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">u16_t</span> ref;</span><br><span class="line">    SYS_ARCH_DECL_PROTECT(old_level); <span class="comment">//申请临界保护变量</span></span><br><span class="line">    SYS_ARCH_PROTECT(old_level);  <span class="comment">//进入临界区</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_free: p-&gt;ref &gt; 0&quot;</span>, p-&gt;ref &gt; <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    ref = --(p-&gt;ref); <span class="comment">//该pbuf引用次数-1</span></span><br><span class="line">    SYS_ARCH_UNPROTECT(old_level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若引用次数为0，根据pbuf不同类型释放</span></span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="number">0</span>) &#123; </span><br><span class="line">      q = p-&gt;next;	<span class="comment">//保存下一个pbuf</span></span><br><span class="line">      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_free: deallocating %p\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line">      type = p-&gt;type;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SUPPORT_CUSTOM_PBUF</span></span><br><span class="line">      <span class="keyword">if</span> ((p-&gt;flags &amp; PBUF_FLAG_IS_CUSTOM) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom</span> *<span class="title">pc</span> =</span> (<span class="keyword">struct</span> pbuf_custom*)p;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;pc-&gt;custom_free_function != NULL&quot;</span>, pc-&gt;custom_free_function != <span class="literal">NULL</span>);</span><br><span class="line">        pc-&gt;custom_free_function(p);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//pool类型释放MEMP_PBUF_POOL</span></span><br><span class="line">        <span class="keyword">if</span> (type == PBUF_POOL) &#123;</span><br><span class="line">          memp_free(MEMP_PBUF_POOL, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == PBUF_ROM || type == PBUF_REF) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ESP_LWIP</span></span><br><span class="line">          <span class="keyword">if</span> (p-&gt;l2_owner != <span class="literal">NULL</span></span><br><span class="line">              &amp;&amp; p-&gt;l2_buf != <span class="literal">NULL</span></span><br><span class="line">              &amp;&amp; p-&gt;l2_owner-&gt;l2_buffer_free_notify != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;l2_owner-&gt;l2_buffer_free_notify(p-&gt;l2_buf);</span><br><span class="line">          &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          memp_free(MEMP_PBUF, p);</span><br><span class="line">        <span class="comment">/* type == PBUF_RAM */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mem_free(p);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">//检查下一个是否也需要释放</span></span><br><span class="line">      p = q;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//不为0，退出释放</span></span><br><span class="line">      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_free: %p has ref %&quot;</span>U16_F<span class="string">&quot;, ending here.\n&quot;</span>, (<span class="type">void</span> *)p, ref));</span><br><span class="line">		</span><br><span class="line">      p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  PERF_STOP(<span class="string">&quot;pbuf_free&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，给pbuf链表减肥"><a href="#四，给pbuf链表减肥" class="headerlink" title="四，给pbuf链表减肥"></a>四，给pbuf链表减肥</h2><p>pbuf在使用中，可能原先分配的内存过大，需要调整为小点的内存，使用函数<code>pbuf_realloc(struct pbuf *p, u16_t new_len);</code>可以为pbuf链表重新分配内存：</p>
<p>其重点是对pbuf链表的操作，即找到链表中new_len所在的那个pbuf，然后给他重新分配内存，并释放它后面的pbuf。<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213144729146.jpg" alt="在这里插入图片描述"></p>
<p>代码及注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给pbuf减肥，新的长度为new——len</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pbuf_realloc</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="type">u16_t</span> new_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> rem_len; <span class="comment">/* remaining length */</span></span><br><span class="line">  <span class="type">s32_t</span> grow; <span class="comment">//需要增加的长度，其实这个值是负数，也就是长度实际上是减少</span></span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pbuf_realloc: p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pbuf_realloc: sane p-&gt;type&quot;</span>, p-&gt;type == PBUF_POOL ||</span><br><span class="line">              p-&gt;type == PBUF_ROM ||</span><br><span class="line">              p-&gt;type == PBUF_RAM ||</span><br><span class="line">              p-&gt;type == PBUF_REF);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新长度不能大于pbuf链的总长</span></span><br><span class="line">  <span class="keyword">if</span> (new_len &gt;= p-&gt;tot_len) &#123;</span><br><span class="line">    <span class="comment">/* enlarging not yet supported */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  grow = new_len - p-&gt;tot_len;  <span class="comment">//需要减少的长度</span></span><br><span class="line"></span><br><span class="line">  rem_len = new_len;  <span class="comment">//剩余长度=全新的长度</span></span><br><span class="line">  q = p;</span><br><span class="line">  <span class="comment">//从pbuf链开始往下找，找到满足pbuf链表中长度为new_len时的pbuf</span></span><br><span class="line">  <span class="keyword">while</span> (rem_len &gt; q-&gt;len) &#123;</span><br><span class="line">    rem_len -= q-&gt;len;  <span class="comment">//每经过一个pbuf剩余长度就减少p-&gt;len</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;grow &lt; max_u16_t&quot;</span>, grow &lt; <span class="number">0xffff</span>);</span><br><span class="line">    q-&gt;tot_len += (<span class="type">u16_t</span>)grow;  <span class="comment">//该pbuf的tot_len减少</span></span><br><span class="line">    q = q-&gt;next;  <span class="comment">//下一个</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_realloc: q != NULL&quot;</span>, q != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//找到最后一个pbuf，PBUF_RAM类型且rem_len小于pbuf原来的大小，则重新分配pbuf的大小</span></span><br><span class="line">  <span class="keyword">if</span> ((q-&gt;type == PBUF_RAM) &amp;&amp; (rem_len != q-&gt;len)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SUPPORT_CUSTOM_PBUF</span></span><br><span class="line">      &amp;&amp; ((q-&gt;flags &amp; PBUF_FLAG_IS_CUSTOM) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">     ) &#123;</span><br><span class="line">    <span class="comment">//新的pbuf=首部大小（payload-q）+rem_len</span></span><br><span class="line">    q = (<span class="keyword">struct</span> pbuf *)mem_trim(q, (<span class="type">u16_t</span>)((<span class="type">u8_t</span> *)q-&gt;payload - (<span class="type">u8_t</span> *)q) + rem_len);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;mem_trim returned q == NULL&quot;</span>, q != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调节最后一个pbuf的长度</span></span><br><span class="line">  q-&gt;len = rem_len;</span><br><span class="line">  q-&gt;tot_len = q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//q后面的pbuf不会被使用了，释放掉</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pbuf_free(q-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五，移动payload"><a href="#五，移动payload" class="headerlink" title="五，移动payload"></a>五，移动payload</h2><p>在第一节我们可以看到，payload指针在数据传递过程中需要频繁的移动，这个过程是由函数pbuf_header();实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//header_size_increment&gt;0,payload前移，数据传递下层</span></span><br><span class="line"><span class="comment">//header_size_increment&lt;0,payload后移，数据传递上层</span></span><br><span class="line">pbuf_header(<span class="keyword">struct</span> pbuf *p, <span class="type">s16_t</span> header_size_increment)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> pbuf_header_impl(p, header_size_increment, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数很简单，header_size_increment决定了payload移动的方向和距离。通过调用pbuf_header_impl();实现；<br>其中，需要判断pbuf结构体与payload指向的地址是否连续，如果连续的情况（如RAM，POOL类型）则需要注意payload指针不能超出边界。代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动pbuf首部地址</span></span><br><span class="line"><span class="comment">//header_size_increment&gt;0 首部在payload外，需要放到payload中</span></span><br><span class="line">pbuf_header_impl(<span class="keyword">struct</span> pbuf *p, <span class="type">s16_t</span> header_size_increment, <span class="type">u8_t</span> force)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u16_t</span> type;</span><br><span class="line">  <span class="type">void</span> *payload;</span><br><span class="line">  <span class="type">u16_t</span> increment_magnitude;  <span class="comment">//位移</span></span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> ((header_size_increment == <span class="number">0</span>) || (p == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算header_size_increment的绝对值</span></span><br><span class="line">  <span class="keyword">if</span> (header_size_increment &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    increment_magnitude = (<span class="type">u16_t</span>)-header_size_increment;</span><br><span class="line">    <span class="comment">/* Check that we aren&#x27;t going to move off the end of the pbuf */</span></span><br><span class="line">    LWIP_ERROR(<span class="string">&quot;increment_magnitude &lt;= p-&gt;len&quot;</span>, (increment_magnitude &lt;= p-&gt;len), <span class="keyword">return</span> <span class="number">1</span>;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    increment_magnitude = (<span class="type">u16_t</span>)header_size_increment;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  type = p-&gt;type;</span><br><span class="line">  <span class="comment">/* remember current payload pointer */</span></span><br><span class="line">  payload = p-&gt;payload; <span class="comment">//暂存原payload</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pbuf types containing payloads? */</span></span><br><span class="line">  <span class="comment">//如果payload与pbuf结构体是在连续内存，则直接移动payload</span></span><br><span class="line">  <span class="keyword">if</span> (type == PBUF_RAM || type == PBUF_POOL) &#123;</span><br><span class="line">    <span class="comment">/* set new payload pointer */</span></span><br><span class="line">    p-&gt;payload = (<span class="type">u8_t</span> *)p-&gt;payload - header_size_increment;</span><br><span class="line">    <span class="comment">/* boundary check fails? */</span></span><br><span class="line">    <span class="comment">//如果payload超过buffer头部内存边界，则复原payload，退出</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">u8_t</span> *)p-&gt;payload &lt; (<span class="type">u8_t</span> *)p + SIZEOF_STRUCT_PBUF) &#123;</span><br><span class="line">      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,</span><br><span class="line">        (<span class="string">&quot;pbuf_header: failed as %p &lt; %p (not enough space for new header size)\n&quot;</span>,</span><br><span class="line">        (<span class="type">void</span> *)p-&gt;payload, (<span class="type">void</span> *)((<span class="type">u8_t</span> *)p + SIZEOF_STRUCT_PBUF)));</span><br><span class="line">      <span class="comment">/* restore old payload pointer */</span></span><br><span class="line">      p-&gt;payload = payload;</span><br><span class="line">      <span class="comment">/* bail out unsuccessfully */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果pbuf与payload内存不连续，则无需检查是否超出边界</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == PBUF_REF || type == PBUF_ROM) &#123;</span><br><span class="line">    <span class="comment">/* hide a header in the payload? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//header_size_increment &lt; 0说明首部在payload中，将payload指针后移</span></span><br><span class="line">    <span class="keyword">if</span> ((header_size_increment &lt; <span class="number">0</span>) &amp;&amp; (increment_magnitude &lt;= p-&gt;len)) &#123;</span><br><span class="line">      <span class="comment">/* increase payload pointer */</span></span><br><span class="line">      p-&gt;payload = (<span class="type">u8_t</span> *)p-&gt;payload - header_size_increment;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((header_size_increment &gt; <span class="number">0</span>) &amp;&amp; force) &#123;</span><br><span class="line">      p-&gt;payload = (<span class="type">u8_t</span> *)p-&gt;payload - header_size_increment;  <span class="comment">//首部在payload外，payload需要前移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* cannot expand payload to front (yet!)</span></span><br><span class="line"><span class="comment">       * bail out unsuccessfully */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Unknown type */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;bad pbuf type&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* modify pbuf length fields */</span></span><br><span class="line">  <span class="comment">//更新pbuf的成员</span></span><br><span class="line">  p-&gt;len += header_size_increment;</span><br><span class="line">  p-&gt;tot_len += header_size_increment;</span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_header: old %p new %p (%&quot;</span>S16_F<span class="string">&quot;)\n&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)payload, (<span class="type">void</span> *)p-&gt;payload, header_size_increment));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六，小结"><a href="#六，小结" class="headerlink" title="六，小结"></a>六，小结</h2><p>学习好pbuf，重点是理解pbuf结构体的payload成员，以及对各个类型的pbuf有一个抽象的认识。最好搭配示意图理解pbuf在数据传递过程中的灵活性。<br>pbuf是lwip协议各层数据传递的基础，掌握得好，后面事半功倍。<br>pbuf其他函数比较少用，读者可以自己去看，加深对pbuf的理解。<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213143318498.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_pbuf/" data-id="cmbcy7rhx003it8mteymwdl9i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_UDP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_UDP/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.655Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，udp-h"><a href="#一，udp-h" class="headerlink" title="一，udp.h"></a>一，udp.h</h2><p>udp协议呢比tcp简单，其数据结构也简单了许多。lwip的udp代码结构简单如下：比较复杂的是udp_input()函数。<br><img src="/2025/05/30/hello-world/lwip/lwip_UDP/20201221195017947.png" alt="在这里插入图片描述"><br>（图侵删）</p>
<p><strong>下面来看看udp.h这个udp协议接口文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp_pcb</span> &#123;</span></span><br><span class="line">  IP_PCB; <span class="comment">//ip地址等</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">udp_pcb</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> local_port, remote_port;  <span class="comment">//本地，远端端口号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_MULTICAST_TX_OPTIONS</span></span><br><span class="line">  <span class="comment">/** outgoing network interface for multicast packets */</span></span><br><span class="line">  <span class="type">ip_addr_t</span> multicast_ip;</span><br><span class="line">  <span class="comment">/** TTL for outgoing multicast packets */</span></span><br><span class="line">  <span class="type">u8_t</span> mcast_ttl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_MULTICAST_TX_OPTIONS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_UDPLITE</span></span><br><span class="line">  <span class="comment">/** used for UDP_LITE only */</span></span><br><span class="line">  <span class="type">u16_t</span> chksum_len_rx, chksum_len_tx;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_UDPLITE */</span></span></span><br><span class="line"></span><br><span class="line">  udp_recv_fn recv; <span class="comment">//接收回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *recv_arg; <span class="comment">//接收回调函数参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>udp_pcb结构体非常简单哈，主要包含了ip地址，端口，还有上层应用的回调函数。<br>flag的取值有以下：udp是可以补进行校验和计算的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_FLAGS_NOCHKSUM       0x01U  <span class="comment">//不进行校验和计算</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_FLAGS_UDPLITE        0x02U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_FLAGS_CONNECTED      0x04U  <span class="comment">//控制块已经和对方建立连接</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_FLAGS_MULTICAST_LOOP 0x08U  <span class="comment">//循环广播</span></span></span><br></pre></td></tr></table></figure>
<p>其次是应用回调函数，它是个函数指针，用于udp接收到正常的数据时，调用函数，让应用层对数据进行处理，应用层处理完数据应该对数据缓存pbuf进行释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Function prototype for udp pcb receive callback functions</span></span><br><span class="line"><span class="comment"> * addr and port are in same byte order as in the pcb</span></span><br><span class="line"><span class="comment"> * The callback is responsible for freeing the pbuf</span></span><br><span class="line"><span class="comment"> * if it&#x27;s not used any more.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ATTENTION: Be aware that &#x27;addr&#x27; might point into the pbuf &#x27;p&#x27; so freeing this pbuf</span></span><br><span class="line"><span class="comment"> *            can make &#x27;addr&#x27; invalid, too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg user supplied argument (udp_pcb.recv_arg)</span></span><br><span class="line"><span class="comment"> * @param pcb the udp_pcb which received data</span></span><br><span class="line"><span class="comment"> * @param p the packet buffer that was received</span></span><br><span class="line"><span class="comment"> * @param addr the remote IP address from which the packet was received</span></span><br><span class="line"><span class="comment"> * @param port the remote port from which the packet was received</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*udp_recv_fn)</span><span class="params">(<span class="type">void</span> *arg, <span class="keyword">struct</span> udp_pcb *pcb, <span class="keyword">struct</span> pbuf *p,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">ip_addr_t</span> *addr, <span class="type">u16_t</span> port)</span>; <span class="comment">//上层应用的数据接收回调函数</span></span><br></pre></td></tr></table></figure>
<p>udp.h中有两个比较重要的函数，也就是数据的输入输出函数，接下来看看他们的代码，其他函数不复杂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span>            <span class="title function_">udp_send</span>       <span class="params">(<span class="keyword">struct</span> udp_pcb *pcb, <span class="keyword">struct</span> pbuf *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>             <span class="title function_">udp_input</span>      <span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="二，udp数据输出"><a href="#二，udp数据输出" class="headerlink" title="二，udp数据输出"></a>二，udp数据输出</h2><p>代码提供了多个udp输出的函数，这些函数各自实现一部分功能，最后都要调用<code>udp_sendto_if_src()</code>函数把数据交给ip层。<br>例如：udp_send()将pbuf发送到udp_pcb中记录的目的地址。其实它调用了<code>udp_sendto()</code>，而udp_sendto()中由目的ip和源ip地址，先确定使用的网络接口netif，然后调用udp_sendto_if();在udp_sendto_if()中确定了真正的src_ip(源ip地址)并调用udp_sendto_if_src();<br><strong>所以最终boss是函数udp_sendto_if_src();，该函数就是填充了udp的首部，并传递给ip层，其中关于校验和计算的宏会比较复杂</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将pbuf填充并交给ip层</span></span><br><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">udp_sendto_if_src</span><span class="params">(<span class="keyword">struct</span> udp_pcb *pcb, <span class="keyword">struct</span> pbuf *p,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">ip_addr_t</span> *dst_ip, <span class="type">u16_t</span> dst_port, <span class="keyword">struct</span> netif *netif, <span class="type">const</span> <span class="type">ip_addr_t</span> *src_ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">udp_hdr</span> *<span class="title">udphdr</span>;</span> <span class="comment">//发送的udp首部</span></span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span> <span class="comment">/* q will be sent down the stack */</span></span><br><span class="line">  <span class="type">u8_t</span> ip_proto;    <span class="comment">//？</span></span><br><span class="line">  <span class="type">u8_t</span> ttl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pcb == <span class="literal">NULL</span>) || (dst_ip == <span class="literal">NULL</span>) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||</span><br><span class="line">      !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_VAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查端口是否绑定</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;local_port == <span class="number">0</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;udp_send: not yet bound to a port, binding now\n&quot;</span>));</span><br><span class="line">    err = udp_bind(pcb, &amp;pcb-&gt;local_ip, pcb-&gt;local_port); <span class="comment">//未绑定的就帮他绑定</span></span><br><span class="line">    <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, (<span class="string">&quot;udp_send: forced port bind failed\n&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将pbuf的payload指针前移8个字节，用于填充udp首部</span></span><br><span class="line">  <span class="keyword">if</span> (pbuf_header(p, UDP_HLEN)) &#123;   <span class="comment">//0：移动成功；</span></span><br><span class="line">    <span class="comment">//若移动失败，pbuf前面内存不够，需要新增内存</span></span><br><span class="line"></span><br><span class="line">    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);  <span class="comment">//申请一个pbuf存放udp首部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, (<span class="string">&quot;udp_send: could not allocate header\n&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当pbuf中有数据时，将udp首部q连接到pbuf之前</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tot_len != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* chain header q in front of given pbuf p (only if p contains data) */</span></span><br><span class="line">      pbuf_chain(q, p); <span class="comment">//q放到p之前</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(UDP_DEBUG,</span><br><span class="line">                (<span class="string">&quot;udp_send: added header pbuf %p before given pbuf %p\n&quot;</span>, (<span class="type">void</span> *)q, (<span class="type">void</span> *)p));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;	<span class="comment">//移动8字节成功</span></span><br><span class="line">    <span class="comment">/* adding space for header within p succeeded */</span></span><br><span class="line">    <span class="comment">/* first pbuf q equals given pbuf */</span></span><br><span class="line">    q = p; </span><br><span class="line">    LWIP_DEBUGF(UDP_DEBUG, (<span class="string">&quot;udp_send: added header in given pbuf %p\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//q现在是即将发送的pbuf了</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;check that first pbuf can hold struct udp_hdr&quot;</span>,</span><br><span class="line">              (q-&gt;len &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udp_hdr)));</span><br><span class="line"></span><br><span class="line">  udphdr = (<span class="keyword">struct</span> udp_hdr *)q-&gt;payload;  <span class="comment">//取得udp首部</span></span><br><span class="line">  udphdr-&gt;src = lwip_htons(pcb-&gt;local_port);  <span class="comment">//填充udp首部的地址</span></span><br><span class="line">  udphdr-&gt;dest = lwip_htons(dst_port);</span><br><span class="line">  <span class="comment">/* in UDP, 0 checksum means &#x27;no checksum&#x27; */</span></span><br><span class="line">  udphdr-&gt;chksum = <span class="number">0x0000</span>;  <span class="comment">//填充校验和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LWIP_IPV4 &amp;&amp; LWIP_MULTICAST_TX_OPTIONS) || (LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD)</span></span><br><span class="line">  <span class="comment">//判断是否开启循环广播且目标地址是广播地址</span></span><br><span class="line">  <span class="keyword">if</span> (((pcb-&gt;flags &amp; UDP_FLAGS_MULTICAST_LOOP) != <span class="number">0</span>) &amp;&amp; ip_addr_ismulticast(dst_ip)) &#123;</span><br><span class="line">    q-&gt;flags |= PBUF_FLAG_MCASTLOOP;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(UDP_DEBUG, (<span class="string">&quot;udp_send: sending datagram of length %&quot;</span>U16_F<span class="string">&quot;\n&quot;</span>, q-&gt;tot_len));</span><br><span class="line"></span><br><span class="line">  &#123;      </span><br><span class="line">    LWIP_DEBUGF(UDP_DEBUG, (<span class="string">&quot;udp_send: UDP packet length %&quot;</span>U16_F<span class="string">&quot;\n&quot;</span>, q-&gt;tot_len));</span><br><span class="line">    udphdr-&gt;len = lwip_htons(q-&gt;tot_len); <span class="comment">//填充udp首部中的len字段 表示udp的数据长度</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_GEN_UDP</span></span><br><span class="line">    <span class="comment">//检查网络接口校验和计算是否使能</span></span><br><span class="line">    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) &#123;</span><br><span class="line">      <span class="comment">//对于ipv6，校验和是必须的</span></span><br><span class="line">      <span class="keyword">if</span> (IP_IS_V6(dst_ip) || (pcb-&gt;flags &amp; UDP_FLAGS_NOCHKSUM) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">u16_t</span> udpchksum;</span><br><span class="line">        &#123;</span><br><span class="line">          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q-&gt;tot_len,</span><br><span class="line">            src_ip, dst_ip);  <span class="comment">//计算校验和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* chksum zero must become 0xffff, as zero means &#x27;no checksum&#x27; */</span></span><br><span class="line">        <span class="keyword">if</span> (udpchksum == <span class="number">0x0000</span>) &#123;</span><br><span class="line">          udpchksum = <span class="number">0xffff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        udphdr-&gt;chksum = udpchksum;	<span class="comment">//填写新的校验和</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_GEN_UDP */</span></span></span><br><span class="line">    ip_proto = IP_PROTO_UDP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Determine TTL to use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_MULTICAST_TX_OPTIONS</span></span><br><span class="line">  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb-&gt;ttl);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_MULTICAST_TX_OPTIONS */</span></span></span><br><span class="line">  ttl = pcb-&gt;ttl;	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_MULTICAST_TX_OPTIONS */</span></span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(UDP_DEBUG, (<span class="string">&quot;udp_send: UDP checksum 0x%04&quot;</span>X16_F<span class="string">&quot;\n&quot;</span>, udphdr-&gt;chksum));</span><br><span class="line">  LWIP_DEBUGF(UDP_DEBUG, (<span class="string">&quot;udp_send: ip_output_if (,,,,0x%02&quot;</span>X16_F<span class="string">&quot;,)\n&quot;</span>, (<span class="type">u16_t</span>)ip_proto));</span><br><span class="line">  <span class="comment">//这些宏未开启</span></span><br><span class="line">  NETIF_SET_HWADDRHINT(netif, &amp;(pcb-&gt;addr_hint));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//传递pbuf给ip层</span></span><br><span class="line">  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb-&gt;tos, ip_proto, netif);</span><br><span class="line">  NETIF_SET_HWADDRHINT(netif, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* @todo: must this be increased even if error occurred? */</span></span><br><span class="line">  MIB2_STATS_INC(mib2.udpoutdatagrams);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* did we chain a separate header pbuf earlier? */</span></span><br><span class="line">  <span class="comment">//若刚刚使用了q申请udp首部，则释放q</span></span><br><span class="line">  <span class="keyword">if</span> (q != p) &#123;</span><br><span class="line">    <span class="comment">/* free the header pbuf */</span></span><br><span class="line">    pbuf_free(q);</span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* p is still referenced by the caller, and will live on */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UDP_STATS_INC(udp.xmit);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三，udp数据输入"><a href="#三，udp数据输入" class="headerlink" title="三，udp数据输入"></a>三，udp数据输入</h2><p><strong>ip层调用该函数，该函数先判断udp包是否是广播，然后查找匹配的udp，其中又分为以下情况：</strong></p>
<p><strong>1，ip地址不匹配时，直接删除</strong><br><strong>2，ip地址匹配但端口不匹配，则发送端口不可达报文</strong><br><strong>3，ip与端口都匹配，则回调接收函数处理数据，应用层处理完数据后应该将数据释放。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">udp_input</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">udp_hdr</span> *<span class="title">udphdr</span>;</span> <span class="comment">//输入数据包的udp首部</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">udp_pcb</span> *<span class="title">pcb</span>, *<span class="title">prev</span>;</span> <span class="comment">//查找的udp控制块</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">udp_pcb</span> *<span class="title">uncon_pcb</span>;</span>  <span class="comment">//未建立连接的pcb</span></span><br><span class="line">  <span class="type">u16_t</span> src, dest;  <span class="comment">//src：数据包源端口，dest：数据包目的端口</span></span><br><span class="line">  <span class="type">u8_t</span> broadcast; <span class="comment">//1：广播包</span></span><br><span class="line">  <span class="type">u8_t</span> for_us = <span class="number">0</span>;  <span class="comment">//1：数据包ip地址是本地</span></span><br><span class="line"></span><br><span class="line">  LWIP_UNUSED_ARG(inp);</span><br><span class="line"></span><br><span class="line">  PERF_START;</span><br><span class="line"></span><br><span class="line">  UDP_STATS_INC(udp.recv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查最小长度</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &lt; UDP_HLEN) &#123;</span><br><span class="line">    <span class="comment">/* drop short packets */</span></span><br><span class="line">    LWIP_DEBUGF(UDP_DEBUG,</span><br><span class="line">                (<span class="string">&quot;udp_input: short UDP datagram (%&quot;</span>U16_F<span class="string">&quot; bytes) discarded\n&quot;</span>, p-&gt;tot_len));</span><br><span class="line">    UDP_STATS_INC(udp.lenerr);</span><br><span class="line">    UDP_STATS_INC(udp.drop);</span><br><span class="line">    MIB2_STATS_INC(mib2.udpinerrors);</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  udphdr = (<span class="keyword">struct</span> udp_hdr *)p-&gt;payload;  <span class="comment">//获取输入数据包的udp首部</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查是否是广播（当前首部目的地址和网络接口判断）</span></span><br><span class="line">  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());</span><br><span class="line"></span><br><span class="line">  src = lwip_ntohs(udphdr-&gt;src);  <span class="comment">//获取首部中的端口</span></span><br><span class="line">  dest = lwip_ntohs(udphdr-&gt;dest);</span><br><span class="line"></span><br><span class="line">  pcb = <span class="literal">NULL</span>;</span><br><span class="line">  prev = <span class="literal">NULL</span>;</span><br><span class="line">  uncon_pcb = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历已连接的udp链表</span></span><br><span class="line">  <span class="keyword">for</span> (pcb = udp_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找 “本地端口=数据包目的端口 &amp;&amp; 本地ip=数据包目的ip” 的pcb</span></span><br><span class="line">    <span class="comment">//判断udp中的本地端口，ip地址与数据报中的是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> ((pcb-&gt;local_port == dest) &amp;&amp;</span><br><span class="line">        (udp_input_local_match(pcb, inp, broadcast) != <span class="number">0</span>)) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断该udp是否已经建立连接</span></span><br><span class="line">      <span class="keyword">if</span> (((pcb-&gt;flags &amp; UDP_FLAGS_CONNECTED) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">          ((uncon_pcb == <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        <span class="comment">/* the first unconnected matching PCB */</span></span><br><span class="line">        uncon_pcb = pcb;  <span class="comment">//记录第一个未连接的匹配udp</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//接下来判断 pcb的目的端口和目的ip是否和数据包的源端口，源ip匹配</span></span><br><span class="line">      <span class="keyword">if</span> ((pcb-&gt;remote_port == src) &amp;&amp;  <span class="comment">//本地目的地址匹配成功</span></span><br><span class="line">          (ip_addr_isany_val(pcb-&gt;remote_ip) || <span class="comment">//ip匹配成功</span></span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()))) &#123;</span><br><span class="line">       <span class="comment">//到此，说明数据包与pcb完全匹配</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">//将匹配的udp移动到链表首部</span></span><br><span class="line">          prev-&gt;next = pcb-&gt;next;</span><br><span class="line">          pcb-&gt;next = udp_pcbs;</span><br><span class="line">          udp_pcbs = pcb;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          UDP_STATS_INC(udp.cachehit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prev = pcb; <span class="comment">//匹配下一个</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历了所有已连接的控制块，都没有完全匹配的，则将第一个匹配成功的未连接控制块作为结果</span></span><br><span class="line">  <span class="keyword">if</span> (pcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pcb = uncon_pcb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb != <span class="literal">NULL</span>) &#123;  <span class="comment">//找到完全匹配的pcb</span></span><br><span class="line">    for_us = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//无完全匹配的控制块。则判断数据包是否是发送到本地ip的</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6</span></span><br><span class="line">    <span class="comment">//若当前数据报是ipv6，且它确实是发送到本地ip的，则for_us=1，但pcb=null</span></span><br><span class="line">    <span class="keyword">if</span> (ip_current_is_v6()) &#123;</span><br><span class="line">      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">    <span class="comment">//若当前数据报不是ipv6，道理一样</span></span><br><span class="line">    <span class="keyword">if</span> (!ip_current_is_v6()) &#123;</span><br><span class="line">      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据包确实是给我们的，ip地址是对的</span></span><br><span class="line">  <span class="keyword">if</span> (for_us) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (udphdr-&gt;chksum != <span class="number">0</span>) &#123;  <span class="comment">//数据包中填写了校验和，则必须校验</span></span><br><span class="line">          <span class="keyword">if</span> (ip_chksum_pseudo(p, IP_PROTO_UDP, p-&gt;tot_len,</span><br><span class="line">                               ip_current_src_addr(),</span><br><span class="line">                               ip_current_dest_addr()) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> chkerr;  <span class="comment">//检验和错误</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验和成功，将payload移动到udp数据区</span></span><br><span class="line">    <span class="keyword">if</span> (pbuf_header(p, -UDP_HLEN)) &#123;</span><br><span class="line">      <span class="comment">/* Can we cope with this failing? Just assert for now */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_header failed\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      UDP_STATS_INC(udp.drop);</span><br><span class="line">      MIB2_STATS_INC(mib2.udpinerrors);</span><br><span class="line">      pbuf_free(p); <span class="comment">//移动失败！</span></span><br><span class="line">      <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若有匹配的控制块，则调用用户的回调函数处理</span></span><br><span class="line">    <span class="keyword">if</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      MIB2_STATS_INC(mib2.udpindatagrams);</span><br><span class="line">      <span class="comment">/* callback */</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;recv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* now the recv function is responsible for freeing p */</span></span><br><span class="line">        pcb-&gt;recv(pcb-&gt;recv_arg, pcb, p, ip_current_src_addr(), src); <span class="comment">//调用应用回调函数处理接收的数据</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     </span><br><span class="line">        pbuf_free(p); <span class="comment">//无回调函数，释放内存</span></span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//若无匹配的控制块，说明端口不正确，返回端口不可达报文</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//确定不是广播或多播的数据报</span></span><br><span class="line">      <span class="keyword">if</span> (!broadcast &amp;&amp; !ip_addr_ismulticast(ip_current_dest_addr())) &#123;</span><br><span class="line">       </span><br><span class="line">        pbuf_header_force(p, (<span class="type">s16_t</span>)(ip_current_header_tot_len() + UDP_HLEN));  <span class="comment">//payload指向ip首部</span></span><br><span class="line">        icmp_port_unreach(ip_current_is_v6(), p); <span class="comment">//发送端口不可达报文</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_ICMP || LWIP_ICMP6 */</span></span></span><br><span class="line">      UDP_STATS_INC(udp.proterr);</span><br><span class="line">      UDP_STATS_INC(udp.drop);</span><br><span class="line">      MIB2_STATS_INC(mib2.udpnoports);</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//不是给我们的，ip地址错误</span></span><br><span class="line">    pbuf_free(p);</span><br><span class="line">  &#125;</span><br><span class="line">end:</span><br><span class="line">  PERF_STOP(<span class="string">&quot;udp_input&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_CHECK_UDP</span></span><br><span class="line">chkerr:</span><br><span class="line"></span><br><span class="line">  UDP_STATS_INC(udp.chkerr);</span><br><span class="line">  UDP_STATS_INC(udp.drop);</span><br><span class="line">  MIB2_STATS_INC(mib2.udpinerrors);</span><br><span class="line">  pbuf_free(p);</span><br><span class="line">  PERF_STOP(<span class="string">&quot;udp_input&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_CHECK_UDP */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>udp相对tcp，简单了许多，但同时也是不可靠的传输。<br><img src="/2025/05/30/hello-world/lwip/lwip_UDP/20201221204533841.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_UDP/" data-id="cmbcy7rhv003at8mt55937rv2" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_dhcp_impl_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_dhcp_impl_2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.655Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，定时器1"><a href="#一，定时器1" class="headerlink" title="一，定时器1"></a>一，定时器1</h2><p>继续上一章，dhcp客户端运行两个定时器，分别周期为1分钟的 <strong>void dhcp_coarse_tmr(void);</strong> 和 每周期为500ms的 <strong>void dhcp_fine_tmr(void);</strong></p>
<p>先看dhcp_fine_tmr()定时任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理dhcp请求超时</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_fine_tmr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span> =</span> netif_list;</span><br><span class="line">  <span class="comment">//遍历所有网口</span></span><br><span class="line">  <span class="keyword">while</span> (netif != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (netif-&gt;dhcp != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">      <span class="comment">//request_timeout -1，表示过去500ms</span></span><br><span class="line">      <span class="keyword">if</span> (netif-&gt;dhcp-&gt;request_timeout &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        netif-&gt;dhcp-&gt;request_timeout--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (netif-&gt;dhcp-&gt;request_timeout == <span class="number">1</span>) &#123; <span class="comment">//请求时间超时</span></span><br><span class="line">        netif-&gt;dhcp-&gt;request_timeout--;	<span class="comment">//此时timeout=0；</span></span><br><span class="line">        dhcp_timeout(netif);  <span class="comment">//执行超时处理</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    netif = netif-&gt;next;  <span class="comment">//检查下一个网口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当dhcp广播请求报文后就进入requesting状态，并设置request_timeout时间。在dhcp_fine_tmr()中，判断是否超时。dhcp_timeout()是超时处理函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_timeout</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span> =</span> netif-&gt;dhcp;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//DHCP_BACKING_OFF和DHCP_SELECTING下超时是因为服务器们无响应，可能是广播的发现报文失踪了</span></span><br><span class="line">  <span class="keyword">if</span> ((dhcp-&gt;state == DHCP_BACKING_OFF) || (dhcp-&gt;state == DHCP_SELECTING)) &#123;</span><br><span class="line">    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;dhcp_timeout(): restarting discovery\n&quot;</span>));</span><br><span class="line">    dhcp_discover(netif); <span class="comment">//重新广播发现报文</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//dhcp处于DHCP_REQUESTING状态而超时，可能是服务器的ack报文丢失</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dhcp-&gt;state == DHCP_REQUESTING) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;tries &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">//重新与该服务器联系，让她重新ack</span></span><br><span class="line">      dhcp_select(netif);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//该服务器可能挂了，我们重新广播发现报文，选择别的服务器</span></span><br><span class="line">      dhcp_release(netif);  <span class="comment">//清除之前的ip</span></span><br><span class="line">      dhcp_discover(netif);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//DHCP_RENEWING下，可能是再续约报文丢失</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dhcp-&gt;state == DHCP_RENEWING) &#123;</span><br><span class="line">    dhcp_renew(netif);  <span class="comment">//重新发送续约报文</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dhcp-&gt;state == DHCP_REBINDING) &#123; <span class="comment">//重新绑定状态下，可能是报文丢失或服务器挂了</span></span><br><span class="line">    <span class="comment">//超过8次无ack，就重新广播，选择其他服务器</span></span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;tries &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">      dhcp_rebind(netif);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dhcp_release(netif);  <span class="comment">//释放资源</span></span><br><span class="line">      dhcp_discover(netif); <span class="comment">//重新广播</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dhcp-&gt;state == DHCP_REBOOTING) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;tries &lt; REBOOT_TRIES) &#123;</span><br><span class="line">      dhcp_reboot(netif);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dhcp_discover(netif);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在超时处理函数中，超时的原因可能是报文丢失或服务器关闭等。所以针对超时的处理有报文重发和重新广播两种方式。</strong></p>
<h2 id="二-定时器2"><a href="#二-定时器2" class="headerlink" title="二 定时器2"></a>二 定时器2</h2><p>通过dhcp协议获取的ip地址是有使用时间的。当过了租用时间的一半时，客户端要发送续约报文给服务器，通知服务器是否继续使用该ip地址；</p>
<p>client发送Rebind报文给任何可以用的服务器（Rebind报文中没有server id选项），以延长分配给client的地址的生存时间并且更新其它配置参数，这个消息是在发送Renew消息没有回应后才发送。</p>
<p><strong>dhcp_coarse_tmr()定时器以一分钟的周期执行，检查续约时间和rebind时间是否超时，若超时则分别执行 dhcp_renew(netif); 和 dhcp_rebind(netif); 函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_coarse_tmr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span> =</span> netif_list;</span><br><span class="line">  <span class="comment">//遍历网口，检查t1，t2是否超时</span></span><br><span class="line">  <span class="keyword">while</span> (netif != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (netif-&gt;dhcp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (netif-&gt;dhcp-&gt;t2_timeout-- == <span class="number">1</span>) &#123;</span><br><span class="line">        dhcp_t2_timeout(netif);	<span class="comment">//rebind超时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (netif-&gt;dhcp-&gt;t1_timeout-- == <span class="number">1</span>) &#123;</span><br><span class="line">        dhcp_t1_timeout(netif);	<span class="comment">//续约超时</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    netif = netif-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/30/hello-world/lwip/lwip_dhcp_impl_2/20210225151942232.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_dhcp_impl_2/" data-id="cmbcy7rhw003ct8mt676e2pmd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_dhcp_impl_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_dhcp_impl_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.655Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，dhcp协议简介"><a href="#一，dhcp协议简介" class="headerlink" title="一，dhcp协议简介"></a>一，dhcp协议简介</h2><p>dhcp协议是动态主机配置协议，是互联网的基本协议。lwip内核也实现了该协议。关于lwip协议的具体内容，请先转到：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lm409/article/details/80298225">https://blog.csdn.net/lm409/article/details/80298225</a></p>
<p>lwip实现dhcp的代码在core&#x2F;dhcp.c中。</p>
<h2 id="二，源码解析"><a href="#二，源码解析" class="headerlink" title="二，源码解析"></a>二，源码解析</h2><p>应用程序要使用dhcp协议，只需要在代码中调用：</p>
<blockquote>
<p>err_t dhcp_start(struct netif *netif);</p>
</blockquote>
<p>并在定时调用以下两个定时器，就能获得ip地址给网口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 每一分钟调用一次 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dhcp_coarse_tmr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/** 500ms调用一次 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dhcp_fine_tmr</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>首先认识描述dhcp客户端的结构体：</p>
<h3 id="2-1-dhcp结构体"><a href="#2-1-dhcp结构体" class="headerlink" title="2.1 dhcp结构体"></a>2.1 dhcp结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">u32_t</span> xid;  <span class="comment">//事务ID，随机数，有客户端生成，服务器Reply时，会把Request中的Transaction拷贝到Reply报文中。</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">udp_pcb</span> *<span class="title">pcb</span>;</span>  <span class="comment">//连接dhcp服务器的udp控制块</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp_msg</span> *<span class="title">msg_in</span>;</span>  <span class="comment">//dhcp输入报文</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">u8_t</span> state; <span class="comment">//当前dhcp状态机</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">u8_t</span> tries; <span class="comment">//重请求次数</span></span><br><span class="line">  <span class="type">u8_t</span> subnet_mask_given;	<span class="comment">//是否有子网掩码</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p_out</span>;</span> <span class="comment">/* 输出的报文的pbuf pbuf of outcoming msg */</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp_msg</span> *<span class="title">msg_out</span>;</span> <span class="comment">/* 输出的报文 outgoing msg */</span></span><br><span class="line">  <span class="type">u16_t</span> options_out_len; <span class="comment">/* 输出的报文的选项长度 outgoing msg options length */</span></span><br><span class="line">  <span class="comment">//请求超时时间</span></span><br><span class="line">  <span class="type">u16_t</span> request_timeout; <span class="comment">/* #ticks with period DHCP_FINE_TIMER_SECS for request timeout */</span></span><br><span class="line">  <span class="type">u16_t</span> t1_timeout;  <span class="comment">/* #ticks with period DHCP_COARSE_TIMER_SECS for renewal time */</span></span><br><span class="line">  <span class="type">u16_t</span> t2_timeout;  <span class="comment">/* #ticks with period DHCP_COARSE_TIMER_SECS for rebind time */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">ip_addr_t</span> server_ip_addr;   <span class="comment">//dhcp服务器地址</span></span><br><span class="line">  <span class="type">ip_addr_t</span> offered_ip_addr;  <span class="comment">//服务器提供的ip</span></span><br><span class="line">  <span class="type">ip_addr_t</span> offered_sn_mask;  <span class="comment">//服务器提供的子网掩码</span></span><br><span class="line">  <span class="type">ip_addr_t</span> offered_gw_addr;  <span class="comment">//服务器提供的网关地址</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//dhcp报文选项字段中的时间</span></span><br><span class="line">  <span class="type">u32_t</span> offered_t0_lease; <span class="comment">/* 租借地址的时间 lease period (in seconds) */</span></span><br><span class="line">  <span class="type">u32_t</span> offered_t1_renew; <span class="comment">/* 续租的时间 recommended renew time (usually 50% of lease period) */</span></span><br><span class="line">  <span class="type">u32_t</span> offered_t2_rebind; <span class="comment">/* 租约重新设定的时间 recommended rebind time (usually 66% of lease period)  */</span></span><br><span class="line">  <span class="comment">/* @todo: LWIP_DHCP_BOOTP_FILE configuration option?</span></span><br><span class="line"><span class="comment">     integrate with possible TFTP-client for booting? */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dhcp报文实质上是udp报文，故结构体有udp控制块。<strong>其中需要关注与时间有关的变量：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">u16_t</span> request_timeout; <span class="comment">//请求超时时间</span></span><br><span class="line"><span class="type">u16_t</span> t1_timeout;  <span class="comment">//续租超时时间</span></span><br><span class="line"><span class="type">u16_t</span> t2_timeout;		<span class="comment">//重绑定超时时间</span></span><br></pre></td></tr></table></figure>
<p><strong>这三个变量会在每次定时函数被执行时减1，当他们其中一个为0时，表示超时时间到，会执行相应的代码来使dhcp客户端保持正常运行。另外三个时间变量也与此相关：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">u32_t</span> offered_t0_lease; <span class="comment">/* 租借地址的时间 lease period (in seconds) */</span></span><br><span class="line"><span class="type">u32_t</span> offered_t1_renew; <span class="comment">/* 续租的时间 recommended renew time (usually 50% of lease period) */</span></span><br><span class="line"><span class="type">u32_t</span> offered_t2_rebind;<span class="comment">/* 租约重新设定的时间 recommended rebind time (usually 66% of lease period)  */</span></span><br></pre></td></tr></table></figure>
<p><strong>这三个变量是由dhcp服务器返回的报文里的选项参数决定的，每一个dhcp服务器报文到来，这三个变量就会对timeout进行更新。</strong><br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后还要注意dhcp客户端状态的转换,dhcp客户端的状态由10种，但我们只需要知道主要的4种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_OFF          0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_REQUESTING   1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_INIT         2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_REBOOTING    3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_REBINDING    4 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_RENEWING     5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_SELECTING    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_INFORMING    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_CHECKING     8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_PERMANENT    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCP_BOUND        10</span></span><br></pre></td></tr></table></figure>
<p>与dhcp建立过程对应的状态如图：<br><strong>设备刚刚启动dhcp客户端时：</strong><br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>续约时间到，dhcp客户端续约当前的ip。</strong><br><img src="/20210224234639613.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-开始广播"><a href="#2-2-开始广播" class="headerlink" title="2.2 开始广播"></a>2.2 开始广播</h3><p>有了以上的认识，对代码逻辑的理解就会更简单。应用代码中，只需要调用dhcp_start()就能开启dhcp功能，那么这个函数它干嘛了？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">dhcp_start</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span>;</span></span><br><span class="line">  <span class="type">err_t</span> result = ERR_OK;</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netif != NULL&quot;</span>, (netif != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line">  dhcp = netif-&gt;dhcp;</span><br><span class="line">  netif-&gt;flags &amp;= ~NETIF_FLAG_DHCP; <span class="comment">//清除dhcp成功标志</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查网络接口是否是以太网</span></span><br><span class="line">  <span class="keyword">if</span> ((netif-&gt;flags &amp; NETIF_FLAG_ETHARP) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_ARG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check MTU of the netif */</span></span><br><span class="line">  <span class="keyword">if</span> (netif-&gt;mtu &lt; DHCP_MAX_MSG_LEN_MIN_REQUIRED) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//该网络接口未使用过dhcp客户端</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    dhcp = (<span class="keyword">struct</span> dhcp *)mem_malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dhcp));  <span class="comment">//分配一个dhcp内存</span></span><br><span class="line">    <span class="keyword">if</span> (dhcp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    netif-&gt;dhcp = dhcp; <span class="comment">//保存dhcp客户端到当前网口</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//接口已经有一个dhcp客户端</span></span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      udp_remove(dhcp-&gt;pcb);  <span class="comment">//为了重新配置ip，需要先将dhcp客户端的pcb移除</span></span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf p_out wasn&#x27;t freed&quot;</span>, dhcp-&gt;p_out == <span class="literal">NULL</span>);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;reply wasn&#x27;t freed&quot;</span>, dhcp-&gt;msg_in == <span class="literal">NULL</span> );</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">memset</span>(dhcp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dhcp)); <span class="comment">//清零dhcp内存</span></span><br><span class="line"></span><br><span class="line">  dhcp-&gt;pcb = udp_new();  <span class="comment">//创建新的udp控制块</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp-&gt;pcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">  &#125;</span><br><span class="line">  dhcp-&gt;pcb-&gt;so_options |= SOF_BROADCAST; <span class="comment">//开启发送和接收的广播</span></span><br><span class="line"></span><br><span class="line">  udp_bind(dhcp-&gt;pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT); <span class="comment">//绑定本地ip（全0）和端口 dhcp客户端专属端口68</span></span><br><span class="line">  udp_connect(dhcp-&gt;pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);  <span class="comment">//连接到远程dhcp服务器端口67</span></span><br><span class="line"> </span><br><span class="line">  udp_recv(dhcp-&gt;pcb, dhcp_recv, netif);  <span class="comment">//设置dhcp接收回调函数和参数</span></span><br><span class="line"></span><br><span class="line">  result = dhcp_discover(netif);  <span class="comment">//dhcp客户端开始运行</span></span><br><span class="line">  <span class="keyword">if</span> (result != ERR_OK) &#123;</span><br><span class="line">    dhcp_stop(netif);	<span class="comment">//错了，停止dhcp</span></span><br><span class="line">    <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">  &#125;</span><br><span class="line">  netif-&gt;flags |= NETIF_FLAG_DHCP;  <span class="comment">//置位dhcp成功</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**可见这个函数主要是为dhcp结构体分配内存，并建立了一个udp连接，注册好dhcp的回调函数（当收到ducp服务器发送的报文时会进入回调函数），并调用dhcp_discover();函数开始广播dhcp发现报文。**接着看这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">err_t</span></span><br><span class="line"><span class="title function_">dhcp_discover</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span> =</span> netif-&gt;dhcp;  <span class="comment">//使用当前网口的dhcp客户端</span></span><br><span class="line">  <span class="type">err_t</span> result = ERR_OK;</span><br><span class="line">  <span class="type">u16_t</span> msecs;</span><br><span class="line">  ip_addr_set_any(&amp;dhcp-&gt;offered_ip_addr);  <span class="comment">//初始化dhcp-&gt;offered_ip_addr为0</span></span><br><span class="line">  dhcp_set_state(dhcp, DHCP_SELECTING); <span class="comment">//dhcp为状态</span></span><br><span class="line">  </span><br><span class="line">  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER); <span class="comment">//创建dhcp发现报文首部</span></span><br><span class="line">  <span class="keyword">if</span> (result == ERR_OK) &#123;</span><br><span class="line">    <span class="comment">//填充发现报文的选项字段（较为复杂，参考协议）</span></span><br><span class="line">    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;dhcp_discover: making request\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);</span><br><span class="line">    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));</span><br><span class="line"></span><br><span class="line">    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, <span class="number">4</span><span class="comment">/*num options*/</span>);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);</span><br><span class="line"></span><br><span class="line">    dhcp_option_trailer(dhcp);</span><br><span class="line">    <span class="comment">//为p_out减少内存</span></span><br><span class="line">    pbuf_realloc(dhcp-&gt;p_out, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dhcp_msg) - DHCP_OPTIONS_LEN + dhcp-&gt;options_out_len);  </span><br><span class="line">	<span class="comment">//将p_out的数据发送，等待dhcp服务器返回报文</span></span><br><span class="line">    udp_sendto_if(dhcp-&gt;pcb, dhcp-&gt;p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);  </span><br><span class="line">    </span><br><span class="line">    dhcp_delete_msg(dhcp);  <span class="comment">//释放dhcp发现报文的内存</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  dhcp-&gt;tries++;  <span class="comment">//重发次数+1</span></span><br><span class="line">  msecs = (dhcp-&gt;tries &lt; <span class="number">6</span> ? <span class="number">1</span> &lt;&lt; dhcp-&gt;tries : <span class="number">60</span>) * <span class="number">1000</span>;</span><br><span class="line">  dhcp-&gt;request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - <span class="number">1</span>) / DHCP_FINE_TIMER_MSECS;  <span class="comment">//计算请求超时时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该函数先将dhcp客户端设置为DHCP_SELECTING状态，然后调用dhcp_create_msg()构造dhcp发现报文并填充选项字段，调用udp_sendto_if()将udp报文广播出去，并设置请求超时时间，等待dhcp客户端的回答。</strong></p>
<p>那么dhcp发现报文如何构造，下图所示dhcp报文内容：<br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>dhcp_create_msg():就是按照上图构造dhcp报文的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">err_t</span></span><br><span class="line"><span class="title function_">dhcp_create_msg</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> dhcp *dhcp, <span class="type">u8_t</span> message_type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u16_t</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">u32_t</span> xid = <span class="number">0xABCD0000</span>;	<span class="comment">//静态的事务id</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//申请dhcp报文的pbuf</span></span><br><span class="line">  dhcp-&gt;p_out = pbuf_alloc(PBUF_TRANSPORT, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dhcp_msg), PBUF_RAM);</span><br><span class="line">  <span class="keyword">if</span> (dhcp-&gt;p_out == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是一个新的dhcp客户端，xid就更新。重绑定的情况下xid不需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp-&gt;tries == <span class="number">0</span>) &#123;</span><br><span class="line">      xid++;</span><br><span class="line">  &#125;</span><br><span class="line">  dhcp-&gt;xid = xid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//dhcp_msg指向dhcp报文的缓存地址</span></span><br><span class="line">  dhcp-&gt;msg_out = (<span class="keyword">struct</span> dhcp_msg *)dhcp-&gt;p_out-&gt;payload;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对dhcp报文填充内容，也就是填充入p_out-&gt;payload;</span></span><br><span class="line">  dhcp-&gt;msg_out-&gt;op = DHCP_BOOTREQUEST;</span><br><span class="line"></span><br><span class="line">  dhcp-&gt;msg_out-&gt;htype = DHCP_HTYPE_ETH;</span><br><span class="line">  dhcp-&gt;msg_out-&gt;hlen = netif-&gt;hwaddr_len;</span><br><span class="line">  dhcp-&gt;msg_out-&gt;hops = <span class="number">0</span>;</span><br><span class="line">  dhcp-&gt;msg_out-&gt;xid = htonl(dhcp-&gt;xid);</span><br><span class="line">  dhcp-&gt;msg_out-&gt;secs = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* we don&#x27;t need the broadcast flag since we can receive unicast traffic</span></span><br><span class="line"><span class="comment">     before being fully configured! */</span></span><br><span class="line">  dhcp-&gt;msg_out-&gt;flags = <span class="number">0</span>;</span><br><span class="line">  ip_addr_set_zero(&amp;dhcp-&gt;msg_out-&gt;ciaddr); <span class="comment">//设置当前客户端ip为0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//下面根据报文类型和dhcp客户端的不同，有不同的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||</span><br><span class="line">      ((message_type == DHCP_REQUEST) &amp;&amp; <span class="comment">/* DHCP_BOUND not used for sending! */</span></span><br><span class="line">       ((dhcp-&gt;state==DHCP_RENEWING) || dhcp-&gt;state==DHCP_REBINDING))) &#123;</span><br><span class="line">    <span class="comment">//通知，拒绝类型的报文</span></span><br><span class="line">    <span class="comment">//重新请求或重新绑定状态下的请求报文</span></span><br><span class="line">   <span class="comment">//以上情况的dhcp客户端都已经有ip地址了，所以构造的报文的ciaddr为接口地址</span></span><br><span class="line">    ip_addr_copy(dhcp-&gt;msg_out-&gt;ciaddr, netif-&gt;ip_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面三个地址清零，这是服务器即将分配的地址</span></span><br><span class="line">  ip_addr_set_zero(&amp;dhcp-&gt;msg_out-&gt;yiaddr);</span><br><span class="line">  ip_addr_set_zero(&amp;dhcp-&gt;msg_out-&gt;siaddr);</span><br><span class="line">  ip_addr_set_zero(&amp;dhcp-&gt;msg_out-&gt;giaddr);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DHCP_CHADDR_LEN; i++) &#123;</span><br><span class="line">    <span class="comment">//将网口硬件地址复制到报文硬件地址选项</span></span><br><span class="line">    dhcp-&gt;msg_out-&gt;chaddr[i] = (i &lt; netif-&gt;hwaddr_len) ? netif-&gt;hwaddr[i] : <span class="number">0</span><span class="comment">/* pad byte*/</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//清零服务端名字</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DHCP_SNAME_LEN; i++) &#123;</span><br><span class="line">    dhcp-&gt;msg_out-&gt;sname[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DHCP_FILE_LEN; i++) &#123;</span><br><span class="line">    dhcp-&gt;msg_out-&gt;file[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dhcp-&gt;msg_out-&gt;cookie = PP_HTONL(DHCP_MAGIC_COOKIE);</span><br><span class="line">  dhcp-&gt;options_out_len = <span class="number">0</span>;  <span class="comment">//初始选项长度为0</span></span><br><span class="line">  <span class="comment">//用一个随便的数组填充报文的选项字段</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DHCP_OPTIONS_LEN; i++) &#123;</span><br><span class="line">    dhcp-&gt;msg_out-&gt;options[i] = (<span class="type">u8_t</span>)i; <span class="comment">/* for debugging only, no matter if truncated */</span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//填充报文选项字段中的报文类型</span></span><br><span class="line">  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);</span><br><span class="line">  dhcp_option_byte(dhcp, message_type);</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-回调接口"><a href="#2-3-回调接口" class="headerlink" title="2.3 回调接口"></a>2.3 回调接口</h3><p>广播完成后，只需等待dhcp服务器们发来reply信息。当udp控制块收到dhcp服务端的消息时，就会调用设置的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_recv</span><span class="params">(<span class="type">void</span> *arg, <span class="keyword">struct</span> udp_pcb *pcb, <span class="keyword">struct</span> pbuf *p, <span class="type">ip_addr_t</span> *addr, <span class="type">u16_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span> =</span> (<span class="keyword">struct</span> netif *)arg;	<span class="comment">//获取网口</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span> =</span> netif-&gt;dhcp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp_msg</span> *<span class="title">reply_msg</span> =</span> (<span class="keyword">struct</span> dhcp_msg *)p-&gt;payload; <span class="comment">//获取返回的数据</span></span><br><span class="line">  <span class="type">u8_t</span> msg_type;</span><br><span class="line">  <span class="type">u8_t</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//检查返回数据长度</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &lt; DHCP_MIN_REPLY_LEN) &#123;</span><br><span class="line">    <span class="keyword">goto</span> free_pbuf_and_return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//检查报文是否是reply类型</span></span><br><span class="line">  <span class="keyword">if</span> (reply_msg-&gt;op != DHCP_BOOTREPLY) &#123;</span><br><span class="line">    <span class="keyword">goto</span> free_pbuf_and_return;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//检查reply报文的客户端硬件地址跟本地网口地址对不对得上</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; netif-&gt;hwaddr_len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (netif-&gt;hwaddr[i] != reply_msg-&gt;chaddr[i]) &#123;</span><br><span class="line">      <span class="keyword">goto</span> free_pbuf_and_return;	<span class="comment">//对不上</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查事物id与当前dhcp客户端的xid对不对</span></span><br><span class="line">  <span class="keyword">if</span> (ntohl(reply_msg-&gt;xid) != dhcp-&gt;xid) &#123;</span><br><span class="line">    <span class="keyword">goto</span> free_pbuf_and_return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析reply报文的内容</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp_parse_reply(dhcp, p) != ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">goto</span> free_pbuf_and_return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查选项字段中是否有Message Type</span></span><br><span class="line">  <span class="keyword">if</span> (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) &#123;</span><br><span class="line">    <span class="keyword">goto</span> free_pbuf_and_return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取报文类型</span></span><br><span class="line">  msg_type = (<span class="type">u8_t</span>)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (msg_type == DHCP_ACK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;state == DHCP_REQUESTING) &#123;</span><br><span class="line">      <span class="comment">//dhcp报文是ack类型，且客户端处于请求状态（联系上图）</span></span><br><span class="line">      dhcp_handle_ack(netif);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DHCP_DOES_ARP_CHECK</span></span><br><span class="line">      <span class="comment">/* check if the acknowledged lease address is already in use */</span></span><br><span class="line">      dhcp_check(netif);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      </span><br><span class="line">      dhcp_bind(netif); <span class="comment">//将dhcp申请到的ip绑定到netif</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下三种状态的dhcp也能进行绑定</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((dhcp-&gt;state == DHCP_REBOOTING) || (dhcp-&gt;state == DHCP_REBINDING) || (dhcp-&gt;state == DHCP_RENEWING)) &#123;</span><br><span class="line">      dhcp_bind(netif);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据dhcp协议，服务器返回nack报文，客户端需要重新广播，重新获取ip</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((msg_type == DHCP_NAK) &amp;&amp;</span><br><span class="line">    ((dhcp-&gt;state == DHCP_REBOOTING) || (dhcp-&gt;state == DHCP_REQUESTING) ||</span><br><span class="line">     (dhcp-&gt;state == DHCP_REBINDING) || (dhcp-&gt;state == DHCP_RENEWING  ))) &#123;</span><br><span class="line">    dhcp_handle_nak(netif);	<span class="comment">//重新广播获取ip</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//offer类型的报文且dhcp处于selecting状态（结合上图）</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((msg_type == DHCP_OFFER) &amp;&amp; (dhcp-&gt;state == DHCP_SELECTING)) &#123;</span><br><span class="line">    dhcp-&gt;request_timeout = <span class="number">0</span>;	<span class="comment">//关闭请求超时</span></span><br><span class="line"></span><br><span class="line">    dhcp_handle_offer(netif); <span class="comment">//保存ip 并进入请求状态</span></span><br><span class="line">  &#125;</span><br><span class="line">free_pbuf_and_return:</span><br><span class="line">  dhcp-&gt;msg_in = <span class="literal">NULL</span>;</span><br><span class="line">  pbuf_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>回调函数首先解析dhcp报文的内容和选项字段，选项字段的值被保存在全局变量 dhcp_rx_options_val[] 中。然后根据报文类型，dhcp客户端所处的状态，判断当前dhcp连接的状态，进行进一步的处理。如图，一共有三种情况需要进一步处理。</strong><br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="a，发送请求"><a href="#a，发送请求" class="headerlink" title="a，发送请求"></a>a，发送请求</h4><p>假设客户端发出发现广播，接收到服务器们的offer报文，接下来客户端应该选择一个服务器，广播请求报文，请求指定服务器的ip。这个功能在dhcp_handle_offer(netif);实现，dhcp_select(netif);则完成了请求报文的构造与发送功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存服务器的ip和分配的ip</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_handle_offer</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span> =</span> netif-&gt;dhcp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//服务器ip不为0</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) &#123;</span><br><span class="line">    <span class="comment">//获取服务器ip</span></span><br><span class="line">    ip4_addr_set_u32(&amp;dhcp-&gt;server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));</span><br><span class="line">    <span class="comment">//获取服务器分配的ip</span></span><br><span class="line">    ip_addr_copy(dhcp-&gt;offered_ip_addr, dhcp-&gt;msg_in-&gt;yiaddr);</span><br><span class="line">    dhcp_select(netif);	<span class="comment">//广播请求报文</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">err_t</span></span><br><span class="line"><span class="title function_">dhcp_select</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span> =</span> netif-&gt;dhcp;</span><br><span class="line">  <span class="type">err_t</span> result;</span><br><span class="line">  <span class="type">u16_t</span> msecs;</span><br><span class="line">  dhcp_set_state(dhcp, DHCP_REQUESTING);  <span class="comment">//请求状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造请求报文，填充选项字段，并广播出去。</span></span><br><span class="line">  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);</span><br><span class="line">  <span class="keyword">if</span> (result == ERR_OK) &#123;</span><br><span class="line">    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);</span><br><span class="line">    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));</span><br><span class="line"></span><br><span class="line">    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//将offer的ip地址填入“ 请求的IP地址 ”选项</span></span><br><span class="line">    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&amp;dhcp-&gt;offered_ip_addr)));</span><br><span class="line"></span><br><span class="line">    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//将服务器地址填入</span></span><br><span class="line">    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&amp;dhcp-&gt;server_ip_addr)));</span><br><span class="line"></span><br><span class="line">    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, <span class="number">4</span><span class="comment">/*num options*/</span>);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);</span><br><span class="line">    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);</span><br><span class="line"></span><br><span class="line">    dhcp_option_trailer(dhcp);</span><br><span class="line">    pbuf_realloc(dhcp-&gt;p_out, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dhcp_msg) - DHCP_OPTIONS_LEN + dhcp-&gt;options_out_len);</span><br><span class="line">	<span class="comment">//通过网口将请求报文广播，等待服务器的ack</span></span><br><span class="line">    udp_sendto_if(dhcp-&gt;pcb, dhcp-&gt;p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);</span><br><span class="line">    dhcp_delete_msg(dhcp);	<span class="comment">//删除报文</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  dhcp-&gt;tries++;	<span class="comment">//重试次数+1</span></span><br><span class="line">  msecs = (dhcp-&gt;tries &lt; <span class="number">6</span> ? <span class="number">1</span> &lt;&lt; dhcp-&gt;tries : <span class="number">60</span>) * <span class="number">1000</span>;</span><br><span class="line">  dhcp-&gt;request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - <span class="number">1</span>) / DHCP_FINE_TIMER_MSECS;	<span class="comment">//计算超时时间</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="b，等待ack"><a href="#b，等待ack" class="headerlink" title="b，等待ack"></a>b，等待ack</h4><p><strong>接收到服务器返回的ack报文后，提取报文中的时间，ip地址信息到dhcp客户端，并由此更新dhcp的超时时间，最后设置与dhcp对应的网口的ip地址，掩码和网关，使能网口。到此，网口就有了一个属于自己的ip地址了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_handle_ack</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span> =</span> netif-&gt;dhcp;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//先将本地dhcp结构的两个变量清零</span></span><br><span class="line">  ip_addr_set_zero(&amp;dhcp-&gt;offered_sn_mask);</span><br><span class="line">  ip_addr_set_zero(&amp;dhcp-&gt;offered_gw_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下都是根据ack报文的内来给dhcp客户端的变量赋值</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) &#123;</span><br><span class="line">    <span class="comment">//更新租约时间</span></span><br><span class="line">    dhcp-&gt;offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) &#123;</span><br><span class="line">  	<span class="comment">//更新续约时间</span></span><br><span class="line">    dhcp-&gt;offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则，计算续约时间</span></span><br><span class="line">    dhcp-&gt;offered_t1_renew = dhcp-&gt;offered_t0_lease / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) &#123;</span><br><span class="line">    dhcp-&gt;offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dhcp-&gt;offered_t2_rebind = dhcp-&gt;offered_t0_lease;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复制服务器提供的ip到dhcp客户端</span></span><br><span class="line">  ip_addr_copy(dhcp-&gt;offered_ip_addr, dhcp-&gt;msg_in-&gt;yiaddr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取子网掩码字段</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) &#123;</span><br><span class="line">    <span class="comment">//复制子网掩码到dhcp</span></span><br><span class="line">    ip4_addr_set_u32(&amp;dhcp-&gt;offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));</span><br><span class="line">    dhcp-&gt;subnet_mask_given = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dhcp-&gt;subnet_mask_given = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取网关字段</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) &#123;</span><br><span class="line">    ip4_addr_set_u32(&amp;dhcp-&gt;offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dhcp_bind</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u32_t</span> timeout;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dhcp</span> *<span class="title">dhcp</span>;</span></span><br><span class="line">  <span class="type">ip_addr_t</span> sn_mask, gw_addr;</span><br><span class="line">  dhcp = netif-&gt;dhcp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由ack报文提供的租约时间 更新dhcp客户端的超时时间</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp-&gt;offered_t1_renew != <span class="number">0xffffffffU</span>L) &#123;</span><br><span class="line">    timeout = (dhcp-&gt;offered_t1_renew + DHCP_COARSE_TIMER_SECS / <span class="number">2</span>) / DHCP_COARSE_TIMER_SECS;</span><br><span class="line">    <span class="keyword">if</span>(timeout &gt; <span class="number">0xffff</span>) &#123;</span><br><span class="line">      timeout = <span class="number">0xffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dhcp-&gt;t1_timeout = (<span class="type">u16_t</span>)timeout;</span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;t1_timeout == <span class="number">0</span>) &#123;</span><br><span class="line">      dhcp-&gt;t1_timeout = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dhcp-&gt;offered_t2_rebind != <span class="number">0xffffffffU</span>L) &#123;</span><br><span class="line">    timeout = (dhcp-&gt;offered_t2_rebind + DHCP_COARSE_TIMER_SECS / <span class="number">2</span>) / DHCP_COARSE_TIMER_SECS;</span><br><span class="line">    <span class="keyword">if</span>(timeout &gt; <span class="number">0xffff</span>) &#123;</span><br><span class="line">      timeout = <span class="number">0xffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dhcp-&gt;t2_timeout = (<span class="type">u16_t</span>)timeout;</span><br><span class="line">    <span class="keyword">if</span> (dhcp-&gt;t2_timeout == <span class="number">0</span>) &#123;</span><br><span class="line">      dhcp-&gt;t2_timeout = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取子网掩码</span></span><br><span class="line">  <span class="keyword">if</span> (dhcp-&gt;subnet_mask_given) &#123;</span><br><span class="line">    ip_addr_copy(sn_mask, dhcp-&gt;offered_sn_mask);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//无提供掩码</span></span><br><span class="line">    <span class="type">u8_t</span> first_octet = ip4_addr1(&amp;dhcp-&gt;offered_ip_addr);</span><br><span class="line">    <span class="keyword">if</span> (first_octet &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">      ip4_addr_set_u32(&amp;sn_mask, PP_HTONL(<span class="number">0xff000000U</span>L));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first_octet &gt;= <span class="number">192</span>) &#123;</span><br><span class="line">      ip4_addr_set_u32(&amp;sn_mask, PP_HTONL(<span class="number">0xffffff00U</span>L));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ip4_addr_set_u32(&amp;sn_mask, PP_HTONL(<span class="number">0xffff0000U</span>L));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取网关地址</span></span><br><span class="line">  ip_addr_copy(gw_addr, dhcp-&gt;offered_gw_addr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isany(&amp;gw_addr)) &#123;</span><br><span class="line">	<span class="comment">//无提供网关，则将网络的第一个主机作为网关</span></span><br><span class="line">    ip_addr_get_network(&amp;gw_addr, &amp;dhcp-&gt;offered_ip_addr, &amp;sn_mask);</span><br><span class="line">    ip4_addr_set_u32(&amp;gw_addr, ip4_addr_get_u32(&amp;gw_addr) | PP_HTONL(<span class="number">0x00000001U</span>L));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新网口的ip，子网掩码，网关为dhcp获取到的</span></span><br><span class="line">  netif_set_ipaddr(netif, &amp;dhcp-&gt;offered_ip_addr);</span><br><span class="line">  netif_set_netmask(netif, &amp;sn_mask);</span><br><span class="line">  netif_set_gw(netif, &amp;gw_addr);</span><br><span class="line">  netif_set_up(netif);  <span class="comment">//使能网口</span></span><br><span class="line"></span><br><span class="line">  dhcp_set_state(dhcp, DHCP_BOUND); <span class="comment">//绑定状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-其他情况"><a href="#2-4-其他情况" class="headerlink" title="2.4 其他情况"></a>2.4 其他情况</h3><p>剩下的情况包括租约时间的更新，重新绑定等，这些与时间相关的代码，<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/114077628">下一章，定时器</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_dhcp_impl_1/" data-id="cmbcy7rhw003dt8mth3zl73jp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_TCP_data_in_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p><strong>在上一章输入的tcp报文在找到了其对应的TCP控制块后，需要根据tcp控制块的不同状态，对报文有不同的处理方式。这将可能导致tcp状态的变化，使用tcp状态机来表示这样状态变化。</strong></p>
<p><img src="/20201218133150202.png" alt="在这里插入图片描述"><br>（图侵删）<br><strong>再结合tcp连接和断开的过程了解tcp状态机</strong></p>
<p><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二，源码分析"><a href="#二，源码分析" class="headerlink" title="二，源码分析"></a>二，源码分析</h2><p>tcp状态机的源码就是上图状态机的实现；<br>首先是处理rst，若输入报文是rst报文，则判断该rst合不合法，合法则复位tcp连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------优先处理rst报文----------------------------------------*/</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; TCP_RST) &#123;  <span class="comment">//报文中带rst标志</span></span><br><span class="line"> <span class="keyword">if</span> (pcb-&gt;state == SYN_SENT) &#123; <span class="comment">//连接建立过程中，判断ackno来识别一个rst是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (ackno == pcb-&gt;snd_nxt) &#123;</span><br><span class="line">      <span class="comment">//连接建立过程。应答序号等于下一个要发送的序号，是正确的</span></span><br><span class="line">      acceptable = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他状态的tcp需要检查报文的序号以判断rst是否合法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//报文序号等于期待接收的序号时，pcb复位</span></span><br><span class="line">    <span class="keyword">if</span> (seqno == pcb-&gt;rcv_nxt) &#123;</span><br><span class="line">      acceptable = <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (TCP_SEQ_BETWEEN(seqno, pcb-&gt;rcv_nxt,</span><br><span class="line">                                pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd)) &#123;</span><br><span class="line">      <span class="comment">//如果序号是在接收窗口内，则发送ack，等待回复重新检查报文序号</span></span><br><span class="line">      tcp_ack_now(pcb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (acceptable) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_process: Connection RESET\n&quot;</span>));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;state != CLOSED&quot;</span>, pcb-&gt;state != CLOSED);</span><br><span class="line">    recv_flags |= TF_RESET; <span class="comment">//process处理结果标志为复位</span></span><br><span class="line">    pcb-&gt;flags &amp;= ~TF_ACK_DELAY;  <span class="comment">//清除ack</span></span><br><span class="line">    <span class="keyword">return</span> ERR_RST;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//不需要复位，忽略rst报文</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_process: unacceptable reset seqno %&quot;</span>U32_F<span class="string">&quot; rcv_nxt %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">     seqno, pcb-&gt;rcv_nxt));</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_process: unacceptable reset seqno %&quot;</span>U32_F<span class="string">&quot; rcv_nxt %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">     seqno, pcb-&gt;rcv_nxt));</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本地不处于SYN_SENT或SYN_RCVD，却收到了SYN，是异常情况，可能是对方重启了</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; TCP_SYN) &amp;&amp; (pcb-&gt;state != SYN_SENT &amp;&amp; pcb-&gt;state != SYN_RCVD)) &#123;</span><br><span class="line">  <span class="comment">/* Cope with new connection attempt after remote end crashed */</span></span><br><span class="line">  <span class="comment">//应对远程端崩溃后的新连接尝试。</span></span><br><span class="line">  tcp_ack_now(pcb);</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果本地接收未关闭，就复位保活计时器</span></span><br><span class="line"><span class="keyword">if</span> ((pcb-&gt;flags &amp; TF_RXCLOSED) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">/* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */</span></span><br><span class="line">  pcb-&gt;tmr = tcp_ticks; </span><br><span class="line">&#125;</span><br><span class="line">pcb-&gt;keep_cnt_sent = <span class="number">0</span>; <span class="comment">//清除保活计数值</span></span><br><span class="line"></span><br><span class="line">tcp_parseopt(pcb);  <span class="comment">//解析出mss</span></span><br></pre></td></tr></table></figure>
<p><strong>现在进入状态机的具体代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">switch</span> (pcb-&gt;state) &#123;</span><br><span class="line">  <span class="comment">/*--------------------------------客户端发起连接请求等待服务器返回syn和ack----------------------------------------*/</span></span><br><span class="line">  <span class="keyword">case</span> SYN_SENT:  </span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;SYN-SENT: ackno %&quot;</span>U32_F<span class="string">&quot; pcb-&gt;snd_nxt %&quot;</span>U32_F<span class="string">&quot; unacked %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>, ackno,</span><br><span class="line">     pcb-&gt;snd_nxt, lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报文是ack和syn，且序号能对的上，则发送ack，并进入连接建立状态</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TCP_ACK) &amp;&amp; (flags &amp; TCP_SYN)</span><br><span class="line">        &amp;&amp; (ackno == pcb-&gt;lastack + <span class="number">1</span>)) &#123;</span><br><span class="line">      pcb-&gt;rcv_nxt = seqno + <span class="number">1</span>;</span><br><span class="line">      pcb-&gt;rcv_ann_right_edge = pcb-&gt;rcv_nxt;<span class="comment">//?不晓得</span></span><br><span class="line">      pcb-&gt;lastack = ackno;</span><br><span class="line">      pcb-&gt;snd_wnd = tcphdr-&gt;wnd; <span class="comment">//本地发送窗口为对方的通告窗口大小</span></span><br><span class="line">      pcb-&gt;snd_wnd_max = pcb-&gt;snd_wnd;</span><br><span class="line">      pcb-&gt;snd_wl1 = seqno - <span class="number">1</span>; <span class="comment">//上次更新时序号</span></span><br><span class="line">      pcb-&gt;state = ESTABLISHED;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//计算ip路径下的mss</span></span><br><span class="line">      pcb-&gt;mss = tcp_eff_send_mss(pcb-&gt;mss, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip);</span><br><span class="line"></span><br><span class="line">      pcb-&gt;cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb-&gt;mss); <span class="comment">//初始化拥塞窗口</span></span><br><span class="line">      LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_process (SENT): cwnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                   <span class="string">&quot; ssthresh %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                   pcb-&gt;cwnd, pcb-&gt;ssthresh));</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pcb-&gt;snd_queuelen &gt; 0&quot;</span>, (pcb-&gt;snd_queuelen &gt; <span class="number">0</span>));</span><br><span class="line">      --pcb-&gt;snd_queuelen;  <span class="comment">//发送报文队列减1</span></span><br><span class="line">      LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;tcp_process: SYN-SENT --queuelen %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//既然收到了ack，那么就将unack队列的第一个报文删除</span></span><br><span class="line">      rseg = pcb-&gt;unacked;</span><br><span class="line">      <span class="comment">//lwip将重传定时到的unacked放到了unsent，所以unacked的报文可能被放到了unsent</span></span><br><span class="line">      <span class="keyword">if</span> (rseg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rseg = pcb-&gt;unsent;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;no segment to free&quot;</span>, rseg != <span class="literal">NULL</span>);</span><br><span class="line">        pcb-&gt;unsent = rseg-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pcb-&gt;unacked = rseg-&gt;next;  <span class="comment">//重新组织unacked</span></span><br><span class="line">      &#125;</span><br><span class="line">      tcp_seg_free(rseg); <span class="comment">//释放被acked的报文</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果接下来没有需要应答的报文，则关闭重传定时器，否则重置它</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pcb-&gt;rtime = <span class="number">-1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pcb-&gt;rtime = <span class="number">0</span>;</span><br><span class="line">        pcb-&gt;nrtx = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//回调连接建立函数</span></span><br><span class="line">      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);</span><br><span class="line">      <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_ABRT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//最后发送一个ack，三次握手结束</span></span><br><span class="line">      tcp_ack_now(pcb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只收到ack报文，可能是半连接</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; TCP_ACK) &#123;</span><br><span class="line">    	<span class="comment">//发送rst报文重新连接</span></span><br><span class="line">      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),</span><br><span class="line">        ip_current_src_addr(), tcphdr-&gt;dest, tcphdr-&gt;src);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//重传次数不超限制则立即重传，包括SYN</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;nrtx &lt; TCP_SYNMAXRTX) &#123;</span><br><span class="line">        pcb-&gt;rtime = <span class="number">0</span>;</span><br><span class="line">        tcp_rexmit_rto(pcb);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">/*------------------------------服务器收到SYN并发送完syn+ack，等待客户端回答-----------------------------------*/</span></span><br><span class="line">  <span class="keyword">case</span> SYN_RCVD:  </span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TCP_ACK) &#123;  <span class="comment">//报文是客户端的ack报文</span></span><br><span class="line">      <span class="keyword">if</span> (TCP_SEQ_BETWEEN(ackno, pcb-&gt;lastack+<span class="number">1</span>, pcb-&gt;snd_nxt)) &#123; <span class="comment">//确认序号在发送窗口的正确范围</span></span><br><span class="line">        pcb-&gt;state = ESTABLISHED; <span class="comment">//进入建立状态</span></span><br><span class="line">        LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;TCP connection established %&quot;</span>U16_F<span class="string">&quot; -&gt; %&quot;</span>U16_F<span class="string">&quot;.\n&quot;</span>, inseg.tcphdr-&gt;src, inseg.tcphdr-&gt;dest));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CALLBACK_API</span></span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;pcb-&gt;listener-&gt;accept != NULL&quot;</span>,</span><br><span class="line">          (pcb-&gt;listener == <span class="literal">NULL</span>) || (pcb-&gt;listener-&gt;accept != <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;listener == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     </span><br><span class="line">          err = ERR_VAL;  <span class="comment">//listen pcb可能已经被关闭了</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */</span></span></span><br><span class="line">        &#123;</span><br><span class="line">          tcp_backlog_accepted(pcb);  <span class="comment">//无操作</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//回调连接建立函数</span></span><br><span class="line">          TCP_EVENT_ACCEPT(pcb-&gt;listener, pcb, pcb-&gt;callback_arg, ERR_OK, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果回调函数返回错误，或者listen pcb已经被关闭，则终止tcp</span></span><br><span class="line">        <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err != ERR_ABRT) &#123;</span><br><span class="line">            tcp_abort(pcb);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ERR_ABRT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//报文中还有其他的数据，则交给应用层处理</span></span><br><span class="line">        tcp_receive(pcb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果本地发送的数据被报文中的ack确认，则实际acked-1，因为syn占一个字节</span></span><br><span class="line">        <span class="keyword">if</span> (recv_acked != <span class="number">0</span>) &#123;</span><br><span class="line">          recv_acked--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pcb-&gt;cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb-&gt;mss); <span class="comment">//设置阻塞窗口</span></span><br><span class="line">        LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_process (SYN_RCVD): cwnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                     <span class="string">&quot; ssthresh %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                     pcb-&gt;cwnd, pcb-&gt;ssthresh));</span><br><span class="line">        <span class="comment">//如果有fin标志，则回答，并进入closewait，等待应用程序</span></span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;</span><br><span class="line">          tcp_ack_now(pcb);</span><br><span class="line">          pcb-&gt;state = CLOSE_WAIT;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//非法的ack确认序号，发送rst</span></span><br><span class="line">        </span><br><span class="line">        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),</span><br><span class="line">          ip_current_src_addr(), tcphdr-&gt;dest, tcphdr-&gt;src);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; TCP_SYN) &amp;&amp; (seqno == pcb-&gt;rcv_nxt - <span class="number">1</span>)) &#123;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">//收到对方重复的syn，说明服务器发出的syn+ack丢失，重发</span></span><br><span class="line">      tcp_rexmit(pcb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CLOSE_WAIT:  <span class="comment">//服务器不会接收数据</span></span><br><span class="line">    <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">  <span class="keyword">case</span> ESTABLISHED: <span class="comment">//已经建立连接</span></span><br><span class="line">    tcp_receive(pcb); <span class="comment">//将数据交给上层</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//被动关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123; <span class="comment">/* passive close */</span></span><br><span class="line">      tcp_ack_now(pcb);</span><br><span class="line">      pcb-&gt;state = CLOSE_WAIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">/*------------------------------------客户端发送断开请求，等待回答-----------------------------------*/</span></span><br><span class="line">  <span class="keyword">case</span> FIN_WAIT_1:  </span><br><span class="line">    tcp_receive(pcb); <span class="comment">//将数据交给上层</span></span><br><span class="line">    <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;  <span class="comment">//收到服务器的断开请求</span></span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; TCP_ACK) &amp;&amp; (ackno == pcb-&gt;snd_nxt) &amp;&amp; <span class="comment">//同时收到本地FIN的ack，且本地没有未发送的数据，跳过wait2，进入timewait</span></span><br><span class="line">          pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_DEBUG,</span><br><span class="line">          (<span class="string">&quot;TCP connection closed: FIN_WAIT_1 %&quot;</span>U16_F<span class="string">&quot; -&gt; %&quot;</span>U16_F<span class="string">&quot;.\n&quot;</span>, inseg.tcphdr-&gt;src, inseg.tcphdr-&gt;dest));</span><br><span class="line">        tcp_ack_now(pcb); <span class="comment">//发送ack</span></span><br><span class="line">        tcp_pcb_purge(pcb); <span class="comment">//释放pcb</span></span><br><span class="line">        TCP_RMV_ACTIVE(pcb);  <span class="comment">//移除链表</span></span><br><span class="line">        pcb-&gt;state = TIME_WAIT;</span><br><span class="line">        TCP_REG(&amp;tcp_tw_pcbs, pcb); <span class="comment">//进入新的链表</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//异常情况，可能是双方同时发起断开</span></span><br><span class="line">        tcp_ack_now(pcb);</span><br><span class="line">        pcb-&gt;state = CLOSING;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; TCP_ACK) &amp;&amp; (ackno == pcb-&gt;snd_nxt) &amp;&amp;</span><br><span class="line">               pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      pcb-&gt;state = FIN_WAIT_2;  <span class="comment">//收到ack，进入FIN_WAIT_2，等待服务器的FIN</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">/*----------------------------------客户端已经发送断开连接，等待服务端应用程序断开----------------------*/</span></span><br><span class="line">  <span class="keyword">case</span> FIN_WAIT_2:</span><br><span class="line">    tcp_receive(pcb); <span class="comment">//将数据交给上层</span></span><br><span class="line">    <span class="comment">//收到服务器的断开请求，回答</span></span><br><span class="line">    <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;  </span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;TCP connection closed: FIN_WAIT_2 %&quot;</span>U16_F<span class="string">&quot; -&gt; %&quot;</span>U16_F<span class="string">&quot;.\n&quot;</span>, inseg.tcphdr-&gt;src, inseg.tcphdr-&gt;dest));</span><br><span class="line">      tcp_ack_now(pcb);</span><br><span class="line">      tcp_pcb_purge(pcb);</span><br><span class="line">      TCP_RMV_ACTIVE(pcb);</span><br><span class="line">      pcb-&gt;state = TIME_WAIT;</span><br><span class="line">      TCP_REG(&amp;tcp_tw_pcbs, pcb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CLOSING: <span class="comment">//两端同时关闭连接</span></span><br><span class="line">    tcp_receive(pcb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到了对方的ack且没有未发送的数据，进入TIME_WAIT</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TCP_ACK) &amp;&amp; ackno == pcb-&gt;snd_nxt &amp;&amp; pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;TCP connection closed: CLOSING %&quot;</span>U16_F<span class="string">&quot; -&gt; %&quot;</span>U16_F<span class="string">&quot;.\n&quot;</span>, inseg.tcphdr-&gt;src, inseg.tcphdr-&gt;dest));</span><br><span class="line">      tcp_pcb_purge(pcb);</span><br><span class="line">      TCP_RMV_ACTIVE(pcb);</span><br><span class="line">      pcb-&gt;state = TIME_WAIT;</span><br><span class="line">      TCP_REG(&amp;tcp_tw_pcbs, pcb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LAST_ACK:  <span class="comment">//服务器上层处理完，发送断开请求，等待对方回答</span></span><br><span class="line">    tcp_receive(pcb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到了对方的ack且没有未发送的数据，结束tcp一生</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TCP_ACK) &amp;&amp; ackno == pcb-&gt;snd_nxt &amp;&amp; pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;TCP connection closed: LAST_ACK %&quot;</span>U16_F<span class="string">&quot; -&gt; %&quot;</span>U16_F<span class="string">&quot;.\n&quot;</span>, inseg.tcphdr-&gt;src, inseg.tcphdr-&gt;dest));</span><br><span class="line"></span><br><span class="line">      recv_flags |= TF_CLOSED;  <span class="comment">//tcp_input会对tcp进一步释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见tcp状态机完成的主要还是tcp状态之间的转换的逻辑。而真正的tcp报文里的数据则交给了<code>tcp_receive()</code>，该函数检查tcp报文数据，并将有序的数据传递给应用层。<br><img src="/20201218134515386.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_2/" data-id="cmbcy7rhu0035t8mt8jsncd0i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_TCP_data_in_3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_3/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>一个有着接近900行代码的函数，庞大的函数，需要我们有庖丁解牛的耐心</p>
</blockquote>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p><code>tcp_receive(struct tcp_pcb *pcb)</code>是tcp数据输入的末端。在之前的tcp_process()函数中，对输入tcp报文已经确定了其对应的tcp控制块。</p>
<p>该实现了tcp通信中的滑动窗口，快速重传与恢复，拥塞控制算法，对无序报文的处理等。并将有效数据传递给应用层。</p>
<p>这个函数必须分成以下几个步骤来解。</p>
<h2 id="二，代码流程"><a href="#二，代码流程" class="headerlink" title="二，代码流程"></a>二，代码流程</h2><h3 id="1，更新发送窗口"><a href="#1，更新发送窗口" class="headerlink" title="1，更新发送窗口"></a>1，更新发送窗口</h3><p>由于接收到对方的报文中会有ackno确认序号，所以根据ackno和通告窗口anno_wnd可更新本地接收窗口的大小。当遇到0窗口通告时，还要开启坚持定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地发送窗口的右边界=上次窗口更新时的确认序号+当前发送窗口大小</span></span><br><span class="line">right_wnd_edge = pcb-&gt;snd_wnd + pcb-&gt;snd_wl2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//snd_wl1 = last seqno</span></span><br><span class="line"><span class="comment">//snd_wl2 = last ackno</span></span><br><span class="line"><span class="comment">//更新窗口三个条件：</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SEQ_LT(pcb-&gt;snd_wl1, seqno) ||  <span class="comment">//对方有发送新的数据</span></span><br><span class="line">   (pcb-&gt;snd_wl1 == seqno &amp;&amp; TCP_SEQ_LT(pcb-&gt;snd_wl2, ackno)) ||  <span class="comment">//对方无发送新的数据但接收到我方发出的数据</span></span><br><span class="line">   (pcb-&gt;snd_wl2 == ackno &amp;&amp; (<span class="type">u32_t</span>)SND_WND_SCALE(pcb, tcphdr-&gt;wnd) &gt; pcb-&gt;snd_wnd)) &#123;  <span class="comment">//无收到我方的新数据且，通告对方接收窗口大于我方发送窗口</span></span><br><span class="line">  pcb-&gt;snd_wnd = SND_WND_SCALE(pcb, tcphdr-&gt;wnd); <span class="comment">//根据通告窗口设置发送窗口</span></span><br><span class="line">  <span class="comment">//限制发送窗口</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_wnd_max &lt; pcb-&gt;snd_wnd) &#123;</span><br><span class="line">    pcb-&gt;snd_wnd_max = pcb-&gt;snd_wnd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新发送窗口的参数</span></span><br><span class="line">  pcb-&gt;snd_wl1 = seqno;</span><br><span class="line">  pcb-&gt;snd_wl2 = ackno;</span><br><span class="line">  <span class="comment">//如果发送窗口为0，即通告窗口是0，需要开启坚持定时器</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_wnd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_backoff == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* start persist timer */</span></span><br><span class="line">      pcb-&gt;persist_cnt = <span class="number">0</span>;</span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pcb-&gt;persist_backoff &gt; <span class="number">0</span>) &#123;  <span class="comment">//否则停止坚持定时器</span></span><br><span class="line">    </span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，快速重传与恢复"><a href="#2，快速重传与恢复" class="headerlink" title="2，快速重传与恢复"></a>2，快速重传与恢复</h3><p>通过检查ackno与上一次更新的ackno是否一致等条件，判断是否需要开启快速重传。退出快重传后，进入快恢复，更新重传参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!快速重传实现原理（当重复确认超过三次则认为需要启动快速重传）</span></span><br><span class="line"><span class="comment">//ackno&lt;lastack，没有确认新数据</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SEQ_LEQ(ackno, pcb-&gt;lastack)) &#123; <span class="comment">//</span></span><br><span class="line">  <span class="comment">/* Clause 2 */</span></span><br><span class="line">  <span class="keyword">if</span> (tcplen == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">/* Clause 3 */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;snd_wl2 + pcb-&gt;snd_wnd == right_wnd_edge) &#123;  <span class="comment">//通告窗口大小没变</span></span><br><span class="line">      <span class="comment">/* Clause 4 */</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;rtime &gt;= <span class="number">0</span>) &#123;  <span class="comment">//重传定时器开启，有数据等待确认</span></span><br><span class="line">        <span class="comment">/* Clause 5 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;lastack == ackno) &#123;  <span class="comment">//确认号等于最高确认号</span></span><br><span class="line">          <span class="comment">//当这里说明该ack是一个空的ack，在重复的确认某一个序号，而发送方同时有数据未被ack，说明之前报文可能丢失</span></span><br><span class="line">          found_dupack = <span class="number">1</span>; <span class="comment">//出现了重复的ack</span></span><br><span class="line">          <span class="comment">//dupacks变量加1同时防止value overflows</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">u8_t</span>)(pcb-&gt;dupacks + <span class="number">1</span>) &gt; pcb-&gt;dupacks) &#123;</span><br><span class="line">            ++pcb-&gt;dupacks;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果重复确认超过3次，可能是报文丢失了</span></span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;dupacks &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">tcpwnd_size_t</span>)(pcb-&gt;cwnd + pcb-&gt;mss) &gt; pcb-&gt;cwnd) &#123;</span><br><span class="line">              pcb-&gt;cwnd += pcb-&gt;mss;<span class="comment">//拥塞窗口增加一个报文段大小</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pcb-&gt;dupacks == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">//执行快速重传丢失报文，初始化cwnd和ssthresh</span></span><br><span class="line">            tcp_rexmit_fast(pcb);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*-------------------------------快速重传算法------------------------------------*/</span></span><br><span class="line">  <span class="comment">//不是重复ack</span></span><br><span class="line">  <span class="keyword">if</span> (!found_dupack) &#123;  </span><br><span class="line">    pcb-&gt;dupacks = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (TCP_SEQ_BETWEEN(ackno, pcb-&gt;lastack+<span class="number">1</span>, pcb-&gt;snd_nxt)) &#123;  <span class="comment">//ackno在last_ack和snd_nxt之间,正确</span></span><br><span class="line">  <span class="comment">//!若tcp处于快速重传，则退出，设置cwnd为ssthresh，这就是快恢复算法</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_INFR) &#123;</span><br><span class="line">    pcb-&gt;flags &amp;= ~TF_INFR;</span><br><span class="line">    pcb-&gt;cwnd = pcb-&gt;ssthresh;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正确的接收到数据，更新重传的参数</span></span><br><span class="line">  pcb-&gt;nrtx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pcb-&gt;rto = (pcb-&gt;sa &gt;&gt; <span class="number">3</span>) + pcb-&gt;sv;</span><br><span class="line">  pcb-&gt;dupacks = <span class="number">0</span>;</span><br><span class="line">  pcb-&gt;lastack = ackno;</span><br></pre></td></tr></table></figure>
<h3 id="3，拥塞控制算法"><a href="#3，拥塞控制算法" class="headerlink" title="3，拥塞控制算法"></a>3，拥塞控制算法</h3><p>根据cwnd与ssthresh的大小，调节cwnd的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------- 拥塞控制算法 ------------------------------------------*/</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state &gt;= ESTABLISHED) &#123;</span><br><span class="line">  <span class="comment">//!慢启动算法cwnd&lt;ssthresh cwnd增加一个报文段大小</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;cwnd &lt; pcb-&gt;ssthresh) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">tcpwnd_size_t</span>)(pcb-&gt;cwnd + pcb-&gt;mss) &gt; pcb-&gt;cwnd) &#123;</span><br><span class="line">      pcb-&gt;cwnd += pcb-&gt;mss;</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_receive: slow start cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>, pcb-&gt;cwnd));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//!拥塞避免算法</span></span><br><span class="line">    <span class="type">tcpwnd_size_t</span> new_cwnd = (pcb-&gt;cwnd + pcb-&gt;mss * pcb-&gt;mss / pcb-&gt;cwnd);</span><br><span class="line">    <span class="keyword">if</span> (new_cwnd &gt; pcb-&gt;cwnd) &#123;</span><br><span class="line">      pcb-&gt;cwnd = new_cwnd;</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_receive: congestion avoidance cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>, pcb-&gt;cwnd));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: ACK for %&quot;</span>U32_F<span class="string">&quot;, unacked-&gt;seqno %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                              ackno,</span><br><span class="line">                              pcb-&gt;unacked != <span class="literal">NULL</span>?</span><br><span class="line">                              lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno): <span class="number">0</span>,</span><br><span class="line">                              pcb-&gt;unacked != <span class="literal">NULL</span>?</span><br><span class="line">                              lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(pcb-&gt;unacked): <span class="number">0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4，更新unacked队列"><a href="#4，更新unacked队列" class="headerlink" title="4，更新unacked队列"></a>4，更新unacked队列</h3><p>由于收到了新的acked，unacked队列就要更新，删除掉被ack的报文，检查是否还有未ack的报文，决定是否开启重传定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将unacked队列中已经确认的报文删除</span></span><br><span class="line"><span class="keyword">while</span> (pcb-&gt;unacked != <span class="literal">NULL</span> &amp;&amp;  <span class="comment">//有未确认的报文</span></span><br><span class="line">       TCP_SEQ_LEQ(lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) +  <span class="comment">//unacked报文尾的序号小于输入报文确认序号？</span></span><br><span class="line">                   TCP_TCPLEN(pcb-&gt;unacked), ackno)) &#123;</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: removing %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot; from pcb-&gt;unacked\n&quot;</span>,</span><br><span class="line">                                lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno),</span><br><span class="line">                                lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">                                TCP_TCPLEN(pcb-&gt;unacked)));</span><br><span class="line">  <span class="comment">//找到被确认的报文：</span></span><br><span class="line">  next = pcb-&gt;unacked;</span><br><span class="line">  pcb-&gt;unacked = pcb-&gt;unacked-&gt;next;  <span class="comment">//下一个检查的unacked报文</span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;tcp_receive: queuelen %&quot;</span>TCPWNDSIZE_F<span class="string">&quot; ... &quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)&quot;</span>, (pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)));</span><br><span class="line"></span><br><span class="line">  pcb-&gt;snd_queuelen -= pbuf_clen(next-&gt;p);    <span class="comment">//因为lwip中未确认队列中的报文被放在了unsent队列中</span></span><br><span class="line"></span><br><span class="line">  recv_acked += next-&gt;len;  <span class="comment">//确认数据增加next-&gt;len</span></span><br><span class="line">  tcp_seg_free(next); <span class="comment">//删除该报文</span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;%&quot;</span>TCPWNDSIZE_F<span class="string">&quot; (after freeing unacked)\n&quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_queuelen != <span class="number">0</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_receive: valid queue length&quot;</span>, pcb-&gt;unacked != <span class="literal">NULL</span> ||</span><br><span class="line">                pcb-&gt;unsent != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若没有等待确认的报文，则关闭重传定时</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  pcb-&gt;rtime = <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pcb-&gt;rtime = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pcb-&gt;polltmr = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5，更新unsent队列"><a href="#5，更新unsent队列" class="headerlink" title="5，更新unsent队列"></a>5，更新unsent队列</h3><p>由于lwip将unacked队列中的部分报文放到unsent队列的首部，所以也要检查unsent对列中被确认的报文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于lwip将超时且需要重传的报文放到了unsent队列，所以需要在unsent中检查\</span></span><br><span class="line"><span class="comment">  是否有的报文已经被确认，代码与以上相似</span></span><br><span class="line"><span class="keyword">while</span> (pcb-&gt;unsent != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">       TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb-&gt;unsent-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">                       TCP_TCPLEN(pcb-&gt;unsent), pcb-&gt;snd_nxt)) &#123;</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: removing %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot; from pcb-&gt;unsent\n&quot;</span>,</span><br><span class="line">                                lwip_ntohl(pcb-&gt;unsent-&gt;tcphdr-&gt;seqno), lwip_ntohl(pcb-&gt;unsent-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">                                TCP_TCPLEN(pcb-&gt;unsent)));</span><br><span class="line">  <span class="comment">//找到已经被确认的报文：</span></span><br><span class="line">  next = pcb-&gt;unsent;</span><br><span class="line">  pcb-&gt;unsent = pcb-&gt;unsent-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pcb-&gt;unsent_oversize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;tcp_receive: queuelen %&quot;</span>TCPWNDSIZE_F<span class="string">&quot; ... &quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)&quot;</span>, (pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)));</span><br><span class="line">  </span><br><span class="line">  pcb-&gt;snd_queuelen -= pbuf_clen(next-&gt;p);</span><br><span class="line">  recv_acked += next-&gt;len;</span><br><span class="line">  tcp_seg_free(next);</span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;%&quot;</span>TCPWNDSIZE_F<span class="string">&quot; (after freeing unsent)\n&quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_queuelen != <span class="number">0</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_receive: valid queue length&quot;</span>,</span><br><span class="line">      pcb-&gt;unacked != <span class="literal">NULL</span> || pcb-&gt;unsent != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6，rtt测试"><a href="#6，rtt测试" class="headerlink" title="6，rtt测试"></a>6，rtt测试</h3><p>若接收的ackno大于用于rtt测试的序号，则可进行rto的计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//TODO pcb的rtt测试开启，且进行rtt测试的序号小于确认序号则可用计算rto，计算rto超时重传时间</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;rttest &amp;&amp; TCP_SEQ_LT(pcb-&gt;rtseq, ackno)) &#123; </span><br><span class="line">    m = (<span class="type">s16_t</span>)(tcp_ticks - pcb-&gt;rttest);</span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_receive: experienced rtt %&quot;</span>U16_F<span class="string">&quot; ticks (%&quot;</span>U16_F<span class="string">&quot; msec).\n&quot;</span>,</span><br><span class="line">                                m, (<span class="type">u16_t</span>)(m * TCP_SLOW_INTERVAL)));</span><br><span class="line">    m = m - (pcb-&gt;sa &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    pcb-&gt;sa += m;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      m = -m;</span><br><span class="line">    &#125;</span><br><span class="line">    m = m - (pcb-&gt;sv &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    pcb-&gt;sv += m;</span><br><span class="line">    pcb-&gt;rto = (pcb-&gt;sa &gt;&gt; <span class="number">3</span>) + pcb-&gt;sv;</span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_receive: RTO %&quot;</span>U16_F<span class="string">&quot; (%&quot;</span>U16_F<span class="string">&quot; milliseconds)\n&quot;</span>,</span><br><span class="line">                                pcb-&gt;rto, (<span class="type">u16_t</span>)(pcb-&gt;rto * TCP_SLOW_INTERVAL)));</span><br><span class="line"></span><br><span class="line">    pcb-&gt;rttest = <span class="number">0</span>;  <span class="comment">//关闭rtt测量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7，滑动窗口"><a href="#7，滑动窗口" class="headerlink" title="7，滑动窗口"></a>7，滑动窗口</h3><p>根据接收到的数据序号在接收窗口的不同位置，对不同位置的数据有不一样的裁剪：</p>
<h4 id="a，接收的数据一部分已经接受过，另一部分是新数据"><a href="#a，接收的数据一部分已经接受过，另一部分是新数据" class="headerlink" title="a，接收的数据一部分已经接受过，另一部分是新数据"></a>a，接收的数据一部分已经接受过，另一部分是新数据</h4><p>此时要把已经接收的部分丢弃，只保留新数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若期待接收的数据处于接收到的数据的中间\</span></span><br><span class="line"><span class="comment">/*------接收到的数据既有已经接受过的数据，也有新的数据，将输入数据从rcv_nxt截断，取rcv_nxt及其之后的新数据-----*/</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SEQ_BETWEEN(pcb-&gt;rcv_nxt, seqno + <span class="number">1</span>, seqno + tcplen - <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span> =</span> inseg.p; <span class="comment">//p是输入报文第一个pbuf</span></span><br><span class="line">  off = pcb-&gt;rcv_nxt - seqno; <span class="comment">//p中将要舍弃的数据的偏移 即payload向后移动的距离</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;inseg.p != NULL&quot;</span>, inseg.p);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;insane offset!&quot;</span>, (off &lt; <span class="number">0x7fff</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若输入报文的第一个pbuf里的数据都是应该舍弃的数据</span></span><br><span class="line">  <span class="keyword">if</span> (inseg.p-&gt;len &lt; off) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf too short!&quot;</span>, (((<span class="type">s32_t</span>)inseg.p-&gt;tot_len) &gt;= off));</span><br><span class="line">    new_tot_len = (<span class="type">u16_t</span>)(inseg.p-&gt;tot_len - off);  <span class="comment">//截取后的pbuf总长度</span></span><br><span class="line">    <span class="comment">//则找到recv_nxt所在那个pbuf，在这个pbuf之前的buffer都要被释放</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;len &lt; off) &#123;</span><br><span class="line">      off -= p-&gt;len;</span><br><span class="line">      <span class="comment">//!注意下面的注释，inseg.p-&gt;tot_len -= p-&gt;len;被注释是因为这些pbuf都将被释放</span></span><br><span class="line">      <span class="comment">/* KJM following line changed (with addition of new_tot_len var)</span></span><br><span class="line"><span class="comment">         to fix bug #9076</span></span><br><span class="line"><span class="comment">         inseg.p-&gt;tot_len -= p-&gt;len; */</span></span><br><span class="line">      p-&gt;tot_len = new_tot_len;</span><br><span class="line">      p-&gt;len = <span class="number">0</span>;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动输入报文的pbuf的payload指针到其recv_nxt所在的地址</span></span><br><span class="line">    <span class="keyword">if</span> (pbuf_header(p, (<span class="type">s16_t</span>)-off)) &#123;</span><br><span class="line">      <span class="comment">/* Do we need to cope with this failing?  Assert for now */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_header failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pbuf_header(inseg.p, (<span class="type">s16_t</span>)-off)) &#123;</span><br><span class="line">      <span class="comment">/* Do we need to cope with this failing?  Assert for now */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_header failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  inseg.len -= (<span class="type">u16_t</span>)(pcb-&gt;rcv_nxt - seqno); <span class="comment">//报文长度被减少了</span></span><br><span class="line">  inseg.tcphdr-&gt;seqno = seqno = pcb-&gt;rcv_nxt; <span class="comment">//tcp报文首部的序号页要改成截断后的序号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------接收到的数据既有已经接受过的数据，也有新的数据，将输入数据从rcv_nxt截断，取rcv_nxt及其之后的新数据-----*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//整个报文都是已接收的数据，回复ack即可</span></span><br><span class="line">  <span class="keyword">if</span> (TCP_SEQ_LT(seqno, pcb-&gt;rcv_nxt)) &#123;</span><br><span class="line">    <span class="comment">/* the whole segment is &lt; rcv_nxt */</span></span><br><span class="line">    <span class="comment">/* must be a duplicate of a packet that has already been correctly handled */</span></span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: duplicate seqno %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>, seqno));</span><br><span class="line">    tcp_ack_now(pcb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b，数据正好在接收窗口左边界"><a href="#b，数据正好在接收窗口左边界" class="headerlink" title="b，数据正好在接收窗口左边界"></a>b，数据正好在接收窗口左边界</h4><p>当数据长度超过窗口大小，则将超出部分丢弃。将报文插入osseq队列，若报文与osseq队列的内容重复，则将报文重复部分丢弃。将osseq队列的有序数据赋值给recv_data指针，上层应用通告该指针读取接收的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TCP_SEQ_BETWEEN(seqno, pcb-&gt;rcv_nxt,</span><br><span class="line">                    pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd - <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">//第一种情况：接收序号正好是期待接收的，说明数据与上次是连续的</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;rcv_nxt == seqno) &#123;</span><br><span class="line">    tcplen = TCP_TCPLEN(&amp;inseg);</span><br><span class="line">    <span class="comment">//报文内容大于接收窗口，将超过接收窗口部分的内容截掉</span></span><br><span class="line">    <span class="keyword">if</span> (tcplen &gt; pcb-&gt;rcv_wnd) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG,</span><br><span class="line">                  (<span class="string">&quot;tcp_receive: other end overran receive window&quot;</span></span><br><span class="line">                   <span class="string">&quot;seqno %&quot;</span>U32_F<span class="string">&quot; len %&quot;</span>U16_F<span class="string">&quot; right edge %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                   seqno, tcplen, pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">      <span class="comment">//!若输入报文中有fin，必须从报头中删除FIN，因为我们要修剪输入报文的数据</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">        <span class="comment">/* Must remove the FIN from the header as we&#x27;re trimming</span></span><br><span class="line"><span class="comment">         * that byte of sequence-space from the packet */</span></span><br><span class="line">        TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &amp; ~(<span class="type">unsigned</span> <span class="type">int</span>)TCP_FIN);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Adjust length of segment to fit in the window. */</span></span><br><span class="line">      TCPWND_CHECK16(pcb-&gt;rcv_wnd);</span><br><span class="line">      inseg.len = (<span class="type">u16_t</span>)pcb-&gt;rcv_wnd;  <span class="comment">//修剪后的报文大小就是窗口大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//若有syn标志，则报文长度-1</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_SYN) &#123;</span><br><span class="line">        inseg.len -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      pbuf_realloc(inseg.p, inseg.len); <span class="comment">//给报文的pbuf重新分配内存</span></span><br><span class="line">      tcplen = TCP_TCPLEN(&amp;inseg);  <span class="comment">//更新修剪后的报文大小</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_receive: segment not trimmed correctly to rcv_wnd\n&quot;</span>,</span><br><span class="line">                  (seqno + tcplen) == (pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*---------------------------------------根据接收窗口修建接收的报文长度-----------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//!现在接收的数据是正常排序的，先放到osseq队列首部，具体情况见p397第九点</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;ooseq != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//fin标志说明后续无数据来了，该报文段后的报文都要删除</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG,</span><br><span class="line">                    (<span class="string">&quot;tcp_receive: received in-order FIN, binning ooseq queue\n&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pcb-&gt;ooseq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">old_ooseq</span> =</span> pcb-&gt;ooseq;</span><br><span class="line">          pcb-&gt;ooseq = pcb-&gt;ooseq-&gt;next;</span><br><span class="line">          tcp_seg_free(old_ooseq);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">/*--------------------根据输入报文，修改osseq中的数据，修剪输入数据------------------------*/</span></span><br><span class="line">        next = pcb-&gt;ooseq;</span><br><span class="line">        <span class="comment">//!因为接收的数据与上一次接收的数据是连续的，以下情况的报文段是要删除</span></span><br><span class="line">        <span class="keyword">while</span> (next &amp;&amp;</span><br><span class="line">               TCP_SEQ_GEQ(seqno + tcplen,</span><br><span class="line">                           next-&gt;tcphdr-&gt;seqno + next-&gt;len)) &#123;</span><br><span class="line">          <span class="comment">/* inseg cannot have FIN here (already processed above) */</span></span><br><span class="line">          <span class="comment">/* 如果这些即将被删除的报文段带FIN标志且输入报文段不带SYN标志 */</span></span><br><span class="line">          <span class="keyword">if</span> ((TCPH_FLAGS(next-&gt;tcphdr) &amp; TCP_FIN) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">              (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_SYN) == <span class="number">0</span>) &#123;</span><br><span class="line">            TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN); <span class="comment">//在输入报文段的TCP头中添加FIN标志</span></span><br><span class="line">            tcplen = TCP_TCPLEN(&amp;inseg);  </span><br><span class="line">          &#125;</span><br><span class="line">          prev = next;</span><br><span class="line">          next = next-&gt;next;</span><br><span class="line">          tcp_seg_free(prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//!此时seqno在osseq是最小的序号</span></span><br><span class="line">        <span class="comment">/* Now trim right side of inseg if it overlaps with the first</span></span><br><span class="line"><span class="comment">         * segment on ooseq */</span></span><br><span class="line">        <span class="comment">//如果输入报文段与osseq中出现部分重叠，则删除输入报文段中重叠部分</span></span><br><span class="line">        <span class="keyword">if</span> (next &amp;&amp;</span><br><span class="line">            TCP_SEQ_GT(seqno + tcplen,</span><br><span class="line">                       next-&gt;tcphdr-&gt;seqno)) &#123;</span><br><span class="line">          <span class="comment">/* inseg cannot have FIN here (already processed above) */</span></span><br><span class="line">          inseg.len = (<span class="type">u16_t</span>)(next-&gt;tcphdr-&gt;seqno - seqno); <span class="comment">//得到输入报文中不重叠部分的长度</span></span><br><span class="line">          <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_SYN) &#123;</span><br><span class="line">            inseg.len -= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          pbuf_realloc(inseg.p, inseg.len); <span class="comment">//给输入报文段调整长度</span></span><br><span class="line">          tcplen = TCP_TCPLEN(&amp;inseg);  <span class="comment">//再次更新报文长度</span></span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;tcp_receive: segment not trimmed correctly to ooseq queue\n&quot;</span>,</span><br><span class="line">                      (seqno + tcplen) == next-&gt;tcphdr-&gt;seqno);</span><br><span class="line">        &#125;</span><br><span class="line">        pcb-&gt;ooseq = next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*--------------------根据输入报文，修改osseq中的数据，修剪输入数据------------------------*/</span></span><br><span class="line"></span><br><span class="line">    pcb-&gt;rcv_nxt = seqno + tcplen;  <span class="comment">//更新下一个期待收到的序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the receiver&#x27;s (our) window. */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_receive: tcplen &gt; rcv_wnd\n&quot;</span>, pcb-&gt;rcv_wnd &gt;= tcplen);</span><br><span class="line">    pcb-&gt;rcv_wnd -= tcplen; <span class="comment">//本地接收窗口变小</span></span><br><span class="line"></span><br><span class="line">    tcp_update_rcv_ann_wnd(pcb);  <span class="comment">//更新通告窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将输入报文段的数据上传给应用层</span></span><br><span class="line">    <span class="keyword">if</span> (inseg.p-&gt;tot_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      recv_data = inseg.p;</span><br><span class="line">      <span class="comment">/* Since this pbuf now is the responsibility of the</span></span><br><span class="line"><span class="comment">         application, we delete our reference to it so that we won&#x27;t</span></span><br><span class="line"><span class="comment">         (mistakingly) deallocate it. */</span></span><br><span class="line">      inseg.p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果报文段有fin标志</span></span><br><span class="line">    <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: received FIN.\n&quot;</span>));</span><br><span class="line">      recv_flags |= TF_GOT_FIN; <span class="comment">//给接收处理结果置位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------------------ooseq有序数据发送到应用层------------------------------------*/</span></span><br><span class="line">    <span class="comment">//(通过比较ooseq队列中报文段的seqno和当前TCP控制块中保存的rcv_nxt来判定该报文段是否有序) </span></span><br><span class="line">    <span class="keyword">while</span> (pcb-&gt;ooseq != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">           pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno == pcb-&gt;rcv_nxt) &#123;</span><br><span class="line"></span><br><span class="line">      cseg = pcb-&gt;ooseq;</span><br><span class="line">      seqno = pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno;</span><br><span class="line"></span><br><span class="line">      pcb-&gt;rcv_nxt += TCP_TCPLEN(cseg);</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_receive: ooseq tcplen &gt; rcv_wnd\n&quot;</span>,</span><br><span class="line">                  pcb-&gt;rcv_wnd &gt;= TCP_TCPLEN(cseg));</span><br><span class="line">      pcb-&gt;rcv_wnd -= TCP_TCPLEN(cseg);</span><br><span class="line"></span><br><span class="line">      tcp_update_rcv_ann_wnd(pcb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果该报文段有数据，则将数据连接到recv_data上，同时将报文的pbuf指针赋值为null</span></span><br><span class="line">      <span class="keyword">if</span> (cseg-&gt;p-&gt;tot_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Chain this pbuf onto the pbuf that we will pass to</span></span><br><span class="line"><span class="comment">           the application. */</span></span><br><span class="line">        <span class="comment">/* With window scaling, this can overflow recv_data-&gt;tot_len, but</span></span><br><span class="line"><span class="comment">           that&#x27;s not a problem since we explicitly fix that before passing</span></span><br><span class="line"><span class="comment">           recv_data to the application. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_data) &#123;</span><br><span class="line">          pbuf_cat(recv_data, cseg-&gt;p); <span class="comment">//将有序的pbuf拼接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recv_data = cseg-&gt;p;</span><br><span class="line">        &#125;</span><br><span class="line">        cseg-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若报文段中有fin标志，则设置处理结果，修改pcb的状态</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(cseg-&gt;tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: dequeued FIN.\n&quot;</span>));</span><br><span class="line">        recv_flags |= TF_GOT_FIN;</span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state == ESTABLISHED) &#123; <span class="comment">/* force passive close or we can move to active close */</span></span><br><span class="line">          pcb-&gt;state = CLOSE_WAIT;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pcb-&gt;ooseq = cseg-&gt;next;  <span class="comment">//处理下一个ooseq报文段</span></span><br><span class="line">      tcp_seg_free(cseg); <span class="comment">//释放被拼接的报文段</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="c，数据不在左边界"><a href="#c，数据不在左边界" class="headerlink" title="c，数据不在左边界"></a>c，数据不在左边界</h4><p>说明接收的数据不是有序到达的。则将该报文插入osseq队列。接下来的代码就是如何将报文正确的插入osseq队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!seqno!=recv-&gt;nxt 说明收到无序报文，将报文插入合适的位置</span></span><br><span class="line">tcp_send_empty_ack(pcb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;ooseq == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  pcb-&gt;ooseq = tcp_seg_copy(&amp;inseg);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/*-----------------------------------处理osseq无序报文-------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  prev = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//遍历ooseq队列</span></span><br><span class="line">  <span class="keyword">for</span> (next = pcb-&gt;ooseq; next != <span class="literal">NULL</span>; next = next-&gt;next) &#123;</span><br><span class="line">    <span class="comment">//若输入的报文序号与osseq队列中的某个报文一样</span></span><br><span class="line">    <span class="keyword">if</span> (seqno == next-&gt;tcphdr-&gt;seqno) &#123;</span><br><span class="line">      <span class="comment">//若输入的报文长度大。则将输入报文插入</span></span><br><span class="line">      <span class="keyword">if</span> (inseg.len &gt; next-&gt;len) &#123;</span><br><span class="line"></span><br><span class="line">        cseg = tcp_seg_copy(&amp;inseg);</span><br><span class="line">        <span class="keyword">if</span> (cseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            prev-&gt;next = cseg;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pcb-&gt;ooseq = cseg;</span><br><span class="line">          &#125;</span><br><span class="line">          tcp_oos_insert_segment(cseg, next); <span class="comment">//替换next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//输入报文段比原报文小，啥不用干了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//输入报文段的序号在osseq队列中无</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//next是第一个osseq报文段</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//输入报文序号小于第一个osseq报文，则将输入报文放到osseq首部</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_LT(seqno, next-&gt;tcphdr-&gt;seqno)) &#123;</span><br><span class="line">          cseg = tcp_seg_copy(&amp;inseg);</span><br><span class="line">          <span class="keyword">if</span> (cseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pcb-&gt;ooseq = cseg;</span><br><span class="line">            tcp_oos_insert_segment(cseg, next); <span class="comment">//替换next的位置</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若输入序号在前一个报文与后一个报文之间，修剪前一个报文，删除下一个报文中重复的部分</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_BETWEEN(seqno, prev-&gt;tcphdr-&gt;seqno+<span class="number">1</span>, next-&gt;tcphdr-&gt;seqno<span class="number">-1</span>)) &#123;</span><br><span class="line">          cseg = tcp_seg_copy(&amp;inseg);</span><br><span class="line">          <span class="keyword">if</span> (cseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//前一个报文太长。修剪</span></span><br><span class="line">            <span class="keyword">if</span> (TCP_SEQ_GT(prev-&gt;tcphdr-&gt;seqno + prev-&gt;len, seqno)) &#123;</span><br><span class="line">              <span class="comment">/* We need to trim the prev segment. */</span></span><br><span class="line">              prev-&gt;len = (<span class="type">u16_t</span>)(seqno - prev-&gt;tcphdr-&gt;seqno);</span><br><span class="line">              pbuf_realloc(prev-&gt;p, prev-&gt;len);</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;next = cseg;</span><br><span class="line">            tcp_oos_insert_segment(cseg, next); <span class="comment">//替换next</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若next是最后一个报文，且输入报文的数据在next之后</span></span><br><span class="line">      <span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">          TCP_SEQ_GT(seqno, next-&gt;tcphdr-&gt;seqno)) &#123;</span><br><span class="line">        <span class="comment">//若next报文有fin，说明其后不应该有数据，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (TCPH_FLAGS(next-&gt;tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">          <span class="comment">/* segment &quot;next&quot; already contains all data */</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;next = tcp_seg_copy(&amp;inseg);  <span class="comment">//输入报文插入最后</span></span><br><span class="line">        <span class="keyword">if</span> (next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">//如果next与输入报文有覆盖，则修改next报文的长度</span></span><br><span class="line">          <span class="keyword">if</span> (TCP_SEQ_GT(next-&gt;tcphdr-&gt;seqno + next-&gt;len, seqno)) &#123;</span><br><span class="line">            <span class="comment">/* We need to trim the last segment. */</span></span><br><span class="line">    </span><br><span class="line">            next-&gt;len = (<span class="type">u16_t</span>)(seqno - next-&gt;tcphdr-&gt;seqno);</span><br><span class="line">            pbuf_realloc(next-&gt;p, next-&gt;len);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* check if the remote side overruns our receive window */</span></span><br><span class="line">          <span class="comment">//检查远程是不是超支我们的接收窗口</span></span><br><span class="line">          <span class="keyword">if</span> (TCP_SEQ_GT((<span class="type">u32_t</span>)tcplen + seqno, pcb-&gt;rcv_nxt + (<span class="type">u32_t</span>)pcb-&gt;rcv_wnd)) &#123;</span><br><span class="line">            LWIP_DEBUGF(TCP_INPUT_DEBUG,</span><br><span class="line">                        (<span class="string">&quot;tcp_receive: other end overran receive window&quot;</span></span><br><span class="line">                         <span class="string">&quot;seqno %&quot;</span>U32_F<span class="string">&quot; len %&quot;</span>U16_F<span class="string">&quot; right edge %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                         seqno, tcplen, pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">            <span class="comment">//!若输入报文有fin，则删除，因为我们正修改输入报文的大小来适应接收窗口</span></span><br><span class="line">            <span class="keyword">if</span> (TCPH_FLAGS(next-&gt;next-&gt;tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">              <span class="comment">/* Must remove the FIN from the header as we&#x27;re trimming</span></span><br><span class="line"><span class="comment">               * that byte of sequence-space from the packet */</span></span><br><span class="line">              TCPH_FLAGS_SET(next-&gt;next-&gt;tcphdr, TCPH_FLAGS(next-&gt;next-&gt;tcphdr) &amp; ~TCP_FIN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Adjust length of segment to fit in the window. */</span></span><br><span class="line">            next-&gt;next-&gt;len = (<span class="type">u16_t</span>)(pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd - seqno); <span class="comment">//经过接收窗口筛选后的报文大小</span></span><br><span class="line">            pbuf_realloc(next-&gt;next-&gt;p, next-&gt;next-&gt;len); <span class="comment">//重新分配报文内存</span></span><br><span class="line">            tcplen = TCP_TCPLEN(next-&gt;next);</span><br><span class="line">            LWIP_ASSERT(<span class="string">&quot;tcp_receive: segment not trimmed correctly to rcv_wnd\n&quot;</span>,</span><br><span class="line">                        (seqno + tcplen) == (pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/20201218151146864.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_3/" data-id="cmbcy7rhu0036t8mtdmqd31fi" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/lwip/lwip_TCP_data_out_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>应用层的数据发送需要通告tcp传递，在已经建立tcp连接中，通过tcp_write()函数向对方发送数据。</p>
</blockquote>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p><strong>tcp_write()通过已建立连接的tcp控制块给对方发送数据。代码的实现逻辑是将数据复制到控制块的unsent队列，代码中为节省内存，分多种情况将发送数据连接到unsent。</strong></p>
<h2 id="二，代码分析"><a href="#二，代码分析" class="headerlink" title="二，代码分析"></a>二，代码分析</h2><p><strong>发送数据插入unsent队列时，需要考虑三种情况：</strong></p>
<h3 id="1，写入最后一个pbuf"><a href="#1，写入最后一个pbuf" class="headerlink" title="1，写入最后一个pbuf"></a>1，写入最后一个pbuf</h3><p>由于tcp是面向字节流的传输协议，所以unsent队列中最后一个pbuf如果有剩余的内存可以使用，则将数据填充进去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">u16_t</span> space;  <span class="comment">//报文可用的内存空间，是一个抽象的数值</span></span><br><span class="line"><span class="type">u16_t</span> unsent_optlen;  <span class="comment">//选项长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到unsent队列最后一个成员</span></span><br><span class="line"><span class="keyword">for</span> (last_unsent = pcb-&gt;unsent; last_unsent-&gt;next != <span class="literal">NULL</span>;</span><br><span class="line">     last_unsent = last_unsent-&gt;next);</span><br><span class="line"></span><br><span class="line">unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent-&gt;flags);  <span class="comment">//最后一个报文的选项长度</span></span><br><span class="line">LWIP_ASSERT(<span class="string">&quot;mss_local is too small&quot;</span>, mss_local &gt;= last_unsent-&gt;len + unsent_optlen);</span><br><span class="line"><span class="comment">//last_unsent的报文剩余内存 = 本地最大报文长度-（last_unsent里tcp数据长度+选项长度）</span></span><br><span class="line">space = mss_local - (last_unsent-&gt;len + unsent_optlen); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//将数据复制到最后一个pbuf的剩余内存中，这里并不直接复制，而是记录复制所需的参数（oversize_used）</span></span><br><span class="line">oversize = pcb-&gt;unsent_oversize;  <span class="comment">//最后一个pbuf剩下的空间，是一个真实的内存</span></span><br><span class="line"><span class="comment">//如果最后的pbuf中还有剩余内存</span></span><br><span class="line"><span class="keyword">if</span> (oversize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;inconsistent oversize vs. space&quot;</span>, oversize &lt;= space);</span><br><span class="line">  seg = last_unsent;</span><br><span class="line">  <span class="comment">//理解space，oversize大小可能不同，取其中的最小值，len一般都比较大</span></span><br><span class="line">  oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));</span><br><span class="line">  pos += oversize_used; <span class="comment">//pos记录数据移动字节</span></span><br><span class="line">  oversize -= oversize_used;  <span class="comment">//更新oversize</span></span><br><span class="line">  space -= oversize_used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里需要区别好space,oversize两个变量。一个报文有大小限制，其下可以挂有多个pbuf，space表示该报文还剩下多少的空间；oversize表示一个pbuf中，剩余内存的大小。所以space与oversize的大小关系是不确定。</strong></p>
<h3 id="2，新建pbuf"><a href="#2，新建pbuf" class="headerlink" title="2，新建pbuf"></a>2，新建pbuf</h3><p>经过1之后，若仍有剩余数据未加入unsent，且最后一个报文段还能继续添加pbuf，则在新建pbuf。</p>
<p><strong>这里还有一个特殊情况，就是发送的数据在内存上正好与最后的pbuf连续，这种特殊情况下，不需要内存复制，只需要将pbuf的大小修改。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将一个新的pbuf连接到pcb-&gt;unsent尾部</span></span><br><span class="line"><span class="comment">     * 这里分复制内存和引用内存两种情况：</span></span><br><span class="line"><span class="comment">     * 复制内存即：复制数据到新的内存空间</span></span><br><span class="line"><span class="comment">     * 引用即：申请新的内存空间，并把指针指向数据的内存地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//最后一个pbuf已经满了且剩余有数据未复制，并且当前的报文还能再放pbuf的话，就在当前报文再添加一个pbuf</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; len) &amp;&amp; (space &gt; <span class="number">0</span>) &amp;&amp; (last_unsent-&gt;len &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="type">u16_t</span> seglen = LWIP_MIN(space, len - pos);  <span class="comment">//计算新的pbuf大小，要么是当前报文剩余的大小，要么是剩下数据的大小</span></span><br><span class="line">      seg = last_unsent;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用内存复制</span></span><br><span class="line">      <span class="keyword">if</span> (apiflags &amp; TCP_WRITE_FLAG_COPY) &#123;</span><br><span class="line">        <span class="comment">/* Data is copied */</span></span><br><span class="line">        <span class="comment">//申请内存大小为seglen的pbuf</span></span><br><span class="line">        <span class="keyword">if</span> ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &amp;oversize, pcb, apiflags, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,</span><br><span class="line">                      (<span class="string">&quot;tcp_write : could not allocate memory for pbuf copy size %&quot;</span>U16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                       seglen));</span><br><span class="line">          <span class="keyword">goto</span> memerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制数据到新pbuf</span></span><br><span class="line">        TCP_DATA_COPY2(concat_p-&gt;payload, (<span class="type">const</span> <span class="type">u8_t</span>*)arg + pos, seglen, &amp;concat_chksum, &amp;concat_chksum_swapped);</span><br><span class="line"></span><br><span class="line">        queuelen += pbuf_clen(concat_p);  <span class="comment">//计算concat_p中pbuf的长度并添加到报文</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">		<span class="comment">//使用地址引用的方式</span></span><br><span class="line">        <span class="keyword">struct</span> pbuf *p;</span><br><span class="line">        <span class="keyword">for</span> (p = last_unsent-&gt;p; p-&gt;next != <span class="literal">NULL</span>; p = p-&gt;next); <span class="comment">//找到last_unsent的最后一个pbuf</span></span><br><span class="line">        <span class="comment">//!如果该pbuf是PBUF_ROM类型且内存与数据的内存是连续的，则直接扩展该pbuf的长度，不用新建</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;type == PBUF_ROM &amp;&amp; (<span class="type">const</span> <span class="type">u8_t</span> *)p-&gt;payload + p-&gt;len == (<span class="type">const</span> <span class="type">u8_t</span> *)arg) &#123;</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;tcp_write: ROM pbufs cannot be oversized&quot;</span>, pos == <span class="number">0</span>);</span><br><span class="line">          extendlen = seglen; <span class="comment">//记下扩展长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他类型的pbuf</span></span><br><span class="line">        	<span class="comment">//申请一块PBUF_ROM类型的pbuf，不给payload分配内存</span></span><br><span class="line">          <span class="keyword">if</span> ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,</span><br><span class="line">                        (<span class="string">&quot;tcp_write: could not allocate memory for zero-copy pbuf\n&quot;</span>));</span><br><span class="line">            <span class="keyword">goto</span> memerr;</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          <span class="comment">//将新的pbuf的payload指向数据地址，省去了复制的步骤</span></span><br><span class="line">          ((<span class="keyword">struct</span> pbuf_rom*)concat_p)-&gt;payload = (<span class="type">const</span> <span class="type">u8_t</span>*)arg + pos;</span><br><span class="line">          queuelen += pbuf_clen(concat_p);  <span class="comment">//计算concat_p中pbuf的长度并添加到报文</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pos += seglen;  <span class="comment">//更新pos</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//最后的pbuf足够放下数据</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，新建报文"><a href="#3，新建报文" class="headerlink" title="3，新建报文"></a>3，新建报文</h3><p>若经过1，2步骤后仍有数据未被放入unsent，则在循环中新建报文存放数据，并将该报文段插入unsent队尾。（这一步并无真正入队，只是创建了一个本地的队列）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建报文，将剩余数据放入报文，报文入队</span></span><br><span class="line"><span class="comment">//pos已入队的数据，len数据总长度</span></span><br><span class="line"><span class="keyword">while</span> (pos &lt; len) &#123;	</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> left = len - pos; <span class="comment">//剩余数据长度</span></span><br><span class="line">  <span class="type">u16_t</span> max_len = mss_local - optlen; <span class="comment">//一个报文的最大长度</span></span><br><span class="line">  <span class="type">u16_t</span> seglen = LWIP_MIN(left, max_len); <span class="comment">//当前报文的大小，要么是最大的报文长度，要么是数据剩余长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用内存复制</span></span><br><span class="line">  <span class="keyword">if</span> (apiflags &amp; TCP_WRITE_FLAG_COPY) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建一个pbuf，大小是报文大小加上tcp首部</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &amp;oversize, pcb, apiflags, <span class="built_in">queue</span> == <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, (<span class="string">&quot;tcp_write : could not allocate memory for pbuf copy size %&quot;</span>U16_F<span class="string">&quot;\n&quot;</span>, seglen));</span><br><span class="line">      <span class="keyword">goto</span> memerr;</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_write: check that first pbuf can hold the complete seglen&quot;</span>,</span><br><span class="line">                (p-&gt;len &gt;= seglen));</span><br><span class="line">    <span class="comment">//复制数据到新pbuf</span></span><br><span class="line">    TCP_DATA_COPY2((<span class="type">char</span> *)p-&gt;payload + optlen, (<span class="type">const</span> <span class="type">u8_t</span>*)arg + pos, seglen, &amp;chksum, &amp;chksum_swapped);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用引用：p2，p分别是tcp内容和tcp首部的pbuf，p2的payload指向数据地址</span></span><br><span class="line">    <span class="keyword">struct</span> pbuf *p2;</span><br><span class="line">    <span class="comment">//分配p2，PBUF_ROM类型不会给payload分配空间</span></span><br><span class="line">    <span class="keyword">if</span> ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, (<span class="string">&quot;tcp_write: could not allocate memory for zero-copy pbuf\n&quot;</span>));</span><br><span class="line">      <span class="keyword">goto</span> memerr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p2的payload指向数据区</span></span><br><span class="line">    ((<span class="keyword">struct</span> pbuf_rom*)p2)-&gt;payload = (<span class="type">const</span> <span class="type">u8_t</span>*)arg + pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给报文头部分配p，如果分配失败，先释放p2</span></span><br><span class="line">    <span class="keyword">if</span> ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      pbuf_free(p2);</span><br><span class="line">      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, (<span class="string">&quot;tcp_write: could not allocate memory for header pbuf\n&quot;</span>));</span><br><span class="line">      <span class="keyword">goto</span> memerr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将首部和报文内容通过链表连接</span></span><br><span class="line">    pbuf_cat(p<span class="comment">/*header*/</span>, p2<span class="comment">/*data*/</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queuelen += pbuf_clen(p); <span class="comment">//更新报文队列长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果发送队列或者缓存超出限制，则释放内存</span></span><br><span class="line">  <span class="keyword">if</span> ((queuelen &gt; TCP_SND_QUEUELEN) || (queuelen &gt; TCP_SNDQUEUELEN_OVERFLOW)) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, (<span class="string">&quot;tcp_write: queue too long %&quot;</span>U16_F<span class="string">&quot; (%d)\n&quot;</span>,</span><br><span class="line">      queuelen, (<span class="type">int</span>)TCP_SND_QUEUELEN));</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">    <span class="keyword">goto</span> memerr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//给新的pbuf创建一个tcp_seg报文</span></span><br><span class="line">  <span class="keyword">if</span> ((seg = tcp_create_segment(pcb, p, <span class="number">0</span>, pcb-&gt;snd_lbb + pos, optflags)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> memerr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是队列第一个报文段，直接引用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">queue</span> = seg;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新报文连接到链尾</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;prev_seg != NULL&quot;</span>, prev_seg != <span class="literal">NULL</span>);</span><br><span class="line">    prev_seg-&gt;next = seg;</span><br><span class="line">  &#125;</span><br><span class="line">  prev_seg = seg; <span class="comment">//更新最后一个报文</span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;tcp_write: queueing %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    lwip_ntohl(seg-&gt;tcphdr-&gt;seqno),</span><br><span class="line">    lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg)));</span><br><span class="line"></span><br><span class="line">  pos += seglen;	<span class="comment">//移动pos</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4，将数据入队"><a href="#4，将数据入队" class="headerlink" title="4，将数据入队"></a>4，将数据入队</h3><p>细心的小伙伴们发现，之前的代码都没有<strong>真正</strong>把数据添加到unsent队列，在1中我们记录的oversize_used用来表示最后一个pbuf填入的数据长度，在2中，我们创建了一个新的pbuf，在3中，我们创建了一个报文队列。</p>
<p><strong>在接下来的代码，则是将以上三种情况的数据一一入unsent队。</strong></p>
<p>  填充第一阶段的pbuf数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果last_unsent的最后一个pbuf有数据需要填入</span></span><br><span class="line"><span class="keyword">if</span> (oversize_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//找到unsent最后一个pbuf</span></span><br><span class="line">  <span class="keyword">for</span> (p = last_unsent-&gt;p; p; p = p-&gt;next) &#123;</span><br><span class="line">    p-&gt;tot_len += oversize_used;  <span class="comment">//所有pbuf的tot_len（理解）都要加上oversize_used</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//在最后一个pbuf复制oversize_used大小的数据</span></span><br><span class="line">      TCP_DATA_COPY((<span class="type">char</span> *)p-&gt;payload + p-&gt;len, arg, oversize_used, last_unsent);</span><br><span class="line">      p-&gt;len += oversize_used;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  last_unsent-&gt;len += oversize_used;  <span class="comment">//报文长度也增加</span></span><br><span class="line">&#125;</span><br><span class="line">pcb-&gt;unsent_oversize = oversize;  <span class="comment">//更新报文oversize</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将第二阶段的pbuf连接到报文上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把新增了concat_p连接到该报文的pbuf链表</span></span><br><span class="line"><span class="keyword">if</span> (concat_p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_write: cannot concatenate when pcb-&gt;unsent is empty&quot;</span>,</span><br><span class="line">    (last_unsent != <span class="literal">NULL</span>));</span><br><span class="line">  pbuf_cat(last_unsent-&gt;p, concat_p);</span><br><span class="line">  last_unsent-&gt;len += concat_p-&gt;tot_len;  <span class="comment">//更新链接后的报文长度</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (extendlen &gt; <span class="number">0</span>) &#123; <span class="comment">//内存扩展的情况： 内存连接在一起，直接把这个pbuf扩展了</span></span><br><span class="line">  <span class="keyword">struct</span> pbuf *p;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_write: extension of reference requires reference&quot;</span>,</span><br><span class="line">    last_unsent != <span class="literal">NULL</span> &amp;&amp; last_unsent-&gt;p != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//所有pbuf的totlen都增加</span></span><br><span class="line">  <span class="keyword">for</span> (p = last_unsent-&gt;p; p-&gt;next != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">    p-&gt;tot_len += extendlen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//由于数据地址与pbuf内存是连续的，所以不需要复制内存</span></span><br><span class="line">  p-&gt;tot_len += extendlen;</span><br><span class="line">  p-&gt;len += extendlen;</span><br><span class="line">  last_unsent-&gt;len += extendlen;  <span class="comment">//报文长度增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将本地的报文队列插到unsent，最后更新tcp的发送窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  pcb-&gt;unsent = <span class="built_in">queue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  last_unsent-&gt;next = <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pcb-&gt;snd_lbb += len;  </span><br><span class="line">pcb-&gt;snd_buf -= len;	<span class="comment">//发送buffer减少</span></span><br><span class="line">pcb-&gt;snd_queuelen = queuelen;	<span class="comment">//更新发送队列长度</span></span><br></pre></td></tr></table></figure>
<h2 id="三，小结"><a href="#三，小结" class="headerlink" title="三，小结"></a>三，小结</h2><p>看到这就会理解，tcp_write()函数只将数据插入unsent队列，并未真正将数据发送出去，而真正将数据发送出去的函数是tcp_output();<br><img src="/20201218163038660.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_1/" data-id="cmbcy7rhu0037t8mt3bn6d3cy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_TCP_timer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_timer/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>TCP协议中许多地方是需要使用到定时功能的，如定时重传功能，保活keepalive功能，坚持定时器功能，这些定时功能会在lwip中的两个定时器函数中实现。</p>
</blockquote>
<h2 id="一，定时器时钟"><a href="#一，定时器时钟" class="headerlink" title="一，定时器时钟"></a>一，定时器时钟</h2><h2 id="二，快速定时任务"><a href="#二，快速定时任务" class="headerlink" title="二，快速定时任务"></a>二，快速定时任务</h2><p><code>void tcp_fasttmr(void)</code>比较简单，它的功能主要是每250ms处理延时发送的ack报文和fin报文，同时通知上层应用处理数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcp_fasttmr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb</span>;</span></span><br><span class="line"></span><br><span class="line">  ++tcp_timer_ctr;</span><br><span class="line"></span><br><span class="line">tcp_fasttmr_start:</span><br><span class="line">  pcb = tcp_active_pcbs;  <span class="comment">//在active中遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;last_timer != tcp_timer_ctr) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">next</span>;</span></span><br><span class="line">      pcb-&gt;last_timer = tcp_timer_ctr;</span><br><span class="line">      <span class="comment">//发送延时的ack</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_DELAY) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: delayed ACK\n&quot;</span>));</span><br><span class="line">        tcp_ack_now(pcb);</span><br><span class="line">        tcp_output(pcb);</span><br><span class="line">        pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//发送延时的fin</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_CLOSEPEND) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: pending FIN\n&quot;</span>));</span><br><span class="line">        pcb-&gt;flags &amp;= ~(TF_CLOSEPEND);</span><br><span class="line">        tcp_close_shutdown_fin(pcb);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      next = pcb-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//若当前tcp有未被上层应用接收的数据</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tcp_active_pcbs_changed = <span class="number">0</span>;</span><br><span class="line">        tcp_process_refused_data(pcb);  <span class="comment">//通过回调函数使上层处理数据</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_active_pcbs_changed) &#123;</span><br><span class="line">          <span class="keyword">goto</span> tcp_fasttmr_start;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pcb = next; <span class="comment">//下一个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pcb = pcb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三，低速定时任务"><a href="#三，低速定时任务" class="headerlink" title="三，低速定时任务"></a>三，低速定时任务</h2><p><code>void tcp_slowtmr(void)</code>每500ms调用，该函数完成了超时重传，tcp保活功能，并会遍历<code>active</code>和<code>timewait</code>链表的PCB，删除那些超时或者出错的PCB，<strong>同时将PCB中unsent队列中的数据发送出去。一般使用tcp_write();写入数据后，数据不会马上发送，而是在定时任务中发送。</strong></p>
<h3 id="1，超时重传"><a href="#1，超时重传" class="headerlink" title="1，超时重传"></a>1，超时重传</h3><p>重点的代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求连接次数超出限制</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == SYN_SENT &amp;&amp; pcb-&gt;nrtx &gt;= TCP_SYNMAXRTX) &#123;</span><br><span class="line">  ++pcb_remove; <span class="comment">//移除增加</span></span><br><span class="line">  LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: max SYN retries reached\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据重发次数超出限制</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pcb-&gt;nrtx &gt;= TCP_MAXRTX) &#123;</span><br><span class="line">  ++pcb_remove;</span><br><span class="line">  LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: max DATA retries reached\n&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果坚持定时器已经开启</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;persist_backoff &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取坚持定时器触发值</span></span><br><span class="line">    <span class="type">u8_t</span> backoff_cnt = tcp_persist_backoff[pcb-&gt;persist_backoff<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//坚持定时器不超过触发值，则加1</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_cnt &lt; backoff_cnt) &#123;</span><br><span class="line">      pcb-&gt;persist_cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//坚持定时器触发，发送窗口探查</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_cnt &gt;= backoff_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tcp_zero_window_probe(pcb) == ERR_OK) &#123;</span><br><span class="line">        pcb-&gt;persist_cnt = <span class="number">0</span>; <span class="comment">//发送成功，清除计数值</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;persist_backoff &lt; <span class="keyword">sizeof</span>(tcp_persist_backoff)) &#123;</span><br><span class="line">          pcb-&gt;persist_backoff++; <span class="comment">//发送探查次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//无开启坚持定时器</span></span><br><span class="line">    <span class="comment">//如果开启了超时重传定时器，则加1</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;rtime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      ++pcb-&gt;rtime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有未确认报文且重传时间到，要重传了</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;unacked != <span class="literal">NULL</span> &amp;&amp; pcb-&gt;rtime &gt;= pcb-&gt;rto) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_slowtmr: rtime %&quot;</span>S16_F</span><br><span class="line">                                  <span class="string">&quot; pcb-&gt;rto %&quot;</span>S16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                  pcb-&gt;rtime, pcb-&gt;rto));</span><br><span class="line"></span><br><span class="line">      ESP_STATS_TCP_PCB(pcb);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">        <span class="type">u8_t</span> backoff_idx = LWIP_MIN(pcb-&gt;nrtx, <span class="keyword">sizeof</span>(tcp_backoff)<span class="number">-1</span>);  <span class="comment">//获得重传次数，但重传次数不会超过7</span></span><br><span class="line">        <span class="comment">//动态设置rto，每次超时后，rto时间会增加</span></span><br><span class="line">        pcb-&gt;rto = ((pcb-&gt;sa &gt;&gt; <span class="number">3</span>) + pcb-&gt;sv) &lt;&lt; tcp_backoff[backoff_idx];  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pcb-&gt;rtime = <span class="number">0</span>; <span class="comment">//重置超时重传定时器</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//TODO 出现重传，说明报文丢失了，可能是网络出现阻塞，减小拥塞窗口</span></span><br><span class="line">      eff_wnd = LWIP_MIN(pcb-&gt;cwnd, pcb-&gt;snd_wnd);</span><br><span class="line">      pcb-&gt;ssthresh = eff_wnd &gt;&gt; <span class="number">1</span>; <span class="comment">//ssthresh减少到拥塞窗口的一半</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//若ssthresh比最大报文长度的两倍还小，后者的数值（限制了ssthresh的最小值）</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;ssthresh &lt; (<span class="type">tcpwnd_size_t</span>)(pcb-&gt;mss &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        pcb-&gt;ssthresh = (pcb-&gt;mss &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pcb-&gt;cwnd = pcb-&gt;mss; <span class="comment">//拥塞窗口设置成最大报文长度，一个报文长度</span></span><br><span class="line">      LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_slowtmr: cwnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                   <span class="string">&quot; ssthresh %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                   pcb-&gt;cwnd, pcb-&gt;ssthresh));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//重传报文</span></span><br><span class="line">      tcp_rexmit_rto(pcb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == FIN_WAIT_2) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//TODO 处于FIN_WAIT_2的时间太长（由于对方长时间无反应）则删除</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_RXCLOSED) &#123;</span><br><span class="line">    <span class="comment">/* PCB was fully closed (either through close() or SHUT_RDWR):</span></span><br><span class="line"><span class="comment">       normal FIN-WAIT timeout handling. */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">        TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">      ++pcb_remove;</span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，保活keepalive"><a href="#2，保活keepalive" class="headerlink" title="2，保活keepalive"></a>2，保活keepalive</h3><p><strong>服务端需要检查客户端是否还能通信，若两小时内无通信，客户端发送探查报文，若客户端ack，则更新保活计时器，否则，每隔75s发送一个探查报文，若发送超过9个报文，则认为客户端已挂掉</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if KEEPALIVE should be sent */</span></span><br><span class="line"><span class="comment">//服务端需要检查客户端是否还能通信，若两小时内无通信，客户端发送探查报文，若客户端ack，则更新保活计时器</span></span><br><span class="line"><span class="comment">//否则，每隔75s发送一个探查报文，若发送超过9个报文，则认为客户端已挂掉</span></span><br><span class="line"><span class="keyword">if</span> (ip_get_option(pcb, SOF_KEEPALIVE) &amp;&amp;</span><br><span class="line">   ((pcb-&gt;state == ESTABLISHED) ||</span><br><span class="line">    (pcb-&gt;state == CLOSE_WAIT))) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发送9个以上探查报文，对方仍无反应，应该关闭tcp</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">     (pcb-&gt;keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: KEEPALIVE timeout. Aborting connection to &quot;</span>));</span><br><span class="line">    ip_addr_debug_print(TCP_DEBUG, &amp;pcb-&gt;remote_ip);</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ++pcb_remove;</span><br><span class="line">    ++pcb_reset;  <span class="comment">//复位对方</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">            (pcb-&gt;keep_idle + pcb-&gt;keep_cnt_sent * TCP_KEEP_INTVL(pcb))</span><br><span class="line">            / TCP_SLOW_INTERVAL)  <span class="comment">//发送探查报文</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    err = tcp_keepalive(pcb); </span><br><span class="line">    <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">      pcb-&gt;keep_cnt_sent++; <span class="comment">//探查次数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3，删除超时PCB"><a href="#3，删除超时PCB" class="headerlink" title="3，删除超时PCB"></a>3，删除超时PCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//若pcb的osseq队列中无序的数据超过一定时长会被丢弃</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;ooseq != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    (<span class="type">u32_t</span>)tcp_ticks - pcb-&gt;tmr &gt;= pcb-&gt;rto * TCP_OOSEQ_TIMEOUT) &#123;</span><br><span class="line">  tcp_segs_free(pcb-&gt;ooseq);</span><br><span class="line">  pcb-&gt;ooseq = <span class="literal">NULL</span>;</span><br><span class="line">  LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_slowtmr: dropping OOSEQ queued data\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一直等不到服务端回答的tcp要被移除</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == SYN_RCVD) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">      TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">    ++pcb_remove;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: removing pcb stuck in SYN-RCVD\n&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在last_ack超过一定时间也被删除</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == LAST_ACK) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt; <span class="number">2</span> * TCP_MSL / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">    ++pcb_remove;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: removing pcb stuck in LAST-ACK\n&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上的代码中若当前PCB需要被删除，则pcb_remove不为0，具体的删除代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (pcb_remove) &#123;	<span class="comment">//不为0则需要删除pcb</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb2</span>;</span></span><br><span class="line"></span><br><span class="line">    tcp_err_fn err_fn = pcb-&gt;errf;  <span class="comment">//错误回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *err_arg;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tcp_state</span> <span class="title">last_state</span>;</span></span><br><span class="line">    tcp_pcb_purge(pcb); <span class="comment">//释放pcb部分成员，pcb结构体不会被释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: middle tcp != tcp_active_pcbs&quot;</span>, pcb != tcp_active_pcbs);</span><br><span class="line">      prev-&gt;next = pcb-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* This PCB was the first. */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: first pcb == tcp_active_pcbs&quot;</span>, tcp_active_pcbs == pcb);</span><br><span class="line">      tcp_active_pcbs = pcb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要发送重置报文</span></span><br><span class="line">    <span class="keyword">if</span> (pcb_reset) &#123;</span><br><span class="line">      tcp_rst(pcb-&gt;snd_nxt, pcb-&gt;rcv_nxt, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip,</span><br><span class="line">               pcb-&gt;local_port, pcb-&gt;remote_port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err_arg = pcb-&gt;callback_arg;</span><br><span class="line">    last_state = pcb-&gt;state;</span><br><span class="line">   </span><br><span class="line">    pcb2 = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;  <span class="comment">//获取下一个pcb</span></span><br><span class="line">    memp_free(MEMP_TCP_PCB, pcb2);  <span class="comment">//释放pcb结构体</span></span><br><span class="line"></span><br><span class="line">    tcp_active_pcbs_changed = <span class="number">0</span>;</span><br><span class="line">    TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT); <span class="comment">//调用错误回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_active_pcbs_changed) &#123;</span><br><span class="line">      <span class="keyword">goto</span> tcp_slowtmr_start;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不需要删除pcb</span></span><br><span class="line">    prev = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;  <span class="comment">//获取下一个pcb</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 定时周期到，调用回调函数</span></span><br><span class="line">    ++prev-&gt;polltmr;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;polltmr &gt;= prev-&gt;pollinterval) &#123;</span><br><span class="line">      prev-&gt;polltmr = <span class="number">0</span>;</span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: polling application\n&quot;</span>));</span><br><span class="line">      tcp_active_pcbs_changed = <span class="number">0</span>;</span><br><span class="line">      TCP_EVENT_POLL(prev, err);  <span class="comment">//!回调周期性函数</span></span><br><span class="line">      <span class="keyword">if</span> (tcp_active_pcbs_changed) &#123;</span><br><span class="line">        <span class="keyword">goto</span> tcp_slowtmr_start;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">        tcp_output(prev); <span class="comment">//输出unsent报文</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是处理active链表的pcb，接下来处理timewait的pcb，苍天饶过谁？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------遍历所有timewait的pcb-----------------------*/</span></span><br><span class="line"><span class="comment">/* Steps through all of the TIME-WAIT PCBs. */</span></span><br><span class="line">prev = <span class="literal">NULL</span>;</span><br><span class="line">pcb = tcp_tw_pcbs;</span><br><span class="line"><span class="keyword">while</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: TIME-WAIT pcb-&gt;state == TIME-WAIT&quot;</span>, pcb-&gt;state == TIME_WAIT);</span><br><span class="line">  pcb_remove = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//是否达到2MSL，是则删除</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt; <span class="number">2</span> * TCP_MSL / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">    ++pcb_remove;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb_remove) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb2</span>;</span></span><br><span class="line">    tcp_pcb_purge(pcb);</span><br><span class="line">    <span class="comment">/* Remove PCB from tcp_tw_pcbs list. */</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: middle tcp != tcp_tw_pcbs&quot;</span>, pcb != tcp_tw_pcbs);</span><br><span class="line">      prev-&gt;next = pcb-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* This PCB was the first. */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: first pcb == tcp_tw_pcbs&quot;</span>, tcp_tw_pcbs == pcb);</span><br><span class="line">      tcp_tw_pcbs = pcb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pcb2 = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;</span><br><span class="line">    memp_free(MEMP_TCP_PCB, pcb2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>tcp定时任务是tcp接收发送的动力来源，需要关注。<br><img src="/2025/05/30/hello-world/lwip/lwip_TCP_timer/20210226004849547.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_timer/" data-id="cmbcy7rhu0038t8mth6165t8i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_TCP_data_out_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p>上一章提到的<code>tcp_write()</code>函数的作用是将数据插入unsent队列，其并无真正的把数据交给ip层发送。<code>tco_output()</code>的功能就是将unsent队列中的tcp报文交给ip层发送。</p>
<p>一般情况下，tcp_output()函数会在500ms定时任务中被循环调用。所以当用户使用<code>tcp_write()</code>将数据写入unsent队列后，会在定时任务中将数据传递给ip层发送。</p>
<h2 id="二，源码分析"><a href="#二，源码分析" class="headerlink" title="二，源码分析"></a>二，源码分析</h2><p><strong>首先需要先判断能不能发送unsent队列，若当前的PCB正在接收数据或者当前发送窗口小于要发送的报文长度，都不能发送数据。代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送控制块中的所有unsents报文段</span></span><br><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">tcp_output</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">seg</span>, *<span class="title">useg</span>;</span><span class="comment">//seg：要发送的报文段，useg：未确认的报文段</span></span><br><span class="line">  <span class="type">u32_t</span> wnd, snd_nxt; <span class="comment">//wnd：真实发送窗口，snd_nxt:下一个发送的序号</span></span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span>;</span>  <span class="comment">//发送的网络接口</span></span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;don&#x27;t call tcp_output for listen-pcbs&quot;</span>,</span><br><span class="line">    pcb-&gt;state != LISTEN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果该tcp正在接收数据，则不发送</span></span><br><span class="line">  <span class="keyword">if</span> (tcp_input_pcb == pcb) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//真实发送窗口是发送窗口和拥塞窗口的最小</span></span><br><span class="line">  wnd = LWIP_MIN(pcb-&gt;snd_wnd, pcb-&gt;cwnd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取第一个报文段</span></span><br><span class="line">  seg = pcb-&gt;unsent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果tcp使用TF_ACK_NOW标志，或者本地不能发送数据（unsent为null或者当前窗口无法发送seg），则发送一个不带任何数据的ack</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">     (seg == <span class="literal">NULL</span> ||</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">     <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将useg指向unacked队尾</span></span><br><span class="line">  useg = pcb-&gt;unacked;</span><br><span class="line">  <span class="keyword">if</span> (useg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; useg-&gt;next != <span class="literal">NULL</span>; useg = useg-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//找到最佳的网络接口</span></span><br><span class="line">  netif = ip_route(&amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip);</span><br><span class="line">  <span class="keyword">if</span> (netif == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查本地ip地址</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isany(&amp;pcb-&gt;local_ip)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">ip_addr_t</span> *local_ip = ip_netif_get_local_ip(netif, &amp;pcb-&gt;remote_ip);</span><br><span class="line">    <span class="keyword">if</span> (local_ip == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">    &#125;</span><br><span class="line">    ip_addr_copy(pcb-&gt;local_ip, *local_ip);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//发送窗口太小而不能发送当前报文，等待对方接收窗口变大，所以启动零窗口探测，坚持定时器开启</span></span><br><span class="line">  <span class="keyword">if</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd &amp;&amp;</span><br><span class="line">      wnd &gt; <span class="number">0</span> &amp;&amp; wnd == pcb-&gt;snd_wnd &amp;&amp; pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Start the persist timer */</span></span><br><span class="line">    <span class="comment">//启动坚持定时器</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_backoff == <span class="number">0</span>) &#123;</span><br><span class="line">      pcb-&gt;persist_cnt = <span class="number">0</span>;</span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于发送窗口太小，函数实际上无输出</span></span><br><span class="line">    <span class="keyword">goto</span> output_done;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>接下来就是遍历unsent队列，将tcp报文发送，直到发送窗口不满足发送调节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">       lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &lt;= wnd) &#123;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;RST not expected here!&quot;</span>,</span><br><span class="line">              (TCPH_FLAGS(seg-&gt;tcphdr) &amp; TCP_RST) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果nagle算法有效或者缓存有错误（这是由write导致的内存错误），停止发送</span></span><br><span class="line">  <span class="keyword">if</span> ((tcp_do_output_nagle(pcb) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">    ((pcb-&gt;flags &amp; (TF_NAGLEMEMERR | TF_FIN)) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//!SYN_SENT状态下发送的报文的ack位无效</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">    TCPH_SET_FLAG(seg-&gt;tcphdr, TCP_ACK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送一个tcp报文</span></span><br><span class="line">  err = tcp_output_segment(seg, pcb, netif);</span><br><span class="line">  <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">    <span class="comment">/* segment could not be sent, for whatever reason */</span></span><br><span class="line">    pcb-&gt;flags |= TF_NAGLEMEMERR;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  pcb-&gt;unsent = seg-&gt;next;  <span class="comment">//队列头部已经发送，更新</span></span><br><span class="line">  <span class="comment">//!SYN_SENT状态下发送的报文的ack位无效</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">    pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW); <span class="comment">//清除应答标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">  snd_nxt = lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg); <span class="comment">//计算下一个要发送的序号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果pcb-&gt;snd_nxt比snd_nxt小，则更新下一个要发送的序号</span></span><br><span class="line">  <span class="keyword">if</span> (TCP_SEQ_LT(pcb-&gt;snd_nxt, snd_nxt)) &#123;</span><br><span class="line">    pcb-&gt;snd_nxt = snd_nxt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将已发送报文插入unacked队列</span></span><br><span class="line">  <span class="keyword">if</span> (TCP_TCPLEN(seg) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unacked为空，seg则放入队首</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      pcb-&gt;unacked = seg;</span><br><span class="line">      useg = seg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//unacked队列的排队是小号在前，大号在后的模式</span></span><br><span class="line">      <span class="comment">//若seg&lt;useg则在循环中中找到合适的位置</span></span><br><span class="line">      <span class="keyword">if</span> (TCP_SEQ_LT(lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), lwip_ntohl(useg-&gt;tcphdr-&gt;seqno))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前报文序号比较低，则查找适合的位置插入，序号越大越靠后</span></span><br><span class="line">        <span class="keyword">struct</span> tcp_seg **cur_seg = &amp;(pcb-&gt;unacked); </span><br><span class="line">        <span class="comment">//找到cur_seg&gt;seg的的报文,并在该报文前插入seg</span></span><br><span class="line">        <span class="keyword">while</span> (*cur_seg &amp;&amp;</span><br><span class="line">          TCP_SEQ_LT(lwip_ntohl((*cur_seg)-&gt;tcphdr-&gt;seqno), lwip_ntohl(seg-&gt;tcphdr-&gt;seqno))) &#123;</span><br><span class="line">            cur_seg = &amp;((*cur_seg)-&gt;next );</span><br><span class="line">        &#125;</span><br><span class="line">        seg-&gt;next = (*cur_seg);</span><br><span class="line">        (*cur_seg) = seg;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//seg&gt;useg，seg插入unacked队尾</span></span><br><span class="line">        useg-&gt;next = seg;</span><br><span class="line">        useg = useg-&gt;next;  <span class="comment">//更新unacked</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//对于空的报文段直接删除不需要插入unacked</span></span><br><span class="line">    tcp_seg_free(seg);</span><br><span class="line">  &#125;</span><br><span class="line">  seg = pcb-&gt;unsent;  <span class="comment">//发送下一个报文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上代码中，tcp_output_segment()是真正将报文传递给ip层的函数，该函数主要做的是，填充即将发送的tcp报文首部的通告窗口，确认序号，mss以及校验和。同时开启PCB的超时重传和rtt估算，最后移动payload指针到首部，并将报文的pbuf传递给ip层。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过调用ip层发送tcp报文</span></span><br><span class="line"><span class="type">static</span> <span class="type">err_t</span></span><br><span class="line"><span class="title function_">tcp_output_segment</span><span class="params">(<span class="keyword">struct</span> tcp_seg *seg, <span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="type">u16_t</span> len;</span><br><span class="line">  <span class="type">u32_t</span> *opts;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//TODO ref为1才能发送</span></span><br><span class="line">  <span class="keyword">if</span> (seg-&gt;p-&gt;ref != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//填充tcp首部确认号字段</span></span><br><span class="line">  seg-&gt;tcphdr-&gt;ackno = lwip_htonl(pcb-&gt;rcv_nxt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//填充tcp首部通告窗口</span></span><br><span class="line">  seg-&gt;tcphdr-&gt;wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb-&gt;rcv_ann_wnd)));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//pcb通告接收窗口右边界=下一个接收序号+通告接收窗口长度</span></span><br><span class="line">  pcb-&gt;rcv_ann_right_edge = pcb-&gt;rcv_nxt + pcb-&gt;rcv_ann_wnd;</span><br><span class="line">  </span><br><span class="line">  opts = (<span class="type">u32_t</span> *)(<span class="type">void</span> *)(seg-&gt;tcphdr + <span class="number">1</span>);  <span class="comment">//选项字段</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//填充mss选项</span></span><br><span class="line">  <span class="keyword">if</span> (seg-&gt;flags &amp; TF_SEG_OPTS_MSS) &#123;</span><br><span class="line">    <span class="type">u16_t</span> mss;</span><br><span class="line">    mss = tcp_eff_send_mss(TCP_MSS, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip); <span class="comment">//针对ip路径计算mss大小</span></span><br><span class="line">    mss = TCP_MSS;</span><br><span class="line">    *opts = TCP_BUILD_MSS_OPTION(mss);  <span class="comment">//构建适用于tcp首部的mss</span></span><br><span class="line">    opts += <span class="number">1</span>;  <span class="comment">//opts移动</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果超时重传定时器没开就给老资开</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;rtime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    pcb-&gt;rtime = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果该tcp的rtt计时器关闭了则开启rtt估测</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;rttest == <span class="number">0</span>) &#123;</span><br><span class="line">    pcb-&gt;rttest = tcp_ticks;  <span class="comment">//记录当前时间</span></span><br><span class="line">    pcb-&gt;rtseq = lwip_ntohl(seg-&gt;tcphdr-&gt;seqno);  <span class="comment">//被估算的报文段的编号</span></span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_output_segment: rtseq %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>, pcb-&gt;rtseq));</span><br><span class="line">  &#125;</span><br><span class="line">  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, (<span class="string">&quot;tcp_output_segment: %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          lwip_htonl(seg-&gt;tcphdr-&gt;seqno), lwip_htonl(seg-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">          seg-&gt;len));</span><br><span class="line"></span><br><span class="line">  len = (<span class="type">u16_t</span>)((<span class="type">u8_t</span> *)seg-&gt;tcphdr - (<span class="type">u8_t</span> *)seg-&gt;p-&gt;payload); <span class="comment">//计算首部占用的字节空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果首部为0那肯定有问题</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    MIB2_STATS_INC(mib2.tcpoutsegs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//pbuf的len指的是tcp数据的长度</span></span><br><span class="line">  seg-&gt;p-&gt;len -= len;</span><br><span class="line">  seg-&gt;p-&gt;tot_len -= len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移动payload到tcp首部，因为需要传递给ip层</span></span><br><span class="line">  seg-&gt;p-&gt;payload = seg-&gt;tcphdr;</span><br><span class="line"></span><br><span class="line">  seg-&gt;tcphdr-&gt;chksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计算tcp校验和</span></span><br><span class="line">  seg-&gt;tcphdr-&gt;chksum = ip_chksum_pseudo(seg-&gt;p, IP_PROTO_TCP,</span><br><span class="line">      seg-&gt;p-&gt;tot_len, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip);</span><br><span class="line">  </span><br><span class="line">  TCP_STATS_INC(tcp.xmit);</span><br><span class="line">  </span><br><span class="line">  NETIF_SET_HWADDRHINT(netif, &amp;(pcb-&gt;addr_hint));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用ip层发送该报文的pbuf</span></span><br><span class="line">  err = ip_output_if(seg-&gt;p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip, pcb-&gt;ttl,</span><br><span class="line">    pcb-&gt;tos, IP_PROTO_TCP, netif);</span><br><span class="line">  NETIF_SET_HWADDRHINT(netif, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ip_output_if()函数就是将tcp报文传递给ip层，tcp报文传递给ip层时数据变化如下，tcp_hdr中被填入相应的参数，payload移动到tcp_hdr</strong><br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三，小结"><a href="#三，小结" class="headerlink" title="三，小结"></a>三，小结</h2><p>tcp_output();将unsent队列的报文填充完整，然后交给ip层，实现数据的发送<br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_2/" data-id="cmbcy7rhv0039t8mtafx8a0zw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_TCP_data_in_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，tcp的数据输入"><a href="#一，tcp的数据输入" class="headerlink" title="一，tcp的数据输入"></a>一，tcp的数据输入</h2><p><strong>ip层接收到数据后，经过处理需要将数据传递给tcp层。</strong><br>ip层通过<code>tcp_input</code>函数将接收到的数据传递给tcp层，该函数是tcp数据的总入口，在此函数中，从ip数据包中提取tcp报文，检验报文的正确性，找到对应的tcp控制块，进入tcp状态机，将报文中的有效数据传递给应用层。</p>
<h2 id="二，ip数据解析"><a href="#二，ip数据解析" class="headerlink" title="二，ip数据解析"></a>二，ip数据解析</h2><p>ip层递交的数据仍然是以pbuf的形式出现的，其中payload指向的是tcp数据的首部，我们需要将tcp的首部与数据分离，其中tcp首部包括20字节的固定长度和可变长度的选项字段。但在此之前，我们还需要先检查tcp报文是否正确，代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  tcphdr = (<span class="keyword">struct</span> tcp_hdr *)p-&gt;payload;  <span class="comment">//从ip数据包中获取tcp首部</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果pbuf长度比默认tcp首部还小，这不好，丢弃</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &lt; TCP_HLEN) &#123;</span><br><span class="line">    <span class="comment">/* drop short packets */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: short packet (%&quot;</span>U16_F<span class="string">&quot; bytes) discarded\n&quot;</span>, p-&gt;tot_len));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对输入的广播和多播的报文不做处理，丢弃</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||</span><br><span class="line">      ip_addr_ismulticast(ip_current_dest_addr())) &#123;</span><br><span class="line">    TCP_STATS_INC(tcp.proterr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查报文的校验字段</span></span><br><span class="line">  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) &#123;</span><br><span class="line">    <span class="comment">//计算校验和</span></span><br><span class="line">    <span class="type">u16_t</span> chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p-&gt;tot_len,</span><br><span class="line">                               ip_current_src_addr(), ip_current_dest_addr());</span><br><span class="line">    <span class="keyword">if</span> (chksum != <span class="number">0</span>) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packet discarded due to failing checksum 0x%04&quot;</span>X16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          chksum));</span><br><span class="line">      tcp_debug_print(tcphdr);</span><br><span class="line">      TCP_STATS_INC(tcp.chkerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * <span class="number">4</span>; <span class="comment">//计算tcp 首部字节数，一个长度单位32bit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果首部字节太大或者太小，丢弃报文</span></span><br><span class="line">  <span class="keyword">if</span> ((hdrlen_bytes &lt; TCP_HLEN) || (hdrlen_bytes &gt; p-&gt;tot_len)) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: invalid header length (%&quot;</span>U16_F<span class="string">&quot;)\n&quot;</span>, (<span class="type">u16_t</span>)hdrlen_bytes));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;  <span class="comment">//计算选项长度=首部长度-固定20字节</span></span><br><span class="line">  tcphdr_opt2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一个pbuf的长度大于首部长度，说明选项字段在此pbuf中</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &gt;= hdrlen_bytes) &#123;</span><br><span class="line">    <span class="comment">//所有选项数据放在第一个pbuf（也就是tcp首部所在的pbuf）</span></span><br><span class="line">    tcphdr_opt1len = tcphdr_optlen;</span><br><span class="line">    <span class="comment">//向后移动payload指针，使payload指向tcp数据</span></span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)hdrlen_bytes); <span class="comment">/* cannot fail */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//选项字段可能分为两份，一份在第一个pbuf，一份在下一个pbuf，移动payload跳过选项</span></span><br><span class="line">    <span class="type">u16_t</span> opt2len;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;next != NULL&quot;</span>, p-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pbuf的payload移动到固定tcp首部尾，此时的p-&gt;len为第一份选项字段的长度</span></span><br><span class="line">    pbuf_header(p, -TCP_HLEN);</span><br><span class="line"></span><br><span class="line">    tcphdr_opt1len = p-&gt;len;</span><br><span class="line">    opt2len = tcphdr_optlen - tcphdr_opt1len; <span class="comment">//计算第二份选项字段的长度</span></span><br><span class="line"></span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)tcphdr_opt1len); <span class="comment">//移动payload指针跳过第一份选项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果第二份选项超过下一个pbuf大小，不合理，丢弃报文</span></span><br><span class="line">    <span class="keyword">if</span> (opt2len &gt; p-&gt;next-&gt;len) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: options overflow second pbuf (%&quot;</span>U16_F<span class="string">&quot; bytes)\n&quot;</span>, p-&gt;next-&gt;len));</span><br><span class="line">      TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p-&gt;next-&gt;payload指向的就是第二份选项字段</span></span><br><span class="line">    tcphdr_opt2 = (<span class="type">u8_t</span>*)p-&gt;next-&gt;payload;</span><br><span class="line"></span><br><span class="line">    pbuf_header(p-&gt;next, -(<span class="type">s16_t</span>)opt2len);  <span class="comment">//移动第一个pbuf的payload跳过第二段选项</span></span><br><span class="line">    p-&gt;tot_len -= opt2len;  <span class="comment">//总长度随着payload后移而减少</span></span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;len == 0&quot;</span>, p-&gt;len == <span class="number">0</span>);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;tot_len == p-&gt;next-&gt;tot_len&quot;</span>, p-&gt;tot_len == p-&gt;next-&gt;tot_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将tcp首部的网络字节的数据转换成主机字节</span></span><br><span class="line">  tcphdr-&gt;src = lwip_ntohs(tcphdr-&gt;src);</span><br><span class="line">  tcphdr-&gt;dest = lwip_ntohs(tcphdr-&gt;dest);</span><br><span class="line">  seqno = tcphdr-&gt;seqno = lwip_ntohl(tcphdr-&gt;seqno);</span><br><span class="line">  ackno = tcphdr-&gt;ackno = lwip_ntohl(tcphdr-&gt;ackno);</span><br><span class="line">  tcphdr-&gt;wnd = lwip_ntohs(tcphdr-&gt;wnd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  flags = TCPH_FLAGS(tcphdr); <span class="comment">//获取tcp首部的标志位</span></span><br><span class="line">  tcplen = p-&gt;tot_len + ((flags &amp; (TCP_FIN | TCP_FIN)) ? <span class="number">1</span> : <span class="number">0</span>);  <span class="comment">//计算tcp报文长度，报文标志位存在TCP_FIN或TCP_FIN时，长度要加一</span></span><br><span class="line">  <span class="comment">//到这儿，我们分离了ip数据包中的tcp首部和数据</span></span><br></pre></td></tr></table></figure>
<h2 id="三，给谁的报文？"><a href="#三，给谁的报文？" class="headerlink" title="三，给谁的报文？"></a>三，给谁的报文？</h2><p>tcp报文解析完成后，就需要确定这报文是传递给那个tcp控制块的。这需要根据报文的源地址和目标地址在各控制块链表中查找。</p>
<h3 id="1，在active链表？"><a href="#1，在active链表？" class="headerlink" title="1，在active链表？"></a>1，在active链表？</h3><p>以下代码确定了报文要送达的tcp控制块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查数据是否是给tcp_active_pcbs链表中的tcp</span></span><br><span class="line"><span class="keyword">for</span> (pcb = tcp_active_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != CLOSED&quot;</span>, pcb-&gt;state != CLOSED);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != TIME-WAIT&quot;</span>, pcb-&gt;state != TIME_WAIT);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != LISTEN&quot;</span>, pcb-&gt;state != LISTEN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//找到报文对应的tcp控制块，并将该pcb放到tcp_active_pcbs链表头，以方便随后的读取</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">      pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">      ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">      ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (before cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      prev-&gt;next = pcb-&gt;next;</span><br><span class="line">      pcb-&gt;next = tcp_active_pcbs;</span><br><span class="line">      tcp_active_pcbs = pcb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (after cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prev = pcb; <span class="comment">//把对应的pcb放到prev</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，在timewait链表？"><a href="#2，在timewait链表？" class="headerlink" title="2，在timewait链表？"></a>2，在timewait链表？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在tcp_tw_pcbs链表找</span></span><br><span class="line">  <span class="keyword">for</span> (pcb = tcp_tw_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: TIME-WAIT pcb-&gt;state == TIME-WAIT&quot;</span>, pcb-&gt;state == TIME_WAIT);</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">        pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">     <span class="comment">//对于处于timewait状态的pcb，不需要将它放在链表头部</span></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for TIME_WAITing connection.\n&quot;</span>));</span><br><span class="line">      tcp_timewait_input(pcb);  <span class="comment">//timewait处理数据</span></span><br><span class="line">      pbuf_free(p); <span class="comment">//释放数据</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>tcp_timewait_input()</code>忽略所有的rst，ack和fin置位报文，且报文数据会被删除。</p>
<h3 id="3，给listen链表的？"><a href="#3，给listen链表的？" class="headerlink" title="3，给listen链表的？"></a>3，给listen链表的？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在tcp_listen_pcbs链表中找</span></span><br><span class="line">  <span class="keyword">for</span> (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != <span class="literal">NULL</span>; lpcb = lpcb-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lpcb-&gt;local_port == tcphdr-&gt;dest) &#123; <span class="comment">//端口对上了</span></span><br><span class="line">      <span class="keyword">if</span> (IP_IS_ANY_TYPE_VAL(lpcb-&gt;local_ip)) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ip_addr_cmp(&amp;lpcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ip_addr_isany(&amp;lpcb-&gt;local_ip)) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = (<span class="keyword">struct</span> tcp_pcb *)lpcb;  <span class="comment">//当前的pcb赋值到prev</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果在listen链表找到对象，则将该对象pcb放到链表头</span></span><br><span class="line">  <span class="keyword">if</span> (lpcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ((<span class="keyword">struct</span> tcp_pcb_listen *)prev)-&gt;next = lpcb-&gt;next;</span><br><span class="line"></span><br><span class="line">      lpcb-&gt;next = tcp_listen_pcbs.listen_pcbs;</span><br><span class="line"></span><br><span class="line">      tcp_listen_pcbs.listen_pcbs = lpcb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for LISTENing connection.\n&quot;</span>));</span><br><span class="line">    tcp_listen_input(lpcb); <span class="comment">//listen对象处理数据</span></span><br><span class="line">    pbuf_free(p); <span class="comment">//释放数据</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>tcp_listen_input()</code>会检查报文是否是连接报文，若是则创建新的pcb并加入active队列，发送syn和ack，mss报文。</p>
<h2 id="四，数据处理后"><a href="#四，数据处理后" class="headerlink" title="四，数据处理后"></a>四，数据处理后</h2><p>细心的你会发现，以上三个链表中，只有active链表没有处理报文的代码，由于这部分代码是最复杂的，其实现需要使用TCP状态机来搞定，在下一章再续TCP状态机，这一节先把tcp_input的最后看完。</p>
<p>经过上面确定了报文是给某个tcp后，先检查该tcp连接中，是否有数据仍然未被应用程序读取，若是，必须先让应用程序处理完上次未读取完成的数据后才进入下一步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来到这，说明该数据的对象是处于active链表中，就是一个已存在的连接的报文</span></span><br><span class="line"><span class="keyword">if</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="comment">//确定了pcb，创建输入报文结构体</span></span><br><span class="line">  inseg.next = <span class="literal">NULL</span>;</span><br><span class="line">  inseg.len = p-&gt;tot_len;</span><br><span class="line">  inseg.p = p;</span><br><span class="line">  inseg.tcphdr = tcphdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化接收的参数</span></span><br><span class="line">  recv_data = <span class="literal">NULL</span>; <span class="comment">//指向最终确认的有序pbuf，被应用程序调用</span></span><br><span class="line">  recv_flags = <span class="number">0</span>; <span class="comment">//接收数据的处理结果</span></span><br><span class="line">  recv_acked = <span class="number">0</span>; <span class="comment">//接收的数据字节数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果tcp报文首部中有TCP_PSH标志，将pbuf的相应标志置位</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; TCP_PSH) &#123;</span><br><span class="line">    p-&gt;flags |= PBUF_FLAG_PUSH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果当前的tcp控制块有数据未被上层应用读取</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//调用上层应用的数据回调函数来处理未读取的数据，若有未读取的数据，只能将tcp终止</span></span><br><span class="line">    <span class="keyword">if</span> ((tcp_process_refused_data(pcb) == ERR_ABRT) ||</span><br><span class="line">      ((pcb-&gt;refused_data != <span class="literal">NULL</span>) &amp;&amp; (tcplen &gt; <span class="number">0</span>))) &#123;</span><br><span class="line">      <span class="comment">//如果对方的窗口通告为0，为防止死锁，启动零窗口探查</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;rcv_ann_wnd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//发送无数据的ack（探查）</span></span><br><span class="line">        tcp_send_empty_ack(pcb);</span><br><span class="line">      &#125;</span><br><span class="line">      TCP_STATS_INC(tcp.drop);</span><br><span class="line">      MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">      <span class="keyword">goto</span> aborted;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>随后进入tcp状态机处理接收报文，<code>tcp_process()</code>将处理结果放在全局变量<code>recv_flag</code>中。接下来根据recv_flag的值，决定pcb的命运。</p>
<p><code>recv_acked</code>本地发送的数据被对方确认的字节数；<br><code>recv_data </code>指向被正确接收到的字节数据；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">    tcp_input_pcb = pcb;</span><br><span class="line">    err = tcp_process(pcb); <span class="comment">//进入状态机处理，根据处理结果recv_flag作出以下反应：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若返回ERR_ABRT，说明pcb已经被终止</span></span><br><span class="line">    <span class="keyword">if</span> (err != ERR_ABRT) &#123;</span><br><span class="line">      <span class="comment">//若收到复位报文，则tcp连接重置，移除该tcp，并释放内存</span></span><br><span class="line">      <span class="keyword">if</span> (recv_flags &amp; TF_RESET) &#123;</span><br><span class="line">        <span class="comment">//调用错误回调函数</span></span><br><span class="line">        TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_RST);</span><br><span class="line">        tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">        memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = ERR_OK;</span><br><span class="line">        <span class="comment">//如果有数据被确认，调用sent回调（用于向send_buff继续填充要发送数据）</span></span><br><span class="line">        <span class="keyword">if</span> (recv_acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          </span><br><span class="line">            acked16 = recv_acked; <span class="comment">//表示已经被确认的字节数</span></span><br><span class="line">            <span class="comment">//调用sent回调函数，通知应用程序可以继续发送数据</span></span><br><span class="line">            TCP_EVENT_SENT(pcb, (<span class="type">u16_t</span>)acked16, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          recv_acked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 延时关闭连接？</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_input_delayed_close(pcb)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> aborted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收到新数据，回调recv函数通知应用程序</span></span><br><span class="line">        <span class="keyword">if</span> (recv_data != <span class="literal">NULL</span>) &#123;  </span><br><span class="line"></span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;pcb-&gt;refused_data == NULL&quot;</span>, pcb-&gt;refused_data == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//TODO 关闭接收，释放内存，同时通知对方接收数据不完整？</span></span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_RXCLOSED) &#123;</span><br><span class="line">            pbuf_free(recv_data);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            tcp_abort(pcb);	<span class="comment">//发送复位报文</span></span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);  <span class="comment">//回调recv函数通知应用程序</span></span><br><span class="line">          <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果上层无法接收数据，则先保存在pcb-&gt;refused_data</span></span><br><span class="line">          <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">            pcb-&gt;refused_data = recv_data;</span><br><span class="line">            LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: keep incoming packet, because pcb is \&quot;full\&quot;\n&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到fin</span></span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;  <span class="comment">//仍然有未被应用读取的数据？</span></span><br><span class="line">            <span class="comment">/* Delay this if we have refused data. */</span></span><br><span class="line">            pcb-&gt;refused_data-&gt;flags |= PBUF_FLAG_TCP_FIN;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* correct rcv_wnd as the application won&#x27;t call tcp_recved()</span></span><br><span class="line"><span class="comment">               for the FIN&#x27;s seqno */</span></span><br><span class="line">            <span class="keyword">if</span> (pcb-&gt;rcv_wnd != TCP_WND_MAX(pcb)) &#123;</span><br><span class="line">              pcb-&gt;rcv_wnd++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用recv通知程序对方准备关闭连接</span></span><br><span class="line">            TCP_EVENT_CLOSED(pcb, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (tcp_input_delayed_close(pcb)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> aborted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Try to send something out. */</span></span><br><span class="line">        tcp_output(pcb);	<span class="comment">//tcp输出</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/30/hello-world/lwip/lwip_TCP_data_in_1/20201217222856148.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_1/" data-id="cmbcy7rhv003bt8mt1s876lsf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_IP_data_in_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_IP_data_in_2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.653Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一-导读"><a href="#一-导读" class="headerlink" title="一 导读"></a>一 导读</h2><p>在上一章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111638632">ip数据输入</a>中，输入的ip分组会被判断是否是一个被分片的分组。若是一个分片的ip数据，则需要将分片暂存起来，等接收完所有的分片再将分片重装成一个完整的ip数据传递给传输层。</p>
<p>这章就介绍lwip如何实现分片的重装。</p>
<h2 id="二，重装数据结构"><a href="#二，重装数据结构" class="headerlink" title="二，重装数据结构"></a>二，重装数据结构</h2><p>由于ip分组在网络传输过程中到达目的地点的时间是不确定的，所以后面的分组可能比前面的分组先达到目的地点。</p>
<p><strong>如图所示，分片A,B,C代表一个完整的ip数据报，他们的目的地址都是192.168.1.1，片偏移的单位是字（32bit），总长度的单位是字节，最后MF标志位表示其后是否有数据。</strong></p>
<p>A分片的片偏移为0，说明它是ip数据的第一个分片，数据长度为1420-20&#x3D;1400.（20字节ip首部）。B分片片偏移为 1400&#x2F;8&#x3D;175；C分片MF为0，说明它是最后一个分片。注意ABC 三分片到达目的站的时间是不确定的。</p>
<p><img src="/2025/05/30/hello-world/lwip/lwip_IP_data_in_2/2020122420583858.jpg" alt="在这里插入图片描述"><br>图中只为方便表示，具体ip首部不是图中所示的位置。</p>
<p><strong>为此，我们需要将接收到的分组先暂存起来，等所有的分组都接收完成，再将数据传递给上层。在lwip中，有专门的结构体负责缓存这些分组。</strong></p>
<p>结合示意图理解结构体成员的意思。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重装数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_reassdata</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_reassdata</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span> <span class="comment">//ip数据报pbuf链</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> <span class="title">iphdr</span>;</span>  <span class="comment">//ip数据报首部（即第一个分组的ip首部）</span></span><br><span class="line">  <span class="type">u16_t</span> datagram_len; <span class="comment">//完整ip数据报大小</span></span><br><span class="line">  <span class="type">u8_t</span> flags; <span class="comment">//标志是否最后一个分组</span></span><br><span class="line">  <span class="type">u8_t</span> timer; <span class="comment">//超时间隔</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>在lwip中会维持一条ip_reassdata链，每一个ip_reassdata结构体代表一个正在重装的ip数据报。当接收到分组时，会将分组的pbuf连接到对应ip_reassdata里的pbuf链中。当该ip数据报接收完整后才递交上层。</strong><br><img src="/2025/05/30/hello-world/lwip/lwip_IP_data_in_2/20201224210537687.png" alt="在这里插入图片描述"><br>在上图中，ip分片首部的8个字节的数据被修改成一个结构体ip_reass_helper，该结构体是用于连接pbuf与判断数据是否完整。定义如下（后面详细分析）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PACK_STRUCT_BEGIN</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_reass_helper</span> &#123;</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="keyword">struct</span> pbuf *next_pbuf);  </span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> start); <span class="comment">//该分组数据起始序号</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> end); <span class="comment">//数据结束序号</span></span><br><span class="line">&#125; PACK_STRUCT_STRUCT;</span><br><span class="line">PACK_STRUCT_END</span><br></pre></td></tr></table></figure>
<h2 id="三，代码分析"><a href="#三，代码分析" class="headerlink" title="三，代码分析"></a>三，代码分析</h2><h3 id="1，分片处理"><a href="#1，分片处理" class="headerlink" title="1，	分片处理"></a>1，	分片处理</h3><p><strong>该函数先检查分片大小是否超出限制，从重装数据报链中找到对应的数据报，将分片插入数据报，根据插入结果决定是否重新组装pbuf成一个完整的ip数据报，递交上层。在理解分片重新组装pbuf时，多结合上面的示意图理解。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将输入的分组插入对应reassdata的pbuf链，若重装完成则返回完整数据的pbuf</span></span><br><span class="line"><span class="keyword">struct</span> pbuf *</span><br><span class="line"><span class="title function_">ip4_reass</span><span class="params">(<span class="keyword">struct</span> pbuf *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">r</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> *<span class="title">fraghdr</span>;</span> <span class="comment">//输入分片的首部</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_reassdata</span> *<span class="title">ipr</span>;</span> <span class="comment">//分片对应的重装数据报</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_reass_helper</span> *<span class="title">iprh</span>;</span> <span class="comment">//pbuf中被强制转换的8个字节，用于指向下一个pbuf与分组起始和结束</span></span><br><span class="line">  <span class="type">u16_t</span> offset, len, clen;  <span class="comment">//offset：片偏移；len：分片长度；clen：分片的pbuf数量</span></span><br><span class="line">  <span class="type">int</span> valid;  <span class="comment">//分片插入链表的结果</span></span><br><span class="line">  <span class="type">int</span> is_last;  <span class="comment">//最后一个分片</span></span><br><span class="line">  </span><br><span class="line">  fraghdr = (<span class="keyword">struct</span> ip_hdr*)p-&gt;payload; <span class="comment">//获取分组首部</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//ip首部不正常</span></span><br><span class="line">  <span class="keyword">if</span> ((IPH_HL(fraghdr) * <span class="number">4</span>) != IP_HLEN) &#123;</span><br><span class="line">    <span class="keyword">goto</span> nullreturn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//得到分组的片偏移量（相对于0的偏移量）</span></span><br><span class="line">  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) &amp; IP_OFFMASK) * <span class="number">8</span>;</span><br><span class="line">  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * <span class="number">4</span>; <span class="comment">//获取分组的数据长度</span></span><br><span class="line"></span><br><span class="line">  clen = pbuf_clen(p);  <span class="comment">//获取输入分组的pbuf数量</span></span><br><span class="line">  <span class="comment">//若将输入报文的pbuf加上reassdatagrams链表所有的pbuf的数量超出限制</span></span><br><span class="line">  <span class="keyword">if</span> ((ip_reass_pbufcount + clen) &gt; IP_REASS_MAX_PBUFS) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IP_REASS_FREE_OLDEST</span></span><br><span class="line">    <span class="comment">//则释放掉最老的reassdatagrams，并再次检查长度是否超出</span></span><br><span class="line">    <span class="keyword">if</span> (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||</span><br><span class="line">        ((ip_reass_pbufcount + clen) &gt; IP_REASS_MAX_PBUFS))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* IP_REASS_FREE_OLDEST */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//长度还是超出，返回错误</span></span><br><span class="line">      <span class="comment">/* @todo: send ICMP time exceeded here? */</span></span><br><span class="line">      <span class="comment">/* drop this pbuf */</span></span><br><span class="line">      <span class="keyword">goto</span> nullreturn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历分组重装链表，找到该分组对应的reassdatagrams</span></span><br><span class="line">  <span class="keyword">for</span> (ipr = reassdatagrams; ipr != <span class="literal">NULL</span>; ipr = ipr-&gt;next) &#123;</span><br><span class="line">    <span class="comment">//找到对应的reassdatagrams，退出循环 此时ipr不为空</span></span><br><span class="line">    <span class="keyword">if</span> (IP_ADDRESSES_AND_ID_MATCH(&amp;ipr-&gt;iphdr, fraghdr)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ipr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//未找到其对应的ip数据报，新建一个数据报</span></span><br><span class="line">    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);</span><br><span class="line">    <span class="keyword">if</span> (ipr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> nullreturn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//找到对应的数据报，若输入分组的片偏移为0，则是数据报的第一个分组</span></span><br><span class="line">    <span class="keyword">if</span> (((lwip_ntohs(IPH_OFFSET(fraghdr)) &amp; IP_OFFMASK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      ((lwip_ntohs(IPH_OFFSET(&amp;ipr-&gt;iphdr)) &amp; IP_OFFMASK) != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//复制输入分组的ip首部到ipr的iphdr成员，由它的首部作为完整数据报的ip首部</span></span><br><span class="line">      SMEMCPY(&amp;ipr-&gt;iphdr, fraghdr, IP_HLEN); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//到此，我们为输入分组找到了对应的数据报</span></span><br><span class="line">  is_last = (IPH_OFFSET(fraghdr) &amp; PP_NTOHS(IP_MF)) == <span class="number">0</span>; <span class="comment">//是否是最后一个分组.MF=0</span></span><br><span class="line">  <span class="keyword">if</span> (is_last) &#123;</span><br><span class="line">    <span class="type">u16_t</span> datagram_len = (<span class="type">u16_t</span>)(offset + len); <span class="comment">//计算数据报长度</span></span><br><span class="line">    <span class="comment">//u16 类型内存溢出</span></span><br><span class="line">    <span class="keyword">if</span> ((datagram_len &lt; offset) || (datagram_len &gt; (<span class="number">0xFFFF</span> - IP_HLEN))) &#123;</span><br><span class="line">     <span class="keyword">goto</span> nullreturn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* @todo: trim pbufs if fragments are overlapping */</span></span><br><span class="line">  <span class="comment">//将分片插入链表并检查重装是否完成</span></span><br><span class="line">  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入失败</span></span><br><span class="line">  <span class="keyword">if</span> (valid == IP_REASS_VALIDATE_PBUF_DROPPED) &#123;</span><br><span class="line">    <span class="keyword">goto</span> nullreturn;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//到此，分片的插入完成</span></span><br><span class="line">  <span class="comment">//ip_reass_pbufcount增加clen个pbuf</span></span><br><span class="line">  ip_reass_pbufcount = (<span class="type">u16_t</span>)(ip_reass_pbufcount + clen);</span><br><span class="line">  <span class="keyword">if</span> (is_last) &#123;</span><br><span class="line">    <span class="comment">//最后一个分片已经到来</span></span><br><span class="line">    <span class="type">u16_t</span> datagram_len = (<span class="type">u16_t</span>)(offset + len); <span class="comment">//计算数据报长度</span></span><br><span class="line">    ipr-&gt;datagram_len = datagram_len;</span><br><span class="line">    ipr-&gt;flags |= IP_REASS_FLAG_LASTFRAG; <span class="comment">//设置数据报标志</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若数据报已完成重装，构建一个存放完整ip数据报的pbuf链（填充首部，连接pbuf），并将ipr从reassdatagrams链表删除</span></span><br><span class="line">  <span class="keyword">if</span> (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_reassdata</span> *<span class="title">ipr_prev</span>;</span></span><br><span class="line">    ipr-&gt;datagram_len += IP_HLEN; <span class="comment">//设置数据报总长度 数据长度+首部长度20字节</span></span><br><span class="line"></span><br><span class="line">    r = ((<span class="keyword">struct</span> ip_reass_helper*)ipr-&gt;p-&gt;payload)-&gt;next_pbuf;  <span class="comment">//保存第二个pbuf（后面有用）</span></span><br><span class="line"></span><br><span class="line">    fraghdr = (<span class="keyword">struct</span> ip_hdr*)(ipr-&gt;p-&gt;payload);  <span class="comment">//fraghdr现在是第一个pbuf的payload，指向ip数据报的首部（我们需要填充这个首部）</span></span><br><span class="line">    SMEMCPY(fraghdr, &amp;ipr-&gt;iphdr, IP_HLEN); <span class="comment">//结合示意图。用之前保存在iphadr中的首部数据填充pbuf首部</span></span><br><span class="line">    IPH_LEN_SET(fraghdr, lwip_htons(ipr-&gt;datagram_len));  <span class="comment">//设置数据报的长度</span></span><br><span class="line">    IPH_OFFSET_SET(fraghdr, <span class="number">0</span>);   <span class="comment">//设置片偏移为0</span></span><br><span class="line">    IPH_CHKSUM_SET(fraghdr, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* @todo: do we need to set/calculate the correct checksum? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_GEN_IP</span></span><br><span class="line">    IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) &#123;</span><br><span class="line">      IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN)); <span class="comment">//设置校验和</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_GEN_IP */</span></span></span><br><span class="line"></span><br><span class="line">    p = ipr-&gt;p; <span class="comment">//p是数据报第一个pbuf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将同一数据报中分片的pbuf链连接连接在一起</span></span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      iprh = (<span class="keyword">struct</span> ip_reass_helper*)r-&gt;payload; <span class="comment">//iprh-&gt;next_pbuf指向下一个分片</span></span><br><span class="line"></span><br><span class="line">      pbuf_header(r, -IP_HLEN); <span class="comment">//将下一个分片第一个pbuf的payload后移，指向数据区，隐藏掉ip首部（我们只需要一个ip首部）</span></span><br><span class="line">      pbuf_cat(p, r); <span class="comment">//将分片的pbuf链 连接到p上</span></span><br><span class="line">      r = iprh-&gt;next_pbuf;  <span class="comment">//获取下一个分片的pbuf链</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定ipr_prev，并删除ipr</span></span><br><span class="line">    <span class="keyword">if</span> (ipr == reassdatagrams) &#123;</span><br><span class="line">      ipr_prev = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (ipr_prev = reassdatagrams; ipr_prev != <span class="literal">NULL</span>; ipr_prev = ipr_prev-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ipr_prev-&gt;next == ipr) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ip_reass_dequeue_datagram(ipr, ipr_prev); <span class="comment">//从链表中删除ipr</span></span><br><span class="line"></span><br><span class="line">    ip_reass_pbufcount -= pbuf_clen(p); <span class="comment">//重装pbuf数量减少</span></span><br><span class="line"></span><br><span class="line">    MIB2_STATS_INC(mib2.ipreasmoks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* the datagram is not (yet?) reassembled completely */</span></span><br><span class="line">  LWIP_DEBUGF(IP_REASS_DEBUG,(<span class="string">&quot;ip_reass_pbufcount: %d out\n&quot;</span>, ip_reass_pbufcount));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">nullreturn:</span><br><span class="line">  LWIP_DEBUGF(IP_REASS_DEBUG,(<span class="string">&quot;ip4_reass: nullreturn\n&quot;</span>));</span><br><span class="line">  IPFRAG_STATS_INC(ip_frag.drop);</span><br><span class="line">  pbuf_free(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，分组插入"><a href="#2，分组插入" class="headerlink" title="2，分组插入"></a>2，分组插入</h3><p><strong>上面提到的将分组插入数据报，其实现也是一个重要的函数。该函数将分片插入链表，并检查链表中的数据是否完整，若数据完整则返回1，在ip4_reass()中就会将完整的数据交给上层。</strong></p>
<p>其中<code>valid</code>值标志数据是否完整。valid初始为1，在分组插入链表的过程中，通过检查分组的数据之间是否连续来修改valid，若有一处的分组不连续，那么数据报肯定不完整，valid为0，只有遍历完链表后valid仍为1且最后一个分组收到时，才说明数据报完整。</p>
<p>在这个函数中，要注意<code>ip_reass_helper</code>这个结构体的作用。该结构体的start和end是判断数据是否连续的关键。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将分片插入分组链</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ip_reass_chain_frag_into_datagram_and_validate</span><span class="params">(<span class="keyword">struct</span> ip_reassdata *ipr, <span class="keyword">struct</span> pbuf *new_p, <span class="type">int</span> is_last)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_reass_helper</span> *<span class="title">iprh</span>, *<span class="title">iprh_tmp</span>, *<span class="title">iprh_prev</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> offset, len;  <span class="comment">//offset：分片片偏移；len：分片数据长度</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> *<span class="title">fraghdr</span>;</span></span><br><span class="line">  <span class="type">int</span> valid = <span class="number">1</span>;  <span class="comment">//数据连续标志。初始化valid为1，当出现前后分组数据不连续时，valid为0，说明数据报不完整</span></span><br><span class="line"></span><br><span class="line">  fraghdr = (<span class="keyword">struct</span> ip_hdr*)new_p-&gt;payload; <span class="comment">//获取当前分片的首部</span></span><br><span class="line">  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * <span class="number">4</span>; <span class="comment">//计算len：分片的数据长度</span></span><br><span class="line">  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) &amp; IP_OFFMASK) * <span class="number">8</span>;  <span class="comment">//计算分片的片偏移</span></span><br><span class="line"></span><br><span class="line">  iprh = (<span class="keyword">struct</span> ip_reass_helper*)new_p-&gt;payload; <span class="comment">//将分片首部的8个字节的数据转换成ip_reass_helper</span></span><br><span class="line">  iprh-&gt;next_pbuf = <span class="literal">NULL</span>;</span><br><span class="line">  iprh-&gt;start = offset; <span class="comment">//填充iprh的开始序号</span></span><br><span class="line">  iprh-&gt;end = offset + len; <span class="comment">//结束序号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历分组链表中的分组的第一个pbuf的ip_reass_helper结构体（序号从小到大）</span></span><br><span class="line">  <span class="comment">//并在合适的位置插入new_pbuf</span></span><br><span class="line">  <span class="keyword">for</span> (q = ipr-&gt;p; q != <span class="literal">NULL</span>;) &#123;</span><br><span class="line">    <span class="comment">//分组的ip_reass_helper，重要！用于确定分组插入位置</span></span><br><span class="line">    iprh_tmp = (<span class="keyword">struct</span> ip_reass_helper*)q-&gt;payload; </span><br><span class="line">    <span class="keyword">if</span> (iprh-&gt;start &lt; iprh_tmp-&gt;start) &#123; </span><br><span class="line">      <span class="comment">//输入分组start小于当前分组，可插入</span></span><br><span class="line">      iprh-&gt;next_pbuf = q;</span><br><span class="line">      <span class="keyword">if</span> (iprh_prev != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="comment">//前面的pbuf与当前的pbuf数据内容出现覆盖</span></span><br><span class="line">        <span class="keyword">if</span> ((iprh-&gt;start &lt; iprh_prev-&gt;end) || (iprh-&gt;end &gt; iprh_tmp-&gt;start)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> freepbuf;</span><br><span class="line">        &#125;</span><br><span class="line">        iprh_prev-&gt;next_pbuf = new_p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前一个pbuf的结尾不等当前pbuf的结尾序号，说明两个pbuf数据不是连续的</span></span><br><span class="line">        <span class="keyword">if</span> (iprh_prev-&gt;end != iprh-&gt;start) &#123;</span><br><span class="line">          valid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//当前分片偏移最小</span></span><br><span class="line">        <span class="comment">//若当前分片出现覆盖，退出</span></span><br><span class="line">        <span class="keyword">if</span> (iprh-&gt;end &gt; iprh_tmp-&gt;start) &#123;</span><br><span class="line">          <span class="keyword">goto</span> freepbuf;</span><br><span class="line">        &#125;</span><br><span class="line">        ipr-&gt;p = new_p; <span class="comment">//插入链表的最前</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iprh-&gt;start == iprh_tmp-&gt;start) &#123;  <span class="comment">//接收到重复的分组</span></span><br><span class="line">      <span class="keyword">goto</span> freepbuf;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iprh-&gt;start &lt; iprh_tmp-&gt;end) &#123;   <span class="comment">//分片的内容与iprh_temp的内容重叠，退出</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">goto</span> freepbuf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//iprh-&gt;start &gt; iprh_tmp-&gt;end</span></span><br><span class="line">      <span class="comment">//检查数据报是否连续</span></span><br><span class="line">      <span class="keyword">if</span> (iprh_prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iprh_prev-&gt;end != iprh_tmp-&gt;start) &#123;</span><br><span class="line">          valid = <span class="number">0</span>;  <span class="comment">//不连续</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q = iprh_tmp-&gt;next_pbuf;  <span class="comment">//检查下一个分片</span></span><br><span class="line">    iprh_prev = iprh_tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//若q为null，输入分组序号最高 则说明分组应该在链表的最末</span></span><br><span class="line">    <span class="keyword">if</span> (iprh_prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      iprh_prev-&gt;next_pbuf = new_p; <span class="comment">//插入链尾</span></span><br><span class="line">      <span class="comment">//判断是否连续</span></span><br><span class="line">      <span class="keyword">if</span> (iprh_prev-&gt;end != iprh-&gt;start) &#123;</span><br><span class="line">        valid = <span class="number">0</span>;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ipr-&gt;p = new_p; <span class="comment">//到这里只能是链表为null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若最后一个分组已经收到</span></span><br><span class="line">  <span class="keyword">if</span> (is_last || ((ipr-&gt;flags &amp; IP_REASS_FLAG_LASTFRAG) != <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">//且输入分片与它前面的分片的数据连续无断点</span></span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="comment">//检查数据报首部是否为null或者偏移是不是0</span></span><br><span class="line">      <span class="keyword">if</span> ((ipr-&gt;p == <span class="literal">NULL</span>) || (((<span class="keyword">struct</span> ip_reass_helper*)ipr-&gt;p-&gt;payload)-&gt;start != <span class="number">0</span>)) &#123;</span><br><span class="line">        valid = <span class="number">0</span>;  <span class="comment">//以上情况说不对</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//检查输入分组之后的分组是否也是连续的</span></span><br><span class="line">        iprh_prev = iprh; </span><br><span class="line">        q = iprh-&gt;next_pbuf;  <span class="comment">//从输入分组之后开始遍历检查</span></span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          iprh = (<span class="keyword">struct</span> ip_reass_helper*)q-&gt;payload;</span><br><span class="line">          <span class="keyword">if</span> (iprh_prev-&gt;end != iprh-&gt;start) &#123;</span><br><span class="line">            <span class="comment">//出现不连续的数据</span></span><br><span class="line">            valid = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//跳出循环。不用再检查了。</span></span><br><span class="line">          &#125;</span><br><span class="line">          iprh_prev = iprh;</span><br><span class="line">          q = iprh-&gt;next_pbuf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;sanity check&quot;</span>, ipr-&gt;p != <span class="literal">NULL</span>);</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;sanity check&quot;</span>,</span><br><span class="line">            ((<span class="keyword">struct</span> ip_reass_helper*)ipr-&gt;p-&gt;payload) != iprh);</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;validate_datagram:next_pbuf!=NULL&quot;</span>,</span><br><span class="line">            iprh-&gt;next_pbuf == <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回1说明数据报重装完成</span></span><br><span class="line">    <span class="keyword">return</span> valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If we come here, not all fragments were received, yet! */</span></span><br><span class="line">  <span class="keyword">return</span> IP_REASS_VALIDATE_PBUF_QUEUED; <span class="comment">/* not yet valid! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IP_REASS_CHECK_OVERLAP</span></span><br><span class="line">freepbuf:</span><br><span class="line">  ip_reass_pbufcount -= pbuf_clen(new_p);</span><br><span class="line">  pbuf_free(new_p);</span><br><span class="line">  <span class="keyword">return</span> IP_REASS_VALIDATE_PBUF_DROPPED;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* IP_REASS_CHECK_OVERLAP */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/30/hello-world/lwip/lwip_IP_data_in_2/20201224220223910.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_IP_data_in_2/" data-id="cmbcy7rhs0030t8mtcimh71qf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_IP_data_out" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_IP_data_out/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.653Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，导读"><a href="#一，导读" class="headerlink" title="一，导读"></a>一，导读</h2><p>lwip提供接口给传输层，使传输层能将数据传递给ip层。本章介绍该接口函数如何实现将传输层的数据封装成ip数据报，并将数据报发送出去。</p>
<h2 id="二，源码分析"><a href="#二，源码分析" class="headerlink" title="二，源码分析"></a>二，源码分析</h2><p>运输层，以TCP协议为例，调用ip_output_if()将tcp数据报传递给ip层，ip_output_if()会根据目的ip选择不同ip版本发送函数。</p>
<h3 id="1，ipv4输出"><a href="#1，ipv4输出" class="headerlink" title="1，ipv4输出"></a>1，ipv4输出</h3><p>若目的ip是ipv4，则使用以下函数发送。</p>
<p><strong>该函数将上层数据报封装成ip数据，并填充ip首部，调用网络接口的发送函数发送数据。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过netif输出ip数据报 pbuf</span></span><br><span class="line"><span class="type">err_t</span> <span class="title function_">ip4_output_if_src</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="type">const</span> <span class="type">ip4_addr_t</span> *src, <span class="type">const</span> <span class="type">ip4_addr_t</span> *dest,</span></span><br><span class="line"><span class="params">             <span class="type">u8_t</span> ttl, <span class="type">u8_t</span> tos,</span></span><br><span class="line"><span class="params">             <span class="type">u8_t</span> proto, <span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> *<span class="title">iphdr</span>;</span></span><br><span class="line">  <span class="type">ip4_addr_t</span> dest_addr;</span><br><span class="line">  <span class="type">u32_t</span> chk_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//目的ip地址不在pbuf中</span></span><br><span class="line">  <span class="keyword">if</span> (dest != LWIP_IP_HDRINCL) &#123;</span><br><span class="line">    <span class="type">u16_t</span> ip_hlen = IP_HLEN;  <span class="comment">//ip首部长度20字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pbuf的payload前移20字节作为ip首部</span></span><br><span class="line">    <span class="keyword">if</span> (pbuf_header(p, IP_HLEN)) &#123;</span><br><span class="line">	  <span class="comment">//移动失败 返回</span></span><br><span class="line">      <span class="keyword">return</span> ERR_BUF;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    iphdr = (<span class="keyword">struct</span> ip_hdr *)p-&gt;payload;  <span class="comment">//payload指向ip首部，接下来要填充ip首部</span></span><br><span class="line"></span><br><span class="line">    IPH_TTL_SET(iphdr, ttl);  <span class="comment">//设置ip存活时间</span></span><br><span class="line">    IPH_PROTO_SET(iphdr, proto);  <span class="comment">//协议类型</span></span><br><span class="line"></span><br><span class="line">    chk_sum += PP_NTOHS(proto | (ttl &lt;&lt; <span class="number">8</span>));  <span class="comment">//校验和</span></span><br><span class="line"></span><br><span class="line">    ip4_addr_copy(iphdr-&gt;dest, *dest);  <span class="comment">//填充目的ip</span></span><br><span class="line">	<span class="comment">//更新校验和</span></span><br><span class="line">    chk_sum += ip4_addr_get_u32(&amp;iphdr-&gt;dest) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    chk_sum += ip4_addr_get_u32(&amp;iphdr-&gt;dest) &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    IPH_VHL_SET(iphdr, <span class="number">4</span>, ip_hlen / <span class="number">4</span>); <span class="comment">//填充版本号和首部长度</span></span><br><span class="line">    IPH_TOS_SET(iphdr, tos);  <span class="comment">//设置服务类型</span></span><br><span class="line"></span><br><span class="line">    chk_sum += PP_NTOHS(tos | (iphdr-&gt;_v_hl &lt;&lt; <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    IPH_LEN_SET(iphdr, lwip_htons(p-&gt;tot_len));</span><br><span class="line"></span><br><span class="line">    chk_sum += iphdr-&gt;_len;</span><br><span class="line"></span><br><span class="line">    IPH_OFFSET_SET(iphdr, <span class="number">0</span>); <span class="comment">//设置第一个分片的片偏移量0</span></span><br><span class="line">    IPH_ID_SET(iphdr, lwip_htons(ip_id)); <span class="comment">//填充标志位</span></span><br><span class="line"></span><br><span class="line">    chk_sum += iphdr-&gt;_id;</span><br><span class="line"></span><br><span class="line">    ++ip_id;  <span class="comment">//ip_id更新，ip_id用于填充ip数据报的id字段，每个ip数据报不一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充源ip地址</span></span><br><span class="line">    <span class="keyword">if</span> (src == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//若src是null，使用0.0.0.0 广播地址？</span></span><br><span class="line">      ip4_addr_copy(iphdr-&gt;src, *IP4_ADDR_ANY4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//否则复制输入的源ip</span></span><br><span class="line">      ip4_addr_copy(iphdr-&gt;src, *src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算校验和</span></span><br><span class="line">    chk_sum += ip4_addr_get_u32(&amp;iphdr-&gt;src) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    chk_sum += ip4_addr_get_u32(&amp;iphdr-&gt;src) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    chk_sum = (chk_sum &gt;&gt; <span class="number">16</span>) + (chk_sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    chk_sum = (chk_sum &gt;&gt; <span class="number">16</span>) + chk_sum;</span><br><span class="line">    chk_sum = ~chk_sum;</span><br><span class="line">    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) &#123;</span><br><span class="line">      iphdr-&gt;_chksum = (<span class="type">u16_t</span>)chk_sum; <span class="comment">/* network order */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) &#123;</span><br><span class="line">      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//ip首部已经在pbuf中</span></span><br><span class="line">    iphdr = (<span class="keyword">struct</span> ip_hdr *)p-&gt;payload;</span><br><span class="line">    ip4_addr_copy(dest_addr, iphdr-&gt;dest);</span><br><span class="line">    dest = &amp;dest_addr;	<span class="comment">//获取目的ip</span></span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若发送的数据长度大于网络接口支持的最大长度，则进行ip分片</span></span><br><span class="line">  <span class="keyword">if</span> (netif-&gt;mtu &amp;&amp; (p-&gt;tot_len &gt; netif-&gt;mtu)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ip4_frag(p, netif, dest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> netif-&gt;output(netif, p, dest); <span class="comment">//调用网络接口的发送函数（链路层）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中需要注意的是<strong>当tcp层进行报文重传时，传递下来的数据是一个之前封装完成的ip数据，所以直接调用接口发送函数就行。dest为null时，说明这是一个重传的报文。</strong></p>
<h3 id="2，ip数据分片发送"><a href="#2，ip数据分片发送" class="headerlink" title="2，ip数据分片发送"></a>2，ip数据分片发送</h3><p>ip层发送的分组大小是受接口的最大数据帧限制的。若发送的ip数据大于接口最大数据帧长度(mtu)，需要将ip数据进行分片发送。</p>
<p>在lwip中，ip4_frag()完成该功能。</p>
<p>在开始代码前，需要先认识一位新朋友，结构体 <code>pbuf_custom_ref</code> 它两个成员，pc是它本身的pbuf，original是它所引用的pbuf，pc的payload指向original的数据区。使用这个结构体是为了避免在分片时对输入的pbuf链进行复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom_ref</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom</span> <span class="title">pc</span>;</span>  <span class="comment">//本地的pbuf</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">original</span>;</span>  <span class="comment">//引用的pbuf</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>分片过程如下图</strong><br><img src="/2025/05/30/hello-world/lwip/lwip_IP_data_out/20201225002927134.jpg" alt="在这里插入图片描述"><br><strong>该函数所做的就是上图所示。把输入的pbuf链中切割成等长的分片，再将分片通过接口的发送函数neitif-&gt;output()发送出去。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span> <span class="title function_">ip4_frag</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *netif, <span class="type">const</span> <span class="type">ip4_addr_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">rambuf</span>;</span>  <span class="comment">//分片的第一个pbuf</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !LWIP_NETIF_TX_SINGLE_PBUF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">newpbuf</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> newpbuflen = <span class="number">0</span>;</span><br><span class="line">  <span class="type">u16_t</span> left_to_copy; <span class="comment">//一个分片中需要复制的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> *<span class="title">original_iphdr</span>;</span>  <span class="comment">//第一个分片ip首部</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> *<span class="title">iphdr</span>;</span>	</span><br><span class="line">  <span class="type">const</span> <span class="type">u16_t</span> nfb = (netif-&gt;mtu - IP_HLEN) / <span class="number">8</span>; <span class="comment">//分片中允许最大数据量</span></span><br><span class="line">  <span class="type">u16_t</span> left, fragsize; <span class="comment">//left：剩下未复制的数据，fragsize：分片大小</span></span><br><span class="line">  <span class="type">u16_t</span> ofo;  <span class="comment">//分片偏移量</span></span><br><span class="line">  <span class="type">int</span> last; <span class="comment">//最后一个分片标志</span></span><br><span class="line">  <span class="type">u16_t</span> poff = IP_HLEN; <span class="comment">//数据在pbuf中的偏移（ip数据第一个pbuf的poff为20，其余为0）</span></span><br><span class="line">  <span class="type">u16_t</span> tmp;  <span class="comment">//offset偏移字段（3位标志+13位分片偏移量）</span></span><br><span class="line"></span><br><span class="line">  original_iphdr = (<span class="keyword">struct</span> ip_hdr *)p-&gt;payload; <span class="comment">//指向当前ip数据首部</span></span><br><span class="line">  iphdr = original_iphdr;</span><br><span class="line">  </span><br><span class="line">  tmp = lwip_ntohs(IPH_OFFSET(iphdr));  <span class="comment">//暂存第一个分片offset字段 </span></span><br><span class="line">  ofo = tmp &amp; IP_OFFMASK; <span class="comment">//得到分片偏移量 应该是0？</span></span><br><span class="line"> </span><br><span class="line">  left = p-&gt;tot_len - IP_HLEN;  <span class="comment">//待发送的数据长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将数据分片并发送</span></span><br><span class="line">  <span class="keyword">while</span> (left) &#123;</span><br><span class="line"></span><br><span class="line">    fragsize = LWIP_MIN(left, nfb * <span class="number">8</span>); <span class="comment">//计算当前分片有效数据大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请一个ram类型pbuf，其包含链路层的首部和ip首部，作为分片的第一个pbuf</span></span><br><span class="line">    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);  </span><br><span class="line">    <span class="keyword">if</span> (rambuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> memerr;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    SMEMCPY(rambuf-&gt;payload, original_iphdr, IP_HLEN);  <span class="comment">//将源ip的首部复制到rambuf的payload，ranbuf是一个链路层的数据包了</span></span><br><span class="line">    iphdr = (<span class="keyword">struct</span> ip_hdr *)rambuf-&gt;payload; <span class="comment">//现在修改iphdr，使其指向第一个分片首部</span></span><br><span class="line"></span><br><span class="line">    left_to_copy = fragsize;	<span class="comment">//需要复制的数据大小等于当前分片有效数据的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用pbuf链填充ip分片，该pbuf链引用了原pbuf</span></span><br><span class="line">    <span class="keyword">while</span> (left_to_copy) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom_ref</span> *<span class="title">pcr</span>;</span>  <span class="comment">//此类型pbuf引用其他pbuf</span></span><br><span class="line">      <span class="type">u16_t</span> plen = p-&gt;len - poff; <span class="comment">//当复制第一个pbuf时，plen=p-&gt;len-20，否则plen=p-&gt;len</span></span><br><span class="line">      newpbuflen = LWIP_MIN(left_to_copy, plen);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (!newpbuflen) &#123;  <span class="comment">//plen=0，要复制的pbuf的数据为0，跳过它</span></span><br><span class="line">        poff = <span class="number">0</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//申请一个ref的pbuf</span></span><br><span class="line">      pcr = ip_frag_alloc_pbuf_custom_ref();</span><br><span class="line">      <span class="keyword">if</span> (pcr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pbuf_free(rambuf);</span><br><span class="line">        <span class="keyword">goto</span> memerr;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">//将p中newpbuflen长度的数据复制到pcr-&gt;pc的pbuf（pcr-&gt;pc的pbuf的payload指向ip数据）</span></span><br><span class="line">      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &amp;pcr-&gt;pc,</span><br><span class="line">        (<span class="type">u8_t</span>*)p-&gt;payload + poff, newpbuflen);</span><br><span class="line">      <span class="comment">//此时，newbuf指向pcr-&gt;pc，newbuf的payload指向p的一段数据</span></span><br><span class="line">      <span class="keyword">if</span> (newpbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ip_frag_free_pbuf_custom_ref(pcr);</span><br><span class="line">        pbuf_free(rambuf);</span><br><span class="line">        <span class="keyword">goto</span> memerr;</span><br><span class="line">      &#125;</span><br><span class="line">      pbuf_ref(p);  <span class="comment">//p的引用次数++</span></span><br><span class="line">      pcr-&gt;original = p;  <span class="comment">//pcr的源pbuf指向p</span></span><br><span class="line">      pcr-&gt;pc.custom_free_function = ipfrag_free_pbuf_custom; <span class="comment">//初始化pbuf_custom_ref释放函数</span></span><br><span class="line"></span><br><span class="line">      pbuf_cat(rambuf, newpbuf);  <span class="comment">//将newpbuf插入rambuf链表尾</span></span><br><span class="line">      left_to_copy -= newpbuflen; <span class="comment">//更新接下来需要复制的数据量</span></span><br><span class="line">      <span class="keyword">if</span> (left_to_copy) &#123; <span class="comment">//若还有数据需要复制</span></span><br><span class="line">        poff = <span class="number">0</span>; <span class="comment">//p的偏移应该为0，因为除了第一个p的payload中包含首部，其余的pbuf的payload中全是数据（看图）</span></span><br><span class="line">        p = p-&gt;next;  <span class="comment">//接着复制下一个pbuf</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充完一个分片，此时pbuf的偏移为newpbuflen。</span></span><br><span class="line">    poff += newpbuflen;</span><br><span class="line">	<span class="comment">//是否是最后最后一个分片</span></span><br><span class="line">    last = (left &lt;= netif-&gt;mtu - IP_HLEN);</span><br><span class="line">	<span class="comment">//设置offset字段</span></span><br><span class="line">    tmp = (IP_OFFMASK &amp; (ofo));</span><br><span class="line">    <span class="keyword">if</span> (!last) &#123;</span><br><span class="line">      tmp = tmp | IP_MF;  <span class="comment">//不是最后一个分片，设置标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充当前分片的首部</span></span><br><span class="line">    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));</span><br><span class="line">    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));</span><br><span class="line">    IPH_CHKSUM_SET(iphdr, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_GEN_IP</span></span><br><span class="line">    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) &#123;</span><br><span class="line">      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN)); <span class="comment">//由首部计算校验和</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_GEN_IP */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络接口输出分片</span></span><br><span class="line">    netif-&gt;output(netif, rambuf, dest);</span><br><span class="line">    </span><br><span class="line">    pbuf_free(rambuf);  <span class="comment">//释放pbuf</span></span><br><span class="line">    left -= fragsize; <span class="comment">//更新剩下的未发送的数据</span></span><br><span class="line">    ofo += nfb; <span class="comment">//更新分片的片偏移（分片偏移量增加一个分片的长度）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">memerr:</span><br><span class="line">  MIB2_STATS_INC(mib2.ipfragfails);</span><br><span class="line">  <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3，ipv6输出"><a href="#3，ipv6输出" class="headerlink" title="3，ipv6输出"></a>3，ipv6输出</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_IP_data_out/" data-id="cmbcy7rht0033t8mt91mj6b2w" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_TCP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.653Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，TCP层简介"><a href="#一，TCP层简介" class="headerlink" title="一，TCP层简介"></a>一，TCP层简介</h2><h2 id="二，tcp-h简介"><a href="#二，tcp-h简介" class="headerlink" title="二，tcp.h简介"></a>二，tcp.h简介</h2><p>tcp.h与tcp.c是tcp层协议实现的重要代码，tcp.h定义了实现该层功能的数据结构tcp_pcb和所有的接口函数。</p>
<p>首先介绍tcp层的主角，tcp_pcb结构体的功能大概如图，结构体成员的具体含意在代码注释中给出。<br><img src="/2025/05/30/hello-world/lwip/lwip_TCP/20201219155652497.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> &#123;</span></span><br><span class="line">  IP_PCB; <span class="comment">//ip层的成员（ip地址等）</span></span><br><span class="line"></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb);</span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> remote_port;  <span class="comment">//tcp层的远端端口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">tcpflags_t</span> flags;   <span class="comment">//tcp传输中的标志，如下：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_ACK_DELAY   0x01U   <span class="comment">/* 延迟回答 ack会在fastmr定时器中被发送 Delayed ACK.*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_ACK_NOW     0x02U   <span class="comment">/* 立即回答 Immediate ACK. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_INFR        0x04U   <span class="comment">/* 快速重连状态 In fast recovery. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_CLOSEPEND   0x08U   <span class="comment">/* fin报文fastmr定时器中被发送*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_RXCLOSED    0x10U   <span class="comment">/* 关闭接收 rx closed by tcp_shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_FIN         0x20U   <span class="comment">/* 本地主动请求关闭Connection was closed locally (FIN segment enqueued). */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_NODELAY     0x40U   <span class="comment">/* Disable Nagle algorithm 禁止Nagle算法*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_NAGLEMEMERR 0x80U   <span class="comment">/* nagle enabled, memerr, try to output to prevent delayed ACK to happen */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> polltmr, pollinterval; <span class="comment">//polltmr&gt;pollinterval时，回调 tcp_poll_fn</span></span><br><span class="line">  <span class="type">u8_t</span> last_timer;  <span class="comment">//上次进入定时任务的时刻</span></span><br><span class="line">  <span class="type">u32_t</span> tmr;  <span class="comment">//保活定时器有关，当接收到对方的数据时会更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">u32_t</span> rcv_nxt;   <span class="comment">//接收窗口期待的下一个序号</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_wnd;   <span class="comment">//接收窗口长度</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_ann_wnd; <span class="comment">//通告窗口（通知对方本地的接收窗口大小）</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_ann_right_edge; <span class="comment">//通告窗口的右边界 rcv_nxt+rcv_ann_wnd </span></span><br><span class="line"></span><br><span class="line">  <span class="type">s16_t</span> rtime;  <span class="comment">//重传定时器</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> mss;   <span class="comment">//最大报文长度</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u32_t</span> rttest; <span class="comment">//RTT估测  rttest=tcpticks开启rtt，rttest=0关闭 </span></span><br><span class="line">  <span class="type">u32_t</span> rtseq;  <span class="comment">// rtt测试的报文序号 </span></span><br><span class="line">  <span class="type">s16_t</span> sa, sv; <span class="comment">/* @todo document this */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">s16_t</span> rto;    <span class="comment">//重发超时时间 rtime&gt;rto时触发超时重传 rto是动态计算的</span></span><br><span class="line">  <span class="type">u8_t</span> nrtx;    <span class="comment">//重传次数&lt;7 </span></span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> dupacks; <span class="comment">//快速重连，回答重复次数</span></span><br><span class="line">  <span class="type">u32_t</span> lastack; <span class="comment">//最高的应答序号 Highest acknowledged seqno. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> cwnd; <span class="comment">//拥塞窗口</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> ssthresh; <span class="comment">//拥塞算法启动条件</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u32_t</span> snd_nxt;   <span class="comment">//下一个将被发送的序号</span></span><br><span class="line">  <span class="type">u32_t</span> snd_wl1, snd_wl2; <span class="comment">//上次收到报文的序号和确认序号</span></span><br><span class="line">                          <span class="comment">//snd_wl1 = last seqno</span></span><br><span class="line">                          <span class="comment">//snd_wl2 = last ackno </span></span><br><span class="line">  <span class="type">u32_t</span> snd_lbb;       <span class="comment">//下一个要被送入buffer的序号（发送窗口最右）</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd;   <span class="comment">//发送窗口大小（由接收方大小决定）</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd_max; <span class="comment">//远程端口声明的最大发送窗口 </span></span><br><span class="line"></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_buf;   <span class="comment">//当前可用的发送缓存大小 </span></span><br><span class="line">  <span class="type">u16_t</span> snd_queuelen; <span class="comment">//unsent队列中的pbuf数量</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> unsent_oversize;  <span class="comment">//unsent队列最后一个pbuf的剩余字节</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">unsent</span>;</span>   <span class="comment">//未发送的报文链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">unacked</span>;</span>  <span class="comment">//发送未确认的报文链表 </span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">ooseq</span>;</span>    <span class="comment">//接收到的无序报文链表（序号小的在前）</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">refused_data</span>;</span> <span class="comment">//已接收但未送到上层应用</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span>* <span class="title">listener</span>;</span>  <span class="comment">//监听控制块</span></span><br><span class="line"></span><br><span class="line">  tcp_sent_fn sent;	<span class="comment">//回调函数：当报文被对方确认时执行，用于释放资源</span></span><br><span class="line"></span><br><span class="line">  tcp_recv_fn recv;	<span class="comment">//回调函数：当接收到数据时执行</span></span><br><span class="line">  </span><br><span class="line">  tcp_connected_fn connected;	<span class="comment">//回调函数：当tcp连接建立时执行</span></span><br><span class="line">  </span><br><span class="line">  tcp_poll_fn poll;	<span class="comment">//周期回调函数：用于处理一些超时等</span></span><br><span class="line"></span><br><span class="line">  tcp_err_fn errf;	<span class="comment">//回调函数：当接收到RST报文或其他异常断开时执行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP_TIMESTAMPS <span class="comment">//使用tcp时间戳</span></span></span><br><span class="line">  <span class="type">u32_t</span> ts_lastacksent;</span><br><span class="line">  <span class="type">u32_t</span> ts_recent;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">u32_t</span> keep_idle;  <span class="comment">//保活机制，超过此值，发送探查检查连接</span></span><br><span class="line">  <span class="type">u8_t</span> persist_cnt; <span class="comment">//坚持定时器，当计数值超过某个值时，则发出零窗口探查数据包</span></span><br><span class="line">  <span class="type">u8_t</span> persist_backoff; <span class="comment">//发出探查包的次数以及是否开启坚持</span></span><br><span class="line">  <span class="type">u8_t</span> keep_cnt_sent; <span class="comment">//发送保活探查报文的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tcp_pcb * <span class="title function_">tcp_new</span>     <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//新建一个默认pcb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册各个回调函数及参数</span></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_recv</span>    <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, tcp_recv_fn recv)</span>; <span class="comment">//接收回调</span></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_sent</span>    <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, tcp_sent_fn sent)</span>;	<span class="comment">//发送回调</span></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_err</span>     <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, tcp_err_fn err)</span>;	<span class="comment">//错误回调</span></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_accept</span>  <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, tcp_accept_fn accept)</span>;	<span class="comment">//连接回调</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_poll</span>    <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, tcp_poll_fn poll, <span class="type">u8_t</span> interval)</span>;	<span class="comment">//周期回调</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_recved</span>  <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">u16_t</span> len)</span>;  <span class="comment">//应用处理完数据后，必须调用此函数来更新通告窗口；len：被应用程序读取的数据长度</span></span><br><span class="line"><span class="type">err_t</span>            <span class="title function_">tcp_bind</span>    <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">const</span> <span class="type">ip_addr_t</span> *ipaddr, <span class="comment">//将pcb绑定到本地某端口</span></span></span><br><span class="line"><span class="params">                              <span class="type">u16_t</span> port)</span>;</span><br><span class="line"><span class="type">err_t</span>            <span class="title function_">tcp_connect</span> <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">const</span> <span class="type">ip_addr_t</span> *ipaddr, <span class="comment">//将pcb连接到远程端口，connected为连接成功回调函数</span></span></span><br><span class="line"><span class="params">                              <span class="type">u16_t</span> port, tcp_connected_fn connected)</span>;</span><br><span class="line">                              </span><br><span class="line"><span class="comment">//pcb开始监听绑定的端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_abort</span> <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span>; <span class="comment">//暴力删除pcb并给对方发送rst</span></span><br><span class="line"></span><br><span class="line"><span class="type">err_t</span>            <span class="title function_">tcp_close</span>   <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span>; <span class="comment">//按步骤断开双方连接</span></span><br><span class="line"><span class="type">err_t</span>            <span class="title function_">tcp_shutdown</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">int</span> shut_rx, <span class="type">int</span> shut_tx)</span>; <span class="comment">//关闭连接（可选择是否发送rst使对方也关闭）</span></span><br><span class="line"></span><br><span class="line"><span class="type">err_t</span>            <span class="title function_">tcp_write</span>   <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">const</span> <span class="type">void</span> *dataptr, <span class="type">u16_t</span> len,  <span class="comment">//将数据写入发送buffer</span></span></span><br><span class="line"><span class="params">                              <span class="type">u8_t</span> apiflags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>             <span class="title function_">tcp_setprio</span> <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">u8_t</span> prio)</span>;  <span class="comment">//设置pcb优先级</span></span><br><span class="line"></span><br><span class="line"><span class="type">err_t</span>            <span class="title function_">tcp_output</span>  <span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span>; <span class="comment">//输出tcp报文</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP/" data-id="cmbcy7rht0034t8mt8x1z1p3k" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/cJSON/3.cJSON_Print()" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/cJSON/3.cJSON_Print()/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.652Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>cJSON系列：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110395913">零基础学习cJSON 源码详解与应用（一）如何学习cJSON</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110406265">零基础学习cJSON 源码详解与应用（二）创建json数据</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110475966">零基础学习cJSON 源码详解与应用 （三）cJSON_Print()；打印json
</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110481533">零基础学习cJSON 源码详解与应用 （四）cJSON_Parse()；解析json字符串</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110499109">零基础学习cJSON 源码详解与应用 （五）修改，复制，比较cjson</a></li>
</ul>
</blockquote>
<blockquote>
<p>继上一章之后，这章讲json的打印。json存在的目的是为了数据交换的方便，而数据交换就比较通过传输来实现，json在互联网上的传输是以字符串的形式进行的，这就需要将cjson中一个个结构体打印成标准的json的字符串形式。</p>
</blockquote>
<h2 id="一，cJSON-Print-源码分析"><a href="#一，cJSON-Print-源码分析" class="headerlink" title="一，cJSON_Print();源码分析"></a>一，cJSON_Print();源码分析</h2><blockquote>
<p>CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);</p>
</blockquote>
<p><code>注意，返回的字符串指针是通过动态内存分配的，使用完成后应该释放内存。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将一个json结构体及其子json输出为字符串</span></span><br><span class="line"><span class="comment"> * note：使用完字符串后要记得释放内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CJSON_PUBLIC(<span class="type">char</span> *) cJSON_Print(<span class="type">const</span> cJSON *item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)print(item, <span class="literal">true</span>, &amp;global_hooks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实调用的是print()函数，其中的format参数为true，说明默认是格式化输出（效果就是有换行，TAB等特殊符号）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将json转为字符串</span></span><br><span class="line"><span class="comment"> * format：true：格式化打印</span></span><br><span class="line"><span class="comment"> * 返回：字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">print</span><span class="params">(<span class="type">const</span> cJSON * <span class="type">const</span> item, cJSON_bool format, <span class="type">const</span> internal_hooks * <span class="type">const</span> hooks)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认print_buff长度，需要根据json结构体修改</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> default_buffer_size = <span class="number">256</span>;  </span><br><span class="line">    printbuffer buffer[<span class="number">1</span>];  <span class="comment">//用于存储输出字符串</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *printed = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//内存初始为0</span></span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建默认的buff</span></span><br><span class="line">    buffer-&gt;buffer = (<span class="type">unsigned</span> <span class="type">char</span>*) hooks-&gt;allocate(default_buffer_size);</span><br><span class="line">    buffer-&gt;length = default_buffer_size;</span><br><span class="line">    buffer-&gt;format = format;</span><br><span class="line">    buffer-&gt;hooks = *hooks;</span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印item的内容到buffer</span></span><br><span class="line">    <span class="keyword">if</span> (!print_value(item, buffer))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新buffer的指针偏移</span></span><br><span class="line">    update_offset(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新分配print_buffer的缓存，并将指针赋值给printed</span></span><br><span class="line">    <span class="keyword">if</span> (hooks-&gt;reallocate != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//reallocate在原指针上进行再分配</span></span><br><span class="line">        printed = (<span class="type">unsigned</span> <span class="type">char</span>*) hooks-&gt;reallocate(buffer-&gt;buffer, buffer-&gt;offset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (printed == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* otherwise copy the JSON over to a new buffer */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//系统不支持reallocate，给指针printed重新分配内存，复制并释放buffer-&gt;buffer</span></span><br><span class="line">        printed = (<span class="type">unsigned</span> <span class="type">char</span>*) hooks-&gt;allocate(buffer-&gt;offset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (printed == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(printed, buffer-&gt;buffer, cjson_min(buffer-&gt;length, buffer-&gt;offset + <span class="number">1</span>));</span><br><span class="line">        printed[buffer-&gt;offset] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* just to be sure */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free the buffer */</span></span><br><span class="line">        hooks-&gt;deallocate(buffer-&gt;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指向打印的字符串的指针</span></span><br><span class="line">    <span class="keyword">return</span> printed;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;buffer != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hooks-&gt;deallocate(buffer-&gt;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (printed != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hooks-&gt;deallocate(printed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要认识一下<code>printbuff结构体</code>该结构体用于辅助打印json：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存json的输出内容</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer;  <span class="comment">//存放结果字符串</span></span><br><span class="line">    <span class="type">size_t</span> length;  <span class="comment">//内存总长度</span></span><br><span class="line">    <span class="type">size_t</span> offset;  <span class="comment">//字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> depth; <span class="comment">//嵌套的层数/* current nesting depth (for formatted printing) */</span></span><br><span class="line">    cJSON_bool noalloc;</span><br><span class="line">    cJSON_bool format; <span class="comment">/* is this print a formatted print */</span></span><br><span class="line">    internal_hooks hooks;</span><br><span class="line">&#125; printbuffer;</span><br></pre></td></tr></table></figure>
<p>另外代码中出现了两个比较重要的函数：<code>print_value()</code>,<code>update_offset()</code>接下来将详解他们；</p>
<h2 id="二，print-value"><a href="#二，print-value" class="headerlink" title="二，print_value();"></a>二，print_value();</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印item内容到output_buffer</span></span><br><span class="line"><span class="comment"> * 成功：true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">print_value</span><span class="params">(<span class="type">const</span> cJSON * <span class="type">const</span> item, printbuffer * <span class="type">const</span> output_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((item == <span class="literal">NULL</span>) || (output_buffer == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据item的类型，打印内容</span></span><br><span class="line">    <span class="keyword">switch</span> ((item-&gt;type) &amp; <span class="number">0xFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> cJSON_NULL:</span><br><span class="line">            <span class="comment">//确保输出内存足够</span></span><br><span class="line">            output = ensure(output_buffer, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符串复制</span></span><br><span class="line">            <span class="built_in">strcpy</span>((<span class="type">char</span>*)output, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cJSON_False:</span><br><span class="line">            output = ensure(output_buffer, <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>((<span class="type">char</span>*)output, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cJSON_True:</span><br><span class="line">            output = ensure(output_buffer, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>((<span class="type">char</span>*)output, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cJSON_Number:</span><br><span class="line">            <span class="keyword">return</span> print_number(item, output_buffer);</span><br><span class="line">        <span class="comment">//若是原生的json字符串数据，则直接取item-&gt;valuestring</span></span><br><span class="line">        <span class="keyword">case</span> cJSON_Raw:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> raw_length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;valuestring == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            raw_length = <span class="built_in">strlen</span>(item-&gt;valuestring) + <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            output = ensure(output_buffer, raw_length);</span><br><span class="line">            <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(output, item-&gt;valuestring, raw_length);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印不同item的内容</span></span><br><span class="line">        <span class="keyword">case</span> cJSON_String:</span><br><span class="line">            <span class="keyword">return</span> print_string(item, output_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cJSON_Array:</span><br><span class="line">            <span class="keyword">return</span> print_array(item, output_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cJSON_Object:</span><br><span class="line">            <span class="keyword">return</span> print_object(item, output_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>print_value()</strong> 只打印item的<code>键-值</code>内容，因为不同类型的item，打印内容的逻辑不一样，所以在这个函数中，对不同类型的item作了不同的处理。</p>
<p>我们主要分析打印字符串，数组与object类型的item的代码：</p>
<h3 id="2-1-ensure"><a href="#2-1-ensure" class="headerlink" title="2.1 ensure();"></a>2.1 ensure();</h3><p>首先另一个同样重要的函数，ensure();人如其名，该函数的作用是确保buff的内存够用，并返回buffer的可用内存的指针。<strong>每次给printbuffer赋值前，都需要计算所需的内存，并调用ensure()确保内存够用。</strong> 分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查printbuffer的缓存区与needed的大小，确保所需内存足够</span></span><br><span class="line"><span class="comment"> * 返回当前buffer的可用内存的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">ensure</span><span class="params">(printbuffer * <span class="type">const</span> p, <span class="type">size_t</span> needed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *newbuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> newsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p == <span class="literal">NULL</span>) || (p-&gt;buffer == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//offset此时应该是0，确保offset的正确性</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;length &gt; <span class="number">0</span>) &amp;&amp; (p-&gt;offset &gt;= p-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* make sure that offset is valid */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//限制缓存大小</span></span><br><span class="line">    <span class="keyword">if</span> (needed &gt; INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* sizes bigger than INT_MAX are currently not supported */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所需内存是offset+1这个1是放字符串结束符</span></span><br><span class="line">    needed += p-&gt;offset + <span class="number">1</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//所需要的内存足够用，返回可用内存的起点</span></span><br><span class="line">    <span class="keyword">if</span> (needed &lt;= p-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;buffer + p-&gt;offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则内存不够，需要重新分配，检查分配函数是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;noalloc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate new buffer size */</span></span><br><span class="line">    <span class="comment">//计算所需要的内存，限制规模</span></span><br><span class="line">    <span class="keyword">if</span> (needed &gt; (INT_MAX / <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* overflow of int, use INT_MAX if possible */</span></span><br><span class="line">        <span class="keyword">if</span> (needed &lt;= INT_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            newsize = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        newsize = needed * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reallocate在原指针上重新分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;hooks.reallocate != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* reallocate with realloc if available */</span></span><br><span class="line">        newbuffer = (<span class="type">unsigned</span> <span class="type">char</span>*)p-&gt;hooks.reallocate(p-&gt;buffer, newsize);</span><br><span class="line">        <span class="keyword">if</span> (newbuffer == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;hooks.deallocate(p-&gt;buffer);</span><br><span class="line">            p-&gt;length = <span class="number">0</span>;</span><br><span class="line">            p-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* otherwise reallocate manually */</span></span><br><span class="line">        <span class="comment">//系统不支持reallocate，使用allocate创建新的指针，再分配内存</span></span><br><span class="line">        newbuffer = (<span class="type">unsigned</span> <span class="type">char</span>*)p-&gt;hooks.allocate(newsize);</span><br><span class="line">        <span class="keyword">if</span> (!newbuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;hooks.deallocate(p-&gt;buffer);</span><br><span class="line">            p-&gt;length = <span class="number">0</span>;</span><br><span class="line">            p-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给new_buff复制旧buff的内容</span></span><br><span class="line">        <span class="keyword">if</span> (newbuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(newbuffer, p-&gt;buffer, p-&gt;offset + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再释放旧buff的内存</span></span><br><span class="line">        p-&gt;hooks.deallocate(p-&gt;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给p装上新的buff</span></span><br><span class="line">    p-&gt;length = newsize;</span><br><span class="line">    p-&gt;buffer = newbuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newbuffer + p-&gt;offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-print-string"><a href="#2-2-print-string" class="headerlink" title="2.2 print_string();"></a>2.2 print_string();</h3><p>打印字符串类型的item,如：</p>
<blockquote>
<p>“name”: “fool”</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将item中的数据复制到printbuffer</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">print_string</span><span class="params">(<span class="type">const</span> cJSON * <span class="type">const</span> item, printbuffer * <span class="type">const</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> print_string_ptr((<span class="type">unsigned</span> <span class="type">char</span>*)item-&gt;valuestring, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的作用是将string类型的item里的字符串值打印到printbuff，实际实现是以下函数print_string_ptr(),它的作用是打印字符串指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印字符串</span></span><br><span class="line"><span class="comment"> * 例如input的内容可能是 &quot;string&quot;,其中的双引号需要特殊处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">print_string_ptr</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * <span class="type">const</span> input, printbuffer * <span class="type">const</span> output_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> output_length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* numbers of additional characters needed for escaping */</span></span><br><span class="line">    <span class="comment">//需要补充字节数</span></span><br><span class="line">    <span class="type">size_t</span> escape_characters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* empty string */</span></span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出为空串</span></span><br><span class="line">        output = ensure(output_buffer, <span class="keyword">sizeof</span>(<span class="string">&quot;\&quot;\&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)output, <span class="string">&quot;\&quot;\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* set &quot;flag&quot; to 1 if something needs to be escaped */</span></span><br><span class="line">    <span class="comment">//检查输入字符串中的特殊字符，如果是换行符&#x27;\n&#x27;，则输出需要两个字符:&#x27;\&#x27;和&#x27;n&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (input_pointer = input; *input_pointer; input_pointer++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*input_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:  <span class="comment">//退格(BS) ，将当前位置移到前一列</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\f&#x27;</span>:  <span class="comment">//换页(FF)，将当前位置移到下页开头</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>: <span class="comment">//换行(LF) ，将当前位置移到下一行开头</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:  <span class="comment">//回车(CR) ，将当前位置移到本行开头</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:  <span class="comment">//水平制表(HT)</span></span><br><span class="line">                <span class="comment">/* one character escape sequence */</span></span><br><span class="line">                <span class="comment">//需要额外一个字符</span></span><br><span class="line">                escape_characters++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (*input_pointer &lt; <span class="number">32</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* UTF-16 escape sequence uXXXX */</span></span><br><span class="line">                    <span class="comment">//需要额外5个字符</span></span><br><span class="line">                    escape_characters += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的长度是输入长度+额外的字节</span></span><br><span class="line">    output_length = (<span class="type">size_t</span>)(input_pointer - input) + escape_characters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保输出buff足够大</span></span><br><span class="line">    output = ensure(output_buffer, output_length + <span class="keyword">sizeof</span>(<span class="string">&quot;\&quot;\&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无额外字节（无转义字符）时直接复制字符串 记得带上双引号和结束符</span></span><br><span class="line">    <span class="comment">/* no characters have to be escaped */</span></span><br><span class="line">    <span class="keyword">if</span> (escape_characters == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        output[<span class="number">0</span>] = <span class="string">&#x27;\&quot;&#x27;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(output + <span class="number">1</span>, input, output_length);</span><br><span class="line">        output[output_length + <span class="number">1</span>] = <span class="string">&#x27;\&quot;&#x27;</span>;</span><br><span class="line">        output[output_length + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有额外字节时（转义字符），需根据不同情况拼接字符串</span></span><br><span class="line">    output[<span class="number">0</span>] = <span class="string">&#x27;\&quot;&#x27;</span>;</span><br><span class="line">    output_pointer = output + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* copy the string */</span></span><br><span class="line">    <span class="keyword">for</span> (input_pointer = input; *input_pointer != <span class="string">&#x27;\0&#x27;</span>; (<span class="type">void</span>)input_pointer++, output_pointer++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*input_pointer &gt; <span class="number">31</span>) &amp;&amp; (*input_pointer != <span class="string">&#x27;\&quot;&#x27;</span>) &amp;&amp; (*input_pointer != <span class="string">&#x27;\\&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* normal character, copy */</span></span><br><span class="line">            <span class="comment">//普通的字符直接复制</span></span><br><span class="line">            *output_pointer = *input_pointer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//特殊字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* character needs to be escaped */</span></span><br><span class="line">            <span class="comment">//需要补充的字符：主要是转义字符</span></span><br><span class="line">            *output_pointer++ = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">            <span class="keyword">switch</span> (*input_pointer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;\&quot;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\f&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">                    *output_pointer = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* escape and print as unicode codepoint */</span></span><br><span class="line">                    <span class="built_in">sprintf</span>((<span class="type">char</span>*)output_pointer, <span class="string">&quot;u%04x&quot;</span>, *input_pointer);</span><br><span class="line">                    output_pointer += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output[output_length + <span class="number">1</span>] = <span class="string">&#x27;\&quot;&#x27;</span>;</span><br><span class="line">    output[output_length + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要关注的是特殊字符的处理，例如换行符<code>LF</code>的ascii码为0x0A，在内存中占一个字节，转换为字符串时为<code>\n</code>占有两个字符。<br><strong>这也是该函数与字符串复制函数strcpy不同的地方。</strong></p>
<h3 id="2-3，print-number"><a href="#2-3，print-number" class="headerlink" title="2.3，print_number();"></a>2.3，print_number();</h3><p>打印数字字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将数字转成字符串 赋值到printbuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">print_number</span><span class="params">(<span class="type">const</span> cJSON * <span class="type">const</span> item, printbuffer * <span class="type">const</span> output_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">double</span> d = item-&gt;valuedouble;   <span class="comment">//获取item的数值</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;     <span class="comment">//数字的字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> number_buffer[<span class="number">26</span>]; <span class="comment">/* temporary buffer to print the number into */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> decimal_point = get_decimal_point();  <span class="comment">//十进制小数点字符</span></span><br><span class="line">    <span class="type">double</span> test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This checks for NaN and Infinity */</span></span><br><span class="line">    <span class="comment">//检查json的数值是否无穷大</span></span><br><span class="line">    <span class="keyword">if</span> ((d * <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里是将null赋值给number_buffer，表示该数值不可信</span></span><br><span class="line">        length = <span class="built_in">sprintf</span>((<span class="type">char</span>*)number_buffer, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先尝试小数点后15位的精度打印</span></span><br><span class="line">        <span class="comment">/* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */</span></span><br><span class="line">        length = <span class="built_in">sprintf</span>((<span class="type">char</span>*)number_buffer, <span class="string">&quot;%1.15g&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check whether the original double can be recovered */</span></span><br><span class="line">        <span class="comment">//检查是否能恢复原来的数据</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">sscanf</span>((<span class="type">char</span>*)number_buffer, <span class="string">&quot;%lg&quot;</span>, &amp;test) != <span class="number">1</span>) || ((<span class="type">double</span>)test != d))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* If not, print with 17 decimal places of precision */</span></span><br><span class="line">            <span class="comment">//如果无法还原，说明转换精度不够，提高到小数点后17位</span></span><br><span class="line">            length = <span class="built_in">sprintf</span>((<span class="type">char</span>*)number_buffer, <span class="string">&quot;%1.17g&quot;</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sprintf failed or buffer overrun occurred */</span></span><br><span class="line">    <span class="comment">//检查number_buffer是否正常赋值或者溢出</span></span><br><span class="line">    <span class="keyword">if</span> ((length &lt; <span class="number">0</span>) || (length &gt; (<span class="type">int</span>)(<span class="keyword">sizeof</span>(number_buffer) - <span class="number">1</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserve appropriate space in the output */</span></span><br><span class="line">    <span class="comment">//确保内存足够</span></span><br><span class="line">    output_pointer = ensure(output_buffer, (<span class="type">size_t</span>)length + <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy the printed number to the output and replace locale</span></span><br><span class="line"><span class="comment">     * dependent decimal point with &#x27;.&#x27; */</span></span><br><span class="line">    <span class="comment">//将number_buffer复制到output_pointer中，并添加小数点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((<span class="type">size_t</span>)length); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number_buffer[i] == decimal_point)</span><br><span class="line">        &#123;</span><br><span class="line">            output_pointer[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output_pointer[i] = number_buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入字符串结束符，更新字符串长度offset</span></span><br><span class="line">    output_pointer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    output_buffer-&gt;offset += (<span class="type">size_t</span>)length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sprintf();是c语言自带的格式化输出函数。</p>
<h3 id="2-4，print-array"><a href="#2-4，print-array" class="headerlink" title="2.4，print_array();"></a>2.4，print_array();</h3><p>打印数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Render an array to text */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印数组全部内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">print_array</span><span class="params">(<span class="type">const</span> cJSON * <span class="type">const</span> item, printbuffer * <span class="type">const</span> output_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    cJSON *current_element = item-&gt;child;   <span class="comment">//获取数组的第一个成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compose the output array. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是数组所以给字符串先赋值一个[</span></span><br><span class="line">    output_pointer = ensure(output_buffer, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *output_pointer = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    output_buffer-&gt;offset++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套层数计+1（因为进入了child）</span></span><br><span class="line">    output_buffer-&gt;depth++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头打印数组里的子元素</span></span><br><span class="line">    <span class="keyword">while</span> (current_element != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印一个子元素</span></span><br><span class="line">        <span class="keyword">if</span> (!print_value(current_element, output_buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新字符串长度</span></span><br><span class="line">        update_offset(output_buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果有下一个元素，还需要另外打印逗号,</span></span><br><span class="line">        <span class="keyword">if</span> (current_element-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断是否是格式化打印，如果是，则:后要加空格</span></span><br><span class="line">            length = (<span class="type">size_t</span>) (output_buffer-&gt;format ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">            output_pointer = ensure(output_buffer, length + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *output_pointer++ = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(output_buffer-&gt;format)</span><br><span class="line">            &#123;</span><br><span class="line">                *output_pointer++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//&#x27;\0&#x27;后续会被覆盖掉，因为offset在它之前</span></span><br><span class="line">            *output_pointer = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            output_buffer-&gt;offset += length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取下一个元素</span></span><br><span class="line">        current_element = current_element-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组打印完成 关门]</span></span><br><span class="line">    output_pointer = ensure(output_buffer, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *output_pointer++ = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    *output_pointer = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">//退出嵌套</span></span><br><span class="line">    output_buffer-&gt;depth--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-print-object"><a href="#2-5-print-object" class="headerlink" title="2.5 print_object();"></a>2.5 print_object();</h3><p>打印json对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印json数据到output_buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">print_object</span><span class="params">(<span class="type">const</span> cJSON * <span class="type">const</span> item, printbuffer * <span class="type">const</span> output_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    cJSON *current_item = item-&gt;child;  <span class="comment">//object对象下的第一个item</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compose the output: */</span></span><br><span class="line">    <span class="comment">//如果是格式化输出，则需要换行符</span></span><br><span class="line">    length = (<span class="type">size_t</span>) (output_buffer-&gt;format ? <span class="number">2</span> : <span class="number">1</span>); <span class="comment">/* fmt: &#123;\n */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保内存</span></span><br><span class="line">    output_pointer = ensure(output_buffer, length + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json必须有大括号</span></span><br><span class="line">    *output_pointer++ = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套层数+1</span></span><br><span class="line">    output_buffer-&gt;depth++;</span><br><span class="line">    <span class="keyword">if</span> (output_buffer-&gt;format)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//格式化输出带换行符</span></span><br><span class="line">        *output_pointer++ = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新offset</span></span><br><span class="line">    output_buffer-&gt;offset += length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印该json所有的item</span></span><br><span class="line">    <span class="keyword">while</span> (current_item)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (output_buffer-&gt;format)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> i;</span><br><span class="line">            output_pointer = ensure(output_buffer, output_buffer-&gt;depth);</span><br><span class="line">            <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//格式化输出需要水平制表符 一层嵌套一个制表符</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; output_buffer-&gt;depth; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                *output_pointer++ = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            output_buffer-&gt;offset += output_buffer-&gt;depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* print key */</span></span><br><span class="line">        <span class="comment">//打印item的键</span></span><br><span class="line">        <span class="keyword">if</span> (!print_string_ptr((<span class="type">unsigned</span> <span class="type">char</span>*)current_item-&gt;<span class="built_in">string</span>, output_buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_offset(output_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打算打印:的字节</span></span><br><span class="line">        length = (<span class="type">size_t</span>) (output_buffer-&gt;format ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">        output_pointer = ensure(output_buffer, length);</span><br><span class="line">        <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *output_pointer++ = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        <span class="comment">//oh,格式化输出，冒号后还要一个制表符</span></span><br><span class="line">        <span class="keyword">if</span> (output_buffer-&gt;format)</span><br><span class="line">        &#123;</span><br><span class="line">            *output_pointer++ = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer-&gt;offset += length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* print value */</span></span><br><span class="line">        <span class="comment">//打印item的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!print_value(current_item, output_buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update_offset(output_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* print comma if not last */</span></span><br><span class="line">        length = ((<span class="type">size_t</span>)(output_buffer-&gt;format ? <span class="number">1</span> : <span class="number">0</span>) + (<span class="type">size_t</span>)(current_item-&gt;next ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        output_pointer = ensure(output_buffer, length + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还有item，则用逗号隔开，最后一个item结尾不用逗号</span></span><br><span class="line">        <span class="keyword">if</span> (current_item-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            *output_pointer++ = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (output_buffer-&gt;format)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//格式化输出需要换行</span></span><br><span class="line">            *output_pointer++ = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给output_pointer一个字符串结束符，outputbuff不会受到影响</span></span><br><span class="line">        *output_pointer = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        output_buffer-&gt;offset += length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印下一个item</span></span><br><span class="line">        current_item = current_item-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后打印右边的大括号，有多少层嵌套就打印多少个</span></span><br><span class="line">    output_pointer = ensure(output_buffer, output_buffer-&gt;format ? (output_buffer-&gt;depth + <span class="number">1</span>) : <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (output_pointer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output_buffer-&gt;format)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (output_buffer-&gt;depth - <span class="number">1</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *output_pointer++ = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *output_pointer++ = <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	<span class="comment">//补上字符串结束</span></span><br><span class="line">    *output_pointer = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    output_buffer-&gt;depth--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-，update-offset"><a href="#三-，update-offset" class="headerlink" title="三 ，update_offset();"></a>三 ，update_offset();</h2><p>如果你足够细心就会发现，每次调用<code>print_value()</code>后都要更新offset，这是由于print_value()会将item打印到printbuffer里，但不会更新offset，而是在printbuffer后加了字符串结束符<code>\0</code>。update_offset()就是以此来更新offset。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算printbuffer里的字符串长度，并由此更新printbuffer的offset，调用print_value()都要更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_offset</span><span class="params">(printbuffer * <span class="type">const</span> buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buffer_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((buffer == <span class="literal">NULL</span>) || (buffer-&gt;buffer == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前offset指向的地址</span></span><br><span class="line">    buffer_pointer = buffer-&gt;buffer + buffer-&gt;offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算新的字符串长度并加到offset</span></span><br><span class="line">    buffer-&gt;offset += <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span>*)buffer_pointer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，其他打印函数"><a href="#四，其他打印函数" class="headerlink" title="四，其他打印函数"></a>四，其他打印函数</h2><p>非格式化打印，效果如下：</p>
<blockquote>
<p>1, CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里插入代码片</span><br></pre></td></tr></table></figure>
<p>prebuffer:指定打印输出buffer的大小;<br>fmt:格式化输出；</p>
<blockquote>
<p>2, CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)</p>
</blockquote>
<p>由外部代码申请的内存来存放打印的数据。<br>buf:存放打印结构的内存；<br>len：内存大小；<br>fmt：格式化输出；</p>
<blockquote>
<p>CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本章打印字符串的学习，对cjson结构体与json字符串之间转换加深理解，对于接下来的逆过程：json字符串转cjson结构体的理解会有更大的帮助。<br><img src="/2025/05/30/hello-world/cJSON/3.cJSON_Print()/4.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/cJSON/3.cJSON_Print()/" data-id="cmbcy7rhr002wt8mt0ee2fvy5" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/cJSON/4.cJSON_Parse()_parse_json_string" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/cJSON/4.cJSON_Parse()_parse_json_string/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.652Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>cJSON系列：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110395913">零基础学习cJSON 源码详解与应用（一）如何学习cJSON</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110406265">零基础学习cJSON 源码详解与应用（二）创建json数据</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110475966">零基础学习cJSON 源码详解与应用 （三）cJSON_Print()；打印json
</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110481533">零基础学习cJSON 源码详解与应用 （四）cJSON_Parse()；解析json字符串</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110499109">零基础学习cJSON 源码详解与应用 （五）修改，复制，比较cjson</a></li>
</ul>
</blockquote>
<blockquote>
<p>上一章介绍了从cjson结构体到json字符串的过程，这一章是逆过程，就是将json字符串转换成cjson结构体。逆过程与上一章思路上是一脉相承的。紧紧围绕着cjson结构体与json的格式。</p>
</blockquote>
<h2 id="一，解析json字符串示例"><a href="#一，解析json字符串示例" class="headerlink" title="一，解析json字符串示例"></a>一，解析json字符串示例</h2><p>还记得在第一章第二节的应用场景示例吗，<strong>通过http接口获取到天气的json数据，这些json数据是通过http协议发送到我们客户端，一般是以字符串形式放在body里。客户端想要从中读取所需信息，就必须将字符串解析成cjson结构体，然后由键读取其中的值。</strong></p>
<p>用以下例子来说明如何使用cjson解析字符串：<br><strong>代码解析了json字符串，然后从cjson中提取每个item的值并打印出来。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非格式化的json字符串</span></span><br><span class="line"><span class="type">char</span> *json = <span class="string">&quot;&#123;\&quot;years\&quot;:22,\&quot;name\&quot;:\&quot;fool\&quot;,\&quot;man\&quot;:true,\&quot;adult\&quot;:false,\&quot;season\&quot;:[\&quot;spring\&quot;,\&quot;summer\&quot;,\&quot;fall\&quot;,\&quot;winter\&quot;],\&quot;money\&quot;:null,\&quot;child\&quot;:&#123;\&quot;girlfriend\&quot;:\&quot;june\&quot;,\&quot;boyfriend\&quot;:null&#125;&#125;&quot;</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(json);</span><br><span class="line"></span><br><span class="line">cJSON *item = cJSON_GetObjectItem(root, <span class="string">&quot;years&quot;</span>);</span><br><span class="line"><span class="type">int</span> years = years-&gt;valuedouble;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;years=%d \r\n&quot;</span>, years);</span><br><span class="line"></span><br><span class="line">item = cJSON_GetObjectItem(root, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">char</span> *name = cJSON_GetStringValue(item);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name=%s \r\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">item = cJSON_GetObjectItem(root, <span class="string">&quot;man&quot;</span>);</span><br><span class="line"><span class="type">int</span> man = item-&gt;type;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;man=%d \r\n&quot;</span>, man);</span><br><span class="line"></span><br><span class="line">item = cJSON_GetObjectItem(root, <span class="string">&quot;adult&quot;</span>);</span><br><span class="line"><span class="type">int</span> adult = item-&gt;type;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;adutl=%d \r\n&quot;</span>, adult);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组item</span></span><br><span class="line">item = cJSON_GetObjectItem(root, <span class="string">&quot;season&quot;</span>);</span><br><span class="line"><span class="type">int</span> arry_size = cJSON_GetArraySize(item);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arry_size;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//打印数组里的所有item</span></span><br><span class="line">    <span class="type">char</span> *season = cJSON_GetStringValue(cJSON_GetArrayItem(item, i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;season[%d]=%s \r\n&quot;</span>,i, season);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item = cJSON_GetObjectItem(root, <span class="string">&quot;money&quot;</span>);</span><br><span class="line"><span class="type">int</span> money = item-&gt;type;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;money=%d \r\n&quot;</span>, money);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取嵌套的json</span></span><br><span class="line">cJSON *child = cJSON_GetObjectItem(root, <span class="string">&quot;child&quot;</span>);</span><br><span class="line">item = cJSON_GetObjectItem(child, <span class="string">&quot;girlfriend&quot;</span>);</span><br><span class="line"><span class="type">char</span> *girlfriend = cJSON_GetStringValue(item);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;girlfriend=%s \r\n&quot;</span>, girlfriend);</span><br><span class="line"></span><br><span class="line">item = cJSON_GetObjectItem(child, <span class="string">&quot;boyfriend&quot;</span>);</span><br><span class="line"><span class="type">int</span> boyfriend = item-&gt;type;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;boyfriend=%d \r\n&quot;</span>, boyfriend);</span><br><span class="line"></span><br><span class="line"><span class="comment">//记得删除json</span></span><br><span class="line">cJSON_Delete(root);</span><br></pre></td></tr></table></figure>

<p>代码运行结果：<br><img src="/2025/05/30/hello-world/cJSON/4.cJSON_Parse()_parse_json_string/6.png" alt="在这里插入图片描述"></p>
<h2 id="二，代码解析"><a href="#二，代码解析" class="headerlink" title="二，代码解析"></a>二，代码解析</h2><p>cJSON_Parse()；调用了cJSON_ParseWithOpts()，只是后两个输入参数为0。这对我们的分析影响不大。先大概看一下cJSON_ParseWithOpts();</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析json字符串</span></span><br><span class="line"><span class="comment"> * value：字符串</span></span><br><span class="line"><span class="comment"> * 成功则返回cjson结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(<span class="type">const</span> <span class="type">char</span> *value, <span class="type">const</span> <span class="type">char</span> **return_parse_end, cJSON_bool require_null_terminated)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//暂存json字符串的buff</span></span><br><span class="line">    parse_buffer buffer = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功返回的item</span></span><br><span class="line">    cJSON *item = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset error position */</span></span><br><span class="line">    <span class="comment">//用于记录错误的全局变量</span></span><br><span class="line">    global_error.json = <span class="literal">NULL</span>;</span><br><span class="line">    global_error.position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化字符串buffer</span></span><br><span class="line">    buffer.content = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)value;   <span class="comment">//json字符串内容</span></span><br><span class="line">    buffer.length = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span>*)value) + <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>);    <span class="comment">//长度</span></span><br><span class="line">    buffer.offset = <span class="number">0</span>;  <span class="comment">//已经解析的长度为0</span></span><br><span class="line">    buffer.hooks = global_hooks;    <span class="comment">//老朋友了，内存管理大师</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个空item对象</span></span><br><span class="line">    item = cJSON_New_Item(&amp;global_hooks);</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">NULL</span>) <span class="comment">/* memory fail */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳过json字符串中的bom和空格等特殊字符，然后再解析字符串</span></span><br><span class="line">    <span class="keyword">if</span> (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&amp;buffer))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* parse failure. ep is set. */</span></span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */</span></span><br><span class="line">    <span class="comment">//require_null_terminated 和 return_parse_end为0，先不管了</span></span><br><span class="line">    <span class="keyword">if</span> (require_null_terminated)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_skip_whitespace(&amp;buffer);</span><br><span class="line">        <span class="keyword">if</span> ((buffer.offset &gt;= buffer.length) || buffer_at_offset(&amp;buffer)[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (return_parse_end)</span><br><span class="line">    &#123;</span><br><span class="line">        *return_parse_end = (<span class="type">const</span> <span class="type">char</span>*)buffer_at_offset(&amp;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回成功的item</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="comment">//失败了，先释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_Delete(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查字符串出错的位置，可供用户分析错误</span></span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error local_error;</span><br><span class="line">        local_error.json = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)value;</span><br><span class="line">        local_error.position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buffer.offset &lt; buffer.length)</span><br><span class="line">        &#123;</span><br><span class="line">            local_error.position = buffer.offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            local_error.position = buffer.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (return_parse_end != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *return_parse_end = (<span class="type">const</span> <span class="type">char</span>*)local_error.json + local_error.position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        global_error = local_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码有几个重要的函数<code>skip_utf8_bom()</code>,<code>buffer_skip_whitespace()</code>,<code>parse_value()</code>同时还有一个重要的结构体<code>parse_buffer</code>。下面从这几个方面入手，深入理解代码。</p>
<h3 id="2-1-parse-buffer-结构体"><a href="#2-1-parse-buffer-结构体" class="headerlink" title="2.1 parse_buffer 结构体"></a>2.1 parse_buffer 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parsebuffer 一个item的字符串内容</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *content;   <span class="comment">//json字符串</span></span><br><span class="line">    <span class="type">size_t</span> length;  <span class="comment">//字符串的字节总长度</span></span><br><span class="line">    <span class="type">size_t</span> offset;  <span class="comment">//当前解析的位置</span></span><br><span class="line">    <span class="type">size_t</span> depth; <span class="comment">//json对象嵌套的深度</span></span><br><span class="line">    internal_hooks hooks;   <span class="comment">//分配内存用到的函数</span></span><br><span class="line">&#125; parse_buffer;</span><br></pre></td></tr></table></figure>
<p>有没有一种熟悉的味道，与上一章<code>print_buffer</code>功能上接近，他将陪伴我们渡过解析字符串的全过程。<br><strong>为了更好的使用parse_buffer</strong>，cjson提供了几个宏来方便操作，简单理解这些宏的作用，在接下来的代码中，他们会经常出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查buffer能否读取从offset开始size个字节的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> can_read(buffer, size) ((buffer != NULL) &amp;&amp; (((buffer)-&gt;offset + size) <span class="string">&lt;= (buffer)-&gt;</span>length))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查buffer能否读取从offset起index个字节的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> can_access_at_index(buffer, index) ((buffer != NULL) &amp;&amp; (((buffer)-&gt;offset + index) <span class="string">&lt; (buffer)-&gt;</span>length))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))</span></span><br><span class="line"><span class="comment">//返回buffer的offset的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buffer_at_offset(buffer) ((buffer)-&gt;content + (buffer)-&gt;offset)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-skip-utf8-bom"><a href="#2-2-skip-utf8-bom" class="headerlink" title="2.2 skip_utf8_bom();"></a>2.2 skip_utf8_bom();</h3><p>uft-8不需要bom表明字节顺序，但可以用BOM来表示编码方式，windows就是采用bom来标记文本文件的编码方式的。解析的时候跳过这些无用的字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳过buffer中表示bom的字符\xEF\xBB\xBF</span></span><br><span class="line"><span class="comment"> * 成功返回buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> parse_buffer *<span class="title function_">skip_utf8_bom</span><span class="params">(parse_buffer * <span class="type">const</span> buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((buffer == <span class="literal">NULL</span>) || (buffer-&gt;content == <span class="literal">NULL</span>) || (buffer-&gt;offset != <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断buffer中是否能读取4个字节的数据，再比较这4个数据与bom的字符串</span></span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(buffer, <span class="number">4</span>) &amp;&amp; (<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span>*)buffer_at_offset(buffer), <span class="string">&quot;\xEF\xBB\xBF&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是bom字符，offset跳过这三个字符</span></span><br><span class="line">        buffer-&gt;offset += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>上面的代码使用了宏，进一步理解宏can_access_at_index和buffer_at_offset的作用。如果没有检查buffer的内存大小，则可能导致内存读取错误。</strong></em></p>
<p>注意通过移动offset来跳过content的字符或是标记已经解析过的字符。</p>
<h3 id="2-3-buffer-skip-whitespace"><a href="#2-3-buffer-skip-whitespace" class="headerlink" title="2.3 buffer_skip_whitespace();"></a>2.3 buffer_skip_whitespace();</h3><p>该函数用于跳过没有利用价值的特殊符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳过cr（回车），lf（换行）和空格 直到遇到普通的字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> parse_buffer *<span class="title function_">buffer_skip_whitespace</span><span class="params">(parse_buffer * <span class="type">const</span> buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((buffer == <span class="literal">NULL</span>) || (buffer-&gt;content == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ascii码小于32的都是不可显示的，作特殊功能的码 </span></span><br><span class="line">    <span class="keyword">while</span> (can_access_at_index(buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(buffer)[<span class="number">0</span>] &lt;= <span class="number">32</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用offset来表示跳过</span></span><br><span class="line">        buffer-&gt;offset++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新offset</span></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;offset == buffer-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer-&gt;offset--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-parse-value"><a href="#2-4-parse-value" class="headerlink" title="2.4 parse_value();"></a>2.4 parse_value();</h3><p>该函数在结构上与print_value()有异曲同工之妙。解析不同类型item的内容。<br><strong>对于简单的null,true,false只需要判断字符串是否相等；<br>对于其他类型的item，判断第一个字符：<br>字符串类型的item，则判断是否有双引号；<br>数组则是[]<br>json则看{}</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析input_buff字符串里的内容到item中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">parse_value</span><span class="params">(cJSON * <span class="type">const</span> item, parse_buffer * <span class="type">const</span> input_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((input_buffer == <span class="literal">NULL</span>) || (input_buffer-&gt;content == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* no input */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析不同类型的item,通过字符串比较函数strncmp</span></span><br><span class="line">    <span class="comment">/* null */</span></span><br><span class="line">    <span class="keyword">if</span> (can_read(input_buffer, <span class="number">4</span>) &amp;&amp; (<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span>*)buffer_at_offset(input_buffer), <span class="string">&quot;null&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确定item类型，offset前进4（null占了四个字符）</span></span><br><span class="line">        item-&gt;type = cJSON_NULL;</span><br><span class="line">        input_buffer-&gt;offset += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* false */</span></span><br><span class="line">    <span class="keyword">if</span> (can_read(input_buffer, <span class="number">5</span>) &amp;&amp; (<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span>*)buffer_at_offset(input_buffer), <span class="string">&quot;false&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确定item类型，offset前进5（false占了四个字符）</span></span><br><span class="line">        item-&gt;type = cJSON_False;</span><br><span class="line">        input_buffer-&gt;offset += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* true */</span></span><br><span class="line">    <span class="keyword">if</span> (can_read(input_buffer, <span class="number">4</span>) &amp;&amp; (<span class="built_in">strncmp</span>((<span class="type">const</span> <span class="type">char</span>*)buffer_at_offset(input_buffer), <span class="string">&quot;true&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确定item类型，offset前进4（true占了四个字符）</span></span><br><span class="line">        item-&gt;type = cJSON_True;</span><br><span class="line">        item-&gt;valueint = <span class="number">1</span>;</span><br><span class="line">        input_buffer-&gt;offset += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* string 检查的是双引号*/</span></span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;\&quot;&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//解析字符串</span></span><br><span class="line">        <span class="keyword">return</span> parse_string(item, input_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* number 由符号及ascii码判断*/</span></span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; ((buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) || ((buffer_at_offset(input_buffer)[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入解析数字</span></span><br><span class="line">        <span class="keyword">return</span>  parse_number(item, input_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* array 由数组的标志符号[]判断*/</span></span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入解析数组</span></span><br><span class="line">        <span class="keyword">return</span> parse_array(item, input_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* object 由json标志符号&#123;&#125;判断*/</span></span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入解析json</span></span><br><span class="line">        <span class="keyword">return</span> parse_object(item, input_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1，parse_string(); 从字符串解析字符串</strong><br>在代码同样要注意特殊符号的处理。例如，假设item的内容是：</p>
<blockquote>
<p>“item”:  “hello world\r\n”</p>
</blockquote>
<p><strong>解析的时候就会把\r\n转换成真正的回车和换行，而不是简单的字符串复制</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析input_buffer里的字符串，并给item赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">parse_string</span><span class="params">(cJSON * <span class="type">const</span> item, parse_buffer * <span class="type">const</span> input_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input_pointer = buffer_at_offset(input_buffer) + <span class="number">1</span>;    <span class="comment">//input_pointer此时跳过了&quot;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input_end = buffer_at_offset(input_buffer) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output_pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查是不是字符串*/</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_at_offset(input_buffer)[<span class="number">0</span>] != <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* calculate approximate size of the output (overestimate) */</span></span><br><span class="line">        <span class="comment">//计算大概的输出字节大小</span></span><br><span class="line">        <span class="type">size_t</span> allocation_length = <span class="number">0</span>;   <span class="comment">//内存分配所需字节</span></span><br><span class="line">        <span class="type">size_t</span> skipped_bytes = <span class="number">0</span>;   <span class="comment">//一些特殊符号需要跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查所有的buff，计算需要跳过的字节，并找到字符串结束的&quot;的指针</span></span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">size_t</span>)(input_end - input_buffer-&gt;content) &lt; input_buffer-&gt;length) &amp;&amp; (*input_end != <span class="string">&#x27;\&quot;&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* is escape sequence */</span></span><br><span class="line">            <span class="comment">//如果是转义字符\，对解析无用，则跳过该字符</span></span><br><span class="line">            <span class="keyword">if</span> (input_end[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//防止当最后一个是反斜杠时，内存溢出</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">size_t</span>)(input_end + <span class="number">1</span> - input_buffer-&gt;content) &gt;= input_buffer-&gt;length)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* prevent buffer overflow when last input character is a backslash */</span></span><br><span class="line">                    <span class="keyword">goto</span> fail;</span><br><span class="line">                &#125;</span><br><span class="line">                skipped_bytes++;</span><br><span class="line">                input_end++;</span><br><span class="line">            &#125;</span><br><span class="line">            input_end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正确情况下，input_end此时应该是结尾的&quot;，且长度不该超length 再次检查</span></span><br><span class="line">        <span class="keyword">if</span> (((<span class="type">size_t</span>)(input_end - input_buffer-&gt;content) &gt;= input_buffer-&gt;length) || (*input_end != <span class="string">&#x27;\&quot;&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* string ended unexpectedly */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is at most how much we need for the output */</span></span><br><span class="line">        <span class="comment">//计算大概所需内存为字符串尾部-头部-跳过的字节数</span></span><br><span class="line">        allocation_length = (<span class="type">size_t</span>) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;</span><br><span class="line">        <span class="comment">//分配所需内存</span></span><br><span class="line">        output = (<span class="type">unsigned</span> <span class="type">char</span>*)input_buffer-&gt;hooks.allocate(allocation_length + <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* allocation failure */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制字符串内的有效内容到output</span></span><br><span class="line">    output_pointer = output;</span><br><span class="line">    <span class="comment">/* loop through the string literal */</span></span><br><span class="line">    <span class="comment">//从头复制input内容</span></span><br><span class="line">    <span class="keyword">while</span> (input_pointer &lt; input_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果不是特殊字符，直接复制到output_pointer</span></span><br><span class="line">        <span class="keyword">if</span> (*input_pointer != <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *output_pointer++ = *input_pointer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* escape sequence */</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//存在特殊符号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//input_pointer[0]=&#x27;\\&#x27;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> sequence_length = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//到字符串尾部</span></span><br><span class="line">            <span class="keyword">if</span> ((input_end - input_pointer) &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将大小两个字符的特殊符号，转化成一个字节的对应符号</span></span><br><span class="line">            <span class="keyword">switch</span> (input_pointer[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                    *output_pointer++ = <span class="string">&#x27;\b&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                    *output_pointer++ = <span class="string">&#x27;\f&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                    *output_pointer++ = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                    *output_pointer++ = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                    *output_pointer++ = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    *output_pointer++ = input_pointer[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* UTF-16 literal */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &amp;output_pointer);</span><br><span class="line">                    <span class="keyword">if</span> (sequence_length == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* failed to convert UTF16-literal to UTF-8 */</span></span><br><span class="line">                        <span class="keyword">goto</span> fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动input_pointer指针</span></span><br><span class="line">            input_pointer += sequence_length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero terminate the output */</span></span><br><span class="line">    <span class="comment">//字符串结束符，使output_pointer结束</span></span><br><span class="line">    *output_pointer = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将解析出的字符串指针赋值给item，并更新offset</span></span><br><span class="line">    item-&gt;type = cJSON_String;</span><br><span class="line">    item-&gt;valuestring = (<span class="type">char</span>*)output;</span><br><span class="line"></span><br><span class="line">    input_buffer-&gt;offset = (<span class="type">size_t</span>) (input_end - input_buffer-&gt;content);</span><br><span class="line">    input_buffer-&gt;offset++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="comment">//失败则释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (output != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        input_buffer-&gt;hooks.deallocate(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新offset</span></span><br><span class="line">    <span class="keyword">if</span> (input_pointer != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        input_buffer-&gt;offset = (<span class="type">size_t</span>)(input_pointer - input_buffer-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2，parse_number();从字符串中解析数字</strong><br>例如：把字符串”520”转换成 <del>“我爱你”</del> 520.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析字符串中的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">parse_number</span><span class="params">(cJSON * <span class="type">const</span> item, parse_buffer * <span class="type">const</span> input_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> number = <span class="number">0</span>;	<span class="comment">//存放数字结果 520</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *after_end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> number_c_string[<span class="number">64</span>];	<span class="comment">//暂存数字字符串&quot;520&quot;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> decimal_point = get_decimal_point();  <span class="comment">//小数点的字符</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((input_buffer == <span class="literal">NULL</span>) || (input_buffer-&gt;content == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//判断最后63个字符是否是数字或小数点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt; (<span class="keyword">sizeof</span>(number_c_string) - <span class="number">1</span>)) &amp;&amp; can_access_at_index(input_buffer, i); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (buffer_at_offset(input_buffer)[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="comment">//以上情况直接将input_buffer的数字复制到数组</span></span><br><span class="line">                number_c_string[i] = buffer_at_offset(input_buffer)[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                number_c_string[i] = decimal_point;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//不是数字或小数点，说明数字已经结束</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">goto</span> loop_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">loop_end:</span><br><span class="line">    <span class="comment">//给字符数组打上大结局</span></span><br><span class="line">    number_c_string[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//strtod（）将数字字符串转成浮点数，after_end为转换结尾的地址</span></span><br><span class="line">    number = strtod((<span class="type">const</span> <span class="type">char</span>*)number_c_string, (<span class="type">char</span>**)&amp;after_end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若结尾地址==字符串头，肯定错了</span></span><br><span class="line">    <span class="keyword">if</span> (number_c_string == after_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* parse_error */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将解析到的数字赋值给item</span></span><br><span class="line">    item-&gt;valuedouble = number;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*限制number的大小，防止内存溢出*/</span></span><br><span class="line">    <span class="keyword">if</span> (number &gt;= INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        item-&gt;valueint = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (number &lt;= (<span class="type">double</span>)INT_MIN)</span><br><span class="line">    &#123;</span><br><span class="line">        item-&gt;valueint = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最后放到valueint</span></span><br><span class="line">        item-&gt;valueint = (<span class="type">int</span>)number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完善item的信息</span></span><br><span class="line">    item-&gt;type = cJSON_Number;</span><br><span class="line"></span><br><span class="line">    input_buffer-&gt;offset += (<span class="type">size_t</span>)(after_end - number_c_string);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3, parse_array();从字符串中解析数组</strong><br>数组的起始和结束标志很好理解，就是[]符号。</p>
<p><strong>在之前的章节里讲过，cjson里的数组表示起始就是一个以item为节点的链表，所以在代码中嵌套调用了parse_value();这里是值得思考一下的。</strong><br>例如：</p>
<blockquote>
<p>“[1,2,3,4,5]”转换成cjson为节点的链表，一个有5个节点，每个节点的类型都是number，进入parse_value()后都是往parse_number()里钻。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析json数组，数组是以链表连接一起的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">parse_array</span><span class="params">(cJSON * <span class="type">const</span> item, parse_buffer * <span class="type">const</span> input_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *head = <span class="literal">NULL</span>; <span class="comment">//链表的头item</span></span><br><span class="line">    cJSON *current_item = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json深度有限制</span></span><br><span class="line">    <span class="keyword">if</span> (input_buffer-&gt;depth &gt;= CJSON_NESTING_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* to deeply nested */</span></span><br><span class="line">    &#125;</span><br><span class="line">    input_buffer-&gt;depth++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组是以[开始</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_at_offset(input_buffer)[<span class="number">0</span>] != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* not an array */</span></span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_buffer-&gt;offset++;</span><br><span class="line">    <span class="comment">//跳过特殊字符</span></span><br><span class="line">    buffer_skip_whitespace(input_buffer);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;]&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* empty array */</span></span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查我们是不是跳过头，跳到buffer尾部 */</span></span><br><span class="line">    <span class="keyword">if</span> (cannot_access_at_index(input_buffer, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        input_buffer-&gt;offset--;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 做人留一线，日后好相见 */</span></span><br><span class="line">    input_buffer-&gt;offset--;</span><br><span class="line">    <span class="comment">/* loop through the comma separated array elements */</span></span><br><span class="line">    <span class="comment">//在循环中，构建数组，也就是item链表</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* allocate next item */</span></span><br><span class="line">        cJSON *new_item = cJSON_New_Item(&amp;(input_buffer-&gt;hooks));</span><br><span class="line">        <span class="keyword">if</span> (new_item == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* allocation failure */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* attach next item to list */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//确定链表头</span></span><br><span class="line">            current_item = head = new_item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//将新成员依次插入链表</span></span><br><span class="line">            current_item-&gt;next = new_item;</span><br><span class="line">            new_item-&gt;prev = current_item;</span><br><span class="line">            current_item = new_item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析新的子节点item的内容</span></span><br><span class="line">        input_buffer-&gt;offset++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过特殊字符</span></span><br><span class="line">        buffer_skip_whitespace(input_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入解析（嵌套调用了）</span></span><br><span class="line">        <span class="keyword">if</span> (!parse_value(current_item, input_buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* failed to parse value */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer_skip_whitespace(input_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逗号存在表示有下一个item，无则退出</span></span><br><span class="line">    <span class="keyword">while</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;,&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确的情况下，数组最后一个元素解析完后 下一个字符就是] </span></span><br><span class="line">    <span class="keyword">if</span> (cannot_access_at_index(input_buffer, <span class="number">0</span>) || buffer_at_offset(input_buffer)[<span class="number">0</span>] != <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail; <span class="comment">/* expected end of array */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">success:</span><br><span class="line">    input_buffer-&gt;depth--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将item链表头连接到父节点的child 完善item</span></span><br><span class="line">    item-&gt;type = cJSON_Array;</span><br><span class="line">    item-&gt;child = head;</span><br><span class="line"></span><br><span class="line">    input_buffer-&gt;offset++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败了就释放内存</span></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_delete(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4，parse_object();从字符串中解析json</strong></p>
<p><strong>这个函数与上一个代码上非常相似，不同之处在于，解析json对象时，当解析完 {  后，需要先解析出item的键，再嵌套调用parse_value();解析item的值。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析json对象，得到一个json类型的链表赋值给父json</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> cJSON_bool <span class="title function_">parse_object</span><span class="params">(cJSON * <span class="type">const</span> item, parse_buffer * <span class="type">const</span> input_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *head = <span class="literal">NULL</span>; <span class="comment">//json数据里的第一个item</span></span><br><span class="line">    cJSON *current_item = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json深度限制</span></span><br><span class="line">    <span class="keyword">if</span> (input_buffer-&gt;depth &gt;= CJSON_NESTING_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* to deeply nested */</span></span><br><span class="line">    &#125;</span><br><span class="line">    input_buffer-&gt;depth++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json对象是以&#123;&#125;包含起来</span></span><br><span class="line">    <span class="keyword">if</span> (cannot_access_at_index(input_buffer, <span class="number">0</span>) || (buffer_at_offset(input_buffer)[<span class="number">0</span>] != <span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail; <span class="comment">/* not an object */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_buffer-&gt;offset++;</span><br><span class="line">    buffer_skip_whitespace(input_buffer);</span><br><span class="line">    <span class="keyword">if</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//空的json!amazing!</span></span><br><span class="line">        <span class="keyword">goto</span> success; <span class="comment">/* empty object */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if we skipped to the end of the buffer */</span></span><br><span class="line">    <span class="keyword">if</span> (cannot_access_at_index(input_buffer, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        input_buffer-&gt;offset--;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step back to character in front of the first element */</span></span><br><span class="line">    input_buffer-&gt;offset--;</span><br><span class="line">    <span class="comment">/* loop through the comma separated array elements */</span></span><br><span class="line">    <span class="comment">//解析json数据，&#123; 之后一定是 &quot;key&quot;键，所以先解析出键</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* allocate next item */</span></span><br><span class="line">        <span class="comment">//创建新的json item</span></span><br><span class="line">        cJSON *new_item = cJSON_New_Item(&amp;(input_buffer-&gt;hooks));</span><br><span class="line">        <span class="keyword">if</span> (new_item == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* allocation failure */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* attach next item to list */</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* start the linked list */</span></span><br><span class="line">            current_item = head = new_item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* add to the end and advance */</span></span><br><span class="line">            current_item-&gt;next = new_item;</span><br><span class="line">            new_item-&gt;prev = current_item;</span><br><span class="line">            current_item = new_item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* parse the name of the child */</span></span><br><span class="line">        input_buffer-&gt;offset++;</span><br><span class="line">        buffer_skip_whitespace(input_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时的input_buff解析出来的是json的key值</span></span><br><span class="line">        <span class="keyword">if</span> (!parse_string(current_item, input_buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* failed to parse name */</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer_skip_whitespace(input_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//parse_string()把解析的字符串存放在item的valuestring，需要赋值到item的string成员</span></span><br><span class="line">        current_item-&gt;<span class="built_in">string</span> = current_item-&gt;valuestring;</span><br><span class="line">        </span><br><span class="line">        current_item-&gt;valuestring = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查key值后是否是冒号，若不是则出错</span></span><br><span class="line">        <span class="keyword">if</span> (cannot_access_at_index(input_buffer, <span class="number">0</span>) || (buffer_at_offset(input_buffer)[<span class="number">0</span>] != <span class="string">&#x27;:&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* invalid object */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常解析item的value</span></span><br><span class="line">        input_buffer-&gt;offset++;</span><br><span class="line">        buffer_skip_whitespace(input_buffer);</span><br><span class="line">        <span class="keyword">if</span> (!parse_value(current_item, input_buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail; <span class="comment">/* failed to parse value */</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer_skip_whitespace(input_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每个item之间由逗号分隔，最后一个item没有逗号</span></span><br><span class="line">    <span class="keyword">while</span> (can_access_at_index(input_buffer, <span class="number">0</span>) &amp;&amp; (buffer_at_offset(input_buffer)[<span class="number">0</span>] == <span class="string">&#x27;,&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查大括号有没有关上</span></span><br><span class="line">    <span class="keyword">if</span> (cannot_access_at_index(input_buffer, <span class="number">0</span>) || (buffer_at_offset(input_buffer)[<span class="number">0</span>] != <span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail; <span class="comment">/* expected end of object */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将item链表头连接给父节点json</span></span><br><span class="line">success:</span><br><span class="line">    input_buffer-&gt;depth--;</span><br><span class="line"></span><br><span class="line">    item-&gt;type = cJSON_Object;</span><br><span class="line">    item-&gt;child = head;</span><br><span class="line"></span><br><span class="line">    input_buffer-&gt;offset++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_Delete(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，cJSON的基本内容已经完成。感恩！<br><img src="/2025/05/30/hello-world/cJSON/4.cJSON_Parse()_parse_json_string/4.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/cJSON/4.cJSON_Parse()_parse_json_string/" data-id="cmbcy7rht0032t8mthihkgs0p" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Web/setup_tomcat_web" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Web/setup_tomcat_web/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.651Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="阿里云服务器装centos系统，安装jdk环境和tomcat"><a href="#阿里云服务器装centos系统，安装jdk环境和tomcat" class="headerlink" title="阿里云服务器装centos系统，安装jdk环境和tomcat"></a>阿里云服务器装centos系统，安装jdk环境和tomcat</h2><p>@[toc]</p>
<h2 id="准备：安装xftp6-用来与远程服务器进行文件传输"><a href="#准备：安装xftp6-用来与远程服务器进行文件传输" class="headerlink" title="准备：安装xftp6 用来与远程服务器进行文件传输"></a>准备：安装xftp6 用来与远程服务器进行文件传输</h2><blockquote>
<p>我使用的是阿里云的esc服务器<br><a target="_blank" rel="noopener" href="https://www.netsarang.com/zh/free-for-home-school/">xftp免费下载地址</a><br>下载的过程比较慢，耐心等待。<br>安装完成后 sftp连接上云服务器，就可以对云服务器的文件进行下载上传了；</p>
</blockquote>
<h2 id="一，安装git"><a href="#一，安装git" class="headerlink" title="一，安装git"></a>一，安装git</h2><p>检查是否安装git：<code>git --version</code><br>一般先检查apt-get是否已经更新的下载源，如果下载源出问题，那么基本的软件都下载不来，其他都不用说了。<br>使用命令：<code>apt-get update</code>和<code>apt-get upgrade</code>更新apt-get。<br>然后使用<code>apt-get install git</code>安装git,安装完成后再执行一次检查。</p>
<h2 id="二-安装jdk（jdk是java运行所需要的环境）"><a href="#二-安装jdk（jdk是java运行所需要的环境）" class="headerlink" title="二 安装jdk（jdk是java运行所需要的环境）"></a>二 安装jdk（jdk是java运行所需要的环境）</h2><h3 id="1-检查系统是否安装java"><a href="#1-检查系统是否安装java" class="headerlink" title="1. 检查系统是否安装java"></a>1. 检查系统是否安装java</h3><p>输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200227112506537.png" alt="查看Java版本"><br>上图显示我的jdk版本是1.8.0_242,没有安装的朋友看下面</p>
<h3 id="2-安装jdk"><a href="#2-安装jdk" class="headerlink" title="2. 安装jdk"></a>2. 安装jdk</h3><p> <strong>2.1</strong><br>  jdk-8u261-linux-64网盘下载：<br> 	链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1FrfMS5hPQNK5CKrZ77pOrg">https://pan.baidu.com/s/1FrfMS5hPQNK5CKrZ77pOrg</a><br>	提取码：avfg</p>
<p><strong>2.2</strong><br> 到<a target="_blank" rel="noopener" href="https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html">jdk官网下载</a>，选择适合自己系统版本的jdk，我用的是阿里云服务器centos7 所以选了64位的linux版本，下载需要登陆Oracle的账号，而且晚上下载速度比较慢，建议早上下载，速度会快很多；<br> 	<img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200314104339768.png" alt="在这里插入图片描述"><br> 	下载完解压到自己创建的目录下，方便以后查找。<br> 	解压命令 <code>tar -zxvf</code> <strong>文件全称</strong><br> <strong>2.3. 配置环境变量</strong></p>
<blockquote>
<pre><code>	编辑etc文件夹下的profile文件 	
方法一：远程连接服务器，用命令行编辑；
	方法二：用xftp6打开profile文件，添加export内容；
</code></pre>
</blockquote>
<p><strong>方法一：在命令行输入</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>按a 在当前光标位置的右边添加文本<br>JAVA_HOME是你自己安装jdk的路径，我自己在root目录下新建了java文件夹来安装jdk<br><strong>注意！一定要替换成你自己的jdk安装路径</strong><br><strong>注意！一定要替换成你自己的jdk安装路径</strong><br><strong>注意！一定要替换成你自己的jdk安装路径</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/root/java/jdk1.8.0_241</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.<span class="variable">$AVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>输入后按Esc推出编辑模式，输入:wq退出并保存。<br><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200314111708812.png" alt="在这里插入图片描述"><br><strong>方法二：</strong><br>xftp6连接服务器，在etc文件夹下找到profile文件，右键编辑，保存，退出。<br><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200314112144966.png" alt="在这里插入图片描述"><br><strong>最后</strong><br>使用命令<code>source /etc/profile</code>使修改生效。</p>
<blockquote>
<p>如果出现<code>/etc/profile: line 26: syntax error: unexpected end of file</code>之类的错误，请检查profile文件里if对应的fi是否缺少</p>
</blockquote>
<p>随后输入<code>java -version</code>检查是否安装成功</p>
<h2 id="三-安装tomcat"><a href="#三-安装tomcat" class="headerlink" title="三 安装tomcat"></a>三 安装tomcat</h2><p>关于tomcat内容请自行百度<br><a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-80.cgi">tomcat8.5官网下载</a><br>tomcat8.5.57 蓝奏网盘下载 <a target="_blank" rel="noopener" href="https://wws.lanzous.com/ifP0Aggte2h">https://wws.lanzous.com/ifP0Aggte2h</a>
 	</p>
<p><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/2020022712451799.png" alt="在这里插入图片描述"><br>方法一：tar.gz压缩包下载到本地，再用xftp6上传到自定义的文件夹下。</p>
<p>命令行 cd到压缩包目录下，解压；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.51.tar.gz</span><br></pre></td></tr></table></figure>
<p>cd到apache-tomcat-8.5.51目录下bin文件夹，启动 关闭tomcat；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure>

<p><strong>启动tomcat后，在浏览器输入：xxxxx:8080可看到tomcat页面就是成功（xxx是你的公网ip地址）；如果没看到页面就需要关闭防火墙或者放行8080端口；</strong></p>
<p>centos7关闭防火墙：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports　　<span class="comment"># 查看防火墙开放的所有端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent　　<span class="comment"># 添加开放端口</span></span><br><span class="line">firewall-cmd --reload <span class="comment">#重启后就能访问</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：阿里云还需要添加安全组，添加8080&#x2F;8080，授权对象0.0.0.0&#x2F;0</strong><br><strong>注意：阿里云还需要添加安全组，添加8080&#x2F;8080，授权对象0.0.0.0&#x2F;0</strong><br><strong>注意：阿里云还需要添加安全组，添加8080&#x2F;8080，授权对象0.0.0.0&#x2F;0</strong><br><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200227131017895.png" alt="在这里插入图片描述"><br><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200227131453179.png" alt="在这里插入图片描述"></p>
<h2 id="三-部署web项目"><a href="#三-部署web项目" class="headerlink" title="三 部署web项目"></a>三 部署web项目</h2><p>我们用xftp将在电脑开发的web项目上传到服务器<br>在eclipse打包web项目 右键项目-&gt;Export-&gt;war，将生成的war复制到root&#x2F;webapps&#x2F;目录下<br><strong>注意 一定要放在webapps下</strong><br>接着重新启动tomcat，就会自动生成项目文件。项目部署完成，在浏览器输入xxxxx：8080&#x2F;appname 就可以访问项目<br>（appname是你的项目的名称）<br><img src="/2025/05/30/hello-world/Web/setup_tomcat_web/20200227141234988.png" alt="在这里插入图片描述"></p>
<h2 id="四-资料"><a href="#四-资料" class="headerlink" title="四 资料"></a>四 资料</h2><p>参考文章：<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/14259192/2391301">https://blog.51cto.com/14259192/2391301</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lei01/p/9911156.html">https://www.cnblogs.com/lei01/p/9911156.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44538107/article/details/88683530">https://blog.csdn.net/weixin_44538107/article/details/88683530</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guarderming/p/11223817.html">linux防火墙设置指南</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Web/setup_tomcat_web/" data-id="cmbcy7rhf0026t8mtft4ue38a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
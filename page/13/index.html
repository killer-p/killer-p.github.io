<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/OpenHarmony/WLAN_Message" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/WLAN_Message/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.816Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="WLAN-message"><a href="#WLAN-message" class="headerlink" title="WLAN message"></a>WLAN message</h2><p>来自HDI client端的命令主要分三个类型：BaseCommands、APCommands、STACommands。</p>
<p>针对不同类型的CMD，也有三个服务来响应这些命令，分别是base feature、ap feature、sta feature。这三个feature定义在&#x2F;drivers&#x2F;framework&#x2F;model&#x2F;network&#x2F;wifi&#x2F;core&#x2F;components下。</p>
<h3 id="一、ServiceDef"><a href="#一、ServiceDef" class="headerlink" title="一、ServiceDef"></a>一、ServiceDef</h3><p>驱动设计了一套message机制来响应来自HDI的命令，我们先把HDI的命令理解为message，才能使用这套机制，本文用于了解wlan message。</p>
<p>MessageDef：把HDI client命令理解成message，其成员MessageHandler是函数指针，指向处理命令的函数，pri是函数参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MessageDef</span> &#123;</span></span><br><span class="line">    MessageHandler handler;</span><br><span class="line">    <span class="type">uint8_t</span> pri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在wlan 驱动中定义了三个MessageDef数组，分别用于处理三种类型的HDI message。例如sta.c中定义了5个成员的数组，用于处理5个具体的sta命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//messagedef of servicedef</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">MessageDef</span> <span class="title">g_wifiStaFeatureCmds</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">//DUEMessage(index,MessageHandler,pri)</span></span><br><span class="line">    DUEMessage(CMD_STA_CONNECT, WifiCmdAssoc, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_DISCONNECT, WifiCmdDisconnect, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_SCAN, WifiCmdScan, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_ABORT_SCAN, WifiCmdAbortScan, <span class="number">0</span>),</span><br><span class="line">    DUEMessage(CMD_STA_SET_SCAN_MAC_ADDR, WifiCmdSetScanningMacAddress, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时还要注意到g_wifiStaFeatureCmds下方有一句宏定义：将该宏定义展开，可得到函数CreateServiceSTAService()，该函数创建了一个ServiceDef结构体，并调用InitService()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceDefine(STAService, STA_SERVICE_ID, g_wifiStaFeatureCmds);</span><br><span class="line"><span class="comment">/**               </span></span><br><span class="line"><span class="comment">    Service *CreateServiceSTAService(const ServiceCfg *cfg)                </span></span><br><span class="line"><span class="comment">    &#123;                                                                         </span></span><br><span class="line"><span class="comment">        static struct ServiceDef serviceDef = &#123;                               </span></span><br><span class="line"><span class="comment">            .serviceId = STA_SERVICE_ID,                                          </span></span><br><span class="line"><span class="comment">            .messagesLength = sizeof(g_wifiStaFeatureCmds) / sizeof(struct MessageDef), </span></span><br><span class="line"><span class="comment">            .messages = g_wifiStaFeatureCmds                                            </span></span><br><span class="line"><span class="comment">        &#125;;                                                                    </span></span><br><span class="line"><span class="comment">        return InitService(&amp;serviceDef, cfg);                                 </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这里就引入了ServiceDef对象，他不仅包含MessageDef，还有ServiceId，以及messagesLength。整个驱动一共有三个ServiceDef，分别为三种类型的message提供服务响应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ServiceDef</span> &#123;</span></span><br><span class="line">    ServiceId serviceId;	<span class="comment">//DispatcherId dispatcherId，用于指示是baseservice,staservice,apservice</span></span><br><span class="line">    <span class="type">uint8_t</span> messagesLength;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MessageDef</span> *<span class="title">messages</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、RemoteService"><a href="#二、RemoteService" class="headerlink" title="二、RemoteService()"></a>二、RemoteService()</h3><p>InitService()函数在sidecar.c中，其主要作用就是创建Service结构体，调用RegistLocalService()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create sidecar service and remote service,the cfg is defaultid </span></span><br><span class="line">Service *<span class="title function_">InitService</span><span class="params">(<span class="keyword">struct</span> ServiceDef *def, <span class="type">const</span> ServiceCfg *cfg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Service *service = (Service *)OsalMemCalloc(<span class="keyword">sizeof</span>(Service));</span><br><span class="line">	<span class="comment">//init some funcs</span></span><br><span class="line">    service-&gt;SendAsyncMessage = SideCarSendAsyncMessage;</span><br><span class="line">    service-&gt;SendSyncMessage = SideCarSendSyncMessage;</span><br><span class="line">    service-&gt;SendOneWayMessage = SideCarSendOneWayMessage;</span><br><span class="line">    service-&gt;Destroy = DestroyService;</span><br><span class="line"></span><br><span class="line">    SideCarPrivateData *privateData = (SideCarPrivateData *)OsalMemCalloc(<span class="keyword">sizeof</span>(SideCarPrivateData));</span><br><span class="line">    privateData-&gt;serviceId = def-&gt;serviceId;</span><br><span class="line">    privateData-&gt;dispatcherId = cfg-&gt;dispatcherId;</span><br><span class="line">    service-&gt;privateData = (<span class="type">void</span> *)privateData;</span><br><span class="line">    privateData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init remote service</span></span><br><span class="line">    ErrorCode errCode = RegistLocalService(cfg-&gt;dispatcherId, def);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegistLocalService调用RegistServiceInner。主要完成RemoteService的创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create remote service</span></span><br><span class="line"><span class="type">static</span> ErrorCode <span class="title function_">RegistServiceInner</span><span class="params">(<span class="type">const</span> NodeId nodeId, <span class="type">const</span> DispatcherId dispatcherId, <span class="keyword">struct</span> ServiceDef *mapper)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDF_STATUS status = OsalMutexTimedLock(&amp;g_routerMutex, HDF_WAIT_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get default message node</span></span><br><span class="line">    MessageNode *node = RefMessageNode(nodeId, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    RemoteService *remoteService = <span class="literal">NULL</span>;</span><br><span class="line">    MessageDispatcher *dispatcher = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//get default dispatch</span></span><br><span class="line">        dispatcher = RefDispatcherInner(dispatcherId, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// CreateLocalNodeService(node,dispatcher, mapper)</span></span><br><span class="line">        remoteService = node-&gt;CreateRemoteService(node, dispatcher, mapper);</span><br><span class="line"></span><br><span class="line">        errCode = NotifyAllNodesServiceAdd(nodeId, mapper);</span><br><span class="line">		<span class="comment">//add remoteService to g_servicesIndex[]</span></span><br><span class="line">        errCode = DoRegistService(nodeId, dispatcherId, remoteService);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    status = OsalMutexUnlock(&amp;g_routerMutex);</span><br><span class="line">    <span class="keyword">if</span> (dispatcher != <span class="literal">NULL</span> &amp;&amp; dispatcher-&gt;Disref != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//realease dispatcher</span></span><br><span class="line">        dispatcher-&gt;Disref(dispatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;Disref != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;Disref(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一个新的重要的结构体 RemoteService，但我们先暂时按下不表，来看他是如何被创建的。</p>
<h4 id="2-1、MessageNode"><a href="#2-1、MessageNode" class="headerlink" title="2.1、MessageNode"></a>2.1、MessageNode</h4><p>创建 RemoteService的方式是调用node-&gt;CreateRemoteService()函数，所以这个函数执行的前提是MessageNode先被创建出来，我们需要先知道MessageNode是如何被创建的，才能知道RemoteService被创建时的参数。</p>
<p>MessageNode的创建函数是CreateLocalNode()，定义在local_node.c中，这里我们仅需要关注CreateRemoteService函数指针的实现：CreateLocalNodeService()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ErrorCode <span class="title function_">CreateLocalNode</span><span class="params">(MessageNode **node)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocalMessageNode *newNode = (LocalMessageNode *)OsalMemCalloc(<span class="keyword">sizeof</span>(LocalMessageNode));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        newNode-&gt;status = ME_STATUS_STOPPED;</span><br><span class="line">        newNode-&gt;Init = InitLocalNode;</span><br><span class="line">        <span class="comment">//创建remote service的方法</span></span><br><span class="line">        newNode-&gt;CreateRemoteService = CreateLocalNodeService;</span><br><span class="line">        newNode-&gt;SyncService = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;NotifyServiceAdd = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;NotifyServiceDel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> errCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2、LocalNodeService"><a href="#2-2、LocalNodeService" class="headerlink" title="2.2、LocalNodeService"></a>2.2、LocalNodeService</h4><p>CreateLocalNodeService()创建了RemoteService的超集LocalNodeService。这里实现了RemoteService中的许多函数，并把之前定义的ServiceDef，和dispatch赋值给LocalNodeService。（dispatch在后面介绍）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RemoteService *<span class="title function_">CreateLocalNodeService</span><span class="params">(MessageNode *node, MessageDispatcher *dispatcher, <span class="keyword">struct</span> ServiceDef *mapper)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//create local node service</span></span><br><span class="line">    LocalNodeService *service = (LocalNodeService *)OsalMemCalloc(<span class="keyword">sizeof</span>(LocalNodeService));</span><br><span class="line"></span><br><span class="line">    ErrorCode errCode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//realize some funcs</span></span><br><span class="line">        service-&gt;status = ME_STATUS_RUNNING;</span><br><span class="line">        <span class="comment">//重点</span></span><br><span class="line">        service-&gt;ExecRequestMsg = HandleRequestMessage;</span><br><span class="line">        service-&gt;ExecResponseMsg = HandleResponseMessage;</span><br><span class="line">        service-&gt;SendMessage = SendMessageLocalNode;</span><br><span class="line">        service-&gt;Shutdown = ShutdownLocalService;</span><br><span class="line">        service-&gt;serviceId = mapper-&gt;serviceId;</span><br><span class="line">        service-&gt;mapper = mapper;</span><br><span class="line">        service-&gt;dispatcher = dispatcher-&gt;Ref(dispatcher);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> (RemoteService *)service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalNodeService 展开宏定义后，可见LocalNodeService 就是RemoteService再加上MessageDispatcher和ServiceDef。</p>
<p>所以本质上也是创建RemoteService。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展开宏定义后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LocalNodeService</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">MessageEngineStatus</span> <span class="title">status</span>;</span>                </span><br><span class="line">    OsalAtomic refCount;                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RemoteService</span> *(*<span class="title">Ref</span>)(<span class="keyword">struct</span> <span class="title">RemoteService</span> * <span class="title">obj</span>);</span> </span><br><span class="line">    <span class="type">void</span> (*Disref)(<span class="keyword">struct</span> RemoteService * obj);          </span><br><span class="line">    <span class="type">void</span> (*Destroy)(<span class="keyword">struct</span> RemoteService * obj);</span><br><span class="line">    <span class="comment">//发送请求消息</span></span><br><span class="line">    <span class="type">void</span> (*ExecRequestMsg)(<span class="type">const</span> <span class="keyword">struct</span> RemoteService *service, MessageContext *context);  </span><br><span class="line">    <span class="comment">//发送响应消息</span></span><br><span class="line">    <span class="type">void</span> (*ExecResponseMsg)(<span class="type">const</span> <span class="keyword">struct</span> RemoteService *service, MessageContext *context);  </span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    ErrorCode (*SendMessage)(<span class="type">const</span> <span class="keyword">struct</span> RemoteService *service, MessageContext *context); </span><br><span class="line">    <span class="type">void</span> (*Shutdown)(<span class="keyword">struct</span> RemoteService * service);   </span><br><span class="line">    <span class="comment">//service类型：base、ap、sta</span></span><br><span class="line">    ServiceId serviceId;    </span><br><span class="line">    <span class="comment">//dispatch用于缓存消息</span></span><br><span class="line">    MessageDispatcher *dispatcher;</span><br><span class="line">    <span class="comment">//响应消息的服务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ServiceDef</span> *<span class="title">mapper</span>;</span></span><br><span class="line">&#125; LocalNodeService;</span><br></pre></td></tr></table></figure>

<p>到此我们创建了一个响应HDI层命令所需的结构体。</p>
<h3 id="三、MessageDispatcher"><a href="#三、MessageDispatcher" class="headerlink" title="三、MessageDispatcher"></a>三、MessageDispatcher</h3><p>其作用主要是缓存message，实现的方法是使用优先级队列来缓存message，在RunDispatcher线程中处理message。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MessageDispatcher</span> &#123;</span></span><br><span class="line">    SHARED_OBJ(MessageDispatcher); </span><br><span class="line">    OSAL_DECLARE_MUTEX(mutex); </span><br><span class="line">    ErrorCode (*AppendMessage)(<span class="keyword">struct</span> MessageDispatcher *, <span class="type">const</span> <span class="type">uint8_t</span> priority, MessageContext * context); 	<span class="comment">//将message缓存</span></span><br><span class="line">    ErrorCode (*Start)(<span class="keyword">struct</span> MessageDispatcher * dispatcher);                        </span><br><span class="line">    <span class="type">void</span> (*Shutdown)(<span class="keyword">struct</span> MessageDispatcher * dispatcher);                          </span><br><span class="line">    PriorityQueue *messageQueue</span><br><span class="line">&#125; MessageDispatcher;</span><br></pre></td></tr></table></figure>

<p>RunDispatcher线程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">RunDispatcher</span><span class="params">(<span class="type">void</span> *para)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dispatcher-&gt;status == ME_STATUS_RUNNING) &#123;</span><br><span class="line">        <span class="comment">//pop message</span></span><br><span class="line">        MessageContext *context = PopPriorityQueue(dispatcher-&gt;messageQueue, QUEUE_OPER_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HandleMessage(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleMessage</span><span class="params">(MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (context-&gt;requestType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_TYPE_SYNC_REQ:</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_TYPE_ASYNC_REQ:</span><br><span class="line">                HandleRequestMessage(context);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_TYPE_SYNC_RSP:</span><br><span class="line">                HandleSyncResponse(context);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_TYPE_ASYNC_RSP:</span><br><span class="line">                HandleAsyncResponse(context);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                HDF_LOGE(<span class="string">&quot;Unsupported message type %u&quot;</span>, context-&gt;requestType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleSyncResponse</span><span class="params">(MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDF_STATUS status = OsalSemPost(&amp;context-&gt;rspSemaphore);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用remoteservice-&gt;ExecRequestMsg和SendMessage</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleRequestMessage</span><span class="params">(MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    RemoteService *targetService = RefRemoteService(context-&gt;receiverId);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        targetService-&gt;ExecRequestMsg(targetService, context);</span><br><span class="line">        <span class="comment">// Convert to response message</span></span><br><span class="line">        SetToResponse(context);</span><br><span class="line">        rspService = RefRemoteService(context-&gt;receiverId);</span><br><span class="line">        errCode = rspService-&gt;SendMessage(rspService, context);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateLocalDispatcher用于创建MessageDispatcher，这里我们关注AppendMessage的实现：AppendToLocalDispatcher()，其本质就是将message推入指定的queue，然后在RunDispatcher线程中会弹出队列中的message，对message进行响应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ErrorCode <span class="title function_">CreateLocalDispatcher</span><span class="params">(MessageDispatcher **dispatcher, <span class="type">const</span> DispatcherConfig *config)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocalMessageDispatcher *localDispatcher = (LocalMessageDispatcher *)OsalMemCalloc(<span class="keyword">sizeof</span>(LocalMessageDispatcher));</span><br><span class="line">    ErrorCode errCode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//realize some func</span></span><br><span class="line">        localDispatcher-&gt;status = ME_STATUS_STOPPED;</span><br><span class="line">        localDispatcher-&gt;AppendMessage = AppendToLocalDispatcher;</span><br><span class="line">        localDispatcher-&gt;Shutdown = ShutdownDispatcher;</span><br><span class="line">        localDispatcher-&gt;Start = StartDispatcher;</span><br><span class="line">		<span class="comment">//create queues</span></span><br><span class="line">        localDispatcher-&gt;messageQueue = CreatePriorityQueue(config-&gt;queueSize, config-&gt;priorityLevelCount);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ErrorCode <span class="title function_">AppendToLocalDispatcher</span><span class="params">(MessageDispatcher *dispatcher, <span class="type">const</span> <span class="type">uint8_t</span> priority, MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PushPriorityQueue(dispatcher-&gt;messageQueue, priority, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PushPriorityQueue</span><span class="params">(PriorityQueue *<span class="built_in">queue</span>, <span class="type">const</span> <span class="type">uint8_t</span> priority, <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    queueImpl = (PriorityQueueImpl *)<span class="built_in">queue</span>;</span><br><span class="line">    pri = priority;</span><br><span class="line">    ret = PushQueue(queueImpl-&gt;queues[pri], context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、sidecar"><a href="#四、sidecar" class="headerlink" title="四、sidecar"></a>四、sidecar</h3><p>创建完成以上结构体后，wifi驱动框架究竟如何来响应来自HDI层的命令呢？也就是说我们上面所做的一切为了什么？</p>
<p>在HDF_WIFI驱动的dispatch函数中，调用的是DispatchToMessage()函数，该函数定义在sidecar.c中。sidecar.c就是封装了上面的结构体，提供接口给HDF_WIFI驱动使用，起到连接中介的作用。要注意到，驱动的命令是以id+HdfSBuf的形式传递进来的，需要转换成我们之前一直提到的message，才能由message系统来处理。</p>
<p>HDI client下发的命令通过io-dispatch会传递到DispatchToMessage()函数：</p>
<p>DispatchToMessage首先创建message，获取之前创建的LocalNodeService结构体中的RemoteService，调用其SendMessage()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">DispatchToMessage</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="type">int</span> id, <span class="keyword">struct</span> HdfSBuf *reqData, <span class="keyword">struct</span> HdfSBuf *rspData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//create message</span></span><br><span class="line">    context = CreateMessageContext(RESERVED_SERVICE_ID, serviceId, cmd, reqData);</span><br><span class="line"></span><br><span class="line">    context-&gt;rspData = rspData;</span><br><span class="line">    context-&gt;requestType = MESSAGE_TYPE_SYNC_REQ;</span><br><span class="line">    context-&gt;client = client;</span><br><span class="line">    RemoteService *targetService = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//get LocalNodeService</span></span><br><span class="line">        targetService = RefRemoteService(serviceId);</span><br><span class="line">        <span class="comment">//SendMessage = SendMessageLocalNode()</span></span><br><span class="line">        errCode = targetService-&gt;SendMessage(targetService, context);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (targetService != <span class="literal">NULL</span> &amp;&amp; targetService-&gt;Disref != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        targetService-&gt;Disref(targetService);</span><br><span class="line">    &#125;</span><br><span class="line">    OsalMemFree(context);</span><br><span class="line">    <span class="keyword">return</span> errCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建LocalNodeService时我们已经指定了SendMessage()函数的实现：</p>
<p>SendMessage()根据message类型作不同的处理：</p>
<ul>
<li>sync：同步类消息需要马上传递处理</li>
<li>async：异步类消息由RunDispatcher线程稍后处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ErrorCode <span class="title function_">SendMessageLocalNode</span><span class="params">(<span class="type">const</span> RemoteService *service, MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//sync req need respone</span></span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;crossNode &amp;&amp; context-&gt;requestType == MESSAGE_TYPE_SYNC_REQ) &#123;</span><br><span class="line">        HandleRequestMessage(service, context);</span><br><span class="line">        SetToResponse(context);</span><br><span class="line">        <span class="keyword">return</span> context-&gt;responseStatus;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context-&gt;requestType == MESSAGE_TYPE_SYNC_RSP) &#123;</span><br><span class="line">        (<span class="type">void</span>)OsalSemPost(&amp;context-&gt;rspSemaphore);</span><br><span class="line">        <span class="keyword">return</span> ME_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//async,append to message</span></span><br><span class="line">        <span class="keyword">return</span> localService-&gt;dispatcher-&gt;AppendMessage(localService-&gt;dispatcher, pri, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>message类型还进一步可分为request和response，所有request类型message最终都会调用HandleRequestMessage()来响应请求：</p>
<p>对于所有的请求message，最终都会调用 LocalNodeService的ServiceDef中的MessageDef来处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleRequestMessage</span><span class="params">(<span class="type">const</span> RemoteService *service, MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocalNodeService *localNodeService = (LocalNodeService *)service;</span><br><span class="line">	<span class="comment">//根据commandID获取请求对应的messageDef</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MessageDef</span> <span class="title">messageDef</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (localNodeService-&gt;mapper != <span class="literal">NULL</span> &amp;&amp; context-&gt;commandId &lt; localNodeService-&gt;mapper-&gt;messagesLength) &#123;</span><br><span class="line">        messageDef = localNodeService-&gt;mapper-&gt;messages[context-&gt;commandId];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用messageDef的函数处理请求</span></span><br><span class="line">    context-&gt;responseStatus = messageDef.handler((RequestContext *)context, context-&gt;reqData, context-&gt;rspData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>response类型message最终调用HandleResponseMessage()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleResponseMessage</span><span class="params">(<span class="type">const</span> RemoteService *service, MessageContext *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//sync</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;requestType == MESSAGE_TYPE_SYNC_RSP) &#123;</span><br><span class="line">        HDF_STATUS status = OsalSemPost(&amp;context-&gt;rspSemaphore);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context-&gt;requestType == MESSAGE_TYPE_ASYNC_RSP) &#123;</span><br><span class="line">        <span class="comment">//async</span></span><br><span class="line">        <span class="keyword">if</span> (context-&gt;callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            context-&gt;callback((<span class="type">const</span> RequestContext *)context, context-&gt;reqData, context-&gt;rspData,</span><br><span class="line">                context-&gt;responseStatus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><p>WLAN Message定义了如何处理来自WIFI HDI层的命令，这些命令适用于控制WIFI 硬件的行为。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/WLAN_Message/" data-id="cmbcy7rhn002it8mtci0gfikd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/WLAN_FlowContrl" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/WLAN_FlowContrl/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.816Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flow-Contrl"><a href="#Flow-Contrl" class="headerlink" title="Flow Contrl"></a>Flow Contrl</h2><p>WIFI驱动可以选择是否使用Flow Control来缓存网络数据的收发。</p>
<p>以下是Flow Control的定义，可以看到有两个线程分别负责处理收发数据的逻辑，有对应的两个信号量来完成线程的同步，以及由进程状态的变量，还有由netbuf组成的两个收发队列，这些是FlowControl模块使用到的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlowControlModule</span> &#123;</span></span><br><span class="line">    OSAL_DECLARE_THREAD(txTransferThread);              <span class="comment">//发送数据</span></span><br><span class="line">    OSAL_DECLARE_THREAD(rxTransferThread);              <span class="comment">//接收数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OsalSem</span> <span class="title">sem</span>[<span class="title">FLOW_DIR_COUNT</span>];</span>                 <span class="comment">//线程信号量</span></span><br><span class="line">    FcThreadStatus threadStatus[FLOW_DIR_COUNT];        <span class="comment">//线程状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlQueues</span> <span class="title">fcmQueue</span>[<span class="title">FLOW_DIR_COUNT</span>];</span>  <span class="comment">//netuf缓存队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlOp</span> *<span class="title">op</span>;</span>                           <span class="comment">//驱动实现</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlInterface</span> *<span class="title">interface</span>;</span>             <span class="comment">//提供给开发者的接口</span></span><br><span class="line">    <span class="type">void</span> *fcmPriv;                                      <span class="comment">/**&lt; Private data of the flow control module */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后还提供给开发者接口来操作FlowControl模块，例如FlowControlInterface，其定义在下面。根据g_fcInterface给我们提供的接口，可以知道开发者使用FlowControl模块主要就是向指定队列发送netbuf就完事了。当然还有最重要的，使用RegisterFlowControlOp注册一个FlowControlOp结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlInterface</span> <span class="title">g_fcInterface</span> =</span> &#123;</span><br><span class="line">    .setQueueThreshold = SetQueueThreshold,	<span class="comment">//设置队列最大值</span></span><br><span class="line">    .getQueueIdByEtherBuff = GetQueueIdByEtherBuff,	<span class="comment">//获取队列buff</span></span><br><span class="line">    .sendBuffToFCM = SendBuffToFCM,	<span class="comment">//发送netbuf到队列</span></span><br><span class="line">    .schedFCM = SchedTransfer,		<span class="comment">//调度线程</span></span><br><span class="line">    .registerFlowControlOp = RegisterFlowControlOp,	<span class="comment">//注册FlowControlOp结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>FlowControlOp由驱动开发者根据具体的wifi芯片实现，负责操作wifi 芯片的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlowControlOp</span> &#123;</span></span><br><span class="line">	<span class="comment">//检查wifi芯片是否处于station或p2p模式</span></span><br><span class="line">    <span class="type">bool</span> (*isDeviceStaOrP2PClient)(<span class="type">void</span>);</span><br><span class="line">    <span class="comment">//发送队列中的数据到网口</span></span><br><span class="line">    <span class="type">int32_t</span> (*txDataPacket)(NetBufQueue *q, <span class="type">void</span> *fcmPrivate, <span class="type">int32_t</span> fwPriorityId);</span><br><span class="line">	<span class="comment">//发送队列中的数据到协议栈</span></span><br><span class="line">    <span class="type">int32_t</span> (*rxDataPacket)(NetBufQueue *q, <span class="type">void</span> *fcmPrivate, <span class="type">int32_t</span> fwPriorityId);</span><br><span class="line">	<span class="comment">//获取发送队列id</span></span><br><span class="line">    FlowControlQueueID (*getTxQueueId)(<span class="type">const</span> <span class="type">void</span> *para);</span><br><span class="line">	<span class="comment">//获取接收队列id</span></span><br><span class="line">    FlowControlQueueID (*getRxQueueId)(<span class="type">const</span> <span class="type">void</span> *para);</span><br><span class="line">	<span class="comment">//获取发送队列优先级</span></span><br><span class="line">    <span class="type">int32_t</span> (*getTxPriorityId)(FlowControlQueueID id);</span><br><span class="line">	<span class="comment">//获取接收队列优先级</span></span><br><span class="line">    <span class="type">int32_t</span> (*getRxPriorityId)(FlowControlQueueID id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="一、创建FlowControlModule"><a href="#一、创建FlowControlModule" class="headerlink" title="一、创建FlowControlModule"></a>一、创建FlowControlModule</h3><p>创建FlowContriol模块很简单，就是初始化所有成员变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FlowControlModule *<span class="title function_">InitFlowControl</span><span class="params">(<span class="type">void</span> *fcmPriv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlModule</span> *<span class="title">fcm</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    fcm = (<span class="keyword">struct</span> FlowControlModule *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> FlowControlModule));</span><br><span class="line">    (<span class="type">void</span>)memset_s(fcm, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> FlowControlModule), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> FlowControlModule));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化两个队列</span></span><br><span class="line">    FlowControlQueueInit(fcm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FLOW_DIR_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OsalSemInit(&amp;fcm-&gt;sem[i], <span class="number">0</span>) != HDF_SUCCESS) &#123;</span><br><span class="line">            OsalMemFree(fcm);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化线程</span></span><br><span class="line">    <span class="keyword">if</span> (CreateFlowControlTask(fcm) != HDF_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册接口</span></span><br><span class="line">    fcm-&gt;interface = &amp;g_fcInterface;</span><br><span class="line">    fcm-&gt;fcmPriv = fcmPriv;</span><br><span class="line">    g_fcm = fcm;</span><br><span class="line">    <span class="keyword">return</span> fcm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-1、收发线程"><a href="#1-1、收发线程" class="headerlink" title="1.1、收发线程"></a>1.1、收发线程</h4><p>在创建flowcontrol 线程中可以看到两个线程的优先级是最高的，因为网络数据需要及时处理，否则会导致队列溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">CreateFlowControlTask</span><span class="params">(<span class="keyword">struct</span> FlowControlModule *fcm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OsalThreadParam</span> <span class="title">config</span> =</span> &#123;</span><br><span class="line">        .priority = OSAL_THREAD_PRI_HIGHEST,	<span class="comment">//最高的优先级</span></span><br><span class="line">        .stackSize = <span class="number">0</span>,	<span class="comment">//为什么栈大小为0？</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> ret = CreateTask(&amp;fcm-&gt;txTransferThread, RX_THREAD_NAME, RunWiFiTxFlowControl, &amp;config, fcm);</span><br><span class="line">    ret = CreateTask(&amp;fcm-&gt;rxTransferThread, TX_THREAD_NAME, RunWiFiRxFlowControl, &amp;config, fcm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程使用同一套代码，根据参数dir来判断是接收还是发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">RunWiFiFlowControl</span><span class="params">(<span class="type">void</span> *para, FlowDir dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlModule</span> *<span class="title">fcm</span> =</span> (<span class="keyword">struct</span> FlowControlModule *)para;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        fcm-&gt;threadStatus[dir] = THREAD_WAITING;</span><br><span class="line">        <span class="comment">//等待信号量同步</span></span><br><span class="line">        <span class="keyword">if</span> (OsalSemWait(&amp;fcm-&gt;sem[dir], HDF_WAIT_FOREVER) != HDF_SUCCESS) &#123;</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s exit: OsalSemWait return false!&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fcm-&gt;threadStatus[dir] = THREAD_RUNNING;</span><br><span class="line">        <span class="comment">//分别处理收发逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (dir == FLOW_TX) &#123;</span><br><span class="line">            FlowControlTxTreadProcess(fcm);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == FLOW_RX) &#123;</span><br><span class="line">            FlowControlRxTreadProcess(fcm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2、队列"><a href="#1-2、队列" class="headerlink" title="1.2、队列"></a>1.2、队列</h4><p>我们知道无论什么类型的网络数据，最终都要进入队列，因为该模块的队列比较多，我们先看看有队列是什么以及有哪些队列：</p>
<p>FlowControlQueue定义如下，其本质是在NetBufQueue的基础上，增加一些变量来给FlowControl管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlowControlQueue</span> &#123;</span></span><br><span class="line">    FlowControlQueueID queueID;  <span class="comment">//见下文</span></span><br><span class="line">    NetBufQueue dataQueue;       <span class="comment">//由netbuf组成的队列</span></span><br><span class="line">    <span class="type">uint32_t</span> queueThreshold;     <span class="comment">//网络数据最大值</span></span><br><span class="line">    OsalSpinlock lock;           <span class="comment">/**&lt; Queue lock */</span></span><br><span class="line">    <span class="type">uint32_t</span> pktCount;           <span class="comment">/**&lt; Number of packets received by the network data queue */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>FlowControlQueueID是用于表示一个队列组所拥有的所有类型的队列，一个队列组包含了9个不同等级（类型）的队列，这些队列是有优先级的。例如其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CTRL_QUEUE_ID = <span class="number">0</span>,  <span class="comment">/**&lt; Control queue ID */</span></span><br><span class="line">    VIP_QUEUE_ID,       <span class="comment">/**&lt; VIP queue ID */</span></span><br><span class="line">    NORMAL_QUEUE_ID,    <span class="comment">/**&lt; Normal queue ID */</span></span><br><span class="line">    TCP_DATA_QUEUE_ID,  <span class="comment">/**&lt; TCP data queue ID */</span></span><br><span class="line">    TCP_ACK_QUEUE_ID,   <span class="comment">/**&lt; TCP ACK queue ID */</span></span><br><span class="line">    BK_QUEUE_ID,        <span class="comment">/**&lt; Background flow queue ID */</span></span><br><span class="line">    BE_QUEUE_ID,        <span class="comment">/**&lt; Best-effort flow queue ID */</span></span><br><span class="line">    VI_QUEUE_ID,        <span class="comment">/**&lt; Video flow queue ID */</span></span><br><span class="line">    VO_QUEUE_ID,        <span class="comment">/**&lt; Voice flow queue ID */</span></span><br><span class="line">    QUEUE_ID_COUNT      <span class="comment">/**&lt; Total number of queue IDs */</span></span><br><span class="line">&#125; FlowControlQueueID;</span><br></pre></td></tr></table></figure>

<p>在全局变量中，就有如下四个队列组，其意义见代码注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sta模式发送线程所拥有的队列类型</span></span><br><span class="line"><span class="type">static</span> FlowControlQueueID g_staPriorityMapTx[QUEUE_ID_COUNT] = &#123;</span><br><span class="line">    CTRL_QUEUE_ID, VIP_QUEUE_ID, NORMAL_QUEUE_ID, TCP_ACK_QUEUE_ID, TCP_DATA_QUEUE_ID, VO_QUEUE_ID, VI_QUEUE_ID,</span><br><span class="line">    BE_QUEUE_ID, BK_QUEUE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sta模式接收线程所拥有的队列类型</span></span><br><span class="line"><span class="type">static</span> FlowControlQueueID g_staPriorityMapRx[QUEUE_ID_COUNT] = &#123;</span><br><span class="line">    CTRL_QUEUE_ID, VIP_QUEUE_ID, NORMAL_QUEUE_ID, TCP_DATA_QUEUE_ID, TCP_ACK_QUEUE_ID, VO_QUEUE_ID, VI_QUEUE_ID,</span><br><span class="line">    BE_QUEUE_ID, BK_QUEUE_ID</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//应该是ap模式下的</span></span><br><span class="line"><span class="type">static</span> FlowControlQueueID g_priorityMapTx[QUEUE_ID_COUNT] = &#123;</span><br><span class="line">    CTRL_QUEUE_ID, VIP_QUEUE_ID, NORMAL_QUEUE_ID, TCP_DATA_QUEUE_ID, TCP_ACK_QUEUE_ID, VO_QUEUE_ID, VI_QUEUE_ID,</span><br><span class="line">    BE_QUEUE_ID, BK_QUEUE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> FlowControlQueueID g_priorityMapRx[QUEUE_ID_COUNT] = &#123;</span><br><span class="line">    CTRL_QUEUE_ID, VIP_QUEUE_ID, NORMAL_QUEUE_ID, TCP_ACK_QUEUE_ID, TCP_DATA_QUEUE_ID, VO_QUEUE_ID, VI_QUEUE_ID,</span><br><span class="line">    BE_QUEUE_ID, BK_QUEUE_ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，收发线程的作用就是负责把队列中的netbuf送到他们该去的地方。发送的netbuf就应该传递给网口驱动，而接收到的netbuf就该传递给协议栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送线程处理队列中的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FlowControlTxTreadProcess</span><span class="params">(<span class="keyword">struct</span> FlowControlModule *fcm)</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">//sta发送队列组</span></span><br><span class="line">    <span class="keyword">if</span> (isSta) &#123;</span><br><span class="line">        <span class="comment">//遍历队列组的所有队列</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FLOW_CONTROL_MAP_SIZE; i++) &#123;</span><br><span class="line">            SendFlowControlQueue(fcm, g_staPriorityMapTx[i], FLOW_TX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FLOW_CONTROL_MAP_SIZE; i++) &#123;</span><br><span class="line">            SendFlowControlQueue(fcm,  g_priorityMapTx[i], FLOW_TX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FlowControlTxTreadProcess和FlowControlRxTreadProcess最后会调用SendFlowControlQueue来入队，最终调用txDataPacket或rxDataPacket来发送接受数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">SendFlowControlQueue</span><span class="params">(<span class="keyword">struct</span> FlowControlModule *fcm, <span class="type">uint32_t</span> id, <span class="type">uint32_t</span> dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取指定队列</span></span><br><span class="line">    q = &amp;fcm-&gt;fcmQueue[dir].queues[id].dataQueue;</span><br><span class="line">    <span class="keyword">if</span> (dir == FLOW_TX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fcm-&gt;op != <span class="literal">NULL</span> &amp;&amp; fcm-&gt;op-&gt;getTxPriorityId != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//获取队列优先级</span></span><br><span class="line">            fwPriorityId = fcm-&gt;op-&gt;getTxPriorityId(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fcm-&gt;op != <span class="literal">NULL</span> &amp;&amp; fcm-&gt;op-&gt;txDataPacket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//调用FlowControlOp的发送函数，把队列中的netbuf通过网口发送</span></span><br><span class="line">            fcm-&gt;op-&gt;txDataPacket(q, fcm-&gt;fcmPriv, fwPriorityId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s fail : fcm-&gt;op-&gt;txDataPacket = null!&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == FLOW_RX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fcm-&gt;op != <span class="literal">NULL</span> &amp;&amp; fcm-&gt;op-&gt;getRxPriorityId != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rxPriorityId = fcm-&gt;op-&gt;getRxPriorityId(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fcm-&gt;op != <span class="literal">NULL</span> &amp;&amp; fcm-&gt;op-&gt;rxDataPacket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//调用FlowControlOp的接收函数，把队列中的netbuf传递给协议栈</span></span><br><span class="line">            fcm-&gt;op-&gt;rxDataPacket(q, fcm-&gt;fcmPriv, rxPriorityId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s fail : fcm-&gt;op-&gt;txDataPacket = null!&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、FlowControlInterface"><a href="#二、FlowControlInterface" class="headerlink" title="二、FlowControlInterface"></a>二、FlowControlInterface</h3><p>既然我们了解了FlowControl模块的线程的主要作用，即将数据入队。那么是由谁来发起（同步）线程的运行呢？这就需要使用到FlowControlInterface，开发者调用FlowControlInterface的接口来实现对队列的操作。我们重点关注sendBuffToFCM()和schedFCM()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlowControlInterface</span> &#123;</span></span><br><span class="line">    <span class="comment">//根据netbuf获取到队列的id</span></span><br><span class="line">    FlowControlQueueID (*getQueueIdByEtherBuff)(<span class="type">const</span> NetBuf *buff);</span><br><span class="line">	<span class="comment">//设置队列最大容量</span></span><br><span class="line">    <span class="type">int32_t</span> (*setQueueThreshold)(<span class="keyword">struct</span> FlowControlModule *fcm, <span class="type">uint32_t</span> queueThreshold, <span class="type">uint32_t</span> id, <span class="type">uint32_t</span> dir);</span><br><span class="line">	<span class="comment">//发送netbuf到队列</span></span><br><span class="line">    <span class="type">int32_t</span> (*sendBuffToFCM)(<span class="keyword">struct</span> FlowControlModule *fcm, NetBuf *buff, <span class="type">uint32_t</span> id, <span class="type">uint32_t</span> dir);</span><br><span class="line">	<span class="comment">//发送信号量，同步线程</span></span><br><span class="line">    <span class="type">int32_t</span> (*schedFCM)(<span class="keyword">struct</span> FlowControlModule *fcm, FlowDir dir);</span><br><span class="line">	<span class="comment">//注册FlowControlOp</span></span><br><span class="line">    <span class="type">int32_t</span> (*registerFlowControlOp)(<span class="keyword">struct</span> FlowControlModule *fcm, <span class="keyword">struct</span> FlowControlOp *op);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1、schedFCM"><a href="#2-1、schedFCM" class="headerlink" title="2.1、schedFCM"></a>2.1、schedFCM</h4><p>将netbuf推进到指定队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">SendBuffToFCM</span><span class="params">(<span class="keyword">struct</span> FlowControlModule *fcm, NetBuf *buff, <span class="type">uint32_t</span> id, <span class="type">uint32_t</span> dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlQueue</span> *<span class="title">fcmQueue</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    NetBufQueue *dataQ = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (!IsValidSentToFCMPra(fcm, id, dir)) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s fail : IsValidSentToFCMPra FALSE!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取队列</span></span><br><span class="line">    fcmQueue = &amp;fcm-&gt;fcmQueue[dir].queues[id];</span><br><span class="line">    <span class="comment">//获取netbuf队列</span></span><br><span class="line">    dataQ = &amp;fcmQueue-&gt;dataQueue;</span><br><span class="line">    <span class="comment">//检查fcmQueue的容量</span></span><br><span class="line">    FcmQueuePreProcess(fcmQueue);</span><br><span class="line">    <span class="keyword">if</span> (NetBufQueueIsEmpty(dataQ)) &#123;</span><br><span class="line">        fcm-&gt;fcmQueue[dir].queues[id].pktCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//netbuf入队</span></span><br><span class="line">    NetBufQueueEnqueue(dataQ, buff);</span><br><span class="line">    <span class="comment">//数据包+1</span></span><br><span class="line">    fcm-&gt;fcmQueue[dir].queues[id].pktCount++;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般驱动程序在调用SendBuffToFCM()后，还要调用SchedTransfer()来同步线程，使线程即使的处理队列中的netbuf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">SchedTransfer</span><span class="params">(<span class="keyword">struct</span> FlowControlModule *fcm, FlowDir dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    OsalSemPost(&amp;fcm-&gt;sem[dir]);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/WLAN_FlowContrl/" data-id="cmbcy7rhn002jt8mt70e4hfzu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/vm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/vm/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.815Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>我在想该如何开始虚拟内存的学习呢？</p>
<p>对于驱动开发，与虚拟内存接触最多的应该就是vmalloc() 函数以及 vmap()函数。</p>
<p>那么最好就是从vmalloc()开始看源码，看看vmalloc()是如何实现的。</p>
<p>在此之前我需要先了解vmalloc()的基本原理，有一个大概的思路再去看代码。</p>
<p>vmalloc() 会去申请一段连续的虚拟地址，然后为这个虚拟地址建立映射，目的是提供大块的虚拟内存给程序使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/vm/" data-id="cmbcy7rh9001jt8mtbye30zes" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/3.dsoftbus_core_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/3.dsoftbus_core_1/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.815Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dsoftbus-core（上）"><a href="#dsoftbus-core（上）" class="headerlink" title="dsoftbus core（上）"></a>dsoftbus core（上）</h2><p>好，现在压力给到了core目录，这里是服务端的实现，代码应该会复杂很多，我门应该从哪里入手？softbus服务必须向samgr注册，那么就从这个入手。</p>
<p>了解一下samgr这个是如何使用的。</p>
<h3 id="samgr"><a href="#samgr" class="headerlink" title="samgr"></a>samgr</h3><p>这个samgr的使用还有复杂，建议直接看readme：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/distributedschedule_samgr_lite">https://gitee.com/openharmony/distributedschedule_samgr_lite</a></p>
<h4 id="开发服务"><a href="#开发服务" class="headerlink" title="开发服务"></a>开发服务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义服务</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ExampleService</span> &#123;</span></span><br><span class="line">    INHERIT_SERVICE;</span><br><span class="line">    INHERIT_IUNKNOWNENTRY(DefaultFeatureApi);</span><br><span class="line">    Identity identity;</span><br><span class="line">&#125; ExampleService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="type">static</span> ExampleService g_example = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle,</span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,</span><br><span class="line">        .Invoke = <span class="literal">NULL</span>,</span><br><span class="line">        .SyncCall = SyncCall,</span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向samgr注册接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_example);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(EXAMPLE_SERVICE, GET_IUNKNOWN(g_example));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义服务初始化入口</span></span><br><span class="line">SYSEX_SERVICE_INIT(Init);</span><br></pre></td></tr></table></figure>

<h4 id="开发服务子功能"><a href="#开发服务子功能" class="headerlink" title="开发服务子功能"></a>开发服务子功能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义功能</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DemoFeature</span> &#123;</span></span><br><span class="line">    INHERIT_FEATURE;</span><br><span class="line">    INHERIT_IUNKNOWNENTRY(DemoApi);</span><br><span class="line">    Identity identity;</span><br><span class="line">    Service *parent;</span><br><span class="line">&#125; DemoFeature;</span><br><span class="line"><span class="comment">//功能对象</span></span><br><span class="line"><span class="type">static</span> DemoFeature g_example = &#123;</span><br><span class="line">    .GetName = FEATURE_GetName,</span><br><span class="line">    .OnInitialize = FEATURE_OnInitialize,</span><br><span class="line">    .OnStop = FEATURE_OnStop,</span><br><span class="line">    .OnMessage = FEATURE_OnMessage,</span><br><span class="line">    DEFAULT_IUNKNOWN_ENTRY_BEGIN,</span><br><span class="line">        .AsyncCall = AsyncCall,</span><br><span class="line">        .AsyncTimeCall = AsyncTimeCall,</span><br><span class="line">        .SyncCall = SyncCall,</span><br><span class="line">        .AsyncCallBack = AsyncCallBack,</span><br><span class="line">    DEFAULT_IUNKNOWN_ENTRY_END,</span><br><span class="line">    .identity = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//向samgr注册功能接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterFeature(EXAMPLE_SERVICE, (Feature *)&amp;g_example);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterFeatureApi(EXAMPLE_SERVICE, EXAMPLE_FEATURE, GET_IUNKNOWN(g_example));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义功能初始化入口</span></span><br><span class="line">SYSEX_FEATURE_INIT(Init);</span><br></pre></td></tr></table></figure>

<h3 id="looper"><a href="#looper" class="headerlink" title="looper"></a>looper</h3><p>looper是一种循环处理消息队列中消息的办法。</p>
<p>创建一个looper，应该会有一个对应的线程，在这个线程中去处理消息，如下创建了一个LoopTask</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SoftBusLooper *<span class="title function_">CreateNewLooper</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLooper *looper = (SoftBusLooper *)SoftBusCalloc(<span class="keyword">sizeof</span>(SoftBusLooper));</span><br><span class="line">    SoftBusLooperContext *context = SoftBusCalloc(<span class="keyword">sizeof</span>(SoftBusLooperContext));</span><br><span class="line">    <span class="keyword">if</span> (memcpy_s(context-&gt;name, <span class="keyword">sizeof</span>(context-&gt;name), name, <span class="built_in">strlen</span>(name)) != EOK) &#123;</span><br><span class="line">        SoftBusFree(looper);</span><br><span class="line">        SoftBusFree(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListInit(&amp;context-&gt;msgHead);</span><br><span class="line">    <span class="comment">// init context</span></span><br><span class="line">    pthread_mutex_init(&amp;context-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;context-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;context-&gt;condRunning, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init looper</span></span><br><span class="line">    looper-&gt;context = context;</span><br><span class="line">    looper-&gt;PostMessage = LooperPostMessage;</span><br><span class="line">    looper-&gt;PostMessageDelay = LooperPostMessageDelay;</span><br><span class="line">    looper-&gt;RemoveMessage = LooperRemoveMessage;</span><br><span class="line">    looper-&gt;RemoveMessageCustom = LoopRemoveMessageCustom;</span><br><span class="line">    <span class="type">int</span> ret = StartNewLooperThread(looper);</span><br><span class="line">    <span class="keyword">return</span> looper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">StartNewLooperThread</span><span class="params">(SoftBusLooper *looper)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINLOOP_STACK_SIZE 5120</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> threadAttr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;threadAttr);</span><br><span class="line">    pthread_attr_setstacksize(&amp;threadAttr, MAINLOOP_STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;threadAttr, LoopTask, looper) != <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;create DeathProcTask failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loopTask 的代码逻辑上就是 ：</p>
<ol>
<li>读取looper的上下文</li>
<li>从上下文中读取消息</li>
<li>调用消息的handler处理消息本身</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">LoopTask</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLooper *looper = arg;</span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    SoftBusLooperContext *context = looper-&gt;context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;context-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;lock failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context-&gt;running = <span class="number">1</span>;</span><br><span class="line">    g_isThreadStarted = <span class="number">1</span>;</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;context-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;lock failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait 检查线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (context-&gt;stop == <span class="number">1</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], stop ==1&quot;</span>, context-&gt;name);</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_isNeedDestroy == <span class="number">1</span>) &#123;</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上下文没有消息，进入等待</span></span><br><span class="line">        <span class="keyword">if</span> (IsListEmpty(&amp;context-&gt;msgHead)) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s] wait msg list empty&quot;</span>, context-&gt;name);</span><br><span class="line">            pthread_cond_wait(&amp;context-&gt;cond, &amp;context-&gt;lock);</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//有消息需要处理了</span></span><br><span class="line">        <span class="type">uint64_t</span> now = UptimeMicros();</span><br><span class="line">        ListNode *item = context-&gt;msgHead.next;</span><br><span class="line">        SoftBusMessage *msg = <span class="literal">NULL</span>;</span><br><span class="line">        SoftBusMessageNode *itemNode = CONTAINER_OF(item, SoftBusMessageNode, node);</span><br><span class="line">        <span class="type">uint64_t</span> time = itemNode-&gt;msg-&gt;time;</span><br><span class="line">        <span class="comment">//当前时间大于消息发送的时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt;= time) &#123;</span><br><span class="line">            <span class="comment">//获取消息 </span></span><br><span class="line">            msg = itemNode-&gt;msg;</span><br><span class="line">            ListDelete(item);    <span class="comment">//移除链表</span></span><br><span class="line">            SoftBusFree(itemNode);</span><br><span class="line">            context-&gt;msgSize--;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], get message. handle=%s,what=%d,msgSize=%u&quot;</span>,</span><br><span class="line">                context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what, context-&gt;msgSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> timespec tv;</span><br><span class="line">            tv.tv_sec = time / TIME_THOUSANDS_MULTIPLIER / TIME_THOUSANDS_MULTIPLIER;</span><br><span class="line">            tv.tv_nsec = time % (TIME_THOUSANDS_MULTIPLIER * TIME_THOUSANDS_MULTIPLIER) * TIME_THOUSANDS_MULTIPLIER;</span><br><span class="line">            pthread_cond_timedwait(&amp;context-&gt;cond, &amp;context-&gt;lock, &amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        context-&gt;currentMsg = msg;</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], HandleMessage message. handle=%s,what=%d&quot;</span>,</span><br><span class="line">            context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what);</span><br><span class="line">		<span class="comment">//使用消息的handler去处理消息本身</span></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;handler-&gt;HandleMessage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            msg-&gt;handler-&gt;HandleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], after HandleMessage message. handle=%s,what=%d&quot;</span>,</span><br><span class="line">            context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what);</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_lock(&amp;context-&gt;lock);</span><br><span class="line">        FreeSoftBusMsg(msg);</span><br><span class="line">        context-&gt;currentMsg = <span class="literal">NULL</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_lock(&amp;context-&gt;lock);</span><br><span class="line">    context-&gt;running = <span class="number">0</span>;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], running =0&quot;</span>, context-&gt;name);</span><br><span class="line">    pthread_cond_broadcast(&amp;context-&gt;cond);</span><br><span class="line">    pthread_cond_broadcast(&amp;context-&gt;condRunning);</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (g_isNeedDestroy == <span class="number">1</span>) &#123;</span><br><span class="line">        LooperDeinit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么looper上下文中的消息是怎么来的呢，看looper中定义了消息的发送和撤回。所以我们猜测looper的使用方法：</p>
<p>首先调用CreateNewLooper()创建一个looper结构体和一个线程，然后将一些需要执行的代码封装成消息，looper发送消息，looper会自动的处理这些代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftBusLooper</span> &#123;</span></span><br><span class="line">    SoftBusLooperContext *context;</span><br><span class="line">    <span class="type">void</span> (*PostMessage)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg);   <span class="comment">//想looper发送消息</span></span><br><span class="line">    <span class="type">void</span> (*PostMessageDelay)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg, <span class="type">uint64_t</span> delayMillis);</span><br><span class="line">    <span class="type">void</span> (*RemoveMessage)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler, <span class="type">int32_t</span> what);    <span class="comment">//撤回消息</span></span><br><span class="line">    <span class="comment">// customFunc, when match, return 0</span></span><br><span class="line">    <span class="type">void</span> (*RemoveMessageCustom)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler,</span><br><span class="line">        <span class="type">int</span> (*)(<span class="type">const</span> SoftBusMessage*, <span class="type">void</span>*), <span class="type">void</span> *args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="softbus-server-进程"><a href="#softbus-server-进程" class="headerlink" title="softbus server 进程"></a>softbus server 进程</h3><p>好，让我来看看软总线服务是如何定义的，以及如何启动的</p>
<p>在core&#x2F;frame中的build.gn中，指示了该目录下的代码是如何编译成可执行文件和共享库的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_library(<span class="string">&quot;softbus_server_frame&quot;</span>)</span><br><span class="line">executable(<span class="string">&quot;softbus_server&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>liteosa生成一个共享库和可执行文件，softbus_server以一个进程的方式运行。需要手动去运行。</p>
<p>分析一下这个程序会执行什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitSoftBusServer();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InitSoftBusServer()会依次初始化以下：</p>
<ol>
<li>启动bootstrap</li>
<li>创建默认looper</li>
<li>连接server</li>
<li>传输server</li>
<li>设备认证server</li>
<li>发现server</li>
<li>软总线server</li>
</ol>
<p>looper是什么作用？</p>
<p>初始化完成后，该进程具备什么样的功能？应用要具备软总线的所有的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">SoftbusConfigInit    <span class="comment">//设置g_configItems</span></span><br><span class="line">ServerStubInit</span><br><span class="line">    <span class="title function_">HOS_SystemInit</span><span class="params">()</span>;    <span class="comment">// SAMGR_Bootstrap(); 启动服务框架，需要服务框架支持</span></span><br><span class="line">    SERVER_InitClient()    <span class="comment">//create g_clientInfoList</span></span><br><span class="line">SoftBusTimerInit    <span class="comment">//使用标准的timer_create()等函数实现对g_timerFunList[]函数的回调执行</span></span><br><span class="line">LooperInit    <span class="comment">//create Loop-default，并放入全局数组</span></span><br><span class="line">ConnServerInit()-&gt;    <span class="comment">// 连接 init a ConnectFuncInterface</span></span><br><span class="line">        ConnInitTcp()   <span class="comment">//tcp的相关函数</span></span><br><span class="line">TransServerInit   <span class="comment">//传输</span></span><br><span class="line">    TransPermissionInit    <span class="comment">//LoadPermissionJson(PERMISSION_JSON_FILE)</span></span><br><span class="line">    TransSessionMgrInit    <span class="comment">//create g_sessionServerList</span></span><br><span class="line">    TransChannelInit    <span class="comment">//传输通道初始化，设置一些回调函数和链表</span></span><br><span class="line">        IServerChannelCallBack *cb = TransServerGetChannelCb();    <span class="comment">//return &amp;g_channelCallBack;</span></span><br><span class="line">        TransLaneMgrInit    <span class="comment">// CREATE g_channelLaneList</span></span><br><span class="line">        TransAuthInit(cb)</span><br><span class="line">        TransProxyManagerInit(cb)</span><br><span class="line">            TransProxySetCallBack</span><br><span class="line">            TransProxyTransInit</span><br><span class="line">            g_proxyChannelList = CreateSoftBusList();</span><br><span class="line">            PendingInit</span><br><span class="line">            <span class="title function_">RegisterTimeoutCallback</span><span class="params">(SOFTBUS_PROXYCHANNEL_TIMER_FUN, TransProxyTimerProc)</span>  <span class="comment">// channel的超时处理，添加到链表</span></span><br><span class="line">        <span class="title function_">TransTcpDirectInit</span><span class="params">(cb)</span>    <span class="comment">//设置tcp直连的通道回调函数和超时处理</span></span><br><span class="line">        <span class="title function_">TransUdpChannelInit</span><span class="params">(cb)</span>    <span class="comment">//udp通道初始化（udp主要是用于处理连接）</span></span><br><span class="line">            <span class="title function_">AuthTransDataRegCallback</span><span class="params">(TRANS_UDP_DATA, &amp;transUdpCb)</span>    <span class="comment">//注册udp数据回调函数</span></span><br><span class="line">                decryptData = (<span class="type">uint8_t</span> *)SoftBusCalloc(info-&gt;len - AuthGetEncryptHeadLen() + <span class="number">1</span>);</span><br><span class="line">                AuthDecrypt(option, CLIENT_SIDE_FLAG, (<span class="type">uint8_t</span> *)info-&gt;data, info-&gt;len, &amp;buf)</span><br><span class="line">                TransOnExchangeUdpInfo(authId, info-&gt;flags, info-&gt;seq, json, option);</span><br><span class="line">AuthInit    <span class="comment">//设备认证</span></span><br><span class="line">    AuthCallbackInit(MODULE_NUM)</span><br><span class="line">    AuthGetAbility();</span><br><span class="line">    AuthListInit();</span><br><span class="line">    RegisterConnCallback    <span class="comment">//设置认证回调函数</span></span><br><span class="line">    AuthLooperInit    <span class="comment">//looper是什么 Looper是一种单个线程中持续处理消息的的方式。</span></span><br><span class="line">        g_authHandler.HandleMessage = AuthTimeout;</span><br><span class="line">        g_authHandler.looper = GetLooper(LOOP_TYPE_DEFAULT);   <span class="comment">//获取到之前创建的Loop-default，消息处理函数是AuthTimeout()</span></span><br><span class="line">    UniqueIdInit    <span class="comment">//由时间生成id</span></span><br><span class="line">    HichainServiceInit    <span class="comment">//hichain是用于设备认证的一个安全子系统的,我们关注g_hichainCallback</span></span><br><span class="line">        InitDeviceAuthService    <span class="comment">//base\security\deviceauth\frameworks\src\ipc_sdk.c</span></span><br><span class="line">            InitProxyAdapt() <span class="comment">//请求deviceauth_server</span></span><br><span class="line">DiscServerInit    <span class="comment">//发现</span></span><br><span class="line">    DiscMgrInit    </span><br><span class="line">            g_discMgrMediumCb.OnDeviceFound = DiscOnDeviceFound;</span><br><span class="line">            g_discCoapInterface = DiscCoapInit(&amp;g_discMgrMediumCb);</span><br><span class="line">                InitCoapManager()</span><br><span class="line">                DiscNstackxInit()</span><br><span class="line">                    InitLocalInfo()</span><br><span class="line">                    NSTACKX_Init(&amp;g_nstackxCallBack)   <span class="comment">//注册了一个回调函数OnDeviceFound</span></span><br><span class="line">                        g_epollfd = CreateEpollDesc();</span><br><span class="line">                        PthreadCreate(&amp;g_tid, <span class="literal">NULL</span>, NstackMainLoop, <span class="literal">NULL</span>);</span><br><span class="line">                        InternalInit(g_epollfd);</span><br><span class="line">                            EventModuleInit(&amp;g_eventNodeChain, g_epollfd);</span><br><span class="line">                            DeviceModuleInit(epollfd);   <span class="comment">//初始化数据库、超时处理函数</span></span><br><span class="line">                            P2pUsbTimerInit(epollfd);</span><br><span class="line">                            CoapServerInit()     <span class="comment">//启动libcoap</span></span><br><span class="line">                            CoapDiscoverInit()   <span class="comment">//设置一些发现的定时器</span></span><br><span class="line">                DiscCoapRegisterCb(g_discMgrMediumCb)</span><br><span class="line">BusCenterServerInit    <span class="comment">//软总线服务</span></span><br><span class="line">    LnnInitLocalLedger    <span class="comment">//设置本地的信息</span></span><br><span class="line">    LnnInitDistributedLedger    <span class="comment">//Init Distributed Info</span></span><br><span class="line">    LnnInitSyncLedgerItem    <span class="comment">//设置g_netChanlistener，负责通道打开，消息处理回调</span></span><br><span class="line">    LnnInitEventMonitor</span><br><span class="line">    LnnInitDiscoveryManager   <span class="comment">//设置DeviceFound函数，如下构造一个msg，发送给looper-default</span></span><br><span class="line">        para = CreateConnectionAddrMsgPara(addr);</span><br><span class="line">        PostMessageToHandler(MSG_TYPE_DISCOVERY_DEVICE, para)</span><br><span class="line">            SoftBusMessage *msg = CreateNetBuilderMessage(msgType, para);</span><br><span class="line">            g_netBuilder.looper-&gt;PostMessage(g_netBuilder.looper, msg);</span><br><span class="line">    LnnInitNetworkManager</span><br><span class="line">        LnnInitIpNetwork</span><br><span class="line">            <span class="title function_">LnnRegisterEventHandler</span><span class="params">(LNN_MONITOR_EVENT_IP_ADDR_CHANGED, IpAddrChangeEventHandler)</span> <span class="comment">//注册网络状态的回调函数</span></span><br><span class="line">            <span class="title function_">LnnRegisterEventHandler</span><span class="params">(LNN_MONITOR_EVENT_WIFI_STATE_CHANGED, WifiStateChangeEventHandler)</span></span><br><span class="line">            <span class="title function_">GetUpdateLocalIp</span><span class="params">(ipAddr, IP_LEN, ifName, NET_IF_NAME_LEN, <span class="literal">false</span>)</span>  <span class="comment">//更新ip</span></span><br><span class="line">            <span class="title function_">SetLocalIpInfo</span><span class="params">(ipAddr, ifName)</span></span><br><span class="line">            <span class="title function_">DiscLinkStatusChanged</span><span class="params">(LINK_STATUS_UP, COAP)</span>;   <span class="comment">//最终执行SetLocalDeviceInfo();</span></span><br><span class="line">            OpenIpLink()    <span class="comment">//设置认证相关函数</span></span><br><span class="line">                OpenAuthPort();   <span class="comment">//执行OpenAuthServer，设置回调函数AuthOnConnectEvent和AuthOnDataEvent 处理认证的数据</span></span><br><span class="line">                OpenSessionPort()    <span class="comment">//设置session回调函数</span></span><br><span class="line">            LnnStartDiscovery()    <span class="comment">//通过DiscoveryFuncInterface来触发软总线发现</span></span><br><span class="line">                RestartPublish()</span><br><span class="line">                    DiscStartScan()    <span class="comment">//(DiscoveryFuncInterface)interface-&gt;StartScan()</span></span><br><span class="line">                LnnStartCoapDiscovery()</span><br><span class="line">                    DiscSetDiscoverCallback()</span><br><span class="line">                    DiscStartAdvertise()    <span class="comment">//(DiscoveryFuncInterface)interface-&gt;Subscribe</span></span><br><span class="line">    LnnInitNetBuilder   <span class="comment">//创建一个handler：NetBuilderMessageHandler，传递给looper-default，处理各种软总线的消息g_messageProcessor</span></span><br><span class="line">    LnnLanesInit</span><br><span class="line">    LnnTimeSyncInit     <span class="comment">//创建一个handler：TimeSyncMessageHandler，传递给looper-default，处理软总线的同步</span></span><br></pre></td></tr></table></figure>



<h3 id="softbus-服务"><a href="#softbus-服务" class="headerlink" title="softbus 服务"></a>softbus 服务</h3><p>请先了解一下鸿蒙的服务框架，在openharmony中注册一个softbus服务。</p>
<p>在<code>core/frame/small/init/src/softbus_server_stub.c</code>中，有softbus的注册服务的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(WAIT_FOR_SERVER);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_samgrService);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(SOFTBUS_SERVICE, GET_IUNKNOWN(g_samgrService));</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;Init success %s&quot;</span>, SOFTBUS_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line">SYSEX_SERVICE_INIT(Init);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来是softbus服务的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SoftbusSamgrService g_samgrService = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle, </span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,</span><br><span class="line">    .Invoke = Invoke,   <span class="comment">//重要：其他进程调用的IPC，会调用这个函数</span></span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我门来关注一下Invoke：不难理解，通过funcId来索引找到对应的处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">Invoke</span><span class="params">(IServerProxy *iProxy, <span class="type">int</span> funcId, <span class="type">void</span> *origin, IpcIo *req, IpcIo *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tblSize = <span class="keyword">sizeof</span>(g_serverInvokeCmdTbl) / <span class="keyword">sizeof</span>(ServerInvokeCmd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tblSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (funcId == g_serverInvokeCmdTbl[i].id) &#123;</span><br><span class="line">            <span class="keyword">return</span> g_serverInvokeCmdTbl[i].func(origin, req, reply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以找到softbus提供的全部IPC接口拉，应该可以和sdk目录下的函数相对应的，接下来我们就从这些函数入手，来了解整个core层中的发现，连接、组网，传输是如何实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ServerInvokeCmd g_serverInvokeCmdTbl[] = &#123;</span><br><span class="line">    &#123; MANAGE_REGISTER_SERVICE, ServerRegisterService &#125;,</span><br><span class="line">    &#123; SERVER_PUBLISH_SERVICE, ServerPublishService &#125;,</span><br><span class="line">    &#123; SERVER_UNPUBLISH_SERVICE, ServerUnPublishService &#125;,</span><br><span class="line">    &#123; SERVER_START_DISCOVERY, ServerStartDiscovery &#125;,</span><br><span class="line">    &#123; SERVER_STOP_DISCOVERY, ServerStopDiscovery &#125;,</span><br><span class="line">    &#123; SERVER_JOIN_LNN, ServerJoinLNN &#125;,</span><br><span class="line">    &#123; SERVER_LEAVE_LNN, ServerLeaveLNN &#125;,</span><br><span class="line">    &#123; SERVER_GET_ALL_ONLINE_NODE_INFO, ServerGetAllOnlineNodeInfo &#125;,</span><br><span class="line">    &#123; SERVER_GET_LOCAL_DEVICE_INFO, ServerGetLocalDeviceInfo &#125;,</span><br><span class="line">    &#123; SERVER_GET_NODE_KEY_INFO, ServerGetNodeKeyInfo &#125;,</span><br><span class="line">    &#123; SERVER_START_TIME_SYNC, ServerStartTimeSync &#125;,</span><br><span class="line">    &#123; SERVER_STOP_TIME_SYNC, ServerStopTimeSync &#125;,</span><br><span class="line">    &#123; SERVER_PUBLISH_LNN, ServerPublishLNN &#125;,</span><br><span class="line">    &#123; SERVER_STOP_PUBLISH_LNN, ServerStopPublishLNN &#125;,</span><br><span class="line">    &#123; SERVER_REFRESH_LNN, ServerRefreshLNN &#125;,</span><br><span class="line">    &#123; SERVER_STOP_REFRESH_LNN, ServerStopRefreshLNN &#125;,</span><br><span class="line">    &#123; SERVER_ACTIVE_META_NODE, ServerActiveMetaNode&#125;,</span><br><span class="line">    &#123; SERVER_DEACTIVE_META_NODE, ServerDeactiveMetaNode &#125;,</span><br><span class="line">    &#123; SERVER_GET_ALL_META_NODE_INFO, ServerGetAllMetaNodeInfo &#125;,</span><br><span class="line">    &#123; SERVER_CREATE_SESSION_SERVER, ServerCreateSessionServer &#125;,</span><br><span class="line">    &#123; SERVER_REMOVE_SESSION_SERVER, ServerRemoveSessionServer &#125;,</span><br><span class="line">    &#123; SERVER_OPEN_SESSION, ServerOpenSession &#125;,</span><br><span class="line">    &#123; SERVER_OPEN_AUTH_SESSION, ServerOpenAuthSession&#125;,</span><br><span class="line">    &#123; SERVER_NOTIFY_AUTH_SUCCESS, ServerNotifyAuthSuccess&#125;,</span><br><span class="line">    &#123; SERVER_CLOSE_CHANNEL, ServerCloseChannel &#125;,</span><br><span class="line">    &#123; SERVER_SESSION_SENDMSG, ServerSendSessionMsg &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="发现：ServerStartDiscovery"><a href="#发现：ServerStartDiscovery" class="headerlink" title="发现：ServerStartDiscovery"></a>发现：ServerStartDiscovery</h3><p>我门就以ServerStartDiscovery来看看，discovery包括了Advertise和Subscribe两个部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先是获取函数参数</span></span><br><span class="line">pkgName = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">SubscribeSerializer *info = (SubscribeSerializer *)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line"><span class="type">char</span> *capability = (<span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">callingUid = GetCallingUid(origin);</span><br><span class="line">DiscIpcStartDiscovery(pkgName, &amp;subscribeInfo);</span><br><span class="line">    SetCallLnnStatus(<span class="literal">false</span>);    <span class="comment">//g_isCallLnn = flag;</span></span><br><span class="line">    DiscStartDiscovery(packageName, info, &amp;g_discInnerCb);    <span class="comment">//g_discInnerCb = ClientIpcOnDeviceFound</span></span><br><span class="line">        DiscInfo *infoNode = CreateNewSubscribeInfoNode(info);</span><br><span class="line">        InnerStartDiscovery(packageName, infoNode, cb, SUBSCRIBE_SERVICE);</span><br><span class="line">            AddInfoToList(g_discoveryInfoList, packageName, &amp;callback, info, type);</span><br><span class="line">            DiscInterfaceByMedium(info, STARTDISCOVERTY_FUNC);</span><br><span class="line">                DiscInterfaceProcess(&amp;(info-&gt;option), g_discCoapInterface, info-&gt;mode, type);</span><br><span class="line">                    interface-&gt;StartAdvertise(&amp;(option-&gt;subscribeOption))</span><br><span class="line">                    interface-&gt;Subscribe(&amp;(option-&gt;subscribeOption))</span><br><span class="line">    ClientIpcDiscoverySuccess(packageName, info-&gt;subscribeId);</span><br></pre></td></tr></table></figure>

<p>好吧，最后是使用interface的StartAdvertise和Subscribe方法，g_discCoapInterface是在disc_manager.c中的DiscMgrInit()完成初始化的，DiscMgrInit()就在我们的softbus_server进程中被调用。</p>
<p>下面就是g_discCoapInterface的实例化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> DiscoveryFuncInterface g_discCoapFuncInterface = &#123;</span><br><span class="line">    .Publish = CoapPublish,</span><br><span class="line">    .StartScan = CoapStartScan,</span><br><span class="line">    .Unpublish = CoapUnPublish,</span><br><span class="line">    .StopScan = CoapStopScan,</span><br><span class="line">    .StartAdvertise = CoapStartAdvertise,</span><br><span class="line">    .Subscribe = CoapSubscribe,</span><br><span class="line">    .StopAdvertise = CoapStopAdvertise,</span><br><span class="line">    .Unsubscribe = CoapUnsubscribe,</span><br><span class="line">    .LinkStatusChanged = CoapUpdateLocalIp</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看看CoapStartAdvertise，字面意思应该就是使用coap进行广播。首先会注册能力位图，这是什么？（应该是一个数据，然后每一位上表示某个特性是否使能）然后使用postevent去执行DeviceDiscoverInner。DeviceDiscoverInner中是真正的去发coap请求包，并设置超时回调函数，以及设备发现回调函数。</p>
<p>CoapStartAdvertise函数调用流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RegisterAllCapBitmap</span><br><span class="line">DiscCoapSetFilterCapability</span><br><span class="line">DiscCoapStopDiscovery</span><br><span class="line">DiscCoapStartDiscovery</span><br><span class="line">    NSTACKX_StartDeviceFind</span><br><span class="line">        <span class="title function_">PostEvent</span><span class="params">(&amp;g_eventNodeChain, g_epollfd, DeviceDiscoverInner, <span class="literal">NULL</span>)</span>	<span class="comment">//执行DeviceDiscoverInner</span></span><br><span class="line">            DeviceDiscoverInner</span><br><span class="line">               <span class="title function_">CoapServiceDiscoverInner</span><span class="params">(INNER_DISCOVERY)</span>;</span><br><span class="line">                   SetModeInfo</span><br><span class="line">                   CoapPostServiceDiscover</span><br><span class="line">                       PrepareServiceDiscover</span><br><span class="line">                       CoapSendRequest</span><br><span class="line">                           FillCoapRequest</span><br><span class="line">                           CoapResolveAddress</span><br><span class="line">                           CoapGetSessionOnTargetServer</span><br><span class="line">                           CoapPackToPdu</span><br><span class="line">                           coap_send</span><br><span class="line">                           coap_session_release</span><br><span class="line">                   TimerSetTimeout</span><br><span class="line">               <span class="title function_">NotifyDeviceFound</span><span class="params">(<span class="literal">NULL</span>, <span class="number">0</span>)</span>;    <span class="comment">//g_parameter.onDeviceFound(deviceList, deviceCount);</span></span><br></pre></td></tr></table></figure>

<p>note：PostEvent可以简单的理解为调用DeviceDiscoverInner():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CoapServiceDiscoverInner</span><span class="params">(<span class="type">uint8_t</span> userRequest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> discoverInterval;</span><br><span class="line">    <span class="comment">//检查wifi连接</span></span><br><span class="line">    <span class="keyword">if</span> (!IsWifiApConnected() || g_context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//用户请求开启发现</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest) &#123;</span><br><span class="line">        <span class="comment">//强制进行发现</span></span><br><span class="line">        g_userRequest = NSTACKX_TRUE;</span><br><span class="line">        g_forceUpdate = NSTACKX_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (g_coapDiscoverTargetCount &gt; <span class="number">0</span> &amp;&amp; g_discoverCount &gt;= g_coapDiscoverTargetCount) &#123;</span><br><span class="line">        g_discoverCount = <span class="number">0</span>;</span><br><span class="line">        SetModeInfo(DISCOVER_MODE);</span><br><span class="line">        ClearDevices(GetDeviceDBBackup());</span><br><span class="line">        LOGW(TAG, <span class="string">&quot;clear device list backup&quot;</span>);</span><br><span class="line">        TimerSetTimeout(g_discoverTimer, <span class="number">0</span>, NSTACKX_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//g_discoverCount &gt; 0说明正在发现</span></span><br><span class="line">    <span class="keyword">if</span> (g_discoverCount) &#123;</span><br><span class="line">        <span class="comment">/* Service discover is ongoing, return. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* First discover */</span></span><br><span class="line">        <span class="comment">//备份设备数据</span></span><br><span class="line">        <span class="keyword">if</span> (BackupDeviceDB() != NSTACKX_EOK) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">&quot;backup device list fail&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清除设备</span></span><br><span class="line">        ClearDevices(GetDeviceDB());</span><br><span class="line">        LOGW(TAG, <span class="string">&quot;clear device list&quot;</span>);</span><br><span class="line">        <span class="comment">//设置最大的发现数量</span></span><br><span class="line">        g_coapDiscoverTargetCount = g_coapMaxDiscoverCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SetModeInfo(DISCOVER_MODE);</span><br><span class="line">    <span class="comment">//开始发现流程</span></span><br><span class="line">    <span class="keyword">if</span> (CoapPostServiceDiscover() != NSTACKX_EOK) &#123;</span><br><span class="line">        LOGE(TAG, <span class="string">&quot;failed to post service discover request&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置一些超时检查</span></span><br><span class="line">    discoverInterval = GetDiscoverInterval(g_discoverCount);</span><br><span class="line">    <span class="keyword">if</span> (TimerSetTimeout(g_discoverTimer, discoverInterval, NSTACKX_FALSE) != NSTACKX_EOK) &#123;</span><br><span class="line">        LOGE(TAG, <span class="string">&quot;failed to set timer for service discover&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++g_discoverCount;</span><br><span class="line">    LOGI(TAG, <span class="string">&quot;the first time for device discover.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始发现流程</span></span><br><span class="line">CoapPostServiceDiscover</span><br><span class="line">    GetLocalInterfaceName    <span class="comment">//获取网卡</span></span><br><span class="line">    GetIfBroadcastIp         <span class="comment">//获取广播ip</span></span><br><span class="line">    <span class="comment">//设置请求的uri</span></span><br><span class="line">    sprintf_s(discoverUri, <span class="keyword">sizeof</span>(discoverUri), <span class="string">&quot;coap://%s/%s&quot;</span>, ipString, <span class="string">&quot;device_discover&quot;</span>)</span><br><span class="line">    PrepareServiceDiscover(NSTACKX_TRUE);    <span class="comment">//构建json数据，格式见下文</span></span><br><span class="line">    CoapSendRequest(COAP_MESSAGE_NON, discoverUri, data, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, SERVER_TYPE_WLANORETH);</span><br><span class="line">        FillCoapRequest(&amp;coapRequest, coapType, url, data, dataLen);</span><br><span class="line">        CoapUriParse(coapRequest.remoteUrl, &amp;coapUri)</span><br><span class="line">        CoapResolveAddress(&amp;remote, &amp;dst.addr.sa);</span><br><span class="line">        CoapGetSessionOnTargetServer(serverType, &amp;coapServerParameter);</span><br><span class="line">        CoapPackToPdu(&amp;coapRequest, &amp;coapUri, session);</span><br><span class="line">        coap_send(session, pdu);</span><br><span class="line">json数据格式：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Service Discover JSON format</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   &quot;deviceId&quot;:[device ID, string],</span></span><br><span class="line"><span class="comment"> *   &quot;deviceName&quot;:[device name, string],</span></span><br><span class="line"><span class="comment"> *   &quot;type&quot;: [device type, number],</span></span><br><span class="line"><span class="comment"> *   &quot;version&quot;:[hicom version, string],</span></span><br><span class="line"><span class="comment"> *   &quot;wlanIp&quot;:[WLAN IP address, string],</span></span><br><span class="line"><span class="comment"> *   &quot;capabilityBitmap&quot;:[bitmap, bitmap, bitmap, ...]</span></span><br><span class="line"><span class="comment"> *   &quot;coapUri&quot;:[coap uri for discover, string]   &lt;-- optional. When present, means it&#x27;s broadcast request.</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>最终是调用coap_send函数发送报文的.当coap的发现报文成功发送到另一台设备时，设备会响应，这个响应报文的处理应该是 ClientIpcOnDeviceFound这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">ClientIpcOnDeviceFound</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> DeviceInfo *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_INFO, <span class="string">&quot;ondevice found ipc server push.&quot;</span>);</span><br><span class="line">    IpcIo io;</span><br><span class="line">    <span class="type">uint8_t</span> tmpData[MAX_SOFT_BUS_IPC_LEN_EX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化ipc的栈</span></span><br><span class="line">    IpcIoInit(&amp;io, tmpData, MAX_SOFT_BUS_IPC_LEN_EX, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把DeviceInfo入栈</span></span><br><span class="line">    IpcIoPushFlatObj(&amp;io, (<span class="type">const</span> <span class="type">void</span>*)device, <span class="keyword">sizeof</span>(DeviceInfo));</span><br><span class="line">    SvcIdentity svc = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//获取服务的id</span></span><br><span class="line">    <span class="keyword">if</span> (GetSvcIdentityByPkgName(pkgName, &amp;svc) != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_ERROR, <span class="string">&quot;ondevice found callback get svc failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送ipc请求给服务</span></span><br><span class="line">    <span class="type">int32_t</span> ans = SendRequest(<span class="literal">NULL</span>, svc, CLIENT_DISCOVERY_DEVICE_FOUND, &amp;io, <span class="literal">NULL</span>, LITEIPC_FLAG_ONEWAY, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_ERROR, <span class="string">&quot;ondevice found callback SendRequest failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在softbus 服务里的ClientOnDeviceFound函数就会来处理这个请求，这个函数通过函数指针一路回调到sdk层的，StartDiscovery函数里用户定义的回调函数。</p>
<p>发现的过程就到此。</p>
<h3 id="组网：ServerJoinLNN"><a href="#组网：ServerJoinLNN" class="headerlink" title="组网：ServerJoinLNN"></a>组网：ServerJoinLNN</h3><p>发现设备后要进行组网，就在ServerJoinLNN实现：首先是获取地址信息，组装成一个softbus message，然后发送给LoopTask线程，LoopTask的作用就是执行msg-&gt;handler-&gt;HandleMessage(msg);</p>
<h4 id="ServerJoinLNN"><a href="#ServerJoinLNN" class="headerlink" title="ServerJoinLNN"></a>ServerJoinLNN</h4><p>ServerJoinLNN函数执行流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是获取参数</span></span><br><span class="line">pkgName = IpcIoPopString</span><br><span class="line">addrTypeLen=IpcIoPopUint32</span><br><span class="line">*addr = (<span class="type">void</span>*)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line">callingUid = GetCallingUid(origin);</span><br><span class="line">LnnIpcServerJoin(pkgName, addr, addrTypeLen);</span><br><span class="line">    LnnServerJoin(connAddr);</span><br><span class="line">        para = CreateConnectionAddrMsgPara(addr);    <span class="comment">//para保存着地址信息</span></span><br><span class="line">        PostMessageToHandler(MSG_TYPE_JOIN_LNN, para)    <span class="comment">//把加入网络的消息发送到looper（注意PostMessageToHandler有两个实现）</span></span><br><span class="line">            SoftBusMessage *msg = CreateNetBuilderMessage(msgType, para);    <span class="comment">//创建消息</span></span><br><span class="line">                msg-&gt;handler = &amp;g_netBuilder.handler;   <span class="comment">//NetBuilderMessageHandler：到一个函数数组g_messageProcessor去处理消息</span></span><br><span class="line">            g_netBuilder.looper-&gt;PostMessage(g_netBuilder.looper,msg);  <span class="comment">//发消息让looper执行</span></span><br><span class="line">    AddJoinLNNInfo(pkgName, connAddr);     <span class="comment">//创建一个JoinLnnRequestInfo，然后加入链表</span></span><br></pre></td></tr></table></figure>

<p>所以这里的重点是NetBuilderMessageHandler，该函数比较简单，就是去调用对应的消息处理函数。这些函数被放到一个数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> NetBuilderMessageProcess g_messageProcessor[MSG_TYPE_MAX] = &#123;</span><br><span class="line">    ProcessJoinLNNRequest,</span><br><span class="line">    ProcessDevDiscoveryRequest,</span><br><span class="line">    ProcessCleanConnectionFsm,</span><br><span class="line">    ProcessAuthKeyGenerated,</span><br><span class="line">    ProcessAuthDone,</span><br><span class="line">    ProcessSyncDeviceInfoDone,</span><br><span class="line">    ProcessDeviceNotTrusted,</span><br><span class="line">    ProcessAuthDisconnect,</span><br><span class="line">    ProcessLeaveLNNRequest,</span><br><span class="line">    ProcessSyncOfflineFinish,</span><br><span class="line">    ProcessNodeStateChanged,</span><br><span class="line">    ProcessMasterElect,</span><br><span class="line">    ProcessLeaveInvalidConn,</span><br><span class="line">    ProcessLeaveByAddrType,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>MSG_TYPE_JOIN_LNN 对应的是 下标0 ，即 ProcessJoinLNNRequest()，其参数就是para，包含ip地址信息。</p>
<p>ProcessJoinLNNRequest调用TrySendJoinLNNRequest，进而调用PostJoinRequestToConnFsm：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LnnConnectionFsm *connFsm = StartNewConnectionFsm(addr);</span><br><span class="line">    connFsm = LnnCreateConnectionFsm(addr);</span><br><span class="line">    InitConnectionStateMachine()</span><br><span class="line">        fsm-&gt;looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">    	fsm-&gt;handler.name = name;</span><br><span class="line">    	fsm-&gt;handler.HandleMessage = FsmStateMsgHandler;</span><br><span class="line">    	fsm-&gt;handler.looper = fsm-&gt;looper;</span><br><span class="line">    	fsm-&gt;deinitCallback = cb;</span><br><span class="line">    	connFsm-&gt;connInfo.addr = *target;</span><br><span class="line">LnnSendJoinRequestToConnFsm(connFsm) </span><br><span class="line">    LnnFsmPostMessage(&amp;connFsm-&gt;fsm, FSM_MSG_TYPE_JOIN_LNN, <span class="literal">NULL</span>);</span><br><span class="line">        PostMessageToFsm(&amp;connFsm-&gt;fsm, FSM_CTRL_MSG_DATA, FSM_MSG_TYPE_JOIN_LNN, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            msg = CreateFsmHandleMsg(&amp;connFsm-&gt;fsm, FSM_CTRL_MSG_DATA, FSM_MSG_TYPE_JOIN_LNN, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            fsm-&gt;looper-&gt;PostMessage(fsm-&gt;looper, msg);</span><br></pre></td></tr></table></figure>

<p>可以发现这个函数是使用了LnnConnectionFsm，这个是连接状态机。然后构造一个消息给looper运行，我们只需要关注消息的handler就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg的handler就是状态机的handler</span></span><br><span class="line">msg-&gt;handler = &amp;fsm-&gt;handler;</span><br><span class="line">fsm-&gt;handler.HandleMessage = FsmStateMsgHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// msg-&gt;what == FSM_CTRL_MSG_DATA</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FsmStateMsgHandler</span><span class="params">(SoftBusMessage *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what) &#123;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_START:</span><br><span class="line">            ProcessStartMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_DATA:</span><br><span class="line">            ProcessDataMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_STOP:</span><br><span class="line">            ProcessStopMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_DEINIT:</span><br><span class="line">            ProcessDeinitMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ProcessDataMessage</span><span class="params">(SoftBusMessage *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    FsmCtrlMsgObj *ctrlMsgObj = msg-&gt;obj;</span><br><span class="line">    FsmStateMachine *fsm = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//由于msg-&gt;obj == NULL，所以在这里会返回</span></span><br><span class="line">    <span class="keyword">if</span> (ctrlMsgObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsm = ctrlMsgObj-&gt;fsm;</span><br><span class="line">    <span class="keyword">if</span> (fsm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fsm-&gt;curState == <span class="literal">NULL</span> || (fsm-&gt;flag &amp; FSM_FLAG_RUNNING) == <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_ERROR, <span class="string">&quot;unexpected state in data msg(%d) process, flag=0x%x&quot;</span>,</span><br><span class="line">            (<span class="type">int32_t</span>)msg-&gt;arg1, fsm-&gt;flag);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fsm-&gt;curState-&gt;process != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fsm-&gt;curState-&gt;process(fsm, (<span class="type">int32_t</span>)msg-&gt;arg1, ctrlMsgObj-&gt;obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/3.dsoftbus_core_1/" data-id="cmbcy7rhk002at8mt57i85b8i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/5.softbus_server" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/5.softbus_server/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.815Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="softbus-server程序"><a href="#softbus-server程序" class="headerlink" title="softbus_server程序"></a>softbus_server程序</h2><p>我们已经知道如何使用软总线提供的接口了，接下来可以了解软总线服务是如何实现的。软总线服务对应的系统进程就是softbus_server，这个程序入口位于foundation\communication\dsoftbus\core\frame\small\init\src\softbus_server_main.c </p>
<p>这个程序负责软总线功能的具体实现，所以会比较复杂。</p>
<h3 id="初始化软总线服务器"><a href="#初始化软总线服务器" class="headerlink" title="初始化软总线服务器"></a>初始化软总线服务器</h3><p>分析一下这个程序会执行什么，很明显这个程序会初始化软总线服务器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitSoftBusServer();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InitSoftBusServer()会依次初始化以下：</p>
<ol>
<li>启动bootstrap：会调用 softbus_server_stub.c 的 Init()函数注册softbus服务</li>
<li>创建default-looper：looper的作用见下文</li>
<li>连接server</li>
<li>传输server</li>
<li>设备认证server</li>
<li>发现server</li>
<li>软总线server</li>
</ol>
<p>初始化完成后，该进程具备什么样的功能？应用要具备软总线的所有的功能。下面是函数调用流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">SoftbusConfigInit()    <span class="comment">//设置g_configItems</span></span><br><span class="line">ServerStubInit()-&gt;       <span class="comment">//注册软总线服务到samgr</span></span><br><span class="line">SoftBusTimerInit()    <span class="comment">//使用定时器执行g_timerFunList</span></span><br><span class="line">LooperInit()    <span class="comment">//创建 Loop-default</span></span><br><span class="line">ConnServerInit()-&gt;    <span class="comment">// 初始化 ConnectFuncInterface 以及回调函数</span></span><br><span class="line">        g_connManagerCb.OnConnected = ConnManagerConnected;</span><br><span class="line">    	g_connManagerCb.OnDisconnected = ConnManagerDisconnected;</span><br><span class="line">    	g_connManagerCb.OnDataReceived = ConnManagerRecvData;</span><br><span class="line">        ConnInitTcp(&amp;g_connManagerCb)-&gt;  </span><br><span class="line">             g_tcpInterface.ConnectDevice = TcpConnectDevice;</span><br><span class="line">    	    g_tcpInterface.DisconnectDevice = TcpDisconnectDevice;</span><br><span class="line">    		g_tcpInterface.DisconnectDeviceNow = TcpDisconnectDeviceNow;</span><br><span class="line">    		g_tcpInterface.PostBytes = TcpPostBytes;</span><br><span class="line">    		g_tcpInterface.GetConnectionInfo = TcpGetConnectionInfo;</span><br><span class="line">    		g_tcpInterface.StartLocalListening = TcpStartListening;</span><br><span class="line">    		g_tcpInterface.StopLocalListening = TcpStopListening;</span><br><span class="line">    		g_tcpInterface.CheckActiveConnection = TcpCheckActiveConnection;</span><br><span class="line"></span><br><span class="line">TransServerInit()   <span class="comment">//传输</span></span><br><span class="line">    TransPermissionInit()    <span class="comment">//解析 /etc/softbus_trans_permission.json</span></span><br><span class="line">    TransSessionMgrInit()    <span class="comment">//创建 g_sessionServerList</span></span><br><span class="line">    TransChannelInit()    <span class="comment">//设置传输通道回调函数 g_channelCallBack</span></span><br><span class="line">        IServerChannelCallBack *cb = TransServerGetChannelCb();-&gt;    <span class="comment">//return &amp;g_channelCallBack;</span></span><br><span class="line">            g_channelCallBack.OnChannelOpened = TransServerOnChannelOpened;</span><br><span class="line">            g_channelCallBack.OnChannelClosed = TransServerOnChannelClosed;</span><br><span class="line">            g_channelCallBack.OnChannelOpenFailed = TransServerOnChannelOpenFailed;</span><br><span class="line">            g_channelCallBack.OnDataReceived = TransServerOnMsgReceived;</span><br><span class="line">            g_channelCallBack.OnQosEvent = TransServerOnQosEvent;</span><br><span class="line">            g_channelCallBack.GetPkgNameBySessionName = TransGetPkgNameBySessionName;</span><br><span class="line">            g_channelCallBack.GetUidAndPidBySessionName = TransGetUidAndPid;</span><br><span class="line">        TransLaneMgrInit()    <span class="comment">// 创建 g_channelLaneList</span></span><br><span class="line">        TransAuthInit(cb)-&gt;   <span class="comment">//设置认证通道回调函数</span></span><br><span class="line">            <span class="type">static</span> AuthTransCallback g_authTransCb = &#123;</span><br><span class="line">    			.onTransUdpDataRecv = AuthOnTransDataRecv,</span><br><span class="line">    			.onAuthChannelClose = AuthOnCloseChannel,</span><br><span class="line">		   &#125;;</span><br><span class="line">            AuthTransDataRegCallback(TRANS_AUTH_CHANNEL, &amp;g_authTransCb)</span><br><span class="line">        TransProxyManagerInit(cb)-&gt;</span><br><span class="line">            TransProxySetCallBack(cb)  </span><br><span class="line">            TransProxyTransInit()-&gt;</span><br><span class="line">                proxyCallback.OnConnected = TransProxyOnConnected;</span><br><span class="line">                proxyCallback.OnDisconnected = TransProxyOnDisConnect;</span><br><span class="line">                proxyCallback.OnDataReceived = TransProxyOnDataReceived;</span><br><span class="line">                ConnSetConnectCallback(MODULE_PROXY_CHANNEL, &amp;proxyCallback)</span><br><span class="line">                TransProxyLoopInit()-&gt;</span><br><span class="line">                    g_transLoophandler.looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">                    g_transLoophandler.HandleMessage = TransProxyLoopMsgHandler;  <span class="comment">//设置transproxy的消息处理函数</span></span><br><span class="line">            RegisterTimeoutCallback(SOFTBUS_PROXYCHANNEL_TIMER_FUN, TransProxyTimerProc)  <span class="comment">// channel的超时处理</span></span><br><span class="line">        TransTcpDirectInit(cb)-&gt;    <span class="comment">//注册tdc回调</span></span><br><span class="line">            P2pDirectChannelInit()   <span class="comment">//not supported </span></span><br><span class="line">            TransTdcSetCallBack(cb)-&gt;   </span><br><span class="line">                IServerChannelCallBack g_channelCb = *cb;</span><br><span class="line">            RegisterTimeoutCallback(SOFTBUS_TCP_DIRECTCHANNEL_TIMER_FUN, TransTdcTimerProc)  </span><br><span class="line">        TransUdpChannelInit(cb)    <span class="comment">//udp通道初始化（udp主要是用于处理连接）</span></span><br><span class="line">            AuthTransDataRegCallback(TRANS_UDP_DATA, &amp;transUdpCb)    <span class="comment">//注册udp数据回调函数</span></span><br><span class="line">                </span><br><span class="line">AuthInit    <span class="comment">//设备认证</span></span><br><span class="line">    AuthGetAbility();   <span class="comment">//打印ability</span></span><br><span class="line">    RegisterConnCallback(&amp;g_connCallback, &amp;g_connResult)-&gt;    <span class="comment">//设置认证回调函数</span></span><br><span class="line">        connCb-&gt;OnConnected = AuthOnConnected;</span><br><span class="line">        connCb-&gt;OnDisconnected = AuthOnDisConnect;</span><br><span class="line">        connCb-&gt;OnDataReceived = AuthOnDataReceived;</span><br><span class="line">        ConnSetConnectCallback(MODULE_DEVICE_AUTH, connCb)</span><br><span class="line">        connResult-&gt;OnConnectSuccessed = AuthOnConnectSuccessful;</span><br><span class="line">        connResult-&gt;OnConnectFailed = AuthOnConnectFailed;</span><br><span class="line">    AuthP2pInit()-&gt;   <span class="comment">//p2p的认证回调</span></span><br><span class="line">        VerifyCallback p2pVerifyCb = &#123;</span><br><span class="line">        .onKeyGenerated = AuthP2pOnKeyGenerated,</span><br><span class="line">        .onRecvSyncDeviceInfo = AuthP2pOnRecvSyncDeviceInfo,</span><br><span class="line">        .onDeviceVerifyPass = AuthP2pOnDeviceVerifyPass,</span><br><span class="line">        .onDeviceVerifyFail = AuthP2pOnDeviceVerifyFail,</span><br><span class="line">        .onDisconnect = AuthP2pOnDisconnect,</span><br><span class="line">        .onDeviceNotTrusted = AuthP2pOnDeviceNotTrusted,</span><br><span class="line">        .onGroupCreated = AuthP2pOnGroupCreated,</span><br><span class="line">        .onGroupDeleted = AuthP2pOnGroupDeleted</span><br><span class="line">        &#125;;</span><br><span class="line">    AuthLooperInit()    </span><br><span class="line">        g_authHandler.HandleMessage = AuthHandler;</span><br><span class="line">        g_authHandler.looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">    UniqueIdInit()    <span class="comment">//由时间生成id</span></span><br><span class="line">    HichainServiceInit()-&gt;    <span class="comment">//hichain是用于设备认证的一个安全子系统的,我们关注g_hichainCallback</span></span><br><span class="line">        InitDeviceAuthService()    <span class="comment">//base\security\deviceauth\frameworks\src\ipc_sdk.c 获取deviceauth server</span></span><br><span class="line">        g_hichainGaInstance = GetGaInstance();</span><br><span class="line">        g_hichainGmInstance = GetGmInstance();</span><br><span class="line">        g_hichainCallback.onTransmit = AuthOnTransmit;   <span class="comment">//设置设备认证回调函数</span></span><br><span class="line">        g_hichainCallback.onSessionKeyReturned = AuthOnSessionKeyReturned;</span><br><span class="line">        g_hichainCallback.onFinish = AuthOnFinish;</span><br><span class="line">        g_hichainCallback.onError = AuthOnError;</span><br><span class="line">        g_hichainCallback.onRequest = AuthOnRequest;</span><br><span class="line">        g_hichainListener.onGroupCreated = AuthOnGroupCreated;</span><br><span class="line">        g_hichainListener.onGroupDeleted = AuthOnGroupDeleted;</span><br><span class="line">        g_hichainListener.onDeviceNotTrusted = AuthOnDeviceNotTrusted;</span><br><span class="line"></span><br><span class="line">DiscServerInit()    <span class="comment">//发现</span></span><br><span class="line">    DiscMgrInit()-&gt;    </span><br><span class="line">            g_discMgrMediumCb.OnDeviceFound = DiscOnDeviceFound;</span><br><span class="line">            g_discCoapInterface = DiscCoapInit(&amp;g_discMgrMediumCb)-&gt; </span><br><span class="line">                DiscNstackxInit()</span><br><span class="line">                    InitLocalInfo()</span><br><span class="line">                    NSTACKX_Init(&amp;g_nstackxCallBack)   <span class="comment">//启动coap协议栈、设置epoll</span></span><br><span class="line">                        g_epollfd = CreateEpollDesc();  <span class="comment">//创建EpollSet 需要了解linux网络编程</span></span><br><span class="line">                        InternalInit(g_epollfd);</span><br><span class="line">                            EventModuleInit(&amp;g_eventNodeChain, g_epollfd); </span><br><span class="line">                            DeviceModuleInit(epollfd);   <span class="comment">//初始化数据库、超时处理函数</span></span><br><span class="line">                            P2pUsbTimerInit(epollfd);</span><br><span class="line">                            CoapServerInit(<span class="literal">NULL</span>)-&gt;     </span><br><span class="line">                                IsWifiApConnected()</span><br><span class="line">                                coap_startup();     <span class="comment">//启动libcoap</span></span><br><span class="line">                                g_ctx = CoapGetContext(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;5684&quot;</span>, NSTACKX_TRUE, ip);   <span class="comment">//TODO </span></span><br><span class="line">                                CoapInitResources(g_ctx, SERVER_TYPE_WLANORETH);    <span class="comment">//TODO </span></span><br><span class="line">                                coap_register_response_handler(g_ctx, CoapMessageHandler);    <span class="comment">//TODO </span></span><br><span class="line">                            CoapDiscoverInit()   <span class="comment">//设置发现的定时器</span></span><br><span class="line">                                TimerStart(epollfd, COAP_RECV_COUNT_INTERVAL, NSTACKX_TRUE,CoapRecvRecountTimerHandle, <span class="literal">NULL</span>); <span class="comment">//没用</span></span><br><span class="line">                                TimerStart(epollfd, <span class="number">0</span>, NSTACKX_FALSE, CoapServiceDiscoverTimerHandle, <span class="literal">NULL</span>);  <span class="comment">//用于重复发送coap发现报文</span></span><br><span class="line">                        PthreadCreate(&amp;g_tid, &amp;attr, NstackMainLoop, <span class="literal">NULL</span>)-&gt;</span><br><span class="line">                            EpollLoop(EpollDesc epollfd, <span class="type">int32_t</span> timeout)-&gt;   <span class="comment">//epoll参考下文</span></span><br><span class="line">                                select(epollSetPtr-&gt;maxfd + <span class="number">1</span>, &amp;readfds, &amp;writefds, &amp;exceptfds, tvp);</span><br><span class="line">                                EpollSetTraverse(epollSetPtr, EpollSetFdHandle, &amp;param);   </span><br><span class="line"></span><br><span class="line">BusCenterServerInit()    <span class="comment">//软总线服务 </span></span><br><span class="line">    LnnInitNetLedger()-&gt;    <span class="comment">// Ledger 分类账</span></span><br><span class="line">        LnnInitLocalLedger()-&gt;   <span class="comment">//设置本地网络信息 todo</span></span><br><span class="line">            nodeInfo-&gt;netCapacity = LnnGetNetCapabilty();</span><br><span class="line">            InitLocalDeviceInfo(deviceInfo)</span><br><span class="line">            InitLocalVersionType(nodeInfo)</span><br><span class="line">            InitConnectInfo(&amp;nodeInfo-&gt;connectInfo)</span><br><span class="line">            LnnInitLocalP2pInfo(nodeInfo)</span><br><span class="line">        LnnInitDistributedLedger()-&gt;</span><br><span class="line">            InitDistributedInfo(&amp;g_distributedNetLedger.distributedInfo)</span><br><span class="line">            InitConnectionCode(&amp;g_distributedNetLedger.cnnCode)</span><br><span class="line">            InitLaneStatus();</span><br><span class="line">        LnnInitMetaNodeLedger()</span><br><span class="line">    LnnInitBusCenterEvent()-&gt;</span><br><span class="line">        looper = CreateNewLooper(<span class="string">&quot;NotifyLooper&quot;</span>);   <span class="comment">//创建一个NotifyLooper</span></span><br><span class="line">        g_notifyHandler.looper = looper;</span><br><span class="line">        g_notifyHandler.HandleMessage = HandleNotifyMessage;  <span class="comment">//消息处理函数</span></span><br><span class="line">    LnnInitEventMonitor()-&gt;</span><br><span class="line">        LnnInitNetlinkMonitorImpl()   <span class="comment">//创建NetlinkMonitorThread线程</span></span><br><span class="line">        LnnInitProductMonitorImpl()-&gt;    <span class="comment">//使用hisyslink_sevice驱动</span></span><br><span class="line">            g_serv = HdfIoServiceBind(<span class="string">&quot;hisyslink_sevice&quot;</span>);</span><br><span class="line">            HdfDeviceRegisterEventListener(g_serv, &amp;g_listener)</span><br><span class="line">        LnnInitLwipMonitorImpl()   <span class="comment">//不懂，没成功跑</span></span><br><span class="line">        LnnInitWifiServiceMonitorImpl()-&gt;    <span class="comment">//subscribe wifiservice conn and power state</span></span><br><span class="line">            looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">            LnnAsyncCallbackDelayHelper(looper, LnnSubscribeWifiService, <span class="literal">NULL</span>, DELAY_LEN)-&gt; 跑LnnSubscribeWifiService</span><br><span class="line">        <span class="title function_">LnnInitDriverMonitorImpl</span><span class="params">()</span>-&gt;    <span class="comment">//订阅hdf_dsoftbus驱动服务，处理驱动消息</span></span><br><span class="line">            <span class="title function_">LnnAsyncCallbackDelayHelper</span><span class="params">(GetLooper(LOOP_TYPE_DEFAULT), DelayInitFunction, <span class="literal">NULL</span>, BIND_HDF_DELAY)</span>-&gt;</span><br><span class="line">            g_driverCtrl.softbusService = HdfIoServiceBind(<span class="string">&quot;hdf_dsoftbus&quot;</span>);</span><br><span class="line">            HdfDeviceRegisterEventListener(g_driverCtrl.softbusService, &amp;g_driverCtrl.eventListener); <span class="comment">//接收回调是OnReceiveDriverEvent</span></span><br><span class="line">                ProcessWlanEvent(data); <span class="comment">//todo</span></span><br><span class="line">                ProcessLwipEvent(data);</span><br><span class="line">    LnnInitDiscoveryManager()-&gt;   <span class="comment">//设置DeviceFound回调函数，构造一个msg，发送给looper-default</span></span><br><span class="line">        LnnInitCoapDiscovery()-&gt;  </span><br><span class="line">		   LnnNotifyDiscoveryDevice()-&gt;  </span><br><span class="line">                para = CreateConnectionAddrMsgPara(addr);</span><br><span class="line">                PostMessageToHandler(MSG_TYPE_DISCOVERY_DEVICE, para)</span><br><span class="line">                    SoftBusMessage *msg = CreateNetBuilderMessage(msgType, para);  <span class="comment">//handler.HandleMessage = NetBuilderMessageHandler;</span></span><br><span class="line">                    g_netBuilder.looper-&gt;PostMessage(g_netBuilder.looper, msg);</span><br><span class="line">    LnnInitNetworkManager()</span><br><span class="line">        LnnInitIpNetwork</span><br><span class="line">            <span class="title function_">LnnRegisterEventHandler</span><span class="params">(LNN_MONITOR_EVENT_IP_ADDR_CHANGED, IpAddrChangeEventHandler)</span> <span class="comment">//注册网络状态的回调函数</span></span><br><span class="line">            <span class="title function_">LnnRegisterEventHandler</span><span class="params">(LNN_MONITOR_EVENT_WIFI_STATE_CHANGED, WifiStateChangeEventHandler)</span></span><br><span class="line">            <span class="title function_">GetUpdateLocalIp</span><span class="params">(ipAddr, IP_LEN, ifName, NET_IF_NAME_LEN, <span class="literal">false</span>)</span>  <span class="comment">//更新ip</span></span><br><span class="line">            <span class="title function_">SetLocalIpInfo</span><span class="params">(ipAddr, ifName)</span></span><br><span class="line">            <span class="title function_">DiscLinkStatusChanged</span><span class="params">(LINK_STATUS_UP, COAP)</span>;   <span class="comment">//最终执行SetLocalDeviceInfo();</span></span><br><span class="line">            OpenIpLink()    <span class="comment">//设置认证相关函数</span></span><br><span class="line">                OpenAuthPort()-&gt;  <span class="comment">//设置认证端口回调函数</span></span><br><span class="line">                    port = OpenAuthServer()-&gt;     </span><br><span class="line">                        g_ethListener.onConnectEvent = AuthOnConnectEvent;</span><br><span class="line">    		           g_ethListener.onDataEvent = AuthOnDataEvent;</span><br><span class="line">                        SetSoftbusBaseListener(AUTH, &amp;g_ethListener)</span><br><span class="line">                        StartBaseListener(AUTH, localIp, <span class="number">0</span>, SERVER_MODE);</span><br><span class="line">                    LnnSetLocalNumInfo(NUM_KEY_AUTH_PORT, port);</span><br><span class="line">                OpenSessionPort()-&gt;    <span class="comment">//设置session端口回调函数</span></span><br><span class="line">                    TransTdcStartSessionListener()-&gt;</span><br><span class="line">                        g_sessionListener.onConnectEvent = OnConnectEventWifi;</span><br><span class="line">                        g_sessionListener.onDataEvent = OnDataEventWifi;</span><br><span class="line">                        SetSoftbusBaseListener(DIRECT_CHANNEL_SERVER_WIFI, &amp;g_sessionListener);</span><br><span class="line">                        StartBaseListener(DIRECT_CHANNEL_SERVER_WIFI, ip, port, SERVER_MODE);</span><br><span class="line">                    LnnSetLocalNumInfo(NUM_KEY_SESSION_PORT, port);</span><br><span class="line">            LnnStartDiscovery()-&gt;    <span class="comment">//通过DiscoveryFuncInterface来触发软总线发现</span></span><br><span class="line">                LnnStartCoapDiscovery()-&gt;</span><br><span class="line">                    SubscribeInfo subscribeInfo = &#123;</span><br><span class="line">                        .subscribeId = LNN_SUBSCRIBE_ID,</span><br><span class="line">                        .mode = DISCOVER_MODE_ACTIVE,</span><br><span class="line">                        .medium = COAP,</span><br><span class="line">                        .freq = HIGH,</span><br><span class="line">                        .isSameAccount = <span class="literal">false</span>,</span><br><span class="line">                        .isWakeRemote = <span class="literal">false</span>,</span><br><span class="line">                        .capability = LNN_DISC_CAPABILITY,</span><br><span class="line">                        .capabilityData = (<span class="type">unsigned</span> <span class="type">char</span> *)LNN_DISC_CAPABILITY,</span><br><span class="line">                        .dataLen = <span class="built_in">strlen</span>(LNN_DISC_CAPABILITY) + <span class="number">1</span>,</span><br><span class="line">                    &#125;;</span><br><span class="line">                    LnnStartDiscDevice(<span class="literal">NULL</span>, &amp;subscribeInfo, &amp;callback, <span class="literal">true</span>)-&gt;  <span class="comment">//callback 会更新ip信息然后执行g_callback.OnDeviceFound</span></span><br><span class="line">		               DiscSetDiscoverCallback(MODULE_LNN, &amp;cb-&gt;innerCb)</span><br><span class="line">                        DiscStartAdvertise(MODULE_LNN, info)   <span class="comment">//(DiscoveryFuncInterface)interface-&gt;Subscribe</span></span><br><span class="line">    LnnInitNetBuilder()-&gt;   <span class="comment">//创建一个handler：NetBuilderMessageHandler，传递给looper-default，处理各种软总线的消息g_messageProcessor</span></span><br><span class="line">        LnnInitSyncInfoManager()-&gt;     <span class="comment">//todo</span></span><br><span class="line">            <span class="type">static</span> INetworkingListener g_networkListener = &#123;</span><br><span class="line">                OnChannelOpened,</span><br><span class="line">                OnChannelOpenFailed,</span><br><span class="line">                OnChannelClosed,</span><br><span class="line">                OnMessageReceived,</span><br><span class="line">            &#125;;</span><br><span class="line">            g_netChanlistener = g_networkListener</span><br><span class="line">        LnnInitTopoManager()-&gt;    <span class="comment">//拓扑管理</span></span><br><span class="line">            LnnRegisterEventHandler(LNN_EVENT_RELATION_CHANGED, OnLnnRelationChanged)</span><br><span class="line">            LnnRegSyncInfoHandler(LNN_INFO_TYPE_TOPO_UPDATE, OnReceiveTopoUpdateMsg) </span><br><span class="line">        LnnInitP2p()-&gt;    <span class="comment">//p2p同步信息消息处理</span></span><br><span class="line">            LnnRegSyncInfoHandler(LNN_INFO_TYPE_P2P_INFO, OnReceiveP2pSyncInfoMsg)</span><br><span class="line">        NetBuilderConfigInit();		<span class="comment">//无用</span></span><br><span class="line">        RegisterAuthCallback()-&gt;</span><br><span class="line">            <span class="type">static</span> VerifyCallback g_verifyCb = &#123;</span><br><span class="line">                .onKeyGenerated = OnAuthKeyGenerated,</span><br><span class="line">                .onDeviceVerifyPass = OnAuthPassed,</span><br><span class="line">                .onDeviceVerifyFail = OnAuthFailed,</span><br><span class="line">                .onRecvSyncDeviceInfo = OnRecvPeerDeviceInfo,</span><br><span class="line">                .onDeviceNotTrusted = OnDeviceNotTrusted,</span><br><span class="line">                .onDisconnect = OnDisconnect,</span><br><span class="line">            &#125;;</span><br><span class="line">            AuthRegCallback(LNN, &amp;g_verifyCb)</span><br><span class="line">        LnnRegSyncInfoHandler(LNN_INFO_TYPE_MASTER_ELECT, OnReceiveMasterElectMsg)	<span class="comment">//选举master消息回调</span></span><br><span class="line">        ConifgLocalLedger()-&gt;    <span class="comment">//设置uuid和netid</span></span><br><span class="line">            LnnGenLocalNetworkId()    <span class="comment">//使用GenerateRandomStr()产生随机id</span></span><br><span class="line">            nnSetLocalStrInfo(STRING_KEY_UUID, uuid);</span><br><span class="line">		   LnnSetLocalStrInfo(STRING_KEY_NETWORKID, networkId);</span><br><span class="line">        g_netBuilder.looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">        g_netBuilder.handler.name = <span class="string">&quot;NetBuilderHandler&quot;</span>;</span><br><span class="line">        g_netBuilder.handler.HandleMessage = NetBuilderMessageHandler;</span><br><span class="line">    LnnInitLaneHub()-&gt;</span><br><span class="line">        LnnInitLaneManager()-&gt;</span><br><span class="line">            LnnLanesInit()</span><br><span class="line">            LnnRegisterLaneMonitor(LaneMonitorCallback)  <span class="comment">//在回调中遍历g_laneQosObserver，执行notify </span></span><br><span class="line">            LnnLanePendingInit()  <span class="comment">//g_pendingList</span></span><br><span class="line">        LnnInitTimeSync()-&gt;</span><br><span class="line">            g_timeSyncCtrl.looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">            g_timeSyncCtrl.handler.name = <span class="string">&quot;TimeSync&quot;</span>;</span><br><span class="line">            g_timeSyncCtrl.handler.HandleMessage = TimeSyncMessageHandler;</span><br><span class="line">            LnnTimeSyncImplInit()  <span class="comment">//todo代码没有实现，是一个虚函数</span></span><br><span class="line">        LnnInitHeartbeat-&gt;</span><br><span class="line">            LnnHbMgrInit()-&gt;</span><br><span class="line">                <span class="type">static</span> LnnHeartbeatImplCallback g_hbCallback = &#123;</span><br><span class="line">                    .onRelay = HbMgrRelayToMaster,</span><br><span class="line">                    .onRecvHigherWeight = HbMgrRecvHigherWeight,</span><br><span class="line">                    .onUpdateDev = HbMgrUpdateDevInfo,</span><br><span class="line">                &#125;;</span><br><span class="line">                LnnInitBleHeartbeat(&amp;g_hbCallback)</span><br><span class="line">            LnnHbFsmInit()-&gt;</span><br><span class="line">                g_beatHandler.name = <span class="string">&quot;heartbeat_handler&quot;</span>;</span><br><span class="line">                g_beatHandler.HandleMessage = HbMsgHandler;</span><br><span class="line">                g_beatHandler.looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">            HbMonitorInit()	 <span class="comment">//设置心跳策略</span></span><br><span class="line">            LnnRegisterEventHandler(LNN_EVENT_NODE_MASTER_STATE_CHANGED, LnnHeartbeatMasterNodeChangeEventHandler)  <span class="comment">//master心跳改变回调</span></span><br><span class="line">    StartDelayInit()    </span><br><span class="line">        BusCenterServerDelayInit()-&gt;</span><br><span class="line">            LnnInitNetLedgerDelay()      <span class="comment">//get device uuid</span></span><br><span class="line">            LnnInitNetworkManagerDelay()  <span class="comment">//do nothing</span></span><br><span class="line">            LnnInitNetBuilderDelay()   <span class="comment">// set master weight and master udid</span></span><br><span class="line">            LnnInitLaneHubDelay()-&gt;</span><br><span class="line">                LnnRemoveHbFsmMsg(EVENT_HB_START, <span class="number">0</span>, <span class="literal">NULL</span>)</span><br><span class="line">                LnnRemoveHbFsmMsg(EVENT_HB_STOP, <span class="number">0</span>, <span class="literal">NULL</span>)</span><br><span class="line">                LnnHbFsmStart(STATE_HB_MASTER_NODE_INDEX, <span class="number">0</span>)</span><br><span class="line">                LnnHbFsmStop(delayMillis)</span><br></pre></td></tr></table></figure>



<p>通道module id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MODULE_TRUST_ENGINE = <span class="number">1</span>,</span><br><span class="line">    MODULE_HICHAIN = <span class="number">2</span>,</span><br><span class="line">    MODULE_AUTH_SDK = <span class="number">3</span>,</span><br><span class="line">    MODULE_AUTH_CONNECTION = <span class="number">5</span>,</span><br><span class="line">    MODULE_MESSAGE_SERVICE = <span class="number">8</span>,</span><br><span class="line">    MODULE_AUTH_CHANNEL = <span class="number">8</span>,</span><br><span class="line">    MODULE_AUTH_MSG = <span class="number">9</span>,</span><br><span class="line">    MODULE_BLUETOOTH_MANAGER = <span class="number">9</span>,</span><br><span class="line">    MODULE_CONNECTION = <span class="number">11</span>,</span><br><span class="line">    MODULE_DIRECT_CHANNEL = <span class="number">12</span>,</span><br><span class="line">    MODULE_PROXY_CHANNEL = <span class="number">13</span>,</span><br><span class="line">    MODULE_DEVICE_AUTH = <span class="number">14</span>,</span><br><span class="line">    MODULE_P2P_LINK = <span class="number">15</span>,</span><br><span class="line">    MODULE_P2P_LISTEN = <span class="number">16</span>,</span><br><span class="line">    MODULE_UDP_INFO = <span class="number">17</span>,</span><br><span class="line">    MODULE_TIME_SYNC = <span class="number">18</span>,</span><br><span class="line">    MODULE_PKG_VERIFY = <span class="number">20</span>,</span><br><span class="line">    MODULE_BLE_NET = <span class="number">100</span>,</span><br><span class="line">    MODULE_BLE_CONN = <span class="number">101</span></span><br><span class="line">&#125; ConnModule;</span><br></pre></td></tr></table></figure>



<p>looper的handler</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransProxyLoopMsgHandler</span><br><span class="line">AuthHandler</span><br><span class="line">HbMsgHandler</span><br><span class="line">TimeSyncMessageHandler</span><br><span class="line">NetBuilderMessageHandler</span><br><span class="line">HandleNotifyMessage</span><br></pre></td></tr></table></figure>







<p>我希望结合打印信息分析：</p>
<p>初始化looper、初始认证服务、初始化coap、初始buscenter</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">OHOS <span class="comment"># ./softbus_server</span></span><br><span class="line">001-01 00:03:21.469 13 76 I 015C0/dsoftbus_standard: [COMM]Init success softbus_service</span><br><span class="line">01-01 00:03:21.480 13 76 I 01800/Samgr: Bootstrap core services(count:1).</span><br><span class="line">01-01 00:03:21.480 13 76 I 01800/Samgr: Init service:softbus_service</span><br><span class="line">01-01 00:03:21.480 13 77 I 01800/Samgr: Initialize Client Registry!</span><br><span class="line">01-01 00:03:21.513 13 76 W 015C0/dsoftbus_standard: mutex is already init</span><br><span class="line">01-01 00:03:21.517 13 77 I 01800/Samgr: Init service softbus_service &lt;<span class="keyword">time</span>: 63ms&gt; success!</span><br><span class="line">01-01 00:03:21.517 13 77 I 01800/Samgr: Initialized all core system services!</span><br><span class="line">01-01 00:03:21.517 13 77 I 01800/Samgr: Goto next boot step <span class="built_in">return</span> code:-9</span><br><span class="line">01-01 00:03:21.517 13 76 I 015C0/dsoftbus_standard: [COMM]loop thread creating Loop-default <span class="built_in">id</span> 663272816</span><br><span class="line">01-01 00:03:21.518 13 76 I 015C0/dsoftbus_standard: [COMM][Loop-default]<span class="built_in">wait</span> looper start ok</span><br><span class="line">01-01 00:03:21.518 13 76 I 015C0/dsoftbus_standard: [COMM]init looper success.</span><br><span class="line">01-01 00:03:21.518 3 38 E 01500/Communication: [UnregisterDeathCallback : 984]Wrong cbId:4294967295.</span><br><span class="line">01-01 00:03:21.518 3 38 I 01800/Samgr: Register Endpoint&lt;13, 78, 0&gt;</span><br><span class="line">01-01 00:03:21.524 13 78 E 01500/Communication: [UnregisterDeathCallback : 984]Wrong cbId:4294967295.</span><br><span class="line">01-01 00:03:21.524 13 79 I 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default] running</span><br><span class="line">01-01 00:03:21.524 13 79 I 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default] <span class="built_in">wait</span> msg list empty</span><br><span class="line">01-01 00:03:21.524 3 38 D 01800/Samgr: Register Feature&lt;softbus_service, (null)&gt; pid&lt;13&gt;, <span class="built_in">id</span>&lt;78, 0&gt; ret:0</span><br><span class="line">01-01 00:03:21.524 13 78 D 01800/Samgr: RegisterRemoteFeatures&lt;softbus_service, (null)&gt; ret:0</span><br><span class="line">01-01 00:03:21.524 13 78 I 01800/Samgr: Register endpoint&lt;ipc client&gt; and iunknown finished! remain&lt;0&gt; iunknown!</span><br><span class="line">01-01 00:03:21.542 13 76 I 015C0/dsoftbus_standard: [CONN]tcp MaxConnNum is 30</span><br><span class="line">01-01 00:03:21.542 13 76 I 015C0/dsoftbus_standard: [CONN]tcp MaxLen is 3072</span><br><span class="line">01-01 00:03:21.546 13 76 I 015C0/dsoftbus_standard: [CONN]tcp TimeOut is 100</span><br><span class="line">01-01 00:03:21.546 13 76 I 015C0/dsoftbus_standard: [CONN]init tcp ok </span><br><span class="line"></span><br><span class="line">01-01 00:03:21.546 13 76 I 015C0/dsoftbus_standard: [CONN]connect manager init success. </span><br><span class="line"></span><br><span class="line">01-01 00:03:21.576 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [REGEXP]</span><br><span class="line">01-01 00:03:21.583 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [PKG_NAME]</span><br><span class="line">01-01 00:03:21.584 13 76 I 015C0/dsoftbus_standard: [COMM]appInfo has no pkgname</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]5 nStackXEpoll: EpollEventPtrInit:[373] :epoll event init success</span><br><span class="line">Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [REGEXP]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [REGEXP]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [REGEXP]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [REGEXP]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [SEC_LEVEL]</span><br><span class="line">01-01 00:03:21.584 13 76 E 015C0/dsoftbus_standard: [COMM]Cannot find or invalid [UID]</span><br><span class="line">01-01 00:03:21.594 13 76 I 015C0/dsoftbus_standard: [CONN]proxy auth byteSize[4096], messageSize[1024]</span><br><span class="line">01-01 00:03:21.594 13 76 I 015C0/dsoftbus_standard: [TRAN]proxy channel init ok</span><br><span class="line">01-01 00:03:21.594 13 76 I 015C0/dsoftbus_standard: [TRAN]p2p direct channel not support.</span><br><span class="line">01-01 00:03:21.594 13 76 I 015C0/dsoftbus_standard: [TRAN]server trans udp channel init success.</span><br><span class="line">01-01 00:03:21.594 13 76 I Jan 01 00:03:21 ALRT 015C0/dsoftbus_standard: [TRAN]InitQos virtual</span><br><span class="line">01-01 00:03:21.594 13 76 I 015C0/dsoftbus_standard: [TRAN]trans session server list init succ</span><br><span class="line">coap_socket_bind_udp: setsockopt IP_PKTINFO: Protocol not available</span><br><span class="line">4 nStackXDev: BindToDevice:[213] :device name: wlan0</span><br><span class="line">4 nStackXDev: BindToDeviceInner:[191] :binding interface wlan0 success</span><br><span class="line">01-01 00:03:21.598 13 76 I 015C0/dsoftbus_standard: [AUTH]auth ability is 1</span><br><span class="line">01-01 00:03:21.607 3 38 D 01800/Samgr: Judge Auth&lt;devauth_svc, (null)&gt; ret:0</span><br><span class="line">01-01 00:03:21.607 3 38 D 01800/Samgr: Find Feature&lt;devauth_svc, (null)&gt; <span class="built_in">id</span>&lt;37, 0&gt; ret:0</span><br><span class="line">01-01 00:03:21.607 13 76 I 01800/Samgr: Create remote sa proxy&lt;devauth_svc, (null)&gt;!</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: InitProxyAdapt: get proxy instance success</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: ShowIpcSvcInfo: svc information - handle(80), token(662135808), cookie(0)</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: InitProxyAdapt: register ipc cb success</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: GetGaInstance: Enter InitIpcMethods...</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: InitIpcGaMethods: entering...</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: InitIpcGaMethods: process <span class="keyword">done</span></span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: GetGaInstance: InitIpcMethods <span class="keyword">done</span></span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: GetGmInstance: Enter InitIpcMethods...</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: InitIpcGmMethods: starting ...</span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: InitIpcGmMethods: process <span class="keyword">done</span></span><br><span class="line">01-01 00:03:21.607 13 76 I 00000/[DEVAUTH]: GetGmInstance: InitIpcMethods <span class="keyword">done</span></span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: IpcGmRegDataChangeListener: starting ...</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: IsServiceRunning: service activity check</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: EncodeCallRequest: <span class="built_in">type</span> 1, paramSz 13</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: EncodeCallRequest: <span class="built_in">type</span> 3, paramSz 28</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: ShowIpcSvcInfo: svc information - handle(80), token(662135808), cookie(0)</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: DoBinderCall: proc method 3</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: FinalCallRequest: method <span class="built_in">id</span> 3, param num 2, data length 60, flag 1, io offset 0</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: ShowIpcSvcInfo: svc information - handle(80), token(662135808), cookie(0)</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: FinalCallRequest: ipc call with callback, data flag 1</span><br><span class="line">01-01 00:03:21.608 13 76 I 00000/[DEVAUTH]: ActCall: start to invoke ipc call...</span><br><span class="line">01-01 00:03:21.613 9 36 I 00000/[DEVAUTH]: OnRemoteRequest: request code 1</span><br><span class="line">01-01 00:03:21.613 9 36 I 00000/[DEVAUTH]: GetMethodId: GetMethodId, <span class="built_in">id</span> code 3</span><br><span class="line">01-01 00:03:21.614 9 36 I 00000/[DEVAUTH]: DevAuthRequestCall: request method <span class="built_in">id</span> 3</span><br><span class="line">01-01 00:03:21.614 9 36 I 00000/[DEVAUTH]: DecodeCallRequest: request data length(60), param number: 2</span><br><span class="line">01-01 00:03:21.617 9 36 I 00000/[DEVAUTH]: DecodeCallRequest: decode success, param <span class="built_in">type</span> 1, val size 13</span><br><span class="line">01-01 00:03:21.617 9 36 I 00000/[DEVAUTH]: DecodeCallRequest: decode success, param <span class="built_in">type</span> 3, val size 28</span><br><span class="line">01-01 00:03:21.617 9 36 I 00000/[DEVAUTH]: ShowIpcSvcInfo: svc information - handle(80), token(662135808), cookie(0)</span><br><span class="line">01-01 00:03:21.617 9 36 I 00000/[DEVAUTH]: SetRemoteObject: remote object cache index 0</span><br><span class="line">01-01 00:03:21.617 9 36 I 00000/[DEVAUTH]: ShowIpcSvcInfo: svc information - handle(80), token(662135808), cookie(0)</span><br><span class="line">01-01 00:03:21.617 9 36 I 00000/[DEVAUTH]: WithObject: object trans success, <span class="built_in">set</span> <span class="built_in">id</span> 0</span><br><span class="line">01-01 00:03:21.618 9 36 I 00000/[DEVAUTH]: IpcServiceGmRegDataChangeListener: starting ...</span><br><span class="line">01-01 00:03:21.618 9 36 I 00000/[DEVAUTH]: GetIpcRequestParamByType: <span class="built_in">type</span> 1, result 0x0</span><br><span class="line">01-01 00:03:21.618 9 36 I 00000/[DEVAUTH]: GetIpcRequestParamByType: <span class="built_in">type</span> 3, result 0x0</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: GetIpcCallBackByAppId: appid: softbus_auth</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: AddIpcCallBackByAppId: new callback to add, appid: softbus_auth</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: AddIpcCallBackByAppId: callback add success, appid: softbus_auth, <span class="built_in">type</span> 3</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: GetIpcRequestParamByType: <span class="built_in">type</span> 31, result 0x0</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: GetIpcCallBackByAppId: appid: softbus_auth</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: AddCbDeathRecipient: <span class="keyword">done</span>, ret 0, callback stub idx 0</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: AddIpcCbObjByAppId: ipc object add success, appid: softbus_auth, proxyId 0</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: IpcEncodeCallReplay: reply <span class="built_in">type</span> 23, success</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: IpcServiceGmRegDataChangeListener: process <span class="keyword">done</span>, call ret 0, ipc ret 0</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: OnRemoteRequest: form service result <span class="keyword">done</span>, result length(12)</span><br><span class="line">01-01 00:03:21.619 9 36 I 00000/[DEVAUTH]: OnRemoteRequest: <span class="keyword">done</span>, request code 1, call result 0</span><br><span class="line">01-01 00:03:21.619 13 76 I 00000/[DEVAUTH]: CliInvokeRetCallback: starting...</span><br><span class="line">01-01 00:03:21.619 13 76 I 00000/[DEVAUTH]: CliInvokeRetCallback: <span class="keyword">done</span>, reply data length 20</span><br><span class="line">01-01 00:03:21.619 13 76 I 00000/[DEVAUTH]: ActCall: invoke call <span class="keyword">done</span>, ipc result(0)</span><br><span class="line">01-01 00:03:21.619 13 76 I 00000/[DEVAUTH]: ActCall: service call result(0)</span><br><span class="line">01-01 00:03:21.623 13 76 I 00000/[DEVAUTH]: AddIpcCliCallbackCtx: starting ...</span><br><span class="line">01-01 00:03:21.623 13 76 I 00000/[DEVAUTH]: AddIpcCliCallbackCtx: success, appid: softbus_auth</span><br><span class="line">01-01 00:03:21.623 13 76 I 00000/[DEVAUTH]: IpcGmRegDataChangeListener: process <span class="keyword">done</span>, ret 0</span><br><span class="line">01-01 00:03:21.623 13 76 I 015C0/dsoftbus_standard: [AUTH]auth init succ!</span><br><span class="line">01-01 00:03:21.659 13 76 D 015C0/nStackXDFinder: 5 nStackXDFinder: NSTACKX_Init:[225] :nstack ctrl create epollfd 5</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.661 13 76 D 015C0/nStackXDFinder: 5 nStackXCoAP: CoapServerInit:[262] :CoapServerInit is called</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.662 13 76 D 015C0/nStackXDFinder: 5 nStackXCoAP: CoapServerInit:[268] :wifi not connected</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.662 13 76 I 015C0/nStackXDFinder: 4 nStackXDFinder: NSTACKX_Init:[246] :DFinder init successfully</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.662 13 76 I 015C0/dsoftbus_standard: [DISC]coap discovery init success.</span><br><span class="line">01-01 00:03:21.662 13 76 I 015C0/dsoftbus_standard: [DISC]init success</span><br><span class="line">01-01 00:03:21.671 13 76 I 015C0/dsoftbus_standard: [LNN]lnn capbility is 30</span><br><span class="line">01-01 00:03:21.671 13 76 E 015C0/dsoftbus_standard: [LNN]<span class="built_in">set</span> device <span class="built_in">type</span> error.</span><br><span class="line">01-01 00:03:21.671 13 76 E 015C0/dsoftbus_standard: [LNN]UpdateLocalDeviceType failed</span><br><span class="line">01-01 00:03:21.673 13 76 I 015C0/dsoftbus_standard: [LNN]meta node virtual init success</span><br><span class="line">01-01 00:03:21.673 13 76 I 015C0/dsoftbus_standard: [COMM]loop thread creating NotifyLooper <span class="built_in">id</span> 664296816</span><br><span class="line">01-01 00:03:21.673 13 76 I 015C0/dsoftbus_standard: [COMM][NotifyLooper]<span class="built_in">wait</span> looper start ok</span><br><span class="line">01-01 00:03:21.675 13 87 I 015C0/dsoftbus_standard: [COMM]LoopTask[NotifyLooper] running</span><br><span class="line">01-01 00:03:21.675 13 87 I 015C0/dsoftbus_standard: [COMM]LoopTask[NotifyLooper] <span class="built_in">wait</span> msg list empty</span><br><span class="line">01-01 00:03:21.676 13 76 E 02500/devmgr_service: device hisyslink_sevice not <span class="keyword">in</span> configed device list</span><br><span class="line">01-01 00:03:21.676 13 76 E 02500/hdf_syscall_adapter: Failed to dispatch serv call ioctl -202</span><br><span class="line">01-01 00:03:21.676 13 76 E 02500/HDF_LOG_TAG: failed to load khdf driver hisyslink_sevice</span><br><span class="line">01-01 00:03:21.676 13 76 E 02500/hdf_syscall_adapter: TrytoLoadIoService: load hisyslink_sevice driver failed</span><br><span class="line">01-01 00:03:21.679 13 76 W 015C0/dsoftbus_standard: fail to get service hisyslink_sevice</span><br><span class="line">01-01 00:03:21.679 13 76 E 015C0/dsoftbus_standard: [LNN]hdf driver monitor init enter</span><br><span class="line">01-01 00:03:21.679 13 76 D 015C0/dsoftbus_standard: [COMM][Loop-default]PostMessageAtTime what =0 <span class="keyword">time</span>=202679953 us</span><br><span class="line">01-01 00:03:21.680 13 76 D 015C0/dsoftbus_standard: [COMM][Loop-default]PostMessageAtTime. insert</span><br><span class="line">01-01 00:03:21.680 13 76 D 015C0/dsoftbus_standard: [COMM]DumpLooper. i=0,handler=LnnAsyncHandler,what =0,arg1=0 arg2=0, <span class="keyword">time</span>=202679953</span><br><span class="line">01-01 00:03:21.680 13 76 W 015C0/dsoftbus_standard: [LNN]Create netif mgr [0],[eth0]</span><br><span class="line">01-01 00:03:21.680 13 76 W 015C0/dsoftbus_standard: [LNN]Create netif mgr [1],[wlan0]</span><br><span class="line">01-01 00:03:21.688 13 76 I 015C0/nStackXDFinder: 4 nStackXDFinder: NSTACKX_RegisterDevice:[394] :begin to NSTACKX_RegisterDevice!</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.689 13 81 W 015C0/nStackXDFinder: 3 nStackXDFinder: ConfigureLocalDeviceInfo:[897] :Invalid device name. Will use default name</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.689 13 76 I 015C0/dsoftbus_standard: [LNN]IP protocol registed.</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.703 13 76 I 015C0/dsoftbus_standard: [TRAN]register net listener ok</span><br><span class="line">01-01 00:03:21.705 13 76 I 015C0/dsoftbus_standard: [LNN]lnn config is 10,2</span><br><span class="line">01-01 00:03:21.707 13 76 I 015C0/dsoftbus_standard: [LNN]full path <span class="keyword">for</span> 0 is /usr/dsoftbus/uuid</span><br><span class="line">01-01 00:03:21.709 13 76 E 015C0/dsoftbus_standard: ReadFile open file fail</span><br><span class="line">01-01 00:03:21.723 13 76 I 015C0/dsoftbus_standard: [LNN]init net builder success</span><br><span class="line">01-01 00:03:21.728 13 76 E 015C0/dsoftbus_standard: [LNN]InitLaneManager success</span><br><span class="line">01-01 00:03:21.728 13 76 I 015C0/dsoftbus_standard: [LNN]init <span class="keyword">time</span> <span class="built_in">sync</span> success</span><br><span class="line">01-01 00:03:21.728 13 76 E 015C0/dsoftbus_standard: [LNN]<span class="keyword">time</span> <span class="built_in">sync</span> impl stub init success</span><br><span class="line">01-01 00:03:21.728 13 76 I 015C0/dsoftbus_standard: [LNN]heartbeat stub LnnInitHeartbeat</span><br><span class="line">01-01 00:03:21.728 13 76 I 015C0/dsoftbus_standard: [LNN]lnn delay init len is 0</span><br><span class="line">01-01 00:03:21.728 13 76 D 015C0/dsoftbus_standard: [COMM][Loop-default]PostMessageAtTime what =0 <span class="keyword">time</span>=201728478 us</span><br><span class="line">01-01 00:03:21.728 13 76 D 015C0/dsoftbus_standard: [COMM][Loop-default]PostMessageAtTime. insert</span><br><span class="line">01-01 00:03:21.728 13 76 D 015C0/dsoftbus_standard: [COMM]DumpLooper. i=0,handler=LnnAsyncHandler,what =0,arg1=0 arg2=0, <span class="keyword">time</span>=201728478</span><br><span class="line">01-01 00:03:21.728 13 76 D 015C0/dsoftbus_standard: [COMM]DumpLooper. i=1,handler=LnnAsyncHandler,what =0,arg1=0 arg2=0, <span class="keyword">time</span>=202679953</span><br><span class="line">01-01 00:03:21.728 13 76 I 015C0/dsoftbus_standard: [LNN]bus center server init ok</span><br><span class="line">01-01 00:03:21.728 13 76 I 015C0/dsoftbus_standard: [COMM]p2p <span class="built_in">link</span> not support</span><br><span class="line">01-01 00:03:21.728 13 76 I 015C0/dsoftbus_standard: [COMM]softbus framework init success.</span><br><span class="line">01-01 00:03:21.728 13 79 D 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default], get message. handle=LnnAsyncHandler,what=0,msgSize=1</span><br><span class="line">01-01 00:03:21.728 13 79 D 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default], HandleMessage message. handle=LnnAsyncHandler,what=0</span><br><span class="line">01-01 00:03:21.729 13 79 D 02500/mmc_if_c: MmcCntlrObjGetByNumber: success</span><br><span class="line">01-01 00:03:21.729 13 79 D 02500/emmc_if_c: EmmcServiceGetCid: success</span><br><span class="line">01-01 00:03:21.729 13 79 E 015C0/dsoftbus_standard: ioctl SIOCGIFFLAGS fail, errno = 19</span><br><span class="line">01-01 00:03:21.729 13 79 E 015C0/dsoftbus_standard: GetNetworkIfIp ifName:eth0 fail</span><br><span class="line">01-01 00:03:21.729 13 79 E 015C0/dsoftbus_standard: [LNN]GetAvailableIpAddr:get network IP by ifName failed!</span><br><span class="line">01-01 00:03:21.729 13 79 D 015C0/dsoftbus_standard: [LNN]subnet [eth0, 4] state change to 2</span><br><span class="line">01-01 00:03:21.729 13 79 I 015C0/dsoftbus_standard: [LNN]<span class="built_in">enable</span> protocol (0) <span class="keyword">for</span> netif eth0 success</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.730 13 79 I 015C0/dsoftbus_standard: [LNN]open ip <span class="built_in">link</span> and start discovery</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.732 13 79 I 015C0/dsoftbus_standard: [AUTH]auth open base listener</span><br><span class="line">01-01 00:03:21.737 13 79 E 015C0/dsoftbus_standard: setsockopt : Protocol not available</span><br><span class="line">01-01 00:03:21.737 13 79 E 015C0/dsoftbus_standard: [CONN]<span class="built_in">set</span> SO_REUSEPORT</span><br><span class="line">01-01 00:03:21.737 13 79 I 015C0/dsoftbus_standard: [CONN]create pthread now.</span><br><span class="line">01-01 00:03:21.738 13 79 I 015C0/dsoftbus_standard: [CONN]StartBaseListener success, fd = 58812, module = 1</span><br><span class="line">01-01 00:03:21.738 13 79 E 015C0/dsoftbus_standard: setsockopt : Protocol not available</span><br><span class="line">01-01 00:03:21.738 13 79 E 015C0/dsoftbus_standard: [CONN]<span class="built_in">set</span> SO_REUSEPORT</span><br><span class="line">01-01 00:03:21.738 13 79 I 015C0/dsoftbus_standard: [CONN]StartBaseListener success, fd = 58813, module = 5</span><br><span class="line">01-01 00:03:21.743 13 88 I 015C0/dsoftbus_standard: [CONN]ThreadPoolWorker Start</span><br><span class="line">01-01 00:03:21.743 13 79 E 015C0/dsoftbus_standard: setsockopt : Protocol not available</span><br><span class="line">01-01 00:03:21.744 13 79 E 015C0/dsoftbus_standard: [CONN]<span class="built_in">set</span> SO_REUSEPORT</span><br><span class="line">01-01 00:03:21.744 13 79 I 015C0/dsoftbus_standard: [CONN]StartBaseListener success, fd = 58814, module = 0</span><br><span class="line">01-01 00:03:21.744 13 79 I 015C0/nStackXDFinder: 4 nStackXDFinder: NSTACKX_RegisterDevice:[394] :begin to NSTACKX_RegisterDevice!</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.744 13 81 D 015C0/nStackXDFinder: 5 nStackXCoAP: CoapServerInit:[262] :CoapServerInit is called</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/dsoftbus_standard: [DISC]register input bitmap = [64].</span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/dsoftbus_standard: [DISC]register all <span class="built_in">cap</span> bitmap = [64].</span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/nStackXDFinder: 4 nStackXDFinder: NSTACKX_RegisterCapability:[517] :Register Capability</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/dsoftbus_standard: [DISC]coap start passive publish.</span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/dsoftbus_standard: [DISC]register input bitmap = [64].</span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/dsoftbus_standard: [DISC]register all <span class="built_in">cap</span> bitmap = [64].</span><br><span class="line">01-01 00:03:21.758 13 79 I 015C0/nStackXDFinder: 4 nStackXDFinder: NSTACKX_SetFilterCapability:[523] :Set Filter Capability</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.759 13 79 I 015C0/dsoftbus_standard: [DISC]coap start active discovery.</span><br><span class="line">01-01 00:03:21.759 13 79 D 015C0/dsoftbus_standard: [LNN]subnet [wlan0, 4] state change to 1</span><br><span class="line">01-01 00:03:21.759 13 79 I 015C0/dsoftbus_standard: [LNN]<span class="built_in">enable</span> protocol (0) <span class="keyword">for</span> netif wlan0 success</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.772 13 79 I 015C0/dsoftbus_standard: [LNN]update <span class="built_in">local</span> role from 0 to 1</span><br><span class="line">01-01 00:03:21.772 13 79 I 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default], after HandleMessage message. handle=LnnAsyncHandler,what=0</span><br><span class="line">01-01 00:03:21.849 13 81 D 015C0/nStackXDFinder: 5 nStackXCoAP: CoapInitResources:[968] :CoapInitResources g_wlanOrEthContext update</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.855 13 81 W 015C0/nStackXDFinder: 3 nStackXCoAP: CoapServiceDiscoverStop:[634] :clear device list backup</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.855 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverStopInner:[785] :device discover stopped</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.856 13 81 E 015C0/nStackXDFinder: 2 nStackXDFinder: BackupDeviceDB:[1182] :clear backupDB error</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.856 13 81 W 015C0/nStackXDFinder: 3 nStackXCoAP: CoapServiceDiscoverInner:[727] :clear device list</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.867 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverInner:[742] :the first <span class="keyword">time</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:21.969 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 2 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:22.172 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 3 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:22.375 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 4 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:22.680 13 79 D 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default], get message. handle=LnnAsyncHandler,what=0,msgSize=0</span><br><span class="line">01-01 00:03:22.680 13 79 D 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default], HandleMessage message. handle=LnnAsyncHandler,what=0</span><br><span class="line">01-01 00:03:22.680 13 79 E 02500/devmgr_service: device hdf_dsoftbus not <span class="keyword">in</span> configed device list</span><br><span class="line">01-01 00:03:22.680 13 79 E 02500/hdf_syscall_adapter: Failed to dispatch serv call ioctl -202</span><br><span class="line">01-01 00:03:22.680 13 79 E 02500/HDF_LOG_TAG: failed to load khdf driver hdf_dsoftbus</span><br><span class="line">01-01 00:03:22.680 13 79 E 02500/hdf_syscall_adapter: TrytoLoadIoService: load hdf_dsoftbus driver failed</span><br><span class="line">01-01 00:03:22.680 13 79 E 015C0/dsoftbus_standard: [LNN]get hdf dsoftbus service fail(0)</span><br><span class="line">01-01 00:03:22.680 13 79 I 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default], after HandleMessage message. handle=LnnAsyncHandler,what=0</span><br><span class="line">01-01 00:03:22.680 13 79 I 015C0/dsoftbus_standard: [COMM]LoopTask[Loop-default] <span class="built_in">wait</span> msg list empty</span><br><span class="line">01-01 00:03:22.877 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 5 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">[203380][W:556]hisi_customize_wifi::[ba buffer size:64]</span><br><span class="line">01-01 00:03:23.380 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 6 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">[203880][W:861]&#123;hmac_mgmt_tx_delba:tid=0 ba_tx_info null&#125;</span><br><span class="line">[203882][W:556]hisi_customize_wifi::[ba buffer size:64]</span><br><span class="line">[203884][W:850]&#123;hmac_ba_reset_tx_handle::tx ba not <span class="built_in">set</span> yet.&#125;</span><br><span class="line">01-01 00:03:23.890 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 7 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line">[203895][W:1182]&#123;hmac_mgmt_rx_addba_rsp::tx ba info null.tid[0]&#125;</span><br><span class="line"></span><br><span class="line">[204390][W:861]&#123;hmac_mgmt_tx_delba:tid=0 ba_tx_info null&#125;</span><br><span class="line">[204392][W:556]hisi_customize_wifi::[ba buffer size:64]</span><br><span class="line">[204394][W:850]&#123;hmac_ba_reset_tx_handle::tx ba not <span class="built_in">set</span> yet.&#125;</span><br><span class="line">01-01 00:03:24.399 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 8 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line">[204405][W:1182]&#123;hmac_mgmt_rx_addba_rsp::tx ba info null.tid[0]&#125;</span><br><span class="line"></span><br><span class="line">[204900][W:861]&#123;hmac_mgmt_tx_delba:tid=0 ba_tx_info null&#125;</span><br><span class="line">[204902][W:556]hisi_customize_wifi::[ba buffer size:64]</span><br><span class="line">[204904][W:850]&#123;hmac_ba_reset_tx_handle::tx ba not <span class="built_in">set</span> yet.&#125;</span><br><span class="line">01-01 00:03:24.909 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 9 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line">[204914][W:1182]&#123;hmac_mgmt_rx_addba_rsp::tx ba info null.tid[0]&#125;</span><br><span class="line"></span><br><span class="line">01-01 00:03:25.411 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 10 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:25.914 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 11 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:26.416 13 81 I 015C0/nStackXDFinder: 4 nStackXCoAP: CoapServiceDiscoverTimerHandle:[655] :the 12 <span class="built_in">times</span> <span class="keyword">for</span> device discover.</span><br><span class="line"></span><br><span class="line">01-01 00:03:26.918 13 81 W 015C0/nStackXDFinder: 3 nStackXCoAP: CoapServiceDiscoverStop:[634] :clear device list backup</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>代码在sys_epoll.c中，是一种IO多路复用的机制，就是当系统中存在多个网络连接，只使用一个线程来阻塞等待这些连接的事件。然后通过回调函数来处理事件。</p>
<p>在 <code>EpollLoop</code>线程中，会阻塞等待 <code>epollSetPtr</code> ，然后调用task的响应的handler来处理网络数据。</p>
<p>所以，应该重点关注的是task的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">GetTimeout</span><span class="params">(<span class="keyword">struct</span> <span class="type">coap_context_t</span> *ctx, <span class="type">uint32_t</span> *socketNum, EpollTask *taskList, EpollDesc epollfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;</span><br><span class="line">    <span class="type">coap_tick_t</span> now;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> timeout;</span><br><span class="line">    <span class="type">coap_socket_t</span> *sockets[MAX_COAP_SOCKET_NUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_COAP_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coap_ticks(&amp;now);</span><br><span class="line">    timeout = coap_write(ctx, sockets,</span><br><span class="line">        (<span class="type">uint32_t</span>)(<span class="keyword">sizeof</span>(sockets) / <span class="keyword">sizeof</span>(sockets[<span class="number">0</span>])), socketNum, now);</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span> || timeout &gt; DEFAULT_COAP_TIMEOUT) &#123;</span><br><span class="line">        timeout = DEFAULT_COAP_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*socketNum &gt; MAX_COAP_SOCKET_NUM) &#123;</span><br><span class="line">        *socketNum = MAX_COAP_SOCKET_NUM;</span><br><span class="line">        DFINDER_LOGI(TAG, <span class="string">&quot;socketNum exccedd MAX_COAP_SOCKET_NUM, and set it to MAX_COAP_SOCKET_NUM&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; *socketNum; i++) &#123;</span><br><span class="line">        events = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sockets[i]-&gt;flags &amp; COAP_SOCKET_WANT_READ) || (sockets[i]-&gt;flags &amp; COAP_SOCKET_WANT_ACCEPT)) &#123;</span><br><span class="line">            events = EPOLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sockets[i]-&gt;flags &amp; COAP_SOCKET_WANT_WRITE) || (sockets[i]-&gt;flags &amp; COAP_SOCKET_WANT_CONNECT)) &#123;</span><br><span class="line">            events = events | EPOLLOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sockets[i]-&gt;flags &amp; COAP_SOCKET_WANT_CONNECT) &#123;</span><br><span class="line">            events = events | EPOLLHUP | EPOLLERR;</span><br><span class="line">        &#125;</span><br><span class="line">        taskList[i].taskfd = sockets[i]-&gt;fd;</span><br><span class="line">        taskList[i].epollfd = epollfd;</span><br><span class="line">        taskList[i].readHandle = CoAPEpollReadHandle;</span><br><span class="line">        taskList[i].writeHandle = CoAPEpollWriteHandle;</span><br><span class="line">        taskList[i].errorHandle = CoAPEpollErrorHandle;</span><br><span class="line">        taskList[i].ptr = sockets[i];</span><br><span class="line">        <span class="keyword">if</span> (taskList[i].taskfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RegisterEpollTask(&amp;taskList[i], events);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="looper"><a href="#looper" class="headerlink" title="looper"></a>looper</h3><p>looper是一种循环处理消息队列中消息的办法。</p>
<p>创建一个looper变量，会有一个对应的线程，在这个线程中去处理消息，如下是创建了一个Looper</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SoftBusLooper *<span class="title function_">CreateNewLooper</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLooper *looper = (SoftBusLooper *)SoftBusCalloc(<span class="keyword">sizeof</span>(SoftBusLooper));</span><br><span class="line">    SoftBusLooperContext *context = SoftBusCalloc(<span class="keyword">sizeof</span>(SoftBusLooperContext));</span><br><span class="line">    <span class="keyword">if</span> (memcpy_s(context-&gt;name, <span class="keyword">sizeof</span>(context-&gt;name), name, <span class="built_in">strlen</span>(name)) != EOK) &#123;</span><br><span class="line">        SoftBusFree(looper);</span><br><span class="line">        SoftBusFree(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListInit(&amp;context-&gt;msgHead);</span><br><span class="line">    <span class="comment">// init context 非常重要</span></span><br><span class="line">    pthread_mutex_init(&amp;context-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;context-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;context-&gt;condRunning, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init looper</span></span><br><span class="line">    looper-&gt;context = context;</span><br><span class="line">    looper-&gt;PostMessage = LooperPostMessage;</span><br><span class="line">    looper-&gt;PostMessageDelay = LooperPostMessageDelay;</span><br><span class="line">    looper-&gt;RemoveMessage = LooperRemoveMessage;</span><br><span class="line">    looper-&gt;RemoveMessageCustom = LoopRemoveMessageCustom;</span><br><span class="line">    <span class="type">int</span> ret = StartNewLooperThread(looper);</span><br><span class="line">    <span class="keyword">return</span> looper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">StartNewLooperThread</span><span class="params">(SoftBusLooper *looper)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINLOOP_STACK_SIZE 5120</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> threadAttr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;threadAttr);</span><br><span class="line">    pthread_attr_setstacksize(&amp;threadAttr, MAINLOOP_STACK_SIZE);</span><br><span class="line">    <span class="comment">//创建LoopTask线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;threadAttr, LoopTask线程, looper) != <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;create DeathProcTask failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loopTask 的代码逻辑上就是 ：</p>
<ol>
<li>读取looper的上下文</li>
<li>从上下文中读取消息</li>
<li>调用消息的handler处理消息本身</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">LoopTask</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLooper *looper = arg;</span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    SoftBusLooperContext *context = looper-&gt;context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;context-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;lock failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context-&gt;running = <span class="number">1</span>;</span><br><span class="line">    g_isThreadStarted = <span class="number">1</span>;</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;context-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;lock failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait 检查线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (context-&gt;stop == <span class="number">1</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], stop ==1&quot;</span>, context-&gt;name);</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_isNeedDestroy == <span class="number">1</span>) &#123;</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上下文没有消息，进入等待</span></span><br><span class="line">        <span class="keyword">if</span> (IsListEmpty(&amp;context-&gt;msgHead)) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s] wait msg list empty&quot;</span>, context-&gt;name);</span><br><span class="line">            pthread_cond_wait(&amp;context-&gt;cond, &amp;context-&gt;lock);</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//有消息需要处理了</span></span><br><span class="line">        <span class="type">uint64_t</span> now = UptimeMicros();</span><br><span class="line">        ListNode *item = context-&gt;msgHead.next;</span><br><span class="line">        SoftBusMessage *msg = <span class="literal">NULL</span>;</span><br><span class="line">        SoftBusMessageNode *itemNode = CONTAINER_OF(item, SoftBusMessageNode, node);</span><br><span class="line">        <span class="type">uint64_t</span> time = itemNode-&gt;msg-&gt;time;</span><br><span class="line">        <span class="comment">//当前时间大于消息发送的时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt;= time) &#123;</span><br><span class="line">            <span class="comment">//获取消息 </span></span><br><span class="line">            msg = itemNode-&gt;msg;</span><br><span class="line">            ListDelete(item);    <span class="comment">//移除链表</span></span><br><span class="line">            SoftBusFree(itemNode);</span><br><span class="line">            context-&gt;msgSize--;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], get message. handle=%s,what=%d,msgSize=%u&quot;</span>,</span><br><span class="line">                context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what, context-&gt;msgSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> timespec tv;</span><br><span class="line">            tv.tv_sec = time / TIME_THOUSANDS_MULTIPLIER / TIME_THOUSANDS_MULTIPLIER;</span><br><span class="line">            tv.tv_nsec = time % (TIME_THOUSANDS_MULTIPLIER * TIME_THOUSANDS_MULTIPLIER) * TIME_THOUSANDS_MULTIPLIER;</span><br><span class="line">            pthread_cond_timedwait(&amp;context-&gt;cond, &amp;context-&gt;lock, &amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        context-&gt;currentMsg = msg;</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], HandleMessage message. handle=%s,what=%d&quot;</span>,</span><br><span class="line">            context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what);</span><br><span class="line">		<span class="comment">//使用消息的handler去处理消息本身</span></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;handler-&gt;HandleMessage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            msg-&gt;handler-&gt;HandleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], after HandleMessage message. handle=%s,what=%d&quot;</span>,</span><br><span class="line">            context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what);</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_lock(&amp;context-&gt;lock);</span><br><span class="line">        FreeSoftBusMsg(msg);</span><br><span class="line">        context-&gt;currentMsg = <span class="literal">NULL</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_lock(&amp;context-&gt;lock);</span><br><span class="line">    context-&gt;running = <span class="number">0</span>;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], running =0&quot;</span>, context-&gt;name);</span><br><span class="line">    pthread_cond_broadcast(&amp;context-&gt;cond);</span><br><span class="line">    pthread_cond_broadcast(&amp;context-&gt;condRunning);</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (g_isNeedDestroy == <span class="number">1</span>) &#123;</span><br><span class="line">        LooperDeinit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么looper上下文中的消息是怎么来的呢，看looper中定义了消息的发送和撤回。所以我们猜测looper的使用方法：</p>
<p>首先调用CreateNewLooper()创建一个looper结构体和一个线程，然后将一些数据和处理函数封装成一个消息，给looper发送消息，looper会在得到cpu时处理这些消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftBusLooper</span> &#123;</span></span><br><span class="line">    SoftBusLooperContext *context;</span><br><span class="line">    <span class="type">void</span> (*PostMessage)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg);   <span class="comment">//想looper发送消息</span></span><br><span class="line">    <span class="type">void</span> (*PostMessageDelay)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg, <span class="type">uint64_t</span> delayMillis);</span><br><span class="line">    <span class="type">void</span> (*RemoveMessage)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler, <span class="type">int32_t</span> what);    <span class="comment">//撤回消息</span></span><br><span class="line">    <span class="comment">// customFunc, when match, return 0</span></span><br><span class="line">    <span class="type">void</span> (*RemoveMessageCustom)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler,</span><br><span class="line">        <span class="type">int</span> (*)(<span class="type">const</span> SoftBusMessage*, <span class="type">void</span>*), <span class="type">void</span> *args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/5.softbus_server/" data-id="cmbcy7rhk002bt8mt2xqa4yrt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/4.softbus_core_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/4.softbus_core_2/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.815Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="softbus-core（中）"><a href="#softbus-core（中）" class="headerlink" title="softbus core（中）"></a>softbus core（中）</h2><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>必须搞定连接，才能了解后面的传输，传输就是基于连接创建的socket接口。从哪里入手？softbus_conn_manager.c：</p>
<p>首先要知道g_connManager这个对象，它用来管理所有的类型的连接。每种类型的连接都有对应的一个ConnectFuncInterface。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*ConnectDevice)(<span class="type">const</span> ConnectOption *option, <span class="type">uint32_t</span> requestId, <span class="type">const</span> ConnectResult *result);</span><br><span class="line">    <span class="type">int32_t</span> (*PostBytes)(<span class="type">uint32_t</span> connectionId, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">int32_t</span> len, <span class="type">int32_t</span> pid, <span class="type">int32_t</span> flag);</span><br><span class="line">    <span class="type">int32_t</span> (*DisconnectDevice)(<span class="type">uint32_t</span> connectionId);</span><br><span class="line">    <span class="type">int32_t</span> (*DisconnectDeviceNow)(<span class="type">const</span> ConnectOption *option);</span><br><span class="line">    <span class="type">int32_t</span> (*GetConnectionInfo)(<span class="type">uint32_t</span> connectionId, ConnectionInfo *info);</span><br><span class="line">    <span class="type">int32_t</span> (*StartLocalListening)(<span class="type">const</span> LocalListenerInfo *info);</span><br><span class="line">    <span class="type">int32_t</span> (*StopLocalListening)(<span class="type">const</span> LocalListenerInfo *info);</span><br><span class="line">    <span class="type">bool</span> (*CheckActiveConnection)(<span class="type">const</span> ConnectOption *info);</span><br><span class="line">&#125; ConnectFuncInterface;</span><br><span class="line"></span><br><span class="line">ConnectFuncInterface *g_connManager[CONNECT_TYPE_MAX]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>连接有通道的区分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CHANNEL_TYPE_TCP_DIRECT = <span class="number">0</span>,   </span><br><span class="line">    CHANNEL_TYPE_PROXY,    <span class="comment">//啥？</span></span><br><span class="line">    CHANNEL_TYPE_UDP,</span><br><span class="line">    CHANNEL_TYPE_AUTH,</span><br><span class="line">    CHANNEL_TYPE_BUTT,</span><br><span class="line">&#125; ChannelType;</span><br></pre></td></tr></table></figure>

<p>那么从初始化看：ConnServerInit，可以发现连接的物理层可以是wifi或蓝牙</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">g_connManagerCb.OnConnected = ConnManagerConnected;</span><br><span class="line">g_connManagerCb.OnDisconnected = ConnManagerDisconnected;</span><br><span class="line">g_connManagerCb.OnDataReceived = ConnManagerRecvData;</span><br><span class="line">SoftbusGetConfig(SOFTBUS_INT_SUPPORT_TCP_PROXY, (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;isSupportTcp, <span class="keyword">sizeof</span>(isSupportTcp));<span class="comment">//查看是否支持tcp</span></span><br><span class="line">connectObj = ConnInitTcp(&amp;g_connManagerCb);</span><br><span class="line">    InitProperty()</span><br><span class="line">    InitTcpInterface();</span><br><span class="line">    g_tcpConnCallback = g_connManagerCb;</span><br><span class="line">    g_tcpConnInfoList = CreateSoftBusList();</span><br><span class="line">    <span class="keyword">return</span> &amp;g_tcpInterface;</span><br><span class="line">connectObj = ConnInitBr(&amp;g_connManagerCb);</span><br><span class="line">connectObj = ConnInitBle(&amp;g_connManagerCb);</span><br><span class="line">g_connManager[CONNECT_TCP] = connectObj;</span><br><span class="line">g_listenerList = CreateSoftBusList();</span><br></pre></td></tr></table></figure>

<p>以tcp方式为例，可以看到ConnInitTcp()的任务就是返回了一个tcp的ConnectFuncInterface，这个接口是已经定义好了的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">InitTcpInterface</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tcpInterface.ConnectDevice = TcpConnectDevice;</span><br><span class="line">    g_tcpInterface.DisconnectDevice = TcpDisconnectDevice;</span><br><span class="line">    g_tcpInterface.DisconnectDeviceNow = TcpDisconnectDeviceNow;</span><br><span class="line">    g_tcpInterface.PostBytes = TcpPostBytes;</span><br><span class="line">    g_tcpInterface.GetConnectionInfo = TcpGetConnectionInfo;</span><br><span class="line">    g_tcpInterface.StartLocalListening = TcpStartListening;</span><br><span class="line">    g_tcpInterface.StopLocalListening = TcpStopListening;</span><br><span class="line">    g_tcpInterface.CheckActiveConnection = TcpCheckActiveConnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就需要重点来看这些函数是如何实现的，可以发现其本质就是调用softbus_adapter_socket.c中的函数，这些函数实现了对socket的封装。</p>
<p>首先看看TcpConnectDevice：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fd = OpenTcpClientSocket(option-&gt;info.ipOption.ip, <span class="string">&quot;0.0.0.0&quot;</span>, (<span class="type">uint16_t</span>)option-&gt;info.ipOption.port, <span class="literal">false</span>);</span><br><span class="line">    SoftBusSocketCreate(SOFTBUS_AF_INET, SOFTBUS_SOCK_STREAM, <span class="number">0</span>, &amp;fd);</span><br><span class="line">        socket(domain, type, protocol);</span><br><span class="line">    ConnToggleNonBlockMode(fd, <span class="literal">true</span>)</span><br><span class="line">        fcntl(fd, F_SETFL, flags);</span><br><span class="line">    SetClientOption(fd);</span><br><span class="line">        SetReuseAddr(fd, <span class="number">1</span>);</span><br><span class="line">        SetNoDelay(fd, <span class="number">1</span>);</span><br><span class="line">    BindLocalIP(fd, myIp, <span class="number">0</span>);</span><br><span class="line">        SoftBusSocketBind(fd, (SoftBusSockAddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line">        bind(socketFd, &amp;sysAddr, (<span class="type">socklen_t</span>)addrLen);</span><br><span class="line">    SoftBusSocketConnect(fd, (SoftBusSockAddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line">        connect(socketFd, &amp;sysAddr, (<span class="type">socklen_t</span>)addrLen);</span><br><span class="line">TcpConnInfoNode *tcpConnInfoNode;</span><br><span class="line">AddTcpConnInfo(tcpConnInfoNode) </span><br><span class="line">AddTrigger(option-&gt;info.ipOption.moduleId, fd, WRITE_TRIGGER)</span><br><span class="line">    SoftbusBaseListenerInfo *info = g_listenerList[module].info;</span><br><span class="line">    AddTriggerToSet(fd, triggerType)</span><br><span class="line">    AddNewFdNode(info, fd)</span><br><span class="line">    g_maxFd = MaxFd(fd, g_maxFd);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么大胆的猜测TcpPostBytes()应该也是类似的，可以看到是根据connectid来确定fd的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST_FOR_EACH_ENTRY(item, &amp;g_tcpConnInfoList-&gt;<span class="built_in">list</span>, TcpConnInfoNode, node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item-&gt;connectionId == connectionId) &#123;</span><br><span class="line">        fd = item-&gt;info.info.ipInfo.fd;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SendTcpData(fd, data, len, flag);</span><br><span class="line">    WaitEvent(fd, SOFTBUS_SOCKET_OUT, USER_TIMEOUT_MS);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)SoftBusSocketSend(fd, &amp;buf[bytes], len - bytes, <span class="number">0</span>);</span><br><span class="line">        send(socketFd, buf, len, flags);</span><br><span class="line">    WaitEvent(fd, SOFTBUS_SOCKET_OUT, timeout);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么TcpStartListening也应该是类似的简单，可以发现它创建了一个socket监听端口，然后也创建一个线程ThreadPoolWorker。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListenerModule moduleId = info-&gt;info.ipListenerInfo.moduleId;</span><br><span class="line">SoftbusBaseListener *listener = CheckTcpListener(moduleId);</span><br><span class="line">    <span class="keyword">return</span> g_tcpListenerItems[i].listener;</span><br><span class="line">SetSoftbusBaseListener(moduleId, listener);</span><br><span class="line">    memcpy_s(g_listenerList[module].listener, <span class="keyword">sizeof</span>(SoftbusBaseListener),listener, <span class="keyword">sizeof</span>(SoftbusBaseListener))</span><br><span class="line">StartBaseListener(moduleId, info-&gt;info.ipListenerInfo.ip, info-&gt;info.ipListenerInfo.port, SERVER_MODE);</span><br><span class="line">    InitListenFd(module, ip, port);</span><br><span class="line">        OpenTcpServerSocket(ip, port);</span><br><span class="line">            SoftBusSocketCreate(SOFTBUS_AF_INET, SOFTBUS_SOCK_STREAM, <span class="number">0</span>, (<span class="type">int32_t</span> *)&amp;fd);</span><br><span class="line">            SetServerOption(fd);</span><br><span class="line">            BindLocalIP(fd, ip, (<span class="type">uint16_t</span>)port);</span><br><span class="line">        SoftBusSocketListen(listenerInfo-&gt;listenFd, DEFAULT_BACKLOG);</span><br><span class="line">            listen(socketFd, backLog);</span><br><span class="line">        SoftBusSocketFdSet(listenerInfo-&gt;listenFd, &amp;g_readSet);</span><br><span class="line">    PrepareBaseListener(module, modeType);</span><br><span class="line">        g_threadPool = ThreadPoolInit(THREADPOOL_THREADNUM, THREADPOOL_QUEUE_NUM);</span><br><span class="line">            CreateThreadPool(threadNum, queueMaxNum);</span><br><span class="line">            CreateThread((Runnable)ThreadPoolWorker, (<span class="type">void</span> *)pool, &amp;attr, (<span class="type">uint32_t</span> *)&amp;(pool-&gt;pthreads[i])</span><br><span class="line">        StartThread(module, modeType);</span><br><span class="line">            ThreadPoolAddJob(g_threadPool, (<span class="type">int32_t</span>(*)(<span class="type">void</span> *))SelectThread,<span class="literal">NULL</span>, PERSISTENT, (<span class="type">uintptr_t</span>)<span class="number">0</span>);</span><br><span class="line">                CheckThreadPoolAddReady(pool, callbackFunction);</span><br><span class="line">                SoftBusCondBroadcast(&amp;(pool-&gt;queueNotEmpty));</span><br><span class="line">                    pthread_cond_broadcast((<span class="type">pthread_cond_t</span> *)*cond);    <span class="comment">//解锁一些任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadPoolWorker读取队列中的数据。这部分应该需要了解一下线程池是怎么运行的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((pool-&gt;queueCurNum == <span class="number">0</span>) &amp;&amp; !pool-&gt;poolClose) &#123;</span><br><span class="line">    SoftBusCondWait(&amp;(pool-&gt;queueNotEmpty), &amp;(pool-&gt;mutex), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">JobCheck(pool, job);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;queueCurNum == <span class="number">0</span>) &#123;</span><br><span class="line">     SoftBusCondSignal(&amp;(pool-&gt;queueEmpty));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;queueCurNum == pool-&gt;queueMaxNum - <span class="number">1</span>) &#123;</span><br><span class="line">     SoftBusCondBroadcast(&amp;(pool-&gt;queueNotFull));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TcpStartListening中发现还有一个线程SelectThread，这个线程中，应该使用select读取数据，然后调用回调函数处理数据。</p>
<h2 id="会话传输"><a href="#会话传输" class="headerlink" title="会话传输"></a>会话传输</h2><p>继续分析softbus 服务里的ServerOpenSession()，字面意思表示打开一个会话传输,打开的本质是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取参数、会话的连接信息</span></span><br><span class="line">param.sessionName = (<span class="type">const</span> <span class="type">char</span>*)IpcIoPopString(req, &amp;size);</span><br><span class="line">param.peerSessionName = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;size);</span><br><span class="line">param.peerDeviceId = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;size);</span><br><span class="line">param.groupId = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;size);</span><br><span class="line">param.attr = (SessionAttribute *)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line">TransOpenSession(&amp;param, &amp;(transSerializer.transInfo));</span><br><span class="line">    TransOpenChannel(param, info);</span><br><span class="line">        appInfo = GetAppInfo(param);   </span><br><span class="line">        TransGetLaneInfo(param, appInfo-&gt;myData.pid, &amp;object, &amp;info)</span><br><span class="line">        TransGetConnectOption(info, &amp;connOpt)</span><br><span class="line">        transInfo-&gt;channelType = TransGetChannelType(info);</span><br><span class="line">        TransOpenChannelProc((ChannelType)transInfo-&gt;channelType, appInfo, &amp;connOpt,&amp;(transInfo-&gt;channelId))</span><br></pre></td></tr></table></figure>

<p>那么重点就是TransOpenChannelProc()，能够打开三种类型的通道。udp、proxy、tcp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">TransOpenChannelProc</span><span class="params">(ChannelType type, AppInfo *appInfo, <span class="type">const</span> ConnectOption *connOpt,</span></span><br><span class="line"><span class="params">    <span class="type">int32_t</span> *channelId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == CHANNEL_TYPE_UDP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransOpenUdpChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_INFO, <span class="string">&quot;open udp channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == CHANNEL_TYPE_PROXY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransProxyOpenProxyChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;open proxy channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransOpenTcpDirectChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;open direct channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="udp-channel"><a href="#udp-channel" class="headerlink" title="udp channel"></a>udp channel</h3><p>TransOpenUdpChannel：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PrepareAppInfoForUdpOpen(connOpt, appInfo, &amp;id)</span><br><span class="line">UdpChannelInfo *newChannel = NewUdpChannelByAppInfo(appInfo);</span><br><span class="line">TransAddUdpChannel(newChannel)    <span class="comment">//添加到g_udpChannelMgr中</span></span><br><span class="line">OpenAuthConnForUdpNegotiation(newChannel, connOpt)</span><br><span class="line">    AuthGetIdByOption(connOpt, &amp;authId)</span><br><span class="line">    StartExchangeUdpInfo(channel, authId, connOpt, channel-&gt;seq)</span><br></pre></td></tr></table></figure>

<p>StartExchangeUdpInfo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">StartExchangeUdpInfo</span><span class="params">(UdpChannelInfo *channel, <span class="type">int64_t</span> authId, <span class="type">const</span> ConnectOption *opt, <span class="type">int64_t</span> seq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建json的数据</span></span><br><span class="line">    cJSON *requestMsg = cJSON_CreateObject();</span><br><span class="line">    <span class="comment">//把channel信息打包进json</span></span><br><span class="line">	TransPackRequestUdpInfo(requestMsg, &amp;(channel-&gt;info));</span><br><span class="line">    <span class="comment">//输出json数据</span></span><br><span class="line">    <span class="type">char</span> *msgStr = cJSON_PrintUnformatted(requestMsg);</span><br><span class="line">    cJSON_Delete(requestMsg);</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="comment">//对数据进行加密</span></span><br><span class="line">    <span class="type">uint8_t</span> *encryptData = GetEncryptData(msgStr, opt, &amp;size);</span><br><span class="line">    cJSON_free(msgStr);</span><br><span class="line">	<span class="comment">//接下来是发送数据</span></span><br><span class="line">    AuthDataHead head = &#123;</span><br><span class="line">        .authId = authId,</span><br><span class="line">        .module = MODULE_UDP_INFO,</span><br><span class="line">        .flag = FLAG_REQUEST,</span><br><span class="line">        .seq = seq</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//发送认证数据</span></span><br><span class="line">    AuthPostData(&amp;head, encryptData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="proxy-channel"><a href="#proxy-channel" class="headerlink" title="proxy channel"></a>proxy channel</h3><p>接下来看看CHANNEL_TYPE_PROXY类型：TransProxyOpenProxyChannel:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TransProxyOpenConnChannel(appInfo, connInfo, channelId)</span><br><span class="line">    TransGetConn(connInfo, &amp;conn)</span><br><span class="line">    ProxyChannelInfo *chan;</span><br><span class="line">    <span class="comment">//以下目标就是为了获取一个ProxyConnInfo</span></span><br><span class="line">    TransProxyCreateChanInfo(chan, chanNewId, appInfo)</span><br><span class="line">    ProxyConnInfo *connChan;</span><br><span class="line">    TransAddConnItem(connChan)</span><br><span class="line">    result.OnConnectFailed = TransOnConnectFailed;</span><br><span class="line">    result.OnConnectSuccessed = TransOnConnectSuccessed;</span><br><span class="line">    ConnConnectDevice(&amp;(connChan-&gt;connInfo), reqId, &amp;result);</span><br><span class="line">        g_connManager[info-&gt;type]-&gt;ConnectDevice(info, requestId, result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TODO 未完成</p>
<h3 id="tcp-channel"><a href="#tcp-channel" class="headerlink" title="tcp channel"></a>tcp channel</h3><p>打开一个tcp通道TransOpenTcpDirectChannel:</p>
<p>tdc:tcp direct connection?</p>
<p>首先是创建一个SessionConn，然后调用socket创建一个tcp连接，然后保存fd到全局变量中，那么必然有一个线程来读取这些fd的数据。具体的实现在core&#x2F;connection&#x2F;common&#x2F;src&#x2F;softbus_base_listener.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">appInfo-&gt;routeType = WIFI_STA;</span><br><span class="line">SessionConn *newConn = (SessionConn*)CreateDefaultSession(appInfo, connInfo);</span><br><span class="line">fd = OpenConnTcp(appInfo, connInfo);</span><br><span class="line">    <span class="type">char</span> *ip = (<span class="type">char</span>*)connInfo-&gt;info.ipOption.ip;	<span class="comment">//对端ip</span></span><br><span class="line">    <span class="type">char</span> *myIp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> sessionPort = connInfo-&gt;info.ipOption.port;</span><br><span class="line">    fd = OpenTcpClientSocket(ip, myIp, sessionPort);</span><br><span class="line">*channelId = GenerateTdcChannelId();</span><br><span class="line">TransSrvAddDataBufNode(*channelId, fd)    <span class="comment">//申请一个ServerDataBuf，可能是缓存数据</span></span><br><span class="line">newConn-&gt;appInfo.fd = fd;</span><br><span class="line">newConn-&gt;channelId = *channelId;    </span><br><span class="line">TransTdcAddSessionConn(newConn)</span><br><span class="line">AddTrigger(DIRECT_CHANNEL_SERVER, newConn-&gt;appInfo.fd, WRITE_TRIGGER)</span><br><span class="line">    SoftbusBaseListenerInfo *info = g_listenerList[module].info;    <span class="comment">//获取已经设置的info</span></span><br><span class="line">    AddTriggerToSet(fd, triggerType)	<span class="comment">//把tcp连接的描述符保存</span></span><br><span class="line">    AddNewFdNode(info, fd)   </span><br><span class="line">    g_maxFd = MaxFd(fd, g_maxFd);</span><br></pre></td></tr></table></figure>



<p>当调用StartBaseListener开始监听tcp端口时，会开启一个线程 SelectThread，他会读取上面的会话的socket数据。然后执行回调函数来处理这些数据。这个回调函数是 调用SetSoftbusBaseListener()设置的。在 trans_tcp_direct_listener.c 中应该就调用SetSoftbusBaseListener()来注册回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g_sessionListener-&gt;onConnectEvent = OnConnectEvent;</span><br><span class="line">g_sessionListener-&gt;onDataEvent = OnDataEvent;</span><br><span class="line"><span class="type">int32_t</span> ret = SetSoftbusBaseListener(DIRECT_CHANNEL_SERVER, g_sessionListener);</span><br></pre></td></tr></table></figure>

<p>首先分析OnDataEvent：</p>
<p>有数据输入和数据输出需要处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">OnDataEvent</span><span class="params">(<span class="type">int</span> events, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    SessionConn *conn = SoftBusCalloc(<span class="keyword">sizeof</span>(SessionConn));</span><br><span class="line">    GetSessionConnByFd(fd, conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (events == SOFTBUS_SOCKET_IN) &#123;</span><br><span class="line">        <span class="comment">//TODO 复杂曲折，整不明白</span></span><br><span class="line">        ret = TransTdcSrvRecvData(conn-&gt;channelId);</span><br><span class="line">        <span class="keyword">if</span> (ret == SOFTBUS_DATA_NOT_ENOUGH) &#123;</span><br><span class="line">            SoftBusFree(conn);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        TransProcDataRes(ret, conn-&gt;channelId, fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events == SOFTBUS_SOCKET_OUT) &#123;</span><br><span class="line">        <span class="comment">//本地是服务端的话直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;serverSide == <span class="literal">true</span>) &#123;</span><br><span class="line">            SoftBusFree(conn);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//客户端，从写触发移动到读触发，开始验证会话</span></span><br><span class="line">        DelTrigger(DIRECT_CHANNEL_SERVER, fd, WRITE_TRIGGER);</span><br><span class="line">        AddTrigger(DIRECT_CHANNEL_SERVER, fd, READ_TRIGGER);</span><br><span class="line">        ret = StartVerifySession(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


































<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.icode9.com/content-4-825230.html">https://www.icode9.com/content-4-825230.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/4.softbus_core_2/" data-id="cmbcy7rhl002dt8mt4qc40kjg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/NetDev" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/NetDev/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.815Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="NetDev"><a href="#NetDev" class="headerlink" title="NetDev"></a>NetDev</h2><p>WIFI 芯片属于网络设备，自然也要归OpenHarmony的网络框架管理，本文用于了解 网络数据如何在协议栈和网络驱动之间传输。</p>
<p>网络设备的使用需要配合网络协议栈，OpenHarmony的网络协议栈有两种，一种是liteos-a内核使用的lwip协议栈，一种是标准系统linux内核网络协议栈。</p>
<p>本文以lwip协议栈为例来了解。</p>
<h3 id="一、前提"><a href="#一、前提" class="headerlink" title="一、前提"></a>一、前提</h3><p>网络数据的通路：（这里的网口驱动是具体wifi芯片的驱动程序，由厂商实现。）</p>
<p>发送数据：应用程序-&gt;lwip-&gt;网口驱动</p>
<p>接受数据：网口驱动-&gt;lwip-&gt;应用程序</p>
<h3 id="二、NetDevice"><a href="#二、NetDevice" class="headerlink" title="二、NetDevice"></a>二、NetDevice</h3><p>openharmony使用NetDevice结构体来描述所有的网络设备（网口）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> &#123;</span></span><br><span class="line">    NetIfCategory netifCateg;                 <span class="comment">//内核类型</span></span><br><span class="line">    <span class="type">char</span> name[IFNAMSIZ];                      <span class="comment">//设备名称</span></span><br><span class="line">    NetLinkType LinkLayerType;                <span class="comment">//链路层类型：以太网或wifi</span></span><br><span class="line">    IfType funType;                           <span class="comment">//网络端口类型 including AP, STA, and P2P</span></span><br><span class="line">    <span class="type">uint8_t</span> macAddr[MAC_ADDR_SIZE];           <span class="comment">//mac地址</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceInterFace</span> *<span class="title">netDeviceIf</span>;</span>   <span class="comment">//提供给驱动厂商的接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">owner</span>;</span>                  <span class="comment">/**&lt; Network device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevStats</span> <span class="title">stats</span>;</span>                 <span class="comment">/**&lt; Network statistics */</span></span><br><span class="line">&#125; NetDevice;</span><br></pre></td></tr></table></figure>

<p>其中 NetDeviceInterFace 对象的作用是初始化、打开、关闭一个网络设备等以下功能，必须由驱动开发厂商根据具体的wifi芯片编写的驱动来实现其中的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceInterFace</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*init)(<span class="keyword">struct</span> NetDevice *netDev);  <span class="comment">//初始化网络设备</span></span><br><span class="line">    <span class="type">void</span> (*deInit)(<span class="keyword">struct</span> NetDevice *netDev);   </span><br><span class="line">    <span class="type">int32_t</span> (*open)(<span class="keyword">struct</span> NetDevice *netDev);  <span class="comment">//打开数据链路层</span></span><br><span class="line">    <span class="type">int32_t</span> (*stop)(<span class="keyword">struct</span> NetDevice *netDev);  </span><br><span class="line">    NetDevTxResult (*xmit)(<span class="keyword">struct</span> NetDevice *netDev, NetBuf *netBuff);        <span class="comment">//发送数据</span></span><br><span class="line">    <span class="type">int32_t</span> (*ioctl)(<span class="keyword">struct</span> NetDevice *netDev, IfReq *req, <span class="type">int32_t</span> cmd);      <span class="comment">/**&lt; Used for the control command word. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*setMacAddr)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">void</span> *addr);              <span class="comment">//设置mac地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevStats</span> *(*<span class="title">getStats</span>)(<span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netDev</span>);</span>                <span class="comment">//获取设备状态</span></span><br><span class="line">    <span class="type">void</span> (*setNetIfStatus)(<span class="keyword">struct</span> NetDevice *netDev, NetIfStatus status);     <span class="comment">//设置状态</span></span><br><span class="line">    <span class="type">uint16_t</span> (*selectQueue)(<span class="keyword">struct</span> NetDevice *netDev, NetBuf *netBuff);       <span class="comment">//选择一个队列</span></span><br><span class="line">    <span class="type">uint32_t</span> (*netifNotify)(<span class="keyword">struct</span> NetDevice *netDev, NetDevNotify *notify);  <span class="comment">/**&lt; Notifies the network port status. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*changeMtu)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">int32_t</span> newMtu);           <span class="comment">//改变mtu</span></span><br><span class="line">    <span class="type">void</span> (*linkStatusChanged)(<span class="keyword">struct</span> NetDevice *netDev);   	<span class="comment">//检查以太网连接状态</span></span><br><span class="line">    ProcessingResult (*specialEtherTypeProcess)(<span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDev, NetBuf *buff);</span><br><span class="line">                                                                              <span class="comment">/**&lt; Performs private processing without</span></span><br><span class="line"><span class="comment">                                                                               * involving network-layer data.</span></span><br><span class="line"><span class="comment">                                                                               */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据HdfWlanDevice 创建NetDevice：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> NetDevice *<span class="title function_">AllocPlatformNetDevice</span><span class="params">(<span class="keyword">struct</span> HdfWlanDevice *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> ifName[IFNAMSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfWifiNetDeviceData</span> *<span class="title">data</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    data = (<span class="keyword">struct</span> HdfWifiNetDeviceData *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HdfWifiNetDeviceData));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//分配网卡编号</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_IF_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((g_allocatedIfMap &gt;&gt; i) &amp; <span class="number">0x1</span>) != <span class="number">0x1</span>) &#123;</span><br><span class="line">                id = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//生成网卡名称：wlan0</span></span><br><span class="line">        ret = GetPlatformIfName(id, ifName, IFNAMSIZ);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _PRE_HDF_LINUX</span></span><br><span class="line">        result = NetDeviceInit(ifName, <span class="built_in">strlen</span>(ifName), WIFI_LINK, FULL_OS);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">//获取netdev</span></span><br><span class="line">        result = NetDeviceInit(ifName, <span class="built_in">strlen</span>(ifName), WIFI_LINK, LITE_OS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    result-&gt;classDriverName = HDF_WIFI_PLATFORM_DRIVER_NAME;</span><br><span class="line">    result-&gt;classDriverPriv = data;</span><br><span class="line">    data-&gt;netInterfaceId = id;</span><br><span class="line">    SET_BIT(device-&gt;netIfMap, id);</span><br><span class="line">    SET_BIT(g_allocatedIfMap, id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、NetBuf"><a href="#三、NetBuf" class="headerlink" title="三、NetBuf"></a>三、NetBuf</h3><p>NetBuf用于描述网络数据，以在网络协议栈和网络驱动之间传输数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录一段网络数据的偏移和长度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufField</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> offset;      <span class="comment">/**&lt; Offset of the buffer segment */</span></span><br><span class="line">    <span class="type">uint32_t</span> len;         <span class="comment">/**&lt; Length of the buffer segment */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NetBuf</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DListHead</span> <span class="title">dlist</span>;</span>             <span class="comment">//双链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufField</span> <span class="title">bufs</span>[<span class="title">MAX_BUF_NUM</span>];</span>  </span><br><span class="line">    <span class="type">uint8_t</span>     *mem;                   <span class="comment">//内存地址</span></span><br><span class="line">    <span class="type">uint32_t</span>    len;                    <span class="comment">//内存长度</span></span><br><span class="line">    <span class="type">uint32_t</span>    dataLen;                <span class="comment">//真实数据长度</span></span><br><span class="line">    <span class="type">void</span>        *dev;                   <span class="comment">//接受到该数据的netdev</span></span><br><span class="line">    <span class="type">uint32_t</span>    qmap;                   <span class="comment">/**&lt; Queue mappings of the network data buffer */</span></span><br><span class="line">    <span class="type">uint8_t</span>     rsv[MAX_NETBUF_RESEVER_SIZE]; <span class="comment">/**&lt; Reserved field. For details, see &#123;@link MAX_NETBUF_RESEVER_SIZE&#125;. */</span></span><br><span class="line">&#125; NetBuf;</span><br></pre></td></tr></table></figure>



<h3 id="四、适配器-NetDeviceImpl"><a href="#四、适配器-NetDeviceImpl" class="headerlink" title="四、适配器 NetDeviceImpl"></a>四、适配器 NetDeviceImpl</h3><p>这里有一个问题，就是openharmony使用NetDev来描述网口，用NetBuf来描述网口数据，但是在lwip协议栈中，有他自己的一套机制来描述网口和网络数据。</p>
<p>这里就存在一个适配（adapt）的问题，需要一个适配器（adapter）来适配这两套机制，使得数据能在这两者之间顺利传递。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NetDev ------&gt; netif</span><br><span class="line">NetBuf ------&gt; pbuf</span><br></pre></td></tr></table></figure>

<p>NetDeviceImpl结构体应运而生，该部分的代码在bearpi_micro&#x2F;drivers&#x2F;adapter&#x2F;khdf&#x2F;liteos&#x2F;network&#x2F;src&#x2F;net_device_adapter.c，net_device_adapter顾名思义就是把net_device适配到lwip的netif。同理netbuf_adapter.c实现的就是把netbuf适配到lwip的pbuf。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImpl</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netDevice</span>;</span>	<span class="comment">//可通过netDevice-&gt;NetDeviceInterFace 调用芯片驱动程序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImplOp</span> *<span class="title">interFace</span>;</span>	<span class="comment">//调用lwip的接口</span></span><br><span class="line">    <span class="type">void</span> *osPrivate;	<span class="comment">//指向 lwip的netif对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以NetDeviceImpl 就是芯片驱动程序 和 lwip协议栈沟通的中介，其成员的作用很明显：</p>
<ul>
<li>NetDevice：可通过netDevice-&gt;NetDeviceInterFace 调用芯片驱动程序</li>
<li>NetDeviceImplOp：提供给开发者的接口</li>
<li>osPrivate：指向 lwip的netif对象</li>
</ul>
<h4 id="NetDeviceImplOp"><a href="#NetDeviceImplOp" class="headerlink" title="NetDeviceImplOp"></a>NetDeviceImplOp</h4><p>NetDeviceImplOp结构体就是提供给开发者的接口，使得网口驱动程序能与lwip协议栈交互。在net_device_adapter.c中的g_liteNdImplOps就是NetDeviceImplOp。我们将通过这个结构体，看lwip协议栈如何收发数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImplOp</span> &#123;</span></span><br><span class="line">   	<span class="comment">//初始化netdev</span></span><br><span class="line">    <span class="type">int32_t</span> (*init)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*deInit)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*add)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*delete)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*setStatus)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetIfStatus status);</span><br><span class="line">    <span class="type">int32_t</span> (*setLinkStatus)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetIfLinkStatus status);</span><br><span class="line">    <span class="type">int32_t</span> (*getLinkStatus)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetIfLinkStatus *status);</span><br><span class="line">    <span class="type">int32_t</span> (*receive)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetBuf *buff, ReceiveFlag flag);</span><br><span class="line">    <span class="type">int32_t</span> (*setIpAddr)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, <span class="type">const</span> IpV4Addr *ipAddr, <span class="type">const</span> IpV4Addr *netMask,</span><br><span class="line">        <span class="type">const</span> IpV4Addr *gw);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpsStart)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, <span class="type">char</span> *ip, <span class="type">uint16_t</span> ipNum);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpsStop)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpStart)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpStop)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpIsBound)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*changeMacAddr)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImplOp</span> <span class="title">g_liteNdImplOps</span> =</span> &#123;</span><br><span class="line">    .init = LiteNetDevInit,		<span class="comment">//创建netif</span></span><br><span class="line">    .deInit = LiteNetDevDeInit,</span><br><span class="line">    .add = LiteNetDevAdd,	<span class="comment">//创建netif并添加到协议栈</span></span><br><span class="line">    .delete = LiteNetDevDelete,</span><br><span class="line">    .setStatus = LiteNetDevSetStatus,</span><br><span class="line">    .setLinkStatus = LiteNetDevSetLinkStatus,</span><br><span class="line">    .getLinkStatus = LiteNetDevGetLinkStatus,</span><br><span class="line">    .receive = LiteNetDevReceive,	<span class="comment">//将数据上传到协议栈</span></span><br><span class="line">    .setIpAddr = LiteNetSetIpAddr,	<span class="comment">//设置ip</span></span><br><span class="line">    .dhcpsStart = LiteNetDhcpsStart,	<span class="comment">//开始dhcp</span></span><br><span class="line">    .dhcpsStop = LiteNetDhcpsStop,</span><br><span class="line">    .dhcpStart = LiteNetDhcpStart,</span><br><span class="line">    .dhcpStop = LiteNetDhcpStop,</span><br><span class="line">    .dhcpIsBound = LiteNetDhcpIsBound,</span><br><span class="line">    .changeMacAddr = LiteNetChangeMacAddr,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="五、netif"><a href="#五、netif" class="headerlink" title="五、netif"></a>五、netif</h3><p>要使用lwip协议栈，就需要创建一个netif来描述所使用的wifi 网口。NetDeviceImplOp结构体提供给开发者创建netif的接口：</p>
<p>创建初始化lwip netif的接口：</p>
<ul>
<li>g_liteNdImplOps.init()</li>
<li>g_liteNdImplOps.add()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceAdapterLite</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">lwipNetif</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建netif</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevInit</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceAdapterLite</span> *<span class="title">liteNdPri</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    liteNdPri = (<span class="keyword">struct</span> NetDeviceAdapterLite *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> NetDeviceAdapterLite));</span><br><span class="line">    (<span class="type">void</span>)memset_s(liteNdPri, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NetDeviceAdapterLite), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NetDeviceAdapterLite));</span><br><span class="line">    netDeviceImpl-&gt;osPrivate = (<span class="type">void</span> *)liteNdPri;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建netif并添加到协议栈</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevAdd</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceAdapterLite</span> *<span class="title">liteNdPri</span> =</span> (<span class="keyword">struct</span> NetDeviceAdapterLite *)netDeviceImpl-&gt;osPrivate;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">lwipNd</span> =</span> netDeviceImpl-&gt;netDevice;</span><br><span class="line">	<span class="comment">//根据lwipNd创建netif</span></span><br><span class="line">    lwipNf = CreateLwipNetIf(netDeviceImpl, lwipNd创建netif);</span><br><span class="line">    <span class="keyword">if</span> ((ret = netifapi_netif_add(lwipNf, &amp;ipaddr, &amp;netmask, &amp;gw)) != ERR_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制mac地址</span></span><br><span class="line">    <span class="keyword">if</span> (memcpy_s(lwipNf-&gt;hwaddr, NETIF_MAX_HWADDR_LEN, lwipNd-&gt;macAddr, MAC_ADDR_SIZE) != EOK) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    liteNdPri-&gt;lwipNetif = lwipNf;</span><br><span class="line">    IpV6SpecialProc(lwipNd, lwipNf);</span><br><span class="line">    <span class="comment">/* set netif default status */</span></span><br><span class="line">    netifapi_netif_set_default(lwipNf);</span><br><span class="line">    netif_set_link_callback(lwipNf, LiteNetifLinkChangeCallback);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建netif的同时实现了netif的一些函数如drv_send、drv_set_hwaddr，这些函数需要调用芯片驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> netif *<span class="title function_">CreateLwipNetIf</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl, <span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDev)</span></span><br><span class="line">&#123;</span><br><span class="line">    lwipNf = (<span class="keyword">struct</span> netif *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> netif));</span><br><span class="line">    (<span class="type">void</span>)memset_s(lwipNf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> netif), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> netif));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register netif to lwip */</span></span><br><span class="line">    lwipNf-&gt;state = (<span class="type">void</span> *)netDeviceImpl;</span><br><span class="line">    lwipNf-&gt;drv_send = LwipSend;</span><br><span class="line">    lwipNf-&gt;drv_set_hwaddr = LwipSetHwaddr;</span><br><span class="line">    lwipNf-&gt;link_layer_type = netDev-&gt;LinkLayerType;</span><br><span class="line">    lwipNf-&gt;hwaddr_len = MAC_ADDR_SIZE;</span><br><span class="line">    lwipNf-&gt;drv_config = LwipDrvConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lwipNf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="网口发送数据到lwip"><a href="#网口发送数据到lwip" class="headerlink" title="网口发送数据到lwip"></a>网口发送数据到lwip</h4><p>在网口的驱动程序收到数据后，需要传递给lwip协议栈，这时调用NetDeviceImplOp-&gt;reveive()函数来传递数据：</p>
<p>首先把netdev转换成netif，把netbuf转换成pbuf，再调用driverif_input()传递pbuf给lwip协议栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevReceive</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl, <span class="keyword">struct</span> NetBuf *buff, ReceiveFlag flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//get lwip netif</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">lwipNf</span> =</span> GetNetIfFromDevImpl(netDeviceImpl);</span><br><span class="line">    ProcessingResult ret = LiteNetDevDataFilter(netDeviceImpl, buff);</span><br><span class="line">    <span class="keyword">if</span> (ret == PROCESSING_CONTINUE) &#123;</span><br><span class="line">        <span class="comment">//call LiteNetDevDataReceive to send pbuf</span></span><br><span class="line">        <span class="keyword">return</span> LiteNetDevDataReceive(netDeviceImpl, buff);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == PROCESSING_COMPLETE) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevDataReceive</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl, <span class="keyword">struct</span> NetBuf *buff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">lwipNf</span> =</span> GetNetIfFromDevImpl(netDeviceImpl);</span><br><span class="line">    <span class="comment">//Conver NetBuf To PBuf</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">pBuff</span> =</span> ConverNetBufToPBuf(buff);</span><br><span class="line">	<span class="comment">//post pbuff to lwip</span></span><br><span class="line">    driverif_input(lwipNf, pBuff);</span><br><span class="line">    NetBufFree(buff);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>driverif_input()是由lwip提供的接口，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function should be called by network driver to pass the input packet to LwIP.</span></span><br><span class="line"><span class="comment"> * Before calling this API, driver has to keep the packet in pbuf structure. Driver has to</span></span><br><span class="line"><span class="comment"> * call pbuf_alloc() with type as PBUF_RAM to create pbuf structure. Then driver</span></span><br><span class="line"><span class="comment"> * has to pass the pbuf structure to this API. This will add the pbuf into the TCPIP thread.</span></span><br><span class="line"><span class="comment"> * Once this packet is processed by TCPIP thread, pbuf will be freed. Driver is not required to</span></span><br><span class="line"><span class="comment"> * free the pbuf.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param netif the lwip network interface structure for this driverif</span></span><br><span class="line"><span class="comment"> * @param p packet in pbuf structure format</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">driverif_input</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> pbuf *p)</span></span><br></pre></td></tr></table></figure>

<h4 id="网口从lwip接收数据"><a href="#网口从lwip接收数据" class="headerlink" title="网口从lwip接收数据"></a>网口从lwip接收数据</h4><p>lwip协议栈的数据会传递到netif结构体，而我们在创建netif结构体时，设置了drv_send()等函数，lwip协议栈就会调用该函数，在这个函数中我们就需要实现netif和netdev，pbuf和netbuf的转换，调用NetDeviceInterFace 里的函数发送数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LwipSend</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> pbuf *lwipBuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImpl</span> *<span class="title">ndImpl</span> =</span> (<span class="keyword">struct</span> NetDeviceImpl *)netif-&gt;state;</span><br><span class="line">    <span class="comment">//get netdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netDev</span> =</span> ndImpl-&gt;netDevice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceInterFace</span> *<span class="title">netDevIf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//get netbuf</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetBuf</span> *<span class="title">netBuff</span> =</span> ConverPbuffToNetBuf(netDev, lwipBuf);</span><br><span class="line">	<span class="comment">//get NetDeviceInterFace </span></span><br><span class="line">    netDevIf = netDev-&gt;netDeviceIf;</span><br><span class="line">    <span class="comment">//send netbuf</span></span><br><span class="line">    netDevIf-&gt;xmit(netDev, netBuff);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/NetDev/" data-id="cmbcy7rhm002gt8mt4gdhh7nf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/start_kernel" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/start_kernel/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.814Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/start_kernel/" data-id="cmbcy7rh7001ct8mtfbvt4jbf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/linux_boot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/linux_boot/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.803Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux启动流程"><a href="#Linux启动流程" class="headerlink" title="Linux启动流程"></a>Linux启动流程</h1><p>因为linux内核真正执行之前，需要被解压出来，所以uboot跳转之后其实是先跑解压程序把内核解压到内存。<br>分析vmlinux.lds.S,可以知道linux内核的入口地址</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/linux_boot/" data-id="cmbcy7rh50016t8mtc1ti0hv5" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Linux/VFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/VFS/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.802Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>poll 系统调用如何实现，需要学习：</p>
<ul>
<li>open&#x2F;close</li>
<li>poll</li>
<li>线程调度的实现</li>
<li>时间的计算</li>
</ul>
<h2 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><p>open 会返回fd，该fd 是file 对象在数组中的下标。file 对象是文件系统和进程交互的中介，每一个进程打开一个文件都会产生一个file对象。一个进程可以打开多个文件，所以进程描述符中有一个指针数组存放所有file对象的地址，该指针数组有一个初始的长度（1024），但该数组的长度可以动态增加。</p>
<p>open 返回的fd 就是进程中该指针数组的下标，通过fd + 进程 就可以找到该进程打开的file 对象。</p>
<p>open 函数会去找指定文件，得到该文件的inode节点，将inode-&gt;ops 赋值给 file-&gt;f_ops。假如是字符设备驱动文件，注册驱动程序的时候，将inode-&gt;ops替换成驱动程序写的f_ops</p>
<p>close 原理应该和open 差不多啦</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/VFS/" data-id="cmbcy7rh50017t8mt7viw72pj" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
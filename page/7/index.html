<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/IMX6/pinctrl" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/IMX6/pinctrl/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.640Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="pinctrl子系统"><a href="#pinctrl子系统" class="headerlink" title="pinctrl子系统"></a>pinctrl子系统</h2><p>pinctrl子系统是用于控制io引脚的复用和电气属性的，代码主要在设备树中体现。</p>
<h3 id="硬件-IOMUXC"><a href="#硬件-IOMUXC" class="headerlink" title="硬件 IOMUXC"></a>硬件 IOMUXC</h3><p>在IMX6UL中，有一个IOMUXC控制器，这个控制器负责完成IO端口的复用和电气属性的设置。</p>
<p>如图所示，最右边是IO PAD，就是芯片的引脚。最左边的是PAD Setting Register 可以设置IO的电气属性，中间的是IOMUX可以设置IO的复用功能。</p>
<p><img src="/2025/05/30/hello-world/IMX6/pinctrl/1.png" alt="image-20220612130929250"></p>
<h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>iomuxc控制器节点如下 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iomuxc: iomuxc@<span class="number">020e0000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-iomuxc&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x020e0000</span> <span class="number">0x4000</span>&gt;;  <span class="comment">//寄存器地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子节点</p>
<p>iomucx节点下的每一个子节点，称为functions，例如imx6ul-evk就是一个function，function的每一个子节点是一个外设使用所有pin脚，这些pin脚的集合称为group。要弄清楚这些概念，因为后面的初始化就是围绕设备树里的配置来展开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">	imx6ul-evk &#123;</span><br><span class="line">		pinctrl_hog_1: hoggrp<span class="number">-1</span> &#123;</span><br><span class="line">			fsl,pins = &lt;</span><br><span class="line">				MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	<span class="number">0x17059</span> <span class="comment">/* SD1 CD */</span></span><br><span class="line">				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	<span class="number">0x17059</span> <span class="comment">/* SD1 VSELECT */</span></span><br><span class="line">				<span class="comment">/* MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        0x17059 SD1 RESET */</span></span><br><span class="line">				MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID	<span class="number">0x13058</span>	<span class="comment">/* USB_OTG1_ID */</span></span><br><span class="line">			&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">/* zuozhongkai LED */</span></span><br><span class="line">        pinctrl_led: ledgrp &#123;</span><br><span class="line">            fsl,pins = &lt;</span><br><span class="line">            	MX6UL_PAD_GPIO1_IO03__GPIO1_IO03        <span class="number">0x10B0</span> <span class="comment">/* LED0 */</span></span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>group中的<code>fsl,pins</code> 代表什么意思？</p>
<blockquote>
<p> Each pin represented in fsl,pins consists of 5 u32 PIN_FUNC_ID and 1 u32 CONFIG, so 24 types in total for each pin.</p>
</blockquote>
<p>每一个fsl,pins 表示5个32bit的PIN_FUNC_ID 和1个CONFIG，PIN_FUNC_ID 定义在imx6ul-pinfunc.h 中，具体是什么意思，以MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 为例看看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MX6UL_PAD_GPIO1_IO03__GPIO1_IO03                          0x0068 0x02F4 0x0000 0x5 0x0</span></span><br><span class="line">			<span class="comment">//展开MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 </span></span><br><span class="line">            fsl,pins = &lt;</span><br><span class="line">            	<span class="number">0x0068</span> <span class="number">0x02F4</span> <span class="number">0x0000</span> <span class="number">0x5</span> <span class="number">0x0</span>        <span class="number">0x10B0</span> <span class="comment">/* LED0 */</span></span><br><span class="line">            &gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>0x0068 表示复用寄存器的偏移，该寄存器设置pin脚的复用功能</li>
<li>0x5 表示 复用寄存器的值，这里是MUX_MODE &#x3D; 5，表示复用为gpio引脚</li>
<li>0x02F4 表示配置寄存器的偏移，这个寄存器设置pin脚的电气属性</li>
<li>0x10B0 表示该寄存器的值，二进制1 0000 1011 0000 ，内容是：低转换率，驱动强度r0&#x2F;6，100mhz速率，使能电荷保持器，关闭开漏输出，100k下拉电阻</li>
</ul>
<h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>一般来说，引脚的复用功能和电气属性在系统的运行过程中是不会改变的，所以在linux启动的过程中，所有io的初始化都是自动完成，且不会再改变。这一点应该是在pinctrl子系统完成的。</p>
<p>在drivers中搜索 <code>fsl,imx6ul-iomuxc</code>，找到位于pinctrl-imx6ul.c的驱动程序，可以发现这个是典型的platform_drivers，这个驱动支持<code>&quot;fsl,imx6ull-iomuxc-snvs&quot;</code>和<code>fsl,imx6ul-iomuxc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6ul_pinctrl_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_pinctrl_soc_info</span> *<span class="title">pinctrl_info</span>;</span></span><br><span class="line">	</span><br><span class="line">	match = of_match_device(imx6ul_pinctrl_of_match, &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!match)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	<span class="comment">//拿到指定芯片的引脚信息</span></span><br><span class="line">	pinctrl_info = (<span class="keyword">struct</span> imx_pinctrl_soc_info *) match-&gt;data;</span><br><span class="line">	<span class="comment">//初始所有的引脚</span></span><br><span class="line">	<span class="keyword">return</span> imx_pinctrl_probe(pdev, pinctrl_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx6ul_pinctrl_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;imx6ul-pinctrl&quot;</span>,</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.of_match_table = of_match_ptr(imx6ul_pinctrl_of_match),</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = imx6ul_pinctrl_probe,</span><br><span class="line">	.remove = imx_pinctrl_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个程序本质上是调用 imx_pinctrl_probe(pdev, pinctrl_info); 来完成具体的初始化，该函数位于 pinctrl-imx.c.</p>
<p>在这里，需要注意imx_pinctrl_soc_info ，这个对象其实就是保存group节点中的所有pin的寄存器信息，这个对象是imx的芯片需要的，并非是linux系统的。linux要求驱动需要实现pinctrl_desc 对象，并将其添加到pinctrl子系统。</p>
<p>在 imx_pinctrl_probe(pdev, pinctrl_info)中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">imx_pinctrl_desc</span>;</span> </span><br><span class="line">   <span class="comment">//初始化imx_pinctrl_desc</span></span><br><span class="line">imx_pinctrl_desc-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line">imx_pinctrl_desc-&gt;pins = info-&gt;pins;</span><br><span class="line">imx_pinctrl_desc-&gt;npins = info-&gt;npins;</span><br><span class="line">imx_pinctrl_desc-&gt;pctlops = &amp;imx_pctrl_ops;</span><br><span class="line">imx_pinctrl_desc-&gt;pmxops = &amp;imx_pmx_ops;</span><br><span class="line">imx_pinctrl_desc-&gt;confops = &amp;imx_pinconf_ops;</span><br><span class="line">imx_pinctrl_desc-&gt;owner = THIS_MODULE;</span><br><span class="line"><span class="comment">//初始化iomucx节点下的字节点，完成imx_pinctrl_soc_info 对象的填充</span></span><br><span class="line">ret = imx_pinctrl_probe_dt(pdev, info);</span><br><span class="line"></span><br><span class="line">ipctl-&gt;info = info;</span><br><span class="line">ipctl-&gt;dev = info-&gt;dev;</span><br><span class="line">platform_set_drvdata(pdev, ipctl);</span><br><span class="line"><span class="comment">//注册imx_pinctrl_desc 到pinctrl子系统，同时会设置iomuxc的寄存器</span></span><br><span class="line">ipctl-&gt;pctl = pinctrl_register(imx_pinctrl_desc, &amp;pdev-&gt;dev, ipctl);</span><br></pre></td></tr></table></figure>

<h4 id="pinctrl-desc"><a href="#pinctrl-desc" class="headerlink" title="pinctrl_desc"></a>pinctrl_desc</h4><p>pinctrl驱动开发的重点就是实现pinctrl_desc对象，其中需要关注的是pmxops和confops，这两个分别实现设置io的复用和电气属性配置。</p>
<p>其本质就是使用imx_pinctrl_soc_info 的信息，读写iomuxc的寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;  <span class="comment">//iomuxc名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> <span class="title">const</span> *<span class="title">pins</span>;</span>  <span class="comment">//芯片的引脚描述符数组</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> npins;  <span class="comment">//引脚数量</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>  <span class="comment">//用于分组（可选）</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>  <span class="comment">//引脚复用的函数集</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>  <span class="comment">//引脚配置的函数集</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> <span class="title">imx_pmx_ops</span> =</span> &#123;</span><br><span class="line">	.set_mux = imx_pmx_set,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_pmx_set</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> selector,</span></span><br><span class="line"><span class="params">		       <span class="type">unsigned</span> group)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	writel(pin-&gt;mux_mode, ipctl-&gt;base + pin_reg-&gt;mux_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="imx-pinctrl-probe-dt"><a href="#imx-pinctrl-probe-dt" class="headerlink" title="imx_pinctrl_probe_dt"></a>imx_pinctrl_probe_dt</h4><p>imx_pinctrl_probe_dt 就是根据设备树完成imx_pinctrl_soc_info内所有成员的实现，具体的实际工作就是解析每一个外设节点的pin配置信息，这个在 <code>imx_pinctrl_parse_groups()</code>中实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_pinctrl_soc_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>  </span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span> <span class="comment">//soc上的所有pin脚编号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> npins;  <span class="comment">//pin脚的数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_pin_reg</span> *<span class="title">pin_regs</span>;</span>  <span class="comment">//复用寄存器和配置寄存器的偏移地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_pin_group</span> *<span class="title">groups</span>;</span>  <span class="comment">//该soc上的所有group</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ngroups;  <span class="comment">//group的数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_pmx_func</span> *<span class="title">functions</span>;</span>  <span class="comment">//一个soc可以有多个function，例如imx6ul-evk</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nfunctions;  <span class="comment">//function的数量，这里是1</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	u32 grp_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述一组pin脚的配置和复用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_pin_group</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">unsigned</span> npins;  <span class="comment">//该组pin的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *pin_ids;  <span class="comment">//该组pin的所有引脚序号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_pin</span> *<span class="title">pins</span>;</span>  <span class="comment">//该组包含的pin数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述一个pin</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_pin</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pin;  <span class="comment">//引脚序号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mux_mode;  <span class="comment">//复用模式</span></span><br><span class="line">	u16 input_reg;  <span class="comment">//输入寄存器偏移</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> input_val;  <span class="comment">//输入寄存器的值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> config;  <span class="comment">//引脚的电气配置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我不知道要怎么描述，反正就是代表imx6ul-evk节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_pmx_func</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;  <span class="comment">//名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> **groups;  <span class="comment">//所有的组</span></span><br><span class="line">	<span class="type">unsigned</span> num_groups;  <span class="comment">//组的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析一组pin</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_pinctrl_parse_groups</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> imx_pin_group *grp,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> imx_pinctrl_soc_info *info,</span></span><br><span class="line"><span class="params">				    u32 index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size, pin_size;</span><br><span class="line">	<span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	u32 config;</span><br><span class="line"></span><br><span class="line">	dev_dbg(info-&gt;dev, <span class="string">&quot;group(%d): %s\n&quot;</span>, index, np-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定pin_size，一般是 5*32bits=20个字节</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;flags &amp; SHARE_MUX_CONF_REG)</span><br><span class="line">		pin_size = SHARE_FSL_PIN_SIZE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pin_size = FSL_PIN_SIZE;</span><br><span class="line">	<span class="comment">/* Initialise group */</span></span><br><span class="line">	grp-&gt;name = np-&gt;name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the binding format is fsl,pins = &lt;PIN_FUNC_ID CONFIG ...&gt;,</span></span><br><span class="line"><span class="comment">	 * do sanity check and calculate pins number</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//list是一个u32的数组，是pin脚的配置信息</span></span><br><span class="line">	<span class="built_in">list</span> = of_get_property(np, <span class="string">&quot;fsl,pins&quot;</span>, &amp;size);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">list</span>) &#123;</span><br><span class="line">		dev_err(info-&gt;dev, <span class="string">&quot;no fsl,pins property in node %s\n&quot;</span>, np-&gt;full_name);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we do not check return since it&#x27;s safe node passed down */</span></span><br><span class="line">	<span class="keyword">if</span> (!size || size % pin_size) &#123;</span><br><span class="line">		dev_err(info-&gt;dev, <span class="string">&quot;Invalid fsl,pins property in node %s\n&quot;</span>, np-&gt;full_name);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算pin数量</span></span><br><span class="line">	grp-&gt;npins = size / pin_size;</span><br><span class="line">	<span class="comment">//初始化pins</span></span><br><span class="line">	grp-&gt;pins = devm_kzalloc(info-&gt;dev, grp-&gt;npins * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx_pin),</span><br><span class="line">				GFP_KERNEL);</span><br><span class="line">	grp-&gt;pin_ids = devm_kzalloc(info-&gt;dev, grp-&gt;npins * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>),</span><br><span class="line">				GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!grp-&gt;pins || ! grp-&gt;pin_ids)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; grp-&gt;npins; i++) &#123;</span><br><span class="line">		<span class="comment">//第一个u32是复用寄存器</span></span><br><span class="line">		u32 mux_reg = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">		u32 conf_reg;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> pin_id;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">imx_pin_reg</span> *<span class="title">pin_reg</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">imx_pin</span> *<span class="title">pin</span> =</span> &amp;grp-&gt;pins[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(info-&gt;flags &amp; ZERO_OFFSET_VALID) &amp;&amp; !mux_reg)</span><br><span class="line">			mux_reg = <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">//是否复用和配置是同一个寄存器</span></span><br><span class="line">		<span class="keyword">if</span> (info-&gt;flags &amp; SHARE_MUX_CONF_REG) &#123;</span><br><span class="line">			conf_reg = mux_reg;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//获取第二个u32，是配置寄存器</span></span><br><span class="line">			conf_reg = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">			<span class="keyword">if</span> (!(info-&gt;flags &amp; ZERO_OFFSET_VALID) &amp;&amp; !conf_reg)</span><br><span class="line">				conf_reg = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//计算引脚编号</span></span><br><span class="line">		pin_id = (mux_reg != <span class="number">-1</span>) ? mux_reg / <span class="number">4</span> : conf_reg / <span class="number">4</span>;</span><br><span class="line">		pin_reg = &amp;info-&gt;pin_regs[pin_id];</span><br><span class="line">		pin-&gt;pin = pin_id;</span><br><span class="line">		grp-&gt;pin_ids[i] = pin_id;</span><br><span class="line">		<span class="comment">//保存寄存器偏移</span></span><br><span class="line">		pin_reg-&gt;mux_reg = mux_reg;</span><br><span class="line">		pin_reg-&gt;conf_reg = conf_reg;</span><br><span class="line">		pin-&gt;input_reg = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">		<span class="comment">//保存复用模式</span></span><br><span class="line">		pin-&gt;mux_mode = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">		pin-&gt;input_val = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* SION bit is in mux register */</span></span><br><span class="line">		<span class="comment">//保存配置信息</span></span><br><span class="line">		config = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">		<span class="keyword">if</span> (config &amp; IMX_PAD_SION)</span><br><span class="line">			pin-&gt;mux_mode |= IOMUXC_CONFIG_SION;</span><br><span class="line">		pin-&gt;config = config &amp; ~IMX_PAD_SION;</span><br><span class="line"></span><br><span class="line">		dev_dbg(info-&gt;dev, <span class="string">&quot;%s: 0x%x 0x%08lx&quot;</span>, info-&gt;pins[pin_id].name,</span><br><span class="line">				pin-&gt;mux_mode, pin-&gt;config);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pinctrl-register"><a href="#pinctrl-register" class="headerlink" title="pinctrl_register"></a>pinctrl_register</h4><p>pinctrl_register 会将 pinctrl_desc 注册到pinctrl子系统，并调用pinctrl_desc 中的函数成员，完成对iomuxc寄存器的读写，从而设置好所有外设的pin复用和电气属性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/IMX6/pinctrl/" data-id="cmbcy7rhd001xt8mtcpbfh2xq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Git/git_help" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Git/git_help/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.639Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><blockquote>
<p>git，分布式版本控制系统，可以用来帮助程序员管理代码等，包括代码的保存，恢复，传输到远程服务器等。有了git的帮助，再也不用担心改了一行代码导致系统崩溃无法恢复的情况了。关于git的具体介绍和教程非常多，这里我推荐<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tutorial.html">git-菜鸟教程</a>，想要深入学习的同学可以围观一下。</p>
</blockquote>
<h4 id="1，适用人群"><a href="#1，适用人群" class="headerlink" title="1，适用人群"></a>1，适用人群</h4><p>针对一部分从来没使用过git的同学，我写了一个脚本来方便同学们快速上手git，只要你安装了git并完成用户登录，三分钟就能帮你熟悉了解git的基本功能。适合小白边学习边实践，快速掌握git的基本用法。</p>
<h4 id="2，功能介绍"><a href="#2，功能介绍" class="headerlink" title="2，功能介绍"></a>2，功能介绍</h4><p>功能持续完善中，欢迎朋友们提出问题。<br>目前功能：</p>
<ul>
<li>git初始化</li>
<li>提交</li>
<li>推送</li>
<li>仓库管理（关联&#x2F;取关联，查看仓库）</li>
<li>版本管理（查看版本信息，版本恢复）</li>
<li>readme编辑<br>接下来可能添加更多的基本功能，希望多多关注，点赞支持</li>
</ul>
<h2 id="二，使用方法"><a href="#二，使用方法" class="headerlink" title="二，使用方法"></a>二，使用方法</h2><h3 id="1，下载githelp-bat"><a href="#1，下载githelp-bat" class="headerlink" title="1，下载githelp.bat"></a>1，下载githelp.bat</h3><p><strong>项目码云地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/githelp">https://gitee.com/killerp/githelp</a><br>github地址：<a target="_blank" rel="noopener" href="https://github.com/killer-p/githelp">https://github.com/killer-p/githelp</a></strong><br>推荐使用码云下载，可以用git clone下载或者下载压缩包，解压。<br>如果用git clone下载速度太慢的话，可以参考我的另一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/107574297">github下载速度慢解决方法</a></p>
<h3 id="2，配置环境变量"><a href="#2，配置环境变量" class="headerlink" title="2，配置环境变量"></a>2，配置环境变量</h3><p>使用前需要将githelp.bat添加到系统path路径中。<br>如下图最底下，我的安装目录是<code>D:\\git\githelp</code><br><img src="/2025/05/30/hello-world/Git/git_help/14.png" alt="在这里插入图片描述"></p>
<h3 id="三，使用"><a href="#三，使用" class="headerlink" title="三，使用"></a>三，使用</h3><p>假设你需要初始化一个仓库，在新建的文件夹下，启动cmd，输入<code>githelp.bat</code>，cmd显示如下：<br><img src="/2025/05/30/hello-world/Git/git_help/15.png" alt="在这里插入图片描述"><br>输入3回车，进入初始化菜单，输入1回车完成git仓库的初始化（2目前未实现）。<br>然后你就可以开始敲代码了，敲完可以选择提交，养成习惯。<br><img src="/2025/05/30/hello-world/Git/git_help/16.png" alt="在这里插入图片描述"><br>当你需要上传项目到远程仓库时，先编写readme文档，完成后先提交。进入仓库与版本控制菜单，输入4回车关联远程仓库，<strong>你需要先在GitHub或者其他代码托管网站先创建仓库并保存ssh连接地址 如：<code>git@gitee.com:killerp/githelp.git</code></strong>。然后输入远程仓库的名称和ssh。<br>远程仓库名称随意取，只要自己方便记住就行，关联成功后就可以直接推送了。<br><img src="/2025/05/30/hello-world/Git/git_help/17.png" alt="在这里插入图片描述"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>这个脚本主要是方便小白快速上手，一边学习git，一边使用，效果更好。一般用户使用也比较方便，不用去记住那些git的命令，虽然也不是很多很难记，但就是想偷懒。如果本博客对你有帮助点个赞再走呗</strong><br><img src="/2025/05/30/hello-world/Git/git_help/18.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Git/git_help/" data-id="cmbcy7rh2000wt8mt2b9q5d3l" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Git/speed_github_in_cn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Git/speed_github_in_cn/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.639Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>github上下载仓库或者克隆仓库，速度基本稳定在20k以下，这老哥是真的稳。当克隆一些大的仓库时，以这乌龟速度，很容易出现克隆超时的错误，等了几十分钟的下载一夜回到解放前，那种感觉我猜各位或多或少都经历过。本博客会整理几种亲测可用的方案，下载速度很大地提升，一个大的仓库一分钟左右就可以搞定，也会持续的更新一些可用新方法，希望对你有帮助</strong><br><strong>以下方案均来自网络的分享，我只是做整理推荐。感谢那些无私的程序员们</strong></p>
<blockquote>
<p>更新日志</p>
<blockquote>
<p>2020.9.5 增加了谷歌插件方法，github加速下载链接,使用github镜像下载三种方式。</p>
</blockquote>
</blockquote>
<h3 id="一，谷歌浏览器插件加速"><a href="#一，谷歌浏览器插件加速" class="headerlink" title="一，谷歌浏览器插件加速"></a>一，谷歌浏览器插件加速</h3><p>功能最强大，完善的一种方式，需要使用谷歌浏览器，开启浏览器的插件功能，插件下载地址：<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qGiIUzqNlN1ZczTNFbPg0A">https://pan.baidu.com/s/1qGiIUzqNlN1ZczTNFbPg0A</a> <strong>提取码 stsv</strong><br>备用地址：<a target="_blank" rel="noopener" href="https://wws.lanzous.com/ia7V3gdmv8f">https://wws.lanzous.com/ia7V3gdmv8f</a><br>下载完成后添加到谷歌浏览器的插件中，再打开github，你会发现整个访问速度提升了不止一个档次，插件对github网站添加了加速和镜像功能：亲测加速通道的下载速度可达最少1M，但是镜像方面无法访问，会被浏览器拦截，但这无关紧要，推荐！（这是要我用回谷歌吗？）<br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/1.png" alt="在这里插入图片描述">使用加速通道下载测试：</p>
<p><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/2.png" alt="在这里插入图片描述"><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/3.png" alt="在这里插入图片描述"></p>
<h3 id="二，gitclone-com"><a href="#二，gitclone-com" class="headerlink" title="二，gitclone.com"></a>二，gitclone.com</h3><p>这是我用过最爽最实用功能最全面的一个方式了。gitclone.com是一个提供下载缓存的代码下载网站，使用方法十分简单，只需要<strong>在仓库地址前面加上 gitclone.com</strong>，就可以使速度提升几倍。</p>
<p><strong>例如要克隆github上仓库地址<code>https://github.com/killer-p/ctool.git</code><br>只需将地址改为<code>https://gitclone.com/github.com/killer-p/ctool.git</code>，在命令行中执行<code>git clone https://gitclone.com/github.com/killer-p/ctool.git</code>，速度直接起飞！芜湖！</strong><br>官网首页：<a target="_blank" rel="noopener" href="https://gitclone.com/">https://gitclone.com/</a></p>
<blockquote>
<p>gitclone的工作机理是：当开发者第一次经gitclone.com代理clone项目时，gitclone.com异步镜像项目，以后有开发者clone该项目时，就会利用上gitclone.com的本地镜像，而不是从github.com上clone。gitclone.com会在每天夜间与github.com同步。为了解决不断增长的镜像对硬盘资源的需求，gitclone.com采用区块链集群方式扩展，每次的镜像操作都会广播到集群中所有服务器，各服务器可选择生成镜像并登记以便以响应后续的clone请求。同时，gitclone.com还对stackoverflow.com和go get等的加速访问进行了说明，做到“为开发者服务”。</p>
</blockquote>
<p><strong>这是我使用的最方便的一种方法，墙裂推荐，gitclone.com还提供了其他的加速方法，<a target="_blank" rel="noopener" href="https://www.gitclone.com/docs/howto/howto_github">查看其他方法</a></strong><br>速度非常快。<br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/4.png" alt="在这里插入图片描述"></p>
<h3 id="三，码云下载"><a href="#三，码云下载" class="headerlink" title="三，码云下载"></a>三，码云下载</h3><p>这也算是大家很熟悉的了，给小白科普一下。码云是国内的代码管理网站，所以在国内的下载速度非常快，码云支持从github其他代码代管网站导入码云仓库。<br><strong>使用方法：</strong><br><strong>复制github上仓库地址，例如：<br><code>https://github.com/769484623/MahonyAHRSWithMPU6050_HMC5983.git</code><br>然后注册码云账号，在码云中创建新仓库，直接在底下选择<code>导入已有仓库</code></strong><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/5.png" alt="在这里插入图片描述"><strong>在方框内粘贴github的仓库地址，系统会自动检测链接是哪个代码代管网站的。点击创建。</strong><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/6.png" alt="在这里插入图片描述"><br><strong>等个几十秒，码云把github上的项目拉下来，放在了码云的服务器上，这时候我们就可以从码云下载仓库了，而且由于码云服务器在中国，下载速度很快，具体操作：</strong><br><strong>复制https或者直接下载zip</strong><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/7.png" alt="在这里插入图片描述"></p>
<h3 id="四，githubd"><a href="#四，githubd" class="headerlink" title="四，githubd"></a>四，githubd</h3><p>githud是一个代码代下载网站，只需要输入github仓库地址，网站就会下载GitHub仓库的压缩包，用户可以直接在网站下载。请收下地址：<a target="_blank" rel="noopener" href="https://githubd.com/#/">https://githubd.com/#/</a>，速度比直接在github上下载zip提升十倍！<code>注意！下载的zip是不包括子模块仓库的！注意检查!带子模块仓库的建议看第一点</code><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/8.png" alt="在这里插入图片描述">另一个代码下载网站是：<a target="_blank" rel="noopener" href="https://d.serctl.com/?dl_start">https://d.serctl.com/?dl_start</a>，它也支持下载github仓库的压缩包，具体使用方法看上面的网址。</p>
<h3 id="五，github文件下载加速"><a href="#五，github文件下载加速" class="headerlink" title="五，github文件下载加速"></a>五，github文件下载加速</h3><p>这个网站主要是用来下载github上一些正式版(release)的zip or war 等文件资源的，不支持下载仓库。<br>话不多说，直接上地址：<a target="_blank" rel="noopener" href="https://shrill-pond-3e81.hunsh.workers.dev/">https://shrill-pond-3e81.hunsh.workers.dev/</a><br>只需要输入github上的资源地址，最好是压缩包格式，其他格式的文件可能不支持。</p>
<h3 id="六，github加速下载链接"><a href="#六，github加速下载链接" class="headerlink" title="六，github加速下载链接"></a>六，github加速下载链接</h3><p>网站地址：<a target="_blank" rel="noopener" href="https://github.zhlh6.cn/">https://github.zhlh6.cn/</a></p>
<p>复制github仓库的地址，然后粘贴到第一栏，点击加速！生成加速地址，使用加速地址进行git clone 下载，下载速度最高能提升到1M（我的测试），平均也有600多k，实测效果见下图：<br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/9.png" alt="在这里插入图片描述"><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/10.png" alt="在这里插入图片描述"></p>
<h3 id="七，github镜像访问"><a href="#七，github镜像访问" class="headerlink" title="七，github镜像访问"></a>七，github镜像访问</h3><p>github镜像就是一个跟github一毛一样的网站，他会同步github上的资源，国内访问github镜像的速度较快，也可以在镜像下载仓库，平时逛逛gayhub也可以用这个镜像，反正比较快，缺点就是不能登录，镜像地址：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/">https://hub.fastgit.org/</a><br><code>注意这个网站不能登录github账户，点击sign in会被浏览器拦截</code></p>
<p>效果如下：可以看出下载地址的域名不是github.com,下载速度也达到700多k。</p>
<p><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/11.png" alt="在这里插入图片描述"><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/12.png" alt="在这里插入图片描述"></p>
<h3 id="注意，-带子模块的大型仓库"><a href="#注意，-带子模块的大型仓库" class="headerlink" title="注意， 带子模块的大型仓库"></a>注意， 带子模块的大型仓库</h3><p>以上的方法已经可以解决大部分仓库的下载问题，但是有一些大型仓库是带有子模块，由于在仓库根目录中的<code>.gitmodules</code>文件夹定义了子模块的地址仍然是github仓库的地址，所以用gitclone.com或者码云下载的仓库在下载子模块时会 直接越过gitclone.com和码云而从github上下载，这就又使得下载速度回到石器时代。<br><strong>一种解决办法是先下载主仓库，修改仓库中的<code>.gitmodules</code>文件夹中的仓库地址，加上gitclone.com，保存退出后，cmd执行</strong></p>
<blockquote>
<p>git submodule update –init </p>
</blockquote>
<p><strong>更新子模块或者直接在相应的文件夹下通过gitclone.com自行下载相应的模块，最后一定要记得执行 <code>git submodule update --init</code> 更新子模块。如果子模块中还有子模块，按上述方法重复进行就可以了。</strong></p>
<h3 id="参考资料，感谢以下文章"><a href="#参考资料，感谢以下文章" class="headerlink" title="参考资料，感谢以下文章"></a>参考资料，感谢以下文章</h3><p><a target="_blank" rel="noopener" href="https://code.pingbook.top/blog/2020/How-To-Speed-Github.html#_2-github%E6%96%87%E4%BB%B6%E5%8A%A0%E9%80%9F">10种访问github方法</a><br><a target="_blank" rel="noopener" href="https://github.com/Sicmatr1x/Free-Resource/blob/master/Development.md">github下载解决方案</a><br><strong>觉得博客对你有帮助的话，点个赞收藏支持一下呗，持续更新！</strong><br><img src="/2025/05/30/hello-world/Git/speed_github_in_cn/13.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Git/speed_github_in_cn/" data-id="cmbcy7rh3000yt8mthynoe8jm" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/FreeRTOS/1.task_0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/1.task_0/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.638Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="任务管理（一）"><a href="#任务管理（一）" class="headerlink" title="任务管理（一）"></a>任务管理（一）</h2><p>freertos学习 仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/free-rtos_-study">https://gitee.com/killerp/free-rtos_-study</a></p>
<p>freertos是一个实时操作系统，其相比裸机最大的特点就是支持多任务。学习rtos，核心就是学习任务相关知识及其实现。</p>
<p>多任务是指多个任务轮流使用CPU，每个任务是一个死循环的函数，“调度器”会合理安排这些任务去得到CPU的使用。因此任务就有了状态的区分，正在使用CPU的任务处于运行态，等待CPU的任务处于就绪态，而等待某一资源的任务处于阻塞态。最后还有处于挂起态的任务，他不会被调度器管理。</p>
<h3 id="一、双向链表"><a href="#一、双向链表" class="headerlink" title="一、双向链表"></a>一、双向链表</h3><p>在操作系统中有多个处于不同状态的任务，就需要将他们有效的组织起来，使系统更加高效。freertos中使用双向链表来管理这些任务的状态。其代码位于list.c</p>
<p>链表的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义链表、被调度器使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxNumberOfItems;       <span class="comment">//链表的节点数量</span></span><br><span class="line">    ListItem_t * configLIST_VOLATILE pxIndex;   <span class="comment">//用于遍历链表</span></span><br><span class="line">    MiniListItem_t xListEnd;                    <span class="comment">//链表的最后一个节点              </span></span><br><span class="line">&#125; List_t;</span><br></pre></td></tr></table></figure>

<p>链表节点的定义：</p>
<p>链表是为了方便管理任务，那么一个节点必然对应一个任务。另外还需要节点值来帮助链表进行排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    configLIST_VOLATILE TickType_t xItemValue;          <span class="comment">//节点的值、决定节点在链表中的位置        </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>         </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>    </span><br><span class="line">    <span class="type">void</span> * pvOwner;                                     <span class="comment">//节点的拥有者、一般是任务控制块        </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxContainer</span>;</span>     <span class="comment">//节点所在的链表           </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span>   </span><br></pre></td></tr></table></figure>

<p>同时定义了一个处于链表末尾的最小节点，他不代表任何任务，只用于辅助在链表中的查找。</p>
<p><strong>freertos的链表非常简单，提供了插入、删除、查询等最基本的操作。</strong></p>
<h3 id="二、任务控制块"><a href="#二、任务控制块" class="headerlink" title="二、任务控制块"></a>二、任务控制块</h3><p>任务是程序员抽象出来的概念，在代码中是通过任务控制块TCB来实现。任务控制块帮助调度器管理任务，任务控制块含有一个任务的所有信息。</p>
<p>如下是一个精简版的任务控制块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务控制块</span></span><br><span class="line"><span class="comment"> * 任务控制块包含一个任务运行的所有信息。任务的堆栈地址、状态等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> StackType_t *pxTopOfStack;       <span class="comment">//指向任务栈顶 注意需要volatile修饰</span></span><br><span class="line"></span><br><span class="line">    ListItem_t xStateListItem;                <span class="comment">//任务状态节点、用于将任务挂在就绪、阻塞、挂起链表</span></span><br><span class="line">    ListItem_t xEventListItem;                <span class="comment">//将任务挂在时间链表</span></span><br><span class="line">    UBaseType_t uxPriority;                   <span class="comment">//任务优先级，0为最低</span></span><br><span class="line">    StackType_t *pxStack;                     <span class="comment">//指向任务栈基地址</span></span><br><span class="line">    <span class="type">char</span> pcTaskName[configMAX_TASK_NAME_LEN]; <span class="comment">//任务名称</span></span><br><span class="line"></span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>任务需要有一个任务栈，来保存任务的上下文环境，需要栈基和栈顶指针。</p>
</li>
<li><p>使用链表节点标记任务的状态、任务的等待的事件。通过节点将任务组织到对应的链表中。</p>
</li>
<li><p>freertos是支持抢占的实时操作系统，每个任务有优先级。</p>
</li>
</ul>
<h3 id="三、创建任务"><a href="#三、创建任务" class="headerlink" title="三、创建任务"></a>三、创建任务</h3><p>很疑惑，任务不就是一个函数吗？那么函数的入口应该保存在哪里？</p>
<p>任务函数的入口地址应该保存在栈中，当任务开始运行时，调度器会将函数入口地址从栈中复制到PC，随后CPU就跳转到任务函数执行。</p>
<p>所以接下来就是创建一个任务。（这里以动态内存创建为例，freertos的内存管理详见：）</p>
<p>创建一个任务，需要创建一个任务控制块TCB，以及一个任务栈来保存任务的运行环境。接着初始化任务控制块以及任务栈，任务就可以投入运行了，就将任务插入到就绪链表中，等待调度器调度运行。一共三步：申请内存、初始化、插入就绪表，分别由三个函数完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,</span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *<span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                       UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                       TaskHandle_t *<span class="type">const</span> pxCreatedTask)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *pxNewTCB;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈向上生长，则先分配tcb，后分配栈，防止栈覆盖了tcb（tcb地址小于栈基地址）</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (portSTACK_GROWTH &gt; 0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB = (TCB_t *)pvPortMalloc(<span class="keyword">sizeof</span>(TCB_t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pxNewTCB != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//申请一段内存作为栈、地址保存在tcb中，后续可释放</span></span><br><span class="line">            pxNewTCB-&gt;pxStack = (StackType_t *)pvPortMalloc((((<span class="type">size_t</span>)usStackDepth) * <span class="keyword">sizeof</span>(StackType_t)));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pxNewTCB-&gt;pxStack == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                vPortFree(pxNewTCB);</span><br><span class="line">                pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若栈向下生长，则先分配栈，后分配tcb，防止栈覆盖了tcb（tcb地址大于栈基地址）</span></span><br><span class="line">        StackType_t *pxStack;</span><br><span class="line"></span><br><span class="line">        pxStack = pvPortMalloc((((<span class="type">size_t</span>)usStackDepth) * <span class="keyword">sizeof</span>(StackType_t)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pxStack != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            pxNewTCB = (TCB_t *)pvPortMalloc(<span class="keyword">sizeof</span>(TCB_t));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pxNewTCB != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                vPortFree(pxStack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pxNewTCB != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//初始化新任务</span></span><br><span class="line">        prvInitialiseNewTask(pxTaskCode, pcName, (<span class="type">uint32_t</span>)usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//插入就绪表</span></span><br><span class="line">        prvAddNewTaskToReadyList(pxNewTCB);</span><br><span class="line">        xReturn = pdPASS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseNewTask</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> *<span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                                 TaskHandle_t *<span class="type">const</span> pxCreatedTask,</span></span><br><span class="line"><span class="params">                                 TCB_t *pxNewTCB,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> MemoryRegion_t *<span class="type">const</span> xRegions)</span></span><br><span class="line">&#123;</span><br><span class="line">    StackType_t *pxTopOfStack;</span><br><span class="line">    UBaseType_t x;</span><br><span class="line">	<span class="comment">//设置堆栈地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化堆栈为默认值、帮助debug</span></span><br><span class="line">        (<span class="type">void</span>)<span class="built_in">memset</span>(pxNewTCB-&gt;pxStack, (<span class="type">int</span>)tskSTACK_FILL_BYTE, (<span class="type">size_t</span>)ulStackDepth * <span class="keyword">sizeof</span>(StackType_t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (portSTACK_GROWTH &lt; 0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//栈向下生长、故初始化后的栈顶在高地址</span></span><br><span class="line">        pxTopOfStack = &amp;(pxNewTCB-&gt;pxStack[ulStackDepth - (<span class="type">uint32_t</span>)<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//TODO 堆栈的边沿对齐计算方式  pxTopOfStack &amp; 0xfff8 地址是8的倍数</span></span><br><span class="line">        pxTopOfStack = (StackType_t *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &amp; (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测边沿对齐是否正确</span></span><br><span class="line">        configASSERT((((portPOINTER_SIZE_TYPE)pxTopOfStack &amp; (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == <span class="number">0UL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//堆栈向上生长、初始化栈顶指针在低地址 也就是数组起始地址</span></span><br><span class="line">        pxTopOfStack = pxNewTCB-&gt;pxStack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 为何在这里没有内存对齐？可能是内存在分配时就考虑到？</span></span><br><span class="line">        configASSERT((((portPOINTER_SIZE_TYPE)pxNewTCB-&gt;pxStack &amp; (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == <span class="number">0UL</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置堆栈最高有效地址</span></span><br><span class="line">        pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + (ulStackDepth - (<span class="type">uint32_t</span>)<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制任务名称到TCB</span></span><br><span class="line">    <span class="keyword">if</span> (pcName != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = (UBaseType_t)<span class="number">0</span>; x &lt; (UBaseType_t)configMAX_TASK_NAME_LEN; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;pcTaskName[x] = pcName[x];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pcName[x] == (<span class="type">char</span>)<span class="number">0x00</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确保字符串的正确结束</span></span><br><span class="line">        pxNewTCB-&gt;pcTaskName[configMAX_TASK_NAME_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB-&gt;pcTaskName[<span class="number">0</span>] = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置任务优先级</span></span><br><span class="line">    <span class="keyword">if</span> (uxPriority &gt;= (UBaseType_t)configMAX_PRIORITIES)</span><br><span class="line">    &#123;</span><br><span class="line">        uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)<span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pxNewTCB-&gt;uxPriority = uxPriority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置信号量优先级</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB-&gt;uxBasePriority = uxPriority;</span><br><span class="line">        pxNewTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化任务的节点</span></span><br><span class="line">    vListInitialiseItem(&amp;(pxNewTCB-&gt;xStateListItem));</span><br><span class="line">    vListInitialiseItem(&amp;(pxNewTCB-&gt;xEventListItem));</span><br><span class="line"></span><br><span class="line">    listSET_LIST_ITEM_OWNER(&amp;(pxNewTCB-&gt;xStateListItem), pxNewTCB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置事件节点的值，优先级越高、节点值越小，在链表中排序越靠前</span></span><br><span class="line">    listSET_LIST_ITEM_VALUE(&amp;(pxNewTCB-&gt;xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriority);</span><br><span class="line">    listSET_LIST_ITEM_OWNER(&amp;(pxNewTCB-&gt;xEventListItem), pxNewTCB);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB-&gt;uxCriticalNesting = (UBaseType_t)<span class="number">0U</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (configUSE_TASK_NOTIFICATIONS == 1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span> *)&amp;(pxNewTCB-&gt;ulNotifiedValue[<span class="number">0</span>]), <span class="number">0x00</span>, <span class="keyword">sizeof</span>(pxNewTCB-&gt;ulNotifiedValue));</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span> *)&amp;(pxNewTCB-&gt;ucNotifyState[<span class="number">0</span>]), <span class="number">0x00</span>, <span class="keyword">sizeof</span>(pxNewTCB-&gt;ucNotifyState));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化任务的堆栈使其看起来任务好像已经在运行了，这里需要根据硬件实现</span></span><br><span class="line">    pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pxCreatedTask != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回任务的句柄</span></span><br><span class="line">        *pxCreatedTask = (TaskHandle_t)pxNewTCB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化任务栈 返回更新后的栈顶地址</span></span><br><span class="line"><span class="comment"> * 需要由硬件架构决定具体的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StackType_t * <span class="title function_">pxPortInitialiseStack</span><span class="params">( StackType_t * pxTopOfStack,</span></span><br><span class="line"><span class="params">                                     TaskFunction_t pxCode,</span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> * pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//模拟任务已经在运行时的栈的情况</span></span><br><span class="line">    pxTopOfStack--;                                                      <span class="comment">/* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */</span></span><br><span class="line">    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="comment">/* xPSR */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line">    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="comment">//存放任务函数入口地址，载入PC</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line">    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="comment">//LR寄存器</span></span><br><span class="line"></span><br><span class="line">    pxTopOfStack -= <span class="number">5</span>;                                                   <span class="comment">//R12, R3, R2 and R1</span></span><br><span class="line">    *pxTopOfStack = ( StackType_t ) pvParameters;                        <span class="comment">//传递函数参数 R0</span></span><br><span class="line">    pxTopOfStack -= <span class="number">8</span>;                                                   <span class="comment">// R11, R10, R9, R8, R7, R6, R5 and R4.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pxTopOfStack;                                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从Cortex-M3权威指南中，我们可以查到，任务栈中一般存放的内容：（按入栈先后顺序）</p>
<p><strong>xPSR ,PC,LR,R12,R3,R2,R1,R0,R11,R10,R9,R8,R7,R6,R5,R4</strong>，其中R11-R4需要通过代码入栈，其他寄存器由硬件自动操作。这一部分将在任务调度详解。</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/1.task_0/1.png" alt="在这里插入图片描述"></p>
<h3 id="四、删除任务"><a href="#四、删除任务" class="headerlink" title="四、删除任务"></a>四、删除任务</h3><p>有创建就有删除、而且删除基本就是创建的逆过程。当任务不需要再运行时、可删除任务，删除步骤：移出链表、释放内存、任务调度。（若当前正在运行的任务被删除，那么需要任务调度来选一个新任务运行）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *pxTCB;</span><br><span class="line">	<span class="comment">//进入临界区</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取即将删除的tcb</span></span><br><span class="line">        pxTCB = prvGetTCBFromHandle(xTaskToDelete);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将任务的状态节点移除链表 并重置就绪链表</span></span><br><span class="line">        <span class="keyword">if</span> (uxListRemove(&amp;(pxTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            taskRESET_READY_PRIORITY(pxTCB-&gt;uxPriority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若任务在等待某件事件、则移除该事件链表</span></span><br><span class="line">        <span class="keyword">if</span> (listLIST_ITEM_CONTAINER(&amp;(pxTCB-&gt;xEventListItem)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uxTaskNumber++; <span class="comment">//TODO 为何？</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pxTCB == pxCurrentTCB)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//任务删除自己、需要将任务插入任务终止链表、由空闲任务来释放内存</span></span><br><span class="line">            vListInsertEnd(&amp;xTasksWaitingTermination, &amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line"></span><br><span class="line">            ++uxDeletedTasksWaitingCleanUp;	<span class="comment">//标记有任务需要被释放内存</span></span><br><span class="line"></span><br><span class="line">            traceTASK_DELETE(pxTCB);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The pre-delete hook is primarily for the Windows simulator,</span></span><br><span class="line"><span class="comment">                 * in which Windows specific clean up operations are performed,</span></span><br><span class="line"><span class="comment">                 * after which it is not possible to yield away from this task -</span></span><br><span class="line"><span class="comment">                 * hence xYieldPending is used to latch that a context switch is</span></span><br><span class="line"><span class="comment">                 * required. */</span></span><br><span class="line"></span><br><span class="line">            portPRE_TASK_DELETE_HOOK(pxTCB, &amp;xYieldPending);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            --uxCurrentNumberOfTasks;   <span class="comment">//当前任务总数减少1</span></span><br><span class="line">            traceTASK_DELETE(pxTCB);</span><br><span class="line">            prvDeleteTCB(pxTCB);    <span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//重置下次解锁时间</span></span><br><span class="line">            prvResetNextTaskUnblockTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出临界区</span></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若刚刚删除的是正在运行的任务 则强制任务调度</span></span><br><span class="line">    <span class="keyword">if</span> (xSchedulerRunning != pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pxTCB == pxCurrentTCB)</span><br><span class="line">        &#123;</span><br><span class="line">            configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>内存释放就是根据任务的内存分配方式，选择对应的释放函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放TCB、堆栈的内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvDeleteTCB</span><span class="params">(TCB_t *pxTCB)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ((configSUPPORT_DYNAMIC_ALLOCATION == 1) &amp;&amp; (configSUPPORT_STATIC_ALLOCATION == 0))</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//任务使用动态内存分配策略，直接释放任务控制块内存、堆栈内存</span></span><br><span class="line">        vPortFree(pxTCB-&gt;pxStack);</span><br><span class="line">        vPortFree(pxTCB);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//选择对应的内存释放函数</span></span><br><span class="line">        <span class="keyword">if</span> (pxTCB-&gt;ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//tcb和堆栈都是动态内存分配的，所以必须释放</span></span><br><span class="line">            vPortFree(pxTCB-&gt;pxStack);</span><br><span class="line">            vPortFree(pxTCB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            vPortFree(pxTCB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//tcb和堆栈都是静态内存分配的 不必释放</span></span><br><span class="line">            configASSERT(pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB);</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_DYNAMIC_ALLOCATION */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/1.task_0/" data-id="cmbcy7rgt0009t8mt2jfu4p0o" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/FreeRTOS/3.task_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/3.task_2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.638Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度实现在多个任务之间轮流使用CPU，他的主要工作分为三个阶段：</p>
<ul>
<li>保存当前任务上下文到任务栈</li>
<li>选择新任务</li>
<li>恢复新任务的上下文</li>
</ul>
<p>这三个步骤需要在中断服务函数中执行，所以要求执行的速度要快，所以任务选择策略需要满足快的要求，同时使用汇编代码编写。 任务调度器的具体实现与硬件架构相关，所以需要具备一定的CPU知识。本文以Cortex-M3架构为例。</p>
<h3 id="一、任务运行环境"><a href="#一、任务运行环境" class="headerlink" title="一、任务运行环境"></a>一、任务运行环境</h3><p>任务运行环境、也就是任务上下文，当我们说任务获得CPU时，究竟发生了什么？</p>
<p>CPU运行时，是通过不断的读取指令、数据到CPU的寄存器、然后执行指令处理数据。而任务与任务之间的区别就是代码和数据不同，所以任务获得CPU，本质上就是将任务的代码、数据复制到CPU的寄存器。而任务的代码、数据就是任务的上下文。</p>
<p>以Cortex-M3为例，CPU的寄存器如图所示：<br><img src="/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAa2lsbGVyLXA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="堆栈寄存器"><a href="#堆栈寄存器" class="headerlink" title="堆栈寄存器"></a>堆栈寄存器</h4><p>Cortex M3有两个堆栈指针，但是在同一时刻只能使用一个。分别是：</p>
<ul>
<li>MSP：主堆栈指针（默认）用于操作系统内核、异常服务例程、需要特权级别访问的应用代码</li>
<li>PSP：用户进程使用的指针。</li>
</ul>
<h4 id="连接寄存器LR"><a href="#连接寄存器LR" class="headerlink" title="连接寄存器LR"></a>连接寄存器LR</h4><p>存储了函数调用的返回地址。配合BL使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL fuck</span><br></pre></td></tr></table></figure>

<p>程序跳转到fuck函数执行，且LR寄存器自动存储了fuck函数返回后要执行的下一条指令。</p>
<h4 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h4><p>PC寄存器的值是的下一条指令的地址。可用于改变程序执行顺序。</p>
<h4 id="特殊功能寄存器"><a href="#特殊功能寄存器" class="headerlink" title="特殊功能寄存器"></a>特殊功能寄存器</h4><p>是CM3的特点，这些寄存器只能通过MSR&#x2F;MRS指令访问。临界区进入or退出就是通过开关中断实现。</p>
<ul>
<li>程序状态字寄存器PSRs：记录运算模块ALU的标志（进位、借位、符号以及中断号）</li>
<li>中断屏蔽寄存器PRIMASK：开关所有可屏蔽中断</li>
<li>中断屏蔽寄存器FAULTMASK：开关所有中断（除了NMI）</li>
<li>中断屏蔽寄存器BASEPRI：当被设置为x时，优先级大于x的中断被屏蔽</li>
<li>控制寄存器：定义当前的特权级别、使用的堆栈指针。</li>
</ul>
<h3 id="二、触发任务调度"><a href="#二、触发任务调度" class="headerlink" title="二、触发任务调度"></a>二、触发任务调度</h3><p>操作系统必须提供一个接口，来实现任务调度。通常会使用软件中断来实现任务调度，在Cortex-M3中，在PendSV中断服务函数中实现任务调度。</p>
<h4 id="PendSV"><a href="#PendSV" class="headerlink" title="PendSV"></a>PendSV</h4><p>在systick中断会执行上下文切换，这时就可以在systick中调用PendSV，由于PendSV是一个可挂起的软件中断，等到systick中断退出后，会进入PendSV中断，在PendSV中断中进行上下文切换。其工作如图：</p>
<p><img src="/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAa2lsbGVyLXA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h4><p>当Cortex-M3开始响应一个中断时，首先会由硬件自动保存寄存器xPSR ,PC,LR,R12,R3,R2,R1,R0到当前使用的栈中（PSP or MSP）。随后进入从中断向量表找到中断服务程序入口执行（在中断中一直使用MSP）。</p>
<p>退出中断时，将从进入服务函数前的栈中，将寄存器xPSR ,PC,LR,R12,R3,R2,R1,R0依次恢复。</p>
<h3 id="三、任务调度"><a href="#三、任务调度" class="headerlink" title="三、任务调度"></a>三、任务调度</h3><ul>
<li><p>当触发任务调度时，CPU检测到PendSV中断产生，于是由硬件将xPSR ,PC,LR,R12,R3,R2,R1,R0寄存器的值保存到当前的任务栈中，然后进入xPortPendSVHandler函数，先获取任务栈顶指针，将R11,R10,R9,R8,R7,R6,R5,R4寄存器的值压入任务栈中。</p>
</li>
<li><p>通过vTaskSwitchContext函数选择一个新的任务。</p>
</li>
<li><p>获取新的任务栈顶指针，通过栈顶指针恢复R11,R10,R9,R8,R7,R6,R5,R4寄存器的值，重新设置PSP为新任务栈顶指针，退出中断服务函数；硬件将自动从新任务栈中恢复R11,R10,R9,R8,R7,R6,R5,R4寄存器的值，从而实现了上下文恢复。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PendSV中断服务函数</span></span><br><span class="line"><span class="comment"> * 任务上下文切换 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">xPortPendSVHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> uxCriticalNesting;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;    <span class="comment">/* pxCurrentTCB是一个指向当前任务TCB的指针 */</span></span><br><span class="line">    <span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存上下文 */</span></span><br><span class="line">    mrs r0, psp                 <span class="comment">//将psp保存到r0（psp栈顶指针）</span></span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    ldr r3, =pxCurrentTCB       <span class="comment">//将pxCurrentTCB的地址保存到r3</span></span><br><span class="line">    ldr r2, [ r3 ]              <span class="comment">//读取pxCurrentTCB的值到r2，即当前任务TCB的地址，也是任务栈顶指针的地址</span></span><br><span class="line"></span><br><span class="line">    stmdb r0 !, &#123; r4 - r11 &#125;    <span class="comment">//以栈顶地址（r0）为基地址，将r4-r11寄存器的数据压入任务栈中，r0为新的任务栈顶地址</span></span><br><span class="line">    str r0, [ r2 ]              <span class="comment">//将r0（新的任务栈顶地址）保存到 “以r2的值为地址” 的内存上。（r2的值就是任务栈顶指针的地址）。这个操作就是更新任务控制块的栈顶指针成员。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此时r3保存的是pxCurrentTCB的地址，r14保存返回地址 */</span></span><br><span class="line">    stmdb sp !, &#123; r3, r14 &#125;     <span class="comment">//将r3、r14的值压入栈保护，后续调用vTaskSwitchContext时、r3、r14会被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选择新任务 */</span></span><br><span class="line">    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY   <span class="comment">//通过设置basepri寄存器屏蔽中断</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    bl vTaskSwitchContext       <span class="comment">//跳转到vTaskSwitchContext执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复上下文 */</span></span><br><span class="line">    <span class="comment">/* 从vTaskSwitchContext返回后、pxCurrentTCB的值就修改成下一个任务的tcb */</span></span><br><span class="line">    mov r0, #<span class="number">0</span>                  <span class="comment">//打开中断</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    ldmia sp !, &#123; r3, r14 &#125;     <span class="comment">//恢复r3 r14的寄存器</span></span><br><span class="line"></span><br><span class="line">    ldr r1, [ r3 ]              <span class="comment">//读取pxCurrentTCB的值到r1，即新任务TCB的地址，也是新任务栈顶指针的地址</span></span><br><span class="line">    ldr r0, [ r1 ]              <span class="comment">//读取新任务栈顶地址到r0</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125;    <span class="comment">//以栈顶地址为基地址，将栈内向上增长的8个字数据压入r4-r11寄存器（恢复新任务的运行环境）</span></span><br><span class="line">    msr psp, r0                 <span class="comment">//将新的栈顶地址保存到psp寄存器</span></span><br><span class="line">    isb</span><br><span class="line">    bx r14                      <span class="comment">//退出中断</span></span><br><span class="line">    nop</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>整个过程中、任务栈内的数据内容大致如图所示：</p>
<p><img src="/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAa2lsbGVyLXA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="四、选择新任务"><a href="#四、选择新任务" class="headerlink" title="四、选择新任务"></a>四、选择新任务</h3><p>freertos提供通用的任务选择方法、也提供了与具体硬件相关的任务选择方法，可以通过宏configUSE_PORT_OPTIMISED_TASK_SELECTION来开启or关闭该功能。通过一个全局变量pxCurrentTCB来指向新任务的TCB。</p>
<p>freertos的每一个优先级都有一个就绪链表、通过数组将这些链表组织起来。数组的下标正好对应优先级，如图：</p>
<h4 id="1、通用方式"><a href="#1、通用方式" class="headerlink" title="1、通用方式"></a>1、通用方式</h4><p>当configUSE_PORT_OPTIMISED_TASK_SELECTION为0时，使用通用的任务选择方式，即选择 就绪任务 中优先级最高的任务。</p>
<p>这样就保证优先级高的任务能一直得到执行，符合实时操作系统的要求。freertos通过宏taskSELECT_HIGHEST_PRIORITY_TASK()实现该功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务选择：选择就绪链表中，优先级最高的第一个任务</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                   \</span></span><br><span class="line"><span class="meta">        UBaseType_t uxTopPriority = uxTopReadyPriority;                                 \</span></span><br><span class="line"><span class="meta">                                                                                        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* 找出就绪链表数组中，优先级最高的链表 */</span>                    					  \</span></span><br><span class="line"><span class="meta">        while (listLIST_IS_EMPTY(&amp;(pxReadyTasksLists[uxTopPriority])))                  \</span></span><br><span class="line"><span class="meta">        &#123;                                                                               \</span></span><br><span class="line"><span class="meta">            configASSERT(uxTopPriority);                                                \</span></span><br><span class="line"><span class="meta">            --uxTopPriority;                                                            \</span></span><br><span class="line"><span class="meta">        &#125;                                                                               \</span></span><br><span class="line"><span class="meta">                                                                                        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* 获取就绪链表第一个任务到pxCurrentTCB 记录uxTopReadyPriority */</span>                 \</span></span><br><span class="line"><span class="meta">        listGET_OWNER_OF_NEXT_ENTRY(pxCurrentTCB, &amp;(pxReadyTasksLists[uxTopPriority])); \</span></span><br><span class="line"><span class="meta">        uxTopReadyPriority = uxTopPriority;                                             \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="2、硬件优化方式"><a href="#2、硬件优化方式" class="headerlink" title="2、硬件优化方式"></a>2、硬件优化方式</h4><p>部分硬件提供了一些特殊指令or寄存器来优化该过程，可通过portGET_HIGHEST_PRIORITY接口来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                   \</span></span><br><span class="line"><span class="meta">        UBaseType_t uxTopPriority;                                                      \</span></span><br><span class="line"><span class="meta">                                                                                        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* Find the highest priority list that contains ready tasks. */</span>                 \</span></span><br><span class="line"><span class="meta">        portGET_HIGHEST_PRIORITY(uxTopPriority, uxTopReadyPriority);                    \</span></span><br><span class="line"><span class="meta">        configASSERT(listCURRENT_LIST_LENGTH(&amp;(pxReadyTasksLists[uxTopPriority])) &gt; 0); \</span></span><br><span class="line"><span class="meta">        listGET_OWNER_OF_NEXT_ENTRY(pxCurrentTCB, &amp;(pxReadyTasksLists[uxTopPriority])); \</span></span><br><span class="line"><span class="meta">    &#125; <span class="comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span></span><br></pre></td></tr></table></figure>

<p>对于Cortex-M3内核，可使用前导零来加速计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用CM3的前导零指令（计算二进制数有多少个零在前面）、得到uxReadyPriorities第一个1出现的位置，就是最大优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/3.task_2/" data-id="cmbcy7rgv000bt8mt6gkp4s61" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/FreeRTOS/5.msg_queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/5.msg_queue/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.638Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><blockquote>
<p>FreeRTOS学习仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/free-rtos_-study">https://gitee.com/killerp/free-rtos_-study</a></p>
</blockquote>
<p>消息队列是RTOS的基础数据结构，用于任务之间、任务与中断之间进行数据传递。</p>
<p>没有使用消息队列时，若想要在两个任务之间进行数据传递，那么必须通过全局变量来传递，而在多任务系统中，访问全局变量往往需要用户对资源进行保护，这样就使得编程变得麻烦。</p>
<p>消息队列封装了对共享数据的访问保护，同时还加入了阻塞等待机制。使用户编程时不用去考虑复杂的并发访问。</p>
<h3 id="一、队列的结构"><a href="#一、队列的结构" class="headerlink" title="一、队列的结构"></a>一、队列的结构</h3><p>消息队列结构体的定义如下：</p>
<ul>
<li><p>消息队列可理解为一个环形的队列，通过pcHead和pcTail将队列的首位连接起来。</p>
</li>
<li><p>pcWriteTo和pcReadFrom分别是队列的首部和尾部（若采用默认的FIFO）</p>
</li>
<li><p>队列中每个消息的大小是固定的，一个队列可容纳若干个消息，由消息大小和数量决定队列所占内存的大小</p>
</li>
<li><p>队列有两个链表，分别用于存放因发送&#x2F;接收消息而进入阻塞的任务。</p>
</li>
<li><p>队列支持锁定，当队列锁定时，中断函数不能修改以上链表，实现对数据的保护。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 消息队列 入队使用的是内存复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> /* <span class="title">The</span> <span class="title">old</span> <span class="title">naming</span> <span class="title">convention</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">prevent</span> <span class="title">breaking</span> <span class="title">kernel</span> <span class="title">aware</span> <span class="title">debuggers</span>. */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int8_t</span> * pcHead;           <span class="comment">/*&lt; 指向队列内存起始地址. */</span></span><br><span class="line">    <span class="type">int8_t</span> * pcWriteTo;        <span class="comment">/*&lt; 指向队列下一个空闲地址. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        QueuePointers_t xQueue;    <span class="comment">//TODO 当结构体作为队列时  </span></span><br><span class="line">        SemaphoreData_t xSemaphore; <span class="comment">//当作为信号量时</span></span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    List_t xTasksWaitingToSend;             <span class="comment">//链表：保存那些因发送信号量而进入阻塞的任务 （按优先级排序）</span></span><br><span class="line">    List_t xTasksWaitingToReceive;          <span class="comment">//链表：保存那些因接收信号量而进入阻塞的任务 （按优先级排序）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; <span class="comment">//队列中的消息数量</span></span><br><span class="line">    UBaseType_t uxLength;                   <span class="comment">//队列的最大消息数量</span></span><br><span class="line">    UBaseType_t uxItemSize;                 <span class="comment">//一个消息的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列上锁</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock;                <span class="comment">//队列上锁时，任务从队列接收消息的数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock;                <span class="comment">//队列上锁时，任务向队列发送的消息数量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> ucStaticallyAllocated;      <span class="comment">//标记队列的内存分配方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; xQUEUE;</span><br></pre></td></tr></table></figure>



<p>消息队列可简单的抽象成如下图片：</p>
<p>在同一时间内，只能有一个任务 or 中断在修改队列的链表。是的，队列锁并不能阻止中断向队列复制数据。</p>
<p>在这里插入图片描述</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/2.png" alt="在这里插入图片描述"></p>
<h3 id="二、创建队列"><a href="#二、创建队列" class="headerlink" title="二、创建队列"></a>二、创建队列</h3><p>创建队列的过程与创建任务类似，需要为队列结构体和队列存储区分配内存，并初始化队列结构体的成员变量。</p>
<p>以动态内存分配为例：首先分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> QueueHandle_t <span class="title function_">xQueueGenericCreate</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType )</span></span><br><span class="line"> &#123;</span><br><span class="line">     Queue_t * pxNewQueue;   <span class="comment">//指向新的队列结构体</span></span><br><span class="line">     <span class="type">size_t</span> xQueueSizeInBytes;   <span class="comment">//队列总大小（字节）</span></span><br><span class="line">     <span class="type">uint8_t</span> * pucQueueStorage;  <span class="comment">//指向队列存储区域起始地址</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//队列的长度至少为1</span></span><br><span class="line">     configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">     <span class="comment">//计算队列使用的内存大小</span></span><br><span class="line">     xQueueSizeInBytes = ( <span class="type">size_t</span> ) ( uxQueueLength * uxItemSize );</span><br><span class="line">     <span class="comment">/* 检查乘法溢出 */</span></span><br><span class="line">     configASSERT( ( uxItemSize == <span class="number">0</span> ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 检查溢出. */</span></span><br><span class="line">     configASSERT( ( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ) &gt;  xQueueSizeInBytes );</span><br><span class="line"></span><br><span class="line">     <span class="comment">//todo 申请内存， pvPortMalloc字节对齐问题</span></span><br><span class="line">     pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ); </span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>( pxNewQueue != <span class="literal">NULL</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//队列结构体与队列实际内存区域在同一连续的内存中 所以pucQueueStorage跳过Queue_t</span></span><br><span class="line">         pucQueueStorage = ( <span class="type">uint8_t</span> * ) pxNewQueue;</span><br><span class="line">         pucQueueStorage += <span class="keyword">sizeof</span>( Queue_t ); </span><br><span class="line"></span><br><span class="line">         <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">             &#123;</span><br><span class="line">                 pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;</span><br><span class="line">             &#125;</span><br><span class="line">         <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line"><span class="comment">//初始化队列结构体</span></span><br><span class="line">         prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         traceQUEUE_CREATE_FAILED( ucQueueType );</span><br><span class="line">         mtCOVERAGE_TEST_MARKER();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> pxNewQueue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>初始化队列结构体的成员变量，初始化后的内存大概为：</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/4.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseNewQueue</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint8_t</span> * pucQueueStorage,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType,</span></span><br><span class="line"><span class="params">                                   Queue_t * pxNewQueue )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//移除编译器的警告</span></span><br><span class="line">    ( <span class="type">void</span> ) ucQueueType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置队列结构体的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当队列作为信号量时，uxItemSize为0</span></span><br><span class="line">    <span class="keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pcHead不能为null，因为pcHead为null表示互斥信号量 所以设为一个确定的值</span></span><br><span class="line">        pxNewQueue-&gt;pcHead = ( <span class="type">int8_t</span> * ) pxNewQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//作为队列，pcHead指向存储区</span></span><br><span class="line">        pxNewQueue-&gt;pcHead = ( <span class="type">int8_t</span> * ) pucQueueStorage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置队列长度</span></span><br><span class="line">    pxNewQueue-&gt;uxLength = uxQueueLength;</span><br><span class="line">    pxNewQueue-&gt;uxItemSize = uxItemSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置队列 </span></span><br><span class="line">    ( <span class="type">void</span> ) xQueueGenericReset( pxNewQueue, pdTRUE );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueGenericReset</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                               BaseType_t xNewQueue )</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    </span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重新设置队列的指针</span></span><br><span class="line">        pxQueue-&gt;u.xQueue.pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">        pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;</span><br><span class="line">        </span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - <span class="number">1U</span> ) * pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;cRxLock = queueUNLOCKED;</span><br><span class="line">        pxQueue-&gt;cTxLock = queueUNLOCKED;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( xNewQueue == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不是新的队列</span></span><br><span class="line">            <span class="comment">/* xTasksWaitingToSend的任务可以发送消息，而 xTasksWaitingToReceive则继续等待 */</span></span><br><span class="line">            <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化队列使用的链表</span></span><br><span class="line">            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );</span><br><span class="line">            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pdPASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="三、发送消息到队列"><a href="#三、发送消息到队列" class="headerlink" title="三、发送消息到队列"></a>三、发送消息到队列</h3><blockquote>
<p>RTOS中发送消息的函数五花八门，但万变不离其宗，只要掌握了以下这个函数，其他的发送函数都是这个函数的变体。</p>
</blockquote>
<h4 id="任务中发送消息"><a href="#任务中发送消息" class="headerlink" title="任务中发送消息"></a>任务中发送消息</h4><p>任务调用发送消息函数、在该函数中任务会进入死循环，若任务能成功发送消息，则退出循环。否则，任务就需要进入阻塞，等待队列中出现空闲位置。</p>
<p>同时通过进入临界区来保证当前任务对队列的独占性访问。具体代码逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueGenericSend</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> pvItemToQueue,</span></span><br><span class="line"><span class="params">                              TickType_t xTicksToWait,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> BaseType_t xCopyPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//xEntryTimeSet标记任务是否已经设置过阻塞时间</span></span><br><span class="line">    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;</span><br><span class="line">    TimeOut_t xTimeOut; <span class="comment">//阻塞时间结构体</span></span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查一些错误的用法</span></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvItemToQueue == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="number">1</span> ) ) );</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入临界区 要操作链表</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列未满或是覆盖写入时，消息可以写入队列</span></span><br><span class="line">            <span class="keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )</span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_SEND( pxQueue );</span><br><span class="line">                </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//将队列项复制到队列指定位置</span></span><br><span class="line">                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//如果有任务在等待消息</span></span><br><span class="line">                        <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//将该任务从事件链表中移出</span></span><br><span class="line">                            <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//移出的任务优先级更高，需要任务调度</span></span><br><span class="line">                                queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>( xYieldRequired != pdFALSE )    <span class="comment">//没有任务在等消息，但需要任务调度</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                taskEXIT_CRITICAL();    <span class="comment">//消息发送完成 退出临界区</span></span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//队列满不能入队 需要延时 or 退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//任务不要求延时 直接退出</span></span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">                    traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE ) <span class="comment">//未初始化阻塞</span></span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//初始化阻塞结构体，用于辅助计算阻塞时间</span></span><br><span class="line">                    vTaskInternalSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                 </span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到此、任务未能成功发送消息 需要阻塞等待</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出临界区后，其他任务或中断可能抢占当前任务（然后向队列获取消息，那么当前任务就有可能发送消息）</span></span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//挂起调度器、防止其他任务访问队列的xTasksWaitingToSend链表</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        <span class="comment">//锁住队列 防止中断修改xTasksWaitingToSend链表</span></span><br><span class="line">        prvLockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查当前任务的阻塞时间是否到达</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//阻塞时间未到，且队列中为满 则将当前任务插入队列的WaitingToSend</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueFull( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceBLOCKING_ON_QUEUE_SEND( pxQueue );</span><br><span class="line"></span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解锁队列(允许中断修改链表)</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//恢复调度器，产生任务调度，当前任务进入阻塞，等到阻塞时间到达或有其他任务读取了消息时被唤醒，然后重新进入当前循环</span></span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    portYIELD_WITHIN_API();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队列有位置，重新进入当前循环</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//超时时间到且未能成功发送消息 退出</span></span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">            traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">            <span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/*lint -restore */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FreeRTOS的消息是通过内存复制实现的。过程如图：先从write指针写入消息，再将write指针移动到下一个空闲位置。</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/3.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> BaseType_t <span class="title function_">prvCopyDataToQueue</span><span class="params">( Queue_t * <span class="type">const</span> pxQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> BaseType_t xPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdFALSE;</span><br><span class="line">    UBaseType_t uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当前函数必须在临界区内调用 */</span></span><br><span class="line"></span><br><span class="line">    uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line">    <span class="comment">//作为信号量的情况</span></span><br><span class="line">    <span class="keyword">if</span>( pxQueue-&gt;uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若是互斥信号量的话，说明信号量被释放、需要解除优先级反转</span></span><br><span class="line">                <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    xReturn = xTaskPriorityDisinherit( pxQueue-&gt;u.xSemaphore.xMutexHolder );</span><br><span class="line">                    pxQueue-&gt;u.xSemaphore.xMutexHolder = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作为消息队列 发送到队列尾部（writeto）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( xPosition == queueSEND_TO_BACK )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//内存复制</span></span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pxQueue-&gt;pcWriteTo, pvItemToQueue, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">        <span class="comment">//pcWriteTo增加</span></span><br><span class="line">        pxQueue-&gt;pcWriteTo += pxQueue-&gt;uxItemSize;                                                       </span><br><span class="line">        <span class="comment">//若pcWriteTo到达内存末尾，则回到内存首部</span></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;pcWriteTo &gt;= pxQueue-&gt;u.xQueue.pcTail )                                            </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//复制到队首（pcReadFrom）</span></span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, pvItemToQueue, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom -= pxQueue-&gt;uxItemSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &lt; pxQueue-&gt;pcHead ) </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;u.xQueue.pcReadFrom = ( pxQueue-&gt;u.xQueue.pcTail - pxQueue-&gt;uxItemSize );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若是覆盖写入，则有一个消息被覆盖，uxMessagesWaiting-1</span></span><br><span class="line">        <span class="keyword">if</span>( xPosition == queueOVERWRITE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                --uxMessagesWaiting;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队成功</span></span><br><span class="line">    pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中断中发送消息"><a href="#中断中发送消息" class="headerlink" title="中断中发送消息"></a>中断中发送消息</h4><p>由于在中断中不能进入阻塞，所以需要有一个函数来另外实现在中断发送消息。与在任务中的区别在于，临界区保护以及当不满足发送条件时，直接退出函数，不会进入延时等待。</p>
<p><strong>同时，在中断中若队列上锁，则不能修改链表。这是因为中断触发时，任务可能正在访问队列链表。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueGenericSendFromISR</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> pvItemToQueue,</span></span><br><span class="line"><span class="params">                                     BaseType_t * <span class="type">const</span> pxHigherPriorityTaskWoken,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> BaseType_t xCopyPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;     <span class="comment">//返回值：表示是否需要任务调度</span></span><br><span class="line">    UBaseType_t uxSavedInterruptStatus; <span class="comment">//保存中断状态</span></span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查队列</span></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvItemToQueue == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="number">1</span> ) ) );</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入临界区</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//队列未满或是覆盖写入时，消息可以写入队列</span></span><br><span class="line">        <span class="keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;    <span class="comment">//获得发送锁 </span></span><br><span class="line">            <span class="type">const</span> UBaseType_t uxPreviousMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">            traceQUEUE_SEND_FROM_ISR( pxQueue );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a</span></span><br><span class="line"><span class="comment">             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result</span></span><br><span class="line"><span class="comment">             *  in a task disinheriting a priority and prvCopyDataToQueue() can be</span></span><br><span class="line"><span class="comment">             *  called here even though the disinherit function does not check if</span></span><br><span class="line"><span class="comment">             *  the scheduler is suspended before accessing the ready lists. */</span></span><br><span class="line">            <span class="comment">//复制数据到队列</span></span><br><span class="line">            ( <span class="type">void</span> ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若队列没有被锁</span></span><br><span class="line">            <span class="keyword">if</span>( cTxLock == queueUNLOCKED )</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果有任务正在等待数据</span></span><br><span class="line">                        <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//将任务从等待链表中移除</span></span><br><span class="line">                            <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//标记有更高优先级的任务解锁 退出中断后需要任务调度</span></span><br><span class="line">                                <span class="keyword">if</span>( pxHigherPriorityTaskWoken != <span class="literal">NULL</span> )</span><br><span class="line">                                &#123;</span><br><span class="line">                                    *pxHigherPriorityTaskWoken = pdTRUE;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ( <span class="type">void</span> ) uxPreviousMessagesWaiting;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队列被锁定，增加cTxLock的值，使解锁队列的任务明白有多少消息未能成功入队</span></span><br><span class="line">                configASSERT( cTxLock != queueINT8_MAX );</span><br><span class="line"></span><br><span class="line">                pxQueue-&gt;cTxLock = ( <span class="type">int8_t</span> ) ( cTxLock + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//队列已满 不能阻塞直接退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );</span><br><span class="line">            xReturn = errQUEUE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出临界区</span></span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、接收消息"><a href="#四、接收消息" class="headerlink" title="四、接收消息"></a>四、接收消息</h3><h4 id="任务中接收消息"><a href="#任务中接收消息" class="headerlink" title="任务中接收消息"></a>任务中接收消息</h4><p>接收消息的实现与发送消息类似，同样需要在循环中，成功获取队列的消息则退出，否则进入阻塞，等待消息到来。</p>
<p>代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    BaseType_t xEntryTimeSet = pdFALSE;     <span class="comment">//标记是否初始化的阻塞时间</span></span><br><span class="line">    TimeOut_t xTimeOut;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( ( pxQueue ) );</span><br><span class="line"></span><br><span class="line">    configASSERT( !( ( ( pvBuffer ) == <span class="literal">NULL</span> ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取队列中的消息数量</span></span><br><span class="line">            <span class="type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若队列中有数据</span></span><br><span class="line">            <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//复制数据到buffer，消息数量-1</span></span><br><span class="line">                prvCopyDataFromQueue( pxQueue, pvBuffer );</span><br><span class="line">                traceQUEUE_RECEIVE( pxQueue );</span><br><span class="line">                pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//消息出队后，若有任务在等待发送消息，则恢复该任务去发送</span></span><br><span class="line">                <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//将等待发送的任务移出</span></span><br><span class="line">                    <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//移出的任务优先级更高，发生抢占</span></span><br><span class="line">                        queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">//没有任务在等待发送</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                taskEXIT_CRITICAL();</span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//队列为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不作等待立刻退出</span></span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line">                    traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE ) <span class="comment">//若未初始化阻塞时间</span></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置阻塞时间</span></span><br><span class="line">                    vTaskInternalSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Entry time was already set. */</span></span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到此、当前任务无法成功获取消息 需要进入阻塞等待</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">        <span class="comment">//退出临界区后，其他任务或中断可能抢占当前任务（然后向队列发送消息，那么当前任务就能成功获取消息）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//挂起调度器和锁住队列，防止任务、中断修改队列的链表</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        prvLockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务阻塞时间未到</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列仍为空，需要继续等待</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );</span><br><span class="line">                <span class="comment">//将任务放到等待接收链表 </span></span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );</span><br><span class="line">                prvUnlockQueue( pxQueue );  <span class="comment">//解除锁定</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//恢复调度器，产生任务调度，当前任务进入阻塞，等到阻塞时间到达或有其他任务发送了消息时被唤醒，然后重新进入当前循环</span></span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    portYIELD_WITHIN_API();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队列有消息了，重新进入当前循环</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//阻塞时间到达</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            <span class="comment">//再次查看队列是否有消息，若有则进入当前循环 无则退出等待</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/*lint -restore */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向队列复制消息。在这里需要注意当队列的消息大小为0时，这个队列是信号量，不需要内存的复制，这个部分在下一章中讲信号量说明。</p>
<p>读取消息时，是先将read指针移动，再读取。</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/5.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvCopyDataFromQueue</span><span class="params">( Queue_t * <span class="type">const</span> pxQueue,</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> * <span class="type">const</span> pvBuffer )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pcReadFrom向前移动一个单元</span></span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;          </span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否溢出、需要回到队列头</span></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail ) </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内存复制</span></span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pvBuffer, ( <span class="type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="中断中接收消息"><a href="#中断中接收消息" class="headerlink" title="中断中接收消息"></a>中断中接收消息</h4><p>同理，在中断中读取消息，当队列中没有消息时，不能进入等待，必须马上退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                                 BaseType_t * <span class="type">const</span> pxHigherPriorityTaskWoken )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvBuffer == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入临界区 保存中断状态</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取消息数量</span></span><br><span class="line">        <span class="type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否有消息</span></span><br><span class="line">        <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int8_t</span> cRxLock = pxQueue-&gt;cRxLock;    <span class="comment">//获取接收锁</span></span><br><span class="line"></span><br><span class="line">            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );</span><br><span class="line">            <span class="comment">//数据有效，复制数据到buffer</span></span><br><span class="line">            prvCopyDataFromQueue( pxQueue, pvBuffer );</span><br><span class="line">            pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列未锁，可以修改队列链表</span></span><br><span class="line">            <span class="keyword">if</span>( cRxLock == queueUNLOCKED )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//消息出队后，队列有空闲的位置，若有任务在等待发送消息，则需要恢复该任务</span></span><br><span class="line">                <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//将等待发送的任务移出</span></span><br><span class="line">                    <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//移出的任务优先级更高，需要退出中断后启动任务调度</span></span><br><span class="line">                        <span class="keyword">if</span>( pxHigherPriorityTaskWoken != <span class="literal">NULL</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//设置返回参数</span></span><br><span class="line">                            *pxHigherPriorityTaskWoken = pdTRUE;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//队列上锁，不能操作链表</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                configASSERT( cRxLock != queueINT8_MAX );</span><br><span class="line">                <span class="comment">//设置cRxLock-1 使队列知道在其锁定的时候有消息被读取</span></span><br><span class="line">                pxQueue-&gt;cRxLock = ( <span class="type">int8_t</span> ) ( cRxLock + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功获取消息</span></span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//队列为空 立刻返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = pdFAIL;</span><br><span class="line">            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/5.msg_queue/" data-id="cmbcy7rgw000dt8mt5pks5xuv" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ESP32/solove_ESP32_SRAM_not_enough" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.638Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[TOC]</p>
<h2 id="一，为什么需要外部RAM"><a href="#一，为什么需要外部RAM" class="headerlink" title="一，为什么需要外部RAM"></a>一，为什么需要外部RAM</h2><p>  ESP32有520kB的内部RAM空间可以使用，这对于一般的情况是够用的，但是<strong>如果设备需要涉及音频或者显示图像等处理时，需要更大的内存空间来处理这些数据。ESP32支持扩展外部RAM</strong>，其实乐鑫已经在其ESP32 WROVER系列模组中集成了一个4M大小的外部PSRAM。乐鑫官网文档对外部RAM作了详解：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/external-ram.html?highlight=RAM">片外RAM</a></p>
<p>乐鑫对于ESP32 WROVER的介绍也是：</p>
<blockquote>
<p>ESP32-WROVER 系列模组基于 ESP32-D0WD 双核芯片设计，其强大的双核性能适用于对内存需求大的应用场景，例如多样的 AIoT 应用和网关应用。</p>
</blockquote>
<p><strong>如果你的设备需要使用大内存，例如wifi与ble并存，音频处理和图像显示功能</strong>，推荐使用这个模组。</p>
<h2 id="二-快速上手外部RAM"><a href="#二-快速上手外部RAM" class="headerlink" title="二 快速上手外部RAM"></a>二 快速上手外部RAM</h2><h3 id="2-1-使能外部RAM"><a href="#2-1-使能外部RAM" class="headerlink" title="2.1 使能外部RAM"></a>2.1 使能外部RAM</h3><p><strong>首先必须确保你的芯片是有外部RAM的</strong>。例如ESP32 WROVER模组。<br>进入<code>idf.py menuconfig-&gt;component config-&gt;ESP32-specific</code><br>在下图的<code>Support for external,SPI-connected RAM</code>选项中按<code>y</code>选中,这样就使能了外部RAM。</p>
<p><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201021185500107.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-配置外部RAM"><a href="#2-2-配置外部RAM" class="headerlink" title="2.2 配置外部RAM"></a>2.2 配置外部RAM</h3><p>进入下一行的<code>SPI RAM config</code>进行配置更多的细节。这里讲一下比较重要的配置选项。</p>
<p><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201105104341985.png" alt="在这里插入图片描述"></p>
<h4 id="2-2-1-第二项配置系统的动态内存分配功能"><a href="#2-2-1-第二项配置系统的动态内存分配功能" class="headerlink" title="2.2.1 第二项配置系统的动态内存分配功能"></a>2.2.1 第二项配置系统的动态内存分配功能</h4><p>有三个选项，当选择<code>Make RAM allocatable using heap_caps_malloc(..., M</code>时，需要在代码中使用<code>heap_caps_malloc()</code>函数才能在外部RAM中分配内存。</p>
<p><strong>当选择<code>Make RAM allocatable using malloc() as well</code>时，代码中malloc()函数会自动从外部RAM中分配内存。</strong><br><strong>当使能这个选项时，还能配置第九行<code> Maximum malloc() size, in bytes, to always put in internal memory</code>，该配置设置了一个阈值，这里我设置的是1024bytes，当使用malloc()分配内存时，如果分配的内存小于1024字节，就会从内部RAM中分配，否则从外部RAM中分配。</strong></p>
<h4 id="2-2-2-将BSS段添加到外部RAM"><a href="#2-2-2-将BSS段添加到外部RAM" class="headerlink" title="2.2.2 将BSS段添加到外部RAM"></a>2.2.2 将BSS段添加到外部RAM</h4><p>第13行中选择<code>Allow .bss segment placed in external memory</code>,可以将BSS段的lwip、net80211、libpp 和 bluedroid ESP-IDF 库中零初始化的数据存入外部RAM。<strong>此外全局变量，静态变量也可以放到外部RAM中，只需要在变量声明的地方加上宏EXT_RAM_ATTR,并将变量初始化为0。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXT_RAM_ATTR <span class="type">static</span> <span class="type">int</span> num[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-其他可放入外部RAM的数据"><a href="#2-2-3-其他可放入外部RAM的数据" class="headerlink" title="2.2.3 其他可放入外部RAM的数据"></a>2.2.3 其他可放入外部RAM的数据</h4><p>第十行<code>Try to allocate memories of WiFi and LWIP in SPIRAM firstly. If failed, allocate inter</code>会尝试优先使用外部RAM给wifi与lwip协议栈分配内存，如果失败则会使用内部RAM分配。</p>
<h4 id="2-2-4-创建静态任务"><a href="#2-2-4-创建静态任务" class="headerlink" title="2.2.4 创建静态任务"></a>2.2.4 创建静态任务</h4><p>xTaskCreate()会使用内部RAM给任务分配任务堆栈。而使用xTaskCreateStatic()系统会检查传入的buff数组是否是属于内部RAM的。</p>
<p><strong>但对于不以任何方式直接或间接调用 ROM 中代码的任务,选项 <code>Allow external memory as an argument to xTaskCreateStatic</code> 将解除 xTaskCreateStatic 中的检查，从而允许任务堆栈存储在外部 RAM 中。但是，不建议使用此方法。</strong></p>
<p>实际使用过程中我也发现使用该函数创建任务会出现assert error的错误，不知道具体的原因是什么，希望了解的大佬解答一下。</p>
<h4 id="2-2-5-修改分区表"><a href="#2-2-5-修改分区表" class="headerlink" title="2.2.5 修改分区表"></a>2.2.5 修改分区表</h4><p>由于使用了外部RAM会使<code>partitionstable.bin</code>增加，0x8000的偏移地址会出现覆盖，所以需要修改分区表和partitionstable.bin的偏移地址：<br><code>idf.py menuconfig-&gt;Partition Table</code>修改成<code>0x10000</code><br>如果使用本地的分区表，还需要将分区表修改如下</p>
<p>这是由于partitionstable.bin默认是起始地址0x8000修改成0x10000后，由于其占用0xc00大小的空间，而nvs要实现内存对齐，至少要在0x11000处开始.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size</span><br><span class="line">nvs,      data, nvs,     <span class="number">0x11000</span>,  <span class="number">0x4000</span>,</span><br><span class="line">phy_init, data, phy,     <span class="number">0x15000</span>,  <span class="number">0x1000</span>,</span><br><span class="line">factory,  app,  factory, <span class="number">0x20000</span>, <span class="number">0x300000</span>,</span><br><span class="line">flash_tone,data, <span class="number">0x04</span>,   <span class="number">0x320000</span>,  <span class="number">50</span>k,</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201021200158516.png" alt="在这里插入图片描述"></p>
<h2 id="三-深度解放内部RAM"><a href="#三-深度解放内部RAM" class="headerlink" title="三 深度解放内部RAM"></a>三 深度解放内部RAM</h2><p>IRAM是内部RAM，当我使用wifi+ble+ASR组成的一个工程时，编译后出现<strong>Section .iram0.text will not fit in region iram0_0_seg</strong>的错误，原因是IRAM的内存空间仍然不够，这是因为任务堆栈等数据是不能存放在外部RAM中的，所以IRAM中的内存依然紧张。</p>
<p>解决办法是参考 <a target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/issues/2566">https://github.com/espressif/esp-idf/issues/2566</a></p>
<p><strong>原理就是关闭一些网络功能的优化来减少IRAM的使用</strong>：<br>按照这位老哥的说法，将wifi，lwip的优化功能关闭，以减少IRAM的占用，这样下来能省出大约<code>37KB</code>的内存。这样就能正常的编译运行了。<br><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201021190227819.png" alt="在这里插入图片描述"><br><strong>具体步骤如下</strong>：<br><code>idf.py menuconfig-&gt;component config-&gt;Wi-Fi,</code>将箭头所指的两项按n取消选择<br><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201021190554827.png" alt="在这里插入图片描述"><br>lwip部分同理：进入<code>idf.py menuconfig-&gt;component config-&gt;LWIP</code>,取消箭头所指。</p>
<p><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201021190654481.png" alt="在这里插入图片描述"></p>
<h2 id="四-使用效果"><a href="#四-使用效果" class="headerlink" title="四 使用效果"></a>四 使用效果</h2><p>使用外部RAM前，可用的内存只有几十K，开启外部RAM后，可用的内存增加了<code>几十</code>倍，我使用内存获取函数，打印出内存的使用情况：</p>
<p>下图表示SPI RAM初始化成功。<br><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201105111102612.png" alt="在这里插入图片描述"></p>
<p><strong>下图信息说明，外部RAM可用的内存为4049k bytes，当freertos开始运行，进入main函数后，esp_get_free_heap_size()获取到的可用内存为4253k bytes，这是由内部RAM和外部RAM的所有可用的内存的总和，大概可知道可用的内部RAM只有约200k bytes。可见外部RAM极大的扩展了可用内存。</strong></p>
<p><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201105111321645.png" alt="在这里插入图片描述"></p>
<h2 id="五，小结"><a href="#五，小结" class="headerlink" title="五，小结"></a>五，小结</h2><p>由于外部RAM足足有4M 大小，使得esp32在应对语音，图像时依然能应对，对于一个使用了wifi，ble，lwip或者语音识别的程序来说，这4M的内存是必须的。</p>
<p><img src="/2025/05/30/hello-world/ESP32/solove_ESP32_SRAM_not_enough/20201021191307524.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/" data-id="cmbcy7rh1000tt8mt8ej4cl4g" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ESP32/smart_control" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/smart_control/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.638Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一、演示视频"><a href="#一、演示视频" class="headerlink" title="一、演示视频"></a>一、演示视频</h2><p>离线版地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/off_asr">https://gitee.com/killerp/off_asr</a><br>语音识别优化版地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/smart_control">https://gitee.com/killerp/smart_control</a><br>PCB原理图下载地址：<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1wzTGKnRF7WUzTYZ5U4v9kQ">https://pan.baidu.com/s/1wzTGKnRF7WUzTYZ5U4v9kQ</a><br>提取码：6tds</p>
<p>本项目基于esp32a1s模组，设计了一个遥控器，除了实现基本的红外遥控功能，还利用ESP32芯片具备的AI能力，WIFI及蓝牙功能，实现多种方式的输入输出控制，使人们能通过语音，手机远程进行红外遥控。同时又加入温度传感器，并支持将温度数据上传云端，使人们能随时随地查看、分析数据。<br>项目演示视频如下：</p>
<p>[video(video-19gWGs4l-1617149447766)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=972368801)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/03eaf981b73823d3c328e13cfa1250c6e418c0ca.png)">https://player.bilibili.com/player.html?aid=972368801)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/03eaf981b73823d3c328e13cfa1250c6e418c0ca.png)</a>(title-基于esp32语音助手 语音红外遥控)]</p>
<h2 id="二、程序框架"><a href="#二、程序框架" class="headerlink" title="二、程序框架"></a>二、程序框架</h2><p>项目软件分为上位机端和嵌入式终端，程序框架如图：</p>
<p>位于底层的模块可为其上层的模块提供接口<br><img src="/2025/05/30/hello-world/ESP32/smart_control/cc34e0b2ccef417fb412c0f3445c81e7.png" alt="在这里插入图片描述"></p>
<h2 id="三、硬件设计"><a href="#三、硬件设计" class="headerlink" title="三、硬件设计"></a>三、硬件设计</h2><h2 id="四、模块介绍"><a href="#四、模块介绍" class="headerlink" title="四、模块介绍"></a>四、模块介绍</h2><h3 id="1、语音识别模块"><a href="#1、语音识别模块" class="headerlink" title="1、语音识别模块"></a>1、语音识别模块</h3><p>语言识别模块有两种实现方式，一种是离线识别，一种是针对离线版的优化。（目前离线版不再维护）</p>
<h4 id="离线语音识别"><a href="#离线语音识别" class="headerlink" title="离线语音识别"></a>离线语音识别</h4><p>离线语音的实现依赖于乐鑫提供ESP-Skainet库，该库实现了语音唤醒，语言识别功能，可支持100条自定义的语言识别命令。</p>
<p>ESP-Skainet 由两部分组成：</p>
<p>1，唤醒词模型 <a target="_blank" rel="noopener" href="https://github.com/espressif/esp-sr/tree/master/wake_word_engine/README_cn.md">WakeNet</a>：其实现了语音唤醒的功能，目前普通用户能使用限定的唤醒词，如：嗨乐鑫。模型由乐鑫训练。</p>
<p>2，命令词识别模型 <a target="_blank" rel="noopener" href="https://github.com/espressif/esp-sr/tree/master/speech_command_recognition/README_cn.md">MultiNet</a>：其实现语音识别功能，将需要识别的语音命令写入程序，MultiNet就能在程序运行中进行识别，目前支持100条命令词。</p>
<p>在整个程序运行过程中，WakeNet和MultiNet两个模型以进程的形式运行，实时地读取麦克风的音频输入，将音频经过降噪处理等，输入模型，输出结果。其程序运行如图所示：</p>
<p><img src="/2025/05/30/hello-world/ESP32/smart_control/46e76acc42cf47f7b7a0bf8f84f028da.png" alt="在这里插入图片描述"><br>以下代码在main()中运行，该代码初始化了wakenet，multinet 模型，并创建一个音频流通道（ESP-ADF中的概念），该通道的作用即上图中箭头所示。main()以一个RTOS的任务运行，在循环中实时读取通道的音频，输入模型识别。</p>
<p>命令词识别成功后，在<code>asr_multinet_control</code>函数中编写对命令词的响应动作，如调用红外模块提供的接口打开空调等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">ESP_LOGI(TAG, <span class="string">&quot;Initialize SR wn handle&quot;</span>);</span><br><span class="line"><span class="type">esp_wn_iface_t</span> *wakenet;    <span class="comment">//唤醒模型</span></span><br><span class="line"><span class="type">model_coeff_getter_t</span> *model_coeff_getter;   <span class="comment">//神经网络系数获取</span></span><br><span class="line"><span class="type">model_iface_data_t</span> *model_wn_data;  <span class="comment">//识别模型的数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">esp_mn_iface_t</span> *multinet = &amp;MULTINET_MODEL;   <span class="comment">//识别模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize wakeNet model data</span></span><br><span class="line">get_wakenet_iface(&amp;wakenet);    <span class="comment">//初始化唤醒模型</span></span><br><span class="line">get_wakenet_coeff(&amp;model_coeff_getter); <span class="comment">//获取系数</span></span><br><span class="line">model_wn_data = wakenet-&gt;create(model_coeff_getter, DET_MODE_90);   <span class="comment">//创建唤醒模型，设置灵敏度90%</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wn_num = wakenet-&gt;get_word_num(model_wn_data);  <span class="comment">//唤醒词数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= wn_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name = wakenet-&gt;get_word_name(model_wn_data, i);  <span class="comment">//唤醒词文本</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;keywords: %s (index = %d)&quot;</span>, name, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> wn_threshold = wakenet-&gt;get_det_threshold(model_wn_data, <span class="number">1</span>);  <span class="comment">//获取唤醒阈值</span></span><br><span class="line"><span class="type">int</span> wn_sample_rate = wakenet-&gt;get_samp_rate(model_wn_data); <span class="comment">//唤醒词采样率16k</span></span><br><span class="line"><span class="type">int</span> audio_wn_chunksize = wakenet-&gt;get_samp_chunksize(model_wn_data);    <span class="comment">//内存块大小</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;keywords_num = %d, threshold = %f, sample_rate = %d, chunksize = %d, sizeof_uint16 = %d&quot;</span>, wn_num, wn_threshold, wn_sample_rate, audio_wn_chunksize, <span class="keyword">sizeof</span>(<span class="type">int16_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">model_iface_data_t</span> *model_mn_data = multinet-&gt;create(&amp;MULTINET_COEFF, <span class="number">4000</span>); <span class="comment">//语音识别时间，single模式下最大5s</span></span><br><span class="line"><span class="type">int</span> audio_mn_chunksize = multinet-&gt;get_samp_chunksize(model_mn_data);   <span class="comment">//识别内存块</span></span><br><span class="line"><span class="type">int</span> mn_num = multinet-&gt;get_samp_chunknum(model_mn_data);    <span class="comment">//唤醒词数量</span></span><br><span class="line"><span class="type">int</span> mn_sample_rate = multinet-&gt;get_samp_rate(model_mn_data);    <span class="comment">//采样率16k</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;keywords_num = %d , sample_rate = %d, chunksize = %d, sizeof_uint16 = %d&quot;</span>, mn_num, mn_sample_rate, audio_mn_chunksize, <span class="keyword">sizeof</span>(<span class="type">int16_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择所需的较大的内存块</span></span><br><span class="line"><span class="type">int</span> size = audio_wn_chunksize;</span><br><span class="line"><span class="keyword">if</span> (audio_mn_chunksize &gt; audio_wn_chunksize)</span><br><span class="line">&#123;</span><br><span class="line">    size = audio_mn_chunksize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int16_t</span> *buffer = (<span class="type">int16_t</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">short</span>));  <span class="comment">//buffer用于缓存经过流水线处理的音频</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*[ac101]--&gt;i2s_stream--&gt;filter--&gt;raw--&gt;[SR]*/</span></span><br><span class="line"><span class="type">audio_pipeline_handle_t</span> pipeline;   <span class="comment">//音频输入流水线</span></span><br><span class="line"><span class="type">audio_element_handle_t</span> i2s_stream_reader, filter, raw_read; <span class="comment">//流水线车间</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> enable_wn = <span class="literal">true</span>;  <span class="comment">//唤醒使能</span></span><br><span class="line"><span class="type">uint32_t</span> mn_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 1 ] Start codec chip&quot;</span>);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.0 ] Create audio pipeline for recording&quot;</span>);</span><br><span class="line"><span class="comment">//流水线初始化</span></span><br><span class="line"><span class="type">audio_pipeline_cfg_t</span> pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();</span><br><span class="line">pipeline = audio_pipeline_init(&amp;pipeline_cfg);</span><br><span class="line">mem_assert(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="comment">//i2s初始化，用于与ac101通信</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.1 ] Create i2s stream to read audio data from codec chip&quot;</span>);</span><br><span class="line"><span class="type">i2s_stream_cfg_t</span> i2s_cfg = I2S_STREAM_CFG_DEFAULT();</span><br><span class="line">i2s_cfg.i2s_config.sample_rate = <span class="number">48000</span>;</span><br><span class="line">i2s_cfg.type = AUDIO_STREAM_READER; <span class="comment">//输入流</span></span><br><span class="line">i2s_stream_reader = i2s_stream_init(&amp;i2s_cfg);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.2 ] Create filter to resample audio data&quot;</span>);</span><br><span class="line"><span class="comment">//滤波器初始化，将源采样率变为16k</span></span><br><span class="line"><span class="type">rsp_filter_cfg_t</span> rsp_cfg = DEFAULT_RESAMPLE_FILTER_CONFIG();</span><br><span class="line">rsp_cfg.src_rate = <span class="number">48000</span>;</span><br><span class="line">rsp_cfg.src_ch = <span class="number">2</span>;</span><br><span class="line">rsp_cfg.dest_rate = <span class="number">16000</span>;</span><br><span class="line">rsp_cfg.dest_ch = <span class="number">1</span>;</span><br><span class="line">filter = rsp_filter_init(&amp;rsp_cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//raw初始化，缓存经过处理的音频数据</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 2.3 ] Create raw to receive data&quot;</span>);</span><br><span class="line"><span class="type">raw_stream_cfg_t</span> raw_cfg = &#123;</span><br><span class="line">    .out_rb_size = <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">    .type = AUDIO_STREAM_READER,    <span class="comment">//输入流</span></span><br><span class="line">&#125;;</span><br><span class="line">raw_read = raw_stream_init(&amp;raw_cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将各个车间流连接到流水线</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 3 ] Register all elements to audio pipeline&quot;</span>);</span><br><span class="line">audio_pipeline_register(pipeline, i2s_stream_reader, <span class="string">&quot;i2s&quot;</span>);</span><br><span class="line">audio_pipeline_register(pipeline, raw_read, <span class="string">&quot;raw&quot;</span>);</span><br><span class="line">audio_pipeline_register(pipeline, filter, <span class="string">&quot;filter&quot;</span>);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 4 ] Link elements together [codec_chip]--&gt;i2s_stream--&gt;filter--&gt;raw--&gt;[SR]&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *link_tag[<span class="number">3</span>] = &#123;<span class="string">&quot;i2s&quot;</span>, <span class="string">&quot;filter&quot;</span>, <span class="string">&quot;raw&quot;</span>&#125;;</span><br><span class="line">audio_pipeline_link(pipeline, &amp;link_tag[<span class="number">0</span>], <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行流水线</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 5 ] waiting to be awake&quot;</span>);</span><br><span class="line">audio_pipeline_run(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取raw的音频到buffer</span></span><br><span class="line">    raw_stream_read(raw_read, (<span class="type">char</span> *)buffer, size * <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">    <span class="keyword">if</span> (enable_wn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测buffer是否有唤醒词</span></span><br><span class="line">        <span class="keyword">if</span> (wakenet-&gt;detect(model_wn_data, (<span class="type">int16_t</span> *)buffer) == WAKE_UP)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            LED_ON;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;wake up&quot;</span>);</span><br><span class="line">            enable_wn = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mn_count++;</span><br><span class="line">        <span class="comment">//检测buffer中是否有命令词</span></span><br><span class="line">        <span class="type">int</span> commit_id = multinet-&gt;detect(model_mn_data, buffer);</span><br><span class="line">        <span class="comment">//进入命令词控制函数</span></span><br><span class="line">        <span class="keyword">if</span> (asr_multinet_control(commit_id) == ESP_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            LED_OFF;</span><br><span class="line">            enable_wn = <span class="literal">true</span>;</span><br><span class="line">            mn_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mn_count == mn_num)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;stop multinet&quot;</span>);</span><br><span class="line">            LED_OFF;</span><br><span class="line">            enable_wn = <span class="literal">true</span>;</span><br><span class="line">            mn_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 6 ] Stop audio_pipeline&quot;</span>);</span><br><span class="line"></span><br><span class="line">audio_pipeline_stop(pipeline);</span><br><span class="line">audio_pipeline_wait_for_stop(pipeline);</span><br><span class="line">audio_pipeline_terminate(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Terminate the pipeline before removing the listener */</span></span><br><span class="line">audio_pipeline_remove_listener(pipeline);</span><br><span class="line"></span><br><span class="line">audio_pipeline_unregister(pipeline, raw_read);</span><br><span class="line">audio_pipeline_unregister(pipeline, i2s_stream_reader);</span><br><span class="line">audio_pipeline_unregister(pipeline, filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release all resources */</span></span><br><span class="line">audio_pipeline_deinit(pipeline);</span><br><span class="line">audio_element_deinit(raw_read);</span><br><span class="line">audio_element_deinit(i2s_stream_reader);</span><br><span class="line">audio_element_deinit(filter);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[ 7 ] Destroy model&quot;</span>);</span><br><span class="line">wakenet-&gt;destroy(model_wn_data);</span><br><span class="line">model_wn_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line">buffer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>进入项目的配置程序</p>
<blockquote>
<p>idf.py menuconfig&gt;ESP Speech Recognition&gt;Add speech commands</p>
</blockquote>
<p>即可添加命令词</p>
<h4 id="优化语音识别"><a href="#优化语音识别" class="headerlink" title="优化语音识别"></a>优化语音识别</h4><p>相对于离线版，优化版除了具有本地的语音识别之外，还加入了百度的语音识别API，当本地的语音识别未能匹配到命令时，将音频数据发送到百度语音识别接口，并对返回的文本结果进行解析，逻辑如图（百度智能云语音识别返回结果是utf-8编码的字符串，所以代码编辑器中最好设置utf-8编码.）<br><img src="/2025/05/30/hello-world/ESP32/smart_control/9543ad2ae9994032886c3260f22b4c99.png" alt="在这里插入图片描述"><br><strong>语音模块的工作流程如下：</strong></p>
<p>麦克风输入的音频经过音频解码芯片，通过IIS进入到ESP32内存，经过降噪处理输入WakeNet检测是否存在唤醒词，若有唤醒词则进入语音识别，将音频输入MultiNet匹配命令词，同时缓存音频数据。</p>
<p>若匹配成功则会执行命令内容，若经过设置的时间（eg 4s）匹配失败，则将缓存的音频数据通过Baidu ASR发送到百度智能云并读取返回的文本结果，对结果解析出命令内容执行。</p>
<h3 id="2、BLE模块"><a href="#2、BLE模块" class="headerlink" title="2、BLE模块"></a>2、BLE模块</h3><p>ESP32支持蓝牙双模，目前仅使用蓝牙进行配网（即给esp32发送wifi名称和密码，使esp32连接到wifi）。所以使用ble更合适。</p>
<p>BLE（低功耗蓝牙），适合数据量较小的场合，ESP32支持完整的BLE协议栈，以ESP32作为BLE从机，发送广播、建立GATT Server并等待客户端连接。客户端以微信小程序BLE为例。小程序与ESP32蓝牙通信过程如下图：</p>
<p>ESP32建立一张profile、并创建一个wifi service、用于配置ESP32的wifi。小程序可向wii service 的相应属性中写入数据，来配置ESP32的wifi。</p>
<blockquote>
<p>如图，向SSID、PSWD、CONFIG分别写入下值，ESP32会自动连接到路由器esp</p>
</blockquote>
<p><img src="/2025/05/30/hello-world/ESP32/smart_control/e4f4c07f8b374693af52fc1b267c2fb0.png" alt="在这里插入图片描述"></p>
<h3 id="3、MQTT模块"><a href="#3、MQTT模块" class="headerlink" title="3、MQTT模块"></a>3、MQTT模块</h3><p>该模块使用mqtt_client库实现mqtt客户端进程的登陆，订阅，发布等功能。MQTT broker则使用华为云的设备接入IOT平台。</p>
<p>华为云平台为每个设备定义了以下多个主题，用于最基本的mqtt消息上传和下发，本模块参考了<a target="_blank" rel="noopener" href="https://support.huaweicloud.com/api-iothub/iot_06_v5_3011.html">设备接入Iota-&gt;API参考-&gt;设备侧mqtt接口参考</a><br><strong>上传</strong></p>
<ul>
<li><p>设备消息上报：设备无法按照产品模型中定义的属性格式进行数据上报时，将设备的自定义数据通过设备消息上报接口上报给平台，平台将设备上报的消息转发给应用服务器或华为云其他云服务上进行存储和处理。</p>
</li>
<li><p>设备属性上报：用于设备按产品模型中定义的格式将属性数据上报给平台。</p>
</li>
<li><p>网关批量属性上报：用于网关设备将多个设备的属性数据一次性上报给平台。</p>
</li>
<li><p>设备事件上报：用于设备按产品模型中定义的格式将事件数据上报给平台。</p>
</li>
</ul>
<p><strong>下发</strong></p>
<ul>
<li><p>平台消息下发：用于平台下发自定义格式的数据给设备。</p>
</li>
<li><p>平台设置设备属性：设备的产品模型中定义了平台可向设备设置的属性，应用服务器可通过属性设置的方式修改指定设备的属性值。</p>
</li>
<li><p>平台查询设备属性：应用服务器通过属性查询的方式，实时查询指定设备的属性数据。</p>
</li>
<li><p>平台命令下发：应用服务器按产品模型中定义的命令格式下发控制命令给设备。</p>
</li>
<li><p>平台事件下发：应用服务器按产品模型中定义的事件格式下发事件给设备。</p>
</li>
</ul>
<p>目前实现的软件框架如图所示：<br><img src="/2025/05/30/hello-world/ESP32/smart_control/ec02f9b0affc47ae88edbe62e6b827a5.png" alt="在这里插入图片描述"></p>
<h4 id="3-1、命令下发"><a href="#3-1、命令下发" class="headerlink" title="3.1、命令下发"></a>3.1、命令下发</h4><p>该功能实现参考<a target="_blank" rel="noopener" href="https://console.huaweicloud.com/iotdm/?region=cn-north-4&locale=zh-cn#/dm-portal/device/all-device/device-detail/60b9c9383744a602a5cb9bf3_smart_control_01?appId=7e7b135b6d664d92be89ed696290524d&productId=60b9c9383744a602a5cb9bf3">华为云平台命令下发文档</a><br>华为云平台下发的mqtt命令topic格式固定为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$oc/devices/&#123;device_id&#125;/sys/commands/request_id=&#123;request_id&#125; </span><br></pre></td></tr></table></figure>
<p>数据段中的json数据是命令的具体内容（由用户定义），如空调的控制命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;paras&quot;</span>:&#123;<span class="string">&quot;ac_power&quot;</span>:<span class="number">1</span>,<span class="string">&quot;ac_temp&quot;</span>:<span class="number">27</span>,<span class="string">&quot;ac_wind_speed&quot;</span>:<span class="number">2</span>,<span class="string">&quot;ac_mode&quot;</span>:<span class="number">0</span>&#125;,<span class="string">&quot;service_id&quot;</span>:<span class="string">&quot;ac_control&quot;</span>,<span class="string">&quot;command_name&quot;</span>:<span class="string">&quot;ac_control&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2、设备属性上报"><a href="#3-2、设备属性上报" class="headerlink" title="3.2、设备属性上报"></a>3.2、设备属性上报</h4><p>设备端可主动上报设备的属性（空调的状态，温度），mqtt消息发布的topic为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topic: $oc/devices/&#123;device_id&#125;/sys/properties/report  </span><br></pre></td></tr></table></figure>
<p>并将设备属性以json格式放在数据段中。</p>
<h4 id="3-3、平台查询设备属性"><a href="#3-3、平台查询设备属性" class="headerlink" title="3.3、平台查询设备属性"></a>3.3、平台查询设备属性</h4><p>平台通过给该设备主题发布消息，通知设备端上报属性信息，主题格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$oc/devices/&#123;device_id&#125;/sys/properties/get/request_id=&#123;request_id&#125;</span><br></pre></td></tr></table></figure>
<p>数据段为json数据，包含要求上报的属性。</p>
<h4 id="3-4、应用侧接口"><a href="#3-4、应用侧接口" class="headerlink" title="3.4、应用侧接口"></a>3.4、应用侧接口</h4><p>还可以通过华为云提供的应用侧接口，查询，控制设备的信息，实现在手机&#x2F;网页端对设备的管理。</p>
<h3 id="4、音频播放模块"><a href="#4、音频播放模块" class="headerlink" title="4、音频播放模块"></a>4、音频播放模块</h3><p>本项目板子上装备了两个喇叭，可以用于播放音频，可播放 本地音频 和 网络音频流 。如图所示，由于嵌入式设备内存有限，故本地音频主要是一些简单的提示语音，其优点是播放速度快，响应及时；而HTTP音频流能灵活播放音频，但其受限于网络环境，故将二者结合互补。<br><img src="/2025/05/30/hello-world/ESP32/smart_control/dadd9504768e4ec4b2890331e80c3bab.png" alt="在这里插入图片描述"></p>
<h4 id="4-1、播放本地mp3"><a href="#4-1、播放本地mp3" class="headerlink" title="4.1、播放本地mp3"></a>4.1、播放本地mp3</h4><p>该模块的实现方式是在PC端，将mp3文件转换成二进制的音频文件，将音频文件嵌入到芯片的flash中。在程序运行时可通过读取flash中的二进制音频文件，经过mp3解码，输出到音频芯片播放。</p>
<p>由于flash大小有限，故音频文件只能很短小，适合一些提示性短语，其播放速度也更快。<br>具体实现细节，参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/107934841">esp32播放本地mp3</a></p>
<h4 id="4-3、文本转语音"><a href="#4-3、文本转语音" class="headerlink" title="4.3、文本转语音"></a>4.3、文本转语音</h4><p>文本转语音的核心就是依靠百度AI平台的文本转语音接口，设备端只需要准备好文本数据，发送到AI平台的文本转语音接口，并从该接口中获取音频数据，将该音频数据输出到音频芯片进行播放。</p>
<p>实现的详细代码参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/109107687">esp32a1s 百度文本转语音实现</a></p>
<h3 id="5、红外模块"><a href="#5、红外模块" class="headerlink" title="5、红外模块"></a>5、红外模块</h3><p>目前的家具，电器中，仍有很多电器使用红外遥控，特别是空调。同类型的设备使用的红外协议大同小异，并且都可以查看其协议内容。</p>
<p>红外模块可发送不同类型，品牌的产品的红外控制信号，同时具备<strong>学习功能</strong>，能通过遥控器，学习设备的红外协议。</p>
<h4 id="5-1、红外发射"><a href="#5-1、红外发射" class="headerlink" title="5.1、红外发射"></a>5.1、红外发射</h4><p>红外遥控是通过特定的LED发射信号，设备接收该信号来响应。</p>
<p>在ESP32端来看，所有的红外信号都可看成一个方波信号，ESP32只要能产生所需要的方波信号，结合发射硬件，就能实现红外发射。ESP32中提供了一个叫RMT控制器的设备来控制信号，可利用该RMT控制器，产生所需的方波信号。</p>
<p>如何使用RMT产生方波，可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/108592858">红外发射与接收</a>；</p>
<p>了解了如何产生方波，但更重要的是如何获取方波信号的电平状态和持续时长，这些信息就是红外传输的具体内容。很幸运的是，一些开源红外遥控码库提供了这些信息，本模块使用的Irext就是一个开源万能红外遥控码库、编解码压缩算法以及免费周边服务。</p>
<p>将所需要的码库二进制文件下载到文件系统，就能在程序运行时，通过文件系统打开码库，输入电器类型及遥控命令，即可生成一个特定的数组，该数组表示了方波信号的电平高低及电平时长，即可产生所需的方波信号。</p>
<p>如何使用irext实现该功能，请参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/109292942">基于irext实现万能遥控器</a></p>
<h4 id="5-2、红外学习"><a href="#5-2、红外学习" class="headerlink" title="5.2、红外学习"></a>5.2、红外学习</h4><p>红外学习主要用于快速配置空调协议。用本地空调遥控器，给esp32发射<code>制冷模式 开机 26° 一级风速 自动扫风</code>的特定命令，程序会从本地码库中匹配对应的协议。</p>
<p>红外接收的重点是解析输入的信号并将其与本地数据库进行匹配。目前由人工分别完成了对格力，美的，海尔三种空调的不同协议的分析并生成数据库，并在代码中实现对他们的识别。</p>
<p>红外接收任务负责接收与识别的实现，由parse_items()和ir_code_lib_update()完成信号识别，匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到的红外信号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RX_signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> item_num;  <span class="comment">//item数量</span></span><br><span class="line">    <span class="type">uint32_t</span> lowlevel;  <span class="comment">//低电平时间 us</span></span><br><span class="line">    <span class="type">uint32_t</span> highlevel_1;   <span class="comment">//高电平1的时间</span></span><br><span class="line">    <span class="type">uint32_t</span> highlevel_0;   <span class="comment">//高电平0的时间</span></span><br><span class="line">    <span class="type">uint32_t</span> encode;    <span class="comment">//由0和1组成的编码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 红外接收任务 rmt_rx_start()执行后才会接收数据</span></span><br><span class="line"><span class="comment"> * 接收的数据以item的数据结构存放到nvs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rmt_ir_rxTask</span><span class="params">(<span class="type">void</span> *agr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rx_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    RingbufHandle_t rb = <span class="literal">NULL</span>;</span><br><span class="line">    rmt_get_ringbuf_handle(rx_channel, &amp;rb); <span class="comment">//获取红外接收器接收的数据 放在ringbuff中</span></span><br><span class="line"></span><br><span class="line">    rmt_rx_stop(rx_channel); <span class="comment">//暂停接收</span></span><br><span class="line">    <span class="keyword">while</span> (rb)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从ringbuff读取items 会进入阻塞 直到ringbuff中有新的数据</span></span><br><span class="line">        <span class="type">rmt_item32_t</span> *item = (<span class="type">rmt_item32_t</span> *)xRingbufferReceive(rb, &amp;rx_size, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span> (item)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;rx_size = %u&quot;</span>, rx_size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//!红外线接收器有干扰，需要滤波</span></span><br><span class="line">            <span class="keyword">if</span> (rx_size &gt; <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">RX_signal</span> <span class="title">sig</span>;</span>   <span class="comment">//接收信号结构体</span></span><br><span class="line">                <span class="type">size_t</span> item_num = rx_size / <span class="number">4</span>;  <span class="comment">//一个item32bit</span></span><br><span class="line">                sig.item_num = item_num;</span><br><span class="line">                sig.highlevel_1 = <span class="number">0</span>;</span><br><span class="line">                sig.highlevel_0 = <span class="number">0</span>;</span><br><span class="line">                sig.encode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解析item</span></span><br><span class="line">                parse_items(item, item_num, &amp;sig);</span><br><span class="line"></span><br><span class="line">                ir_code_lib_update(&amp;sig); <span class="comment">//更新ac_handle</span></span><br><span class="line">                rmt_rx_stop(rx_channel);  <span class="comment">//暂停接收</span></span><br><span class="line">                xSemaphoreGive(IR_sem);   <span class="comment">//释放信号量</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析出数据后释放ringbuff的空间</span></span><br><span class="line">            vRingbufferReturnItem(rb, (<span class="type">void</span> *)item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="6、传感器模块"><a href="#6、传感器模块" class="headerlink" title="6、传感器模块"></a>6、传感器模块</h3><p>目前我们的板子上添加了ds18b20温度传感器，用于准确的读取室内的温度。</p>
<h3 id="7、定时模块"><a href="#7、定时模块" class="headerlink" title="7、定时模块"></a>7、定时模块</h3><p>定时模块主要用于记录当前的年份，月份，日期，时间，提供精确到秒的定时提醒服务，支持大时间尺度上的定时，如一天，两天甚至更长时间的定时提醒。其定时的时钟源是freertos的系统时钟。<br>其实现参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/115172987">基于esp32 的时间系统</a></p>
<h3 id="8，无线检测模块"><a href="#8，无线检测模块" class="headerlink" title="8，无线检测模块"></a>8，无线检测模块</h3><p>暂时未完成，预期功能为：能实时检测人体&#x2F;物体在一定空间内的活动状态，如人体是否静止OR活动中，从而来判断空间内是否有人类活动。</p>
<p>其工作原理是利用ESP32的wifi无线信号在复杂空间中传播时，在发送端和接收端之间因为物体移动影响电磁波的多径效应，可用系统的信道频率响应来描述多径传播特性。</p>
<h4 id="8-1、使用相关系数进行人体检测"><a href="#8-1、使用相关系数进行人体检测" class="headerlink" title="8.1、使用相关系数进行人体检测"></a>8.1、使用相关系数进行人体检测</h4><p>根据谈青青的论文，wifi子载波之间相关系数会随着空间环境的变换而变换，当室内无人体活动时，各个载波之间的相关系数相对小，当空间内有人活动时，各个载波会因人体活动而产生变换，此时相关系数会增大。</p>
<p>我的实验：提取2s内的载波振幅，计算相关系数，发现无论何种情况，大部分的子载波的相关系数都接近1，与论文不是很符合，且人体的活动反而导致了相关系数的减小，与论文也不符合。但初期的实验确实证实相关系数可以 反映人体的活动。</p>
<h4 id="8-2、使用振幅平均值进行人体检测"><a href="#8-2、使用振幅平均值进行人体检测" class="headerlink" title="8.2、使用振幅平均值进行人体检测"></a>8.2、使用振幅平均值进行人体检测</h4><p>根据其他论文，一定时间窗口2s内，计算载波的振幅的均值。当空间环境稳定的情况下，振幅均值应该不会出现过大的波动，当人体活动时，振幅均值会受到影响而产生波动。对于esp32的51条子载波，不同的子载波对活动的灵敏度不一样。有的子载波会产生较大的波动，而有的子载波没有明显变化。描述子载波的幅度均值变化程度可以用方差，但实验过程中，全部子载波的方差值似乎不能很好的反映人体活动。但单独一条子载波的振幅均值对人体活动却比较敏感。</p>
<h4 id="8-3、路由器与esp32相对位置对实验的影响"><a href="#8-3、路由器与esp32相对位置对实验的影响" class="headerlink" title="8.3、路由器与esp32相对位置对实验的影响"></a>8.3、路由器与esp32相对位置对实验的影响</h4><p>实验路由器有两种：一般路由器和手机热点。在相关系数实验中，以手机热点为路由的人体检测预期较好，但换成一般路由器则效果很差。</p>
<p>将路由器摆放到较高位置进行实验，实验效果也不明显。</p>
<p><img src="/2025/05/30/hello-world/ESP32/smart_control/20210329225345207.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/smart_control/" data-id="cmbcy7rh2000vt8mtbyjqatno" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ESP32/gree_ir_code_parse" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/gree_ir_code_parse/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.637Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>使用红外遥控空调，就必须先了解红外遥控的原理，数据的定义等。本博客解析了空调的最基本的功能的红外编码，包括：开关，温度，定时，风速，扫风，校验码。其他的功能因为空调型号不同而差别较大，所以暂时不作解析。同时，空调大部分时间工作在制冷模式下，其他模式下的编码也暂时未解析。</p>
</blockquote>
<h2 id="一，红外遥控原理"><a href="#一，红外遥控原理" class="headerlink" title="一，红外遥控原理"></a>一，红外遥控原理</h2><h3 id="1，红外线"><a href="#1，红外线" class="headerlink" title="1，红外线"></a>1，红外线</h3><p>红外线是波长在760nm到1mm的电磁波，根据波长的不同可分为可见光（0.38um-0.76um）和不可见光。使用红外线作为遥控的话，由于红外发射管与红外接收管的响应波长一般为0.8um-0.94um，所以选择波长为0.76um-1.5um的红外光作为通讯的波长。</p>
<p>红外通信广泛应用于家电控制，其优点是抗干扰能力强（频率低），功耗小，性价比高等。</p>
<h3 id="2，工作原理"><a href="#2，工作原理" class="headerlink" title="2，工作原理"></a>2，工作原理</h3><p>发射器发射38khz方波为载波的红外光（占空比50），即红外光以38khz的频率闪烁着，接收器接收到以此频率闪烁的红外光时，会在其信号脚输出高电平信号，否则输出低电平。</p>
<p>根据这个最基本的原理来，来实现编码解码数据。数据就是一组二进制的数据，0和1的区别就是高低电平时间的不同。比如，以下例子中，0与1的区别就是1的高电平时间较长。发射器首先需要编码，根据二进制数据每一位的内容，发射持续时间不一样的红外光（控制低高电平时间），而接收器则需要判断高低电平的时间来解码数据。</p>
<h2 id="二，实验波形"><a href="#二，实验波形" class="headerlink" title="二，实验波形"></a>二，实验波形</h2><p>本实验是基于格力空调的红外数据<br>一帧红外编码数据的组成如下：<br><strong>起始码+35位数据+连接码+32位数据+结束码</strong><br><img src="/2025/05/30/hello-world/ESP32/gree_ir_code_parse/20200921205928763.png" alt="在这里插入图片描述">其中多次测量得出：</p>
<p><strong>起始码：9000us 低电平 + 4500us高电平；<br>连接码：646us低电平 + 20000us高电平；<br>结束码：646us低电平 + 高电平；</strong></p>
<p><strong>数据0：646us低电平 + 516us高电平；<br>数据1：646us低电平 + 1643us高电平；</strong></p>
<p>数据码中的0和1，经过多次的测量，取众数作为依据，实验数据如下：</p>
<p><img src="/2025/05/30/hello-world/ESP32/gree_ir_code_parse/20200921104951188.png" alt="在这里插入图片描述"></p>
<h2 id="三，红外编码解析"><a href="#三，红外编码解析" class="headerlink" title="三，红外编码解析"></a>三，红外编码解析</h2><p>知道了一帧红外数据的0和1的表示，我们就可以自由的组成一帧数据。接下来需要了解的是在一帧数据中，数据位中的每一个bit代表的意思。<br>这里以<code>25℃，制冷模式，低风速，无扫风，打开，定时时间为0</code>的一帧数据为例子：</p>
<h3 id="第一段数据："><a href="#第一段数据：" class="headerlink" title="第一段数据："></a>第一段数据：</h3><p><strong>开关：bit3；</strong></p>
<blockquote>
<p>0：关闭；1：开启</p>
</blockquote>
<p><strong>风速：bit4，bit5；</strong></p>
<blockquote>
<p>自动风速：00<br>一级风速：10<br>二级风速：01<br>三级风速：11</p>
</blockquote>
<p><strong>扫风开关：bit6，以及第二段bit0；</strong></p>
<blockquote>
<p>0：关闭；1：开启</p>
</blockquote>
<p><strong>温度：bit8，bit9，bit10，bit11；</strong></p>
<blockquote>
<p>16℃:	0000<br>17℃:	1000<br>18℃:	0100<br>19℃:	1100<br>20℃:	0010<br>21℃:	1010<br>22℃:	0110<br>23℃:	1110<br>24℃:	0001<br>25℃:	1001<br>26℃:	0101<br>27℃:	1101<br>28℃:	0011</p>
</blockquote>
<p><strong>定时分钟数：bit12，bit13，bit14；</strong></p>
<p>由于我的手机只能发送定时半小时为最小单位的定时时间，所以只有定时30分钟的数据</p>
<blockquote>
<p>30min:	100</p>
</blockquote>
<p><strong>bit15	定时开关；</strong></p>
<blockquote>
<p>0：关闭；1：开启</p>
</blockquote>
<p><strong>定时小时数：bit16，bit17，bit18，bit19；</strong></p>
<blockquote>
<p>一小时：1000<br>两小时：0100<br>三小时：1100<br>…..</p>
</blockquote>
<p><img src="/2025/05/30/hello-world/ESP32/gree_ir_code_parse/20200921215113779.png" alt="在这里插入图片描述"></p>
<h3 id="第二段数据："><a href="#第二段数据：" class="headerlink" title="第二段数据："></a>第二段数据：</h3><p>第二段数据比较简单，需要注意的就是<code>bit0</code>是扫风的开关，她与第一段数据中的<code>bit6</code>是一样的数值。另外是后四位<code>bit28,bit29,bit30,bit31</code>组成的校验码。<br>网上也有许多关于校验码的公式，但是我试了后发现并不适用，于是自己尝试出了一条公式：<br><code>校验码 = 温度 - 18 + 定时小时数 + 空调开关 × 8；</code><br>例如以上例子的校验码是：25 - 18 + 0 + 1× 8 &#x3D; 15 &#x3D; 0xf;<br><img src="/2025/05/30/hello-world/ESP32/gree_ir_code_parse/20200921220014146.png" alt="在这里插入图片描述"></p>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>红外遥控的实现大同小异，最好还是要自己有测试的设备进行代码的测试。红外接收管和逻辑分析仪是你的不二选择。</p>
<p>友情连接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/108592858">esp32实现红外发射与接收</a></p>
<p>作者才疏学浅，难免有错误，希望指正。如果文章对你有帮助，帮忙点个赞呗。</p>
<p><img src="/2025/05/30/hello-world/ESP32/gree_ir_code_parse/weixin.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/gree_ir_code_parse/" data-id="cmbcy7rh1000st8mte3gxhx1e" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ESP32/esp32_weather_report" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/esp32_weather_report/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.636Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文即将为你示例如何使用esp32的wifi，http组件以及百度在线语音合成等功能，实现获取天气数据并通过语音播放。</p>
</blockquote>
<p>@[toc]</p>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>[video(video-9Nehbmpp-1604736367570)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=797685523)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/8eebf58ba36e0518b66f8ec8d28300f84186be1d.jpg)(title-esp32%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%94%BE%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5)%5D">https://player.bilibili.com/player.html?aid=797685523)(image-https://ss.csdn.net/p?http://i2.hdslb.com/bfs/archive/8eebf58ba36e0518b66f8ec8d28300f84186be1d.jpg)(title-esp32语音播放天气预报)]</a></p>
<h2 id="一，请求天气数据"><a href="#一，请求天气数据" class="headerlink" title="一，请求天气数据"></a>一，请求天气数据</h2><h3 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h3><p>利用esp32的http组件，向Web API请求天气数据，我使用的是万维易源提供的API接口，这个接口的调用比较简单，而且提供了1000次的额度，还是比较良心的。</p>
<p><strong>请求的方式也很简单，使用GET方式向天气接口发起请求，服务端会返回json格式的当地城市的天气数据。后续我们只要解析出json中的数据，提取我们想要的天气数据。</strong></p>
<h3 id="1-2-注册账号"><a href="#1-2-注册账号" class="headerlink" title="1.2 注册账号"></a>1.2 注册账号</h3><p>在<a target="_blank" rel="noopener" href="https://www.showapi.com/">官网</a>注册账号，进入控制台，找到<code>接口使用者-》我的应用</code>，系统默认创建了一个应用，<code>just_test_app</code>，将这个应用的<code>showapi_appid</code>，和<code>sercret</code>保存下来，我们需要这两个数据作为请求参数。<br>然后进入<a target="_blank" rel="noopener" href="https://www.showapi.com/apiGateway/view/9?tab=productPrice&skuid=5ee9cb656e36cf1eb67506c1">天气api接口文档</a>，购买0.00元档的套餐，到这一步，你已经可用使用它的接口了。<br>在接口文档中，可以选择根据不同的参数来获取天气数据，这里我选择ip查询。当ip的参数为空时，会默认返回客户端的ip地址的城市的信息。<br><img src="/2025/05/30/hello-world/ESP32/esp32_weather_report/20201105225915438.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-获取数据"><a href="#1-3-获取数据" class="headerlink" title="1.3 获取数据"></a>1.3 获取数据</h3><p><strong>通过ip获取天气的url是<code>https://route.showapi.com/9-4</code>，我们只需要在url后加入<code>showapi_appid</code>和<code>showapi_sign</code>两个参数(showapi_sign就是上文的sercret)，然后发起GET请求，就能接收到返回的json字符串。</strong><br>例如我的url是：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://route.showapi.com/9-4?showapi_appid=421387&showapi_sign=f5f3b508fd6c43e09457be788b251a32">https://route.showapi.com/9-4?showapi_appid=421387&amp;showapi_sign=f5f3b508fd6c43e09457be788b251a32</a></p>
</blockquote>
<p>http请求代码，<strong>具体逻辑见代码注释</strong></p>
<p>全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> http_data[MX_HTTP_BUFF]; <span class="comment">//! 需要定义为全局静态变量，否则会导致任务的堆栈溢出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEATHER_URL <span class="string">&quot;https://route.showapi.com/9-4?showapi_appid=421387&amp;showapi_sign=f5f3b508fd6c43e09457be788b251a32&quot;</span></span></span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> err;</span><br><span class="line"><span class="type">esp_http_client_config_t</span> config = &#123;</span><br><span class="line">            .url = WEATHER_URL,     <span class="comment">//http请求地址</span></span><br><span class="line">            .event_handler = _http_event_handle,    <span class="comment">//http请求回调函数</span></span><br><span class="line">            .method = HTTP_METHOD_GET,      <span class="comment">//GET方式</span></span><br><span class="line">            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">esp_http_client_handle_t</span> client = esp_http_client_init(&amp;config);</span><br><span class="line">AUDIO_MEM_CHECK(TAG, client, <span class="keyword">return</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起请求</span></span><br><span class="line"><span class="keyword">if</span>(esp_http_client_open(client,<span class="number">0</span>)!=ESP_OK)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取返回头</span></span><br><span class="line">esp_http_client_fetch_headers(client);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;Status = %d, content_length = %d&quot;</span>,esp_http_client_get_status_code(client),esp_http_client_get_content_length(client));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//读取返回的数据到http_data</span></span><br><span class="line">	<span class="type">int</span> read_len = esp_http_client_read(client, http_data + index, max_len - index);</span><br><span class="line">	<span class="comment">//读取完毕</span></span><br><span class="line">    <span class="keyword">if</span>(read_len &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index += read_len;</span><br><span class="line">    total += read_len;</span><br><span class="line">    http_data[index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(total&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		ESP_LOGI(TAG,<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	esp_http_client_close(client);</span><br><span class="line">	esp_http_client_cleanup(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二，解析JSON字符串"><a href="#二，解析JSON字符串" class="headerlink" title="二，解析JSON字符串"></a>二，解析JSON字符串</h2><h3 id="2-1-天气数据"><a href="#2-1-天气数据" class="headerlink" title="2.1 天气数据"></a>2.1 天气数据</h3><p>通过将返回的json数据格式化，可得到下面的json数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;showapi_res_error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	<span class="string">&quot;showapi_res_id&quot;</span>: <span class="string">&quot;5fa415b48d57ba1617db793e&quot;</span>,</span><br><span class="line">	<span class="string">&quot;showapi_res_code&quot;</span>: 0,</span><br><span class="line">	<span class="string">&quot;showapi_res_body&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;time&quot;</span>: <span class="string">&quot;20201105180000&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ret_code&quot;</span>: 0,</span><br><span class="line">		<span class="string">&quot;now&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;aqiDetail&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;num&quot;</span>: <span class="string">&quot;95&quot;</span>,</span><br><span class="line">				<span class="string">&quot;co&quot;</span>: <span class="string">&quot;0.5&quot;</span>,</span><br><span class="line">				<span class="string">&quot;so2&quot;</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">				<span class="string">&quot;area&quot;</span>: <span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">				<span class="string">&quot;o3&quot;</span>: <span class="string">&quot;84&quot;</span>,</span><br><span class="line">				<span class="string">&quot;no2&quot;</span>: <span class="string">&quot;32&quot;</span>,</span><br><span class="line">				<span class="string">&quot;aqi&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">				<span class="string">&quot;quality&quot;</span>: <span class="string">&quot;良好&quot;</span>,</span><br><span class="line">				<span class="string">&quot;pm10&quot;</span>: <span class="string">&quot;52&quot;</span>,</span><br><span class="line">				<span class="string">&quot;pm2_5&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">				<span class="string">&quot;o3_8h&quot;</span>: <span class="string">&quot;98&quot;</span>,</span><br><span class="line">				<span class="string">&quot;primary_pollutant&quot;</span>: <span class="string">&quot;颗粒物(PM10)&quot;</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;wind_direction&quot;</span>: <span class="string">&quot;东风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;temperature_time&quot;</span>: <span class="string">&quot;23:00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;wind_power&quot;</span>: <span class="string">&quot;1级&quot;</span>,</span><br><span class="line">			<span class="string">&quot;aqi&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sd&quot;</span>: <span class="string">&quot;78%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;temperature&quot;</span>: <span class="string">&quot;22&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;cityInfo&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;c6&quot;</span>: <span class="string">&quot;guangdong&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c5&quot;</span>: <span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c4&quot;</span>: <span class="string">&quot;shenzhen&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c3&quot;</span>: <span class="string">&quot;宝安&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c9&quot;</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c8&quot;</span>: <span class="string">&quot;china&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c7&quot;</span>: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c17&quot;</span>: <span class="string">&quot;+8&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c16&quot;</span>: <span class="string">&quot;AZ9755&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c1&quot;</span>: <span class="string">&quot;101280605&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c2&quot;</span>: <span class="string">&quot;baoan&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c0&quot;</span>: <span class="string">&quot;440306&quot;</span>,</span><br><span class="line">			<span class="string">&quot;longitude&quot;</span>: 113.878,</span><br><span class="line">			<span class="string">&quot;c11&quot;</span>: <span class="string">&quot;0755&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c10&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">			<span class="string">&quot;latitude&quot;</span>: 22.556,</span><br><span class="line">			<span class="string">&quot;c12&quot;</span>: <span class="string">&quot;518001&quot;</span>,</span><br><span class="line">			<span class="string">&quot;c15&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;showapi_fee_code&quot;</span>: 0,</span><br><span class="line">		<span class="string">&quot;f1&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;night_weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;jiangshui&quot;</span>: <span class="string">&quot;0%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;air_press&quot;</span>: <span class="string">&quot;1005 hPa&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sun_begin_end&quot;</span>: <span class="string">&quot;06:25|16:20&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ziwaixian&quot;</span>: <span class="string">&quot;很强&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/day/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weekday&quot;</span>: 4,</span><br><span class="line">			<span class="string">&quot;night_air_temperature&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_air_temperature&quot;</span>: <span class="string">&quot;27&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_direction&quot;</span>: <span class="string">&quot;北风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day&quot;</span>: <span class="string">&quot;20201105&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_direction&quot;</span>: <span class="string">&quot;无持续风向&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;f3&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;night_weather_code&quot;</span>: <span class="string">&quot;07&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather&quot;</span>: <span class="string">&quot;小雨&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather&quot;</span>: <span class="string">&quot;小雨&quot;</span>,</span><br><span class="line">			<span class="string">&quot;jiangshui&quot;</span>: <span class="string">&quot;70%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;air_press&quot;</span>: <span class="string">&quot;1005 hPa&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_code&quot;</span>: <span class="string">&quot;07&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sun_begin_end&quot;</span>: <span class="string">&quot;06:28|16:17&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ziwaixian&quot;</span>: <span class="string">&quot;最弱&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/day/07.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weekday&quot;</span>: 6,</span><br><span class="line">			<span class="string">&quot;night_air_temperature&quot;</span>: <span class="string">&quot;21&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_air_temperature&quot;</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_direction&quot;</span>: <span class="string">&quot;东北风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day&quot;</span>: <span class="string">&quot;20201107&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/07.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_direction&quot;</span>: <span class="string">&quot;东北风&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;f2&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;night_weather_code&quot;</span>: <span class="string">&quot;07&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather&quot;</span>: <span class="string">&quot;晴&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather&quot;</span>: <span class="string">&quot;小雨&quot;</span>,</span><br><span class="line">			<span class="string">&quot;jiangshui&quot;</span>: <span class="string">&quot;0%&quot;</span>,</span><br><span class="line">			<span class="string">&quot;air_press&quot;</span>: <span class="string">&quot;1005 hPa&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_power&quot;</span>: <span class="string">&quot;0-3级 &lt;5.4m/s&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_code&quot;</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">			<span class="string">&quot;sun_begin_end&quot;</span>: <span class="string">&quot;06:27|16:18&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ziwaixian&quot;</span>: <span class="string">&quot;很强&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/day/00.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;weekday&quot;</span>: 5,</span><br><span class="line">			<span class="string">&quot;night_air_temperature&quot;</span>: <span class="string">&quot;21&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_wind_direction&quot;</span>: <span class="string">&quot;无持续风向&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day_air_temperature&quot;</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_wind_direction&quot;</span>: <span class="string">&quot;东北风&quot;</span>,</span><br><span class="line">			<span class="string">&quot;night_weather_pic&quot;</span>: <span class="string">&quot;http://app1.showapi.com/weather/icon/night/07.png&quot;</span>,</span><br><span class="line">			<span class="string">&quot;day&quot;</span>: <span class="string">&quot;20201106&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用cJSON解析出字符串"><a href="#2-2-使用cJSON解析出字符串" class="headerlink" title="2.2 使用cJSON解析出字符串"></a>2.2 使用cJSON解析出字符串</h3><p><strong>cJSON</strong>是一个用C语言写的专门用于处理json数据的库。官方地址：<a target="_blank" rel="noopener" href="http://www.json.org/">http://www.json.org/</a>。idf中已经集成了cjson组件。</p>
<p>以下代码示例展示了如何使用cjson解析出json字符串里的数据，并将字符串拼接成一句流畅的句子。简单的展示，只读取json中的天气和温度数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> data[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//解析整个json</span></span><br><span class="line">	cJSON *root = cJSON_Parse(http_data);</span><br><span class="line">	<span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">          ESP_LOGI(TAG, <span class="string">&quot;error,json parse error&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="comment">//获取showapi_res_body </span></span><br><span class="line">    cJSON *showapi_res_body = cJSON_GetObjectItem(root,<span class="string">&quot;showapi_res_body&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*---------今天天气数据----------------------------*/</span></span><br><span class="line">	cJSON *f1 = cJSON_GetObjectItem(showapi_res_body, <span class="string">&quot;f1&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//白天的天气</span></span><br><span class="line">	cJSON *item = cJSON_GetObjectItem(f1, <span class="string">&quot;day_weather&quot;</span>);</span><br><span class="line">	<span class="type">char</span> *day_weather = cJSON_GetStringValue(item);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//白天的气温</span></span><br><span class="line">	item = cJSON_GetObjectItem(f1, <span class="string">&quot;day_air_temperature&quot;</span>);</span><br><span class="line">	<span class="type">char</span> *day_air_temperature = cJSON_GetStringValue(item);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//拼接成一句话，如：今天，天气晴，气温26度</span></span><br><span class="line">	<span class="built_in">snprintf</span>(data, <span class="number">50</span>, <span class="string">&quot;今天，天气%s,气温%s度&quot;</span>, day_weather,day_air_temperature);</span><br><span class="line">	</span><br><span class="line">	cJSON_Delete(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>几个重要的函数：</p>
<p><strong>将json字符串转化成json类型的对象，这个函数必须在其他函数之前执行。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Parse(<span class="type">const</span> <span class="type">char</span> *value)</span><br></pre></td></tr></table></figure>


<p><strong>根据键值获取cjson对象的一个成员，这个成员可以也是一个json对象</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_GetObjectItem(<span class="type">const</span> cJSON * <span class="type">const</span> object, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> <span class="built_in">string</span>)</span><br></pre></td></tr></table></figure>

<p><strong>获取json对象数组中的指定成员。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_GetArrayItem(<span class="type">const</span> cJSON *<span class="built_in">array</span>, <span class="type">int</span> index);</span><br></pre></td></tr></table></figure>

<p><strong>获取json对象里的字符串</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_GetStringValue(cJSON *item);</span><br></pre></td></tr></table></figure>

<h2 id="三，语音合成"><a href="#三，语音合成" class="headerlink" title="三，语音合成"></a>三，语音合成</h2><p>使用百度语音合成，将拼接的字符串转换成语音，通过喇叭播放出来。<br>如何将文字转换成语音，请参考另一篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/109107687">ESP32使用百度语音合成 实现文字转语音播放</a></p>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>天气API只是一个例子，网上有许多开放的API可玩，各位有什么好玩的API也可以在评论留言<br><img src="/2025/05/30/hello-world/ESP32/esp32_weather_report/20201105165502804.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/esp32_weather_report/" data-id="cmbcy7rh0000ot8mtagqr7qnp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
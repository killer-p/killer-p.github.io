<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/README/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.671Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="KillerBlog"><a href="#KillerBlog" class="headerlink" title="KillerBlog"></a>KillerBlog</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Killer blog 是killerp的嵌入式软件技术博客，分享嵌入式软件知识，包括Linux、rtos、项目、rust、STM32、esp32等。</p>
<h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><p><a href="mailto:&#x31;&#50;&#52;&#51;&#x37;&#57;&#52;&#x37;&#48;&#x30;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;">1243794700@qq.com</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/README/" data-id="cmbcy7rgn0000t8mt06mhdypw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/dsoftbus_core" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/dsoftbus_core/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.670Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dsoftbus-core（上）"><a href="#dsoftbus-core（上）" class="headerlink" title="dsoftbus core（上）"></a>dsoftbus core（上）</h2><p>好，现在压力给到了core目录，这里是服务端的实现，代码应该会复杂很多，我门应该从哪里入手？softbus服务必须向samgr注册，那么就从这个入手。</p>
<p>了解一下samgr这个是如何使用的。</p>
<h3 id="samgr"><a href="#samgr" class="headerlink" title="samgr"></a>samgr</h3><p>这个samgr的使用还有复杂，建议直接看readme：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/distributedschedule_samgr_lite">https://gitee.com/openharmony/distributedschedule_samgr_lite</a></p>
<h4 id="开发服务"><a href="#开发服务" class="headerlink" title="开发服务"></a>开发服务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义服务</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ExampleService</span> &#123;</span></span><br><span class="line">    INHERIT_SERVICE;</span><br><span class="line">    INHERIT_IUNKNOWNENTRY(DefaultFeatureApi);</span><br><span class="line">    Identity identity;</span><br><span class="line">&#125; ExampleService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="type">static</span> ExampleService g_example = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle,</span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,</span><br><span class="line">        .Invoke = <span class="literal">NULL</span>,</span><br><span class="line">        .SyncCall = SyncCall,</span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向samgr注册接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_example);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(EXAMPLE_SERVICE, GET_IUNKNOWN(g_example));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义服务初始化入口</span></span><br><span class="line">SYSEX_SERVICE_INIT(Init);</span><br></pre></td></tr></table></figure>

<h4 id="开发服务子功能"><a href="#开发服务子功能" class="headerlink" title="开发服务子功能"></a>开发服务子功能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义功能</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DemoFeature</span> &#123;</span></span><br><span class="line">    INHERIT_FEATURE;</span><br><span class="line">    INHERIT_IUNKNOWNENTRY(DemoApi);</span><br><span class="line">    Identity identity;</span><br><span class="line">    Service *parent;</span><br><span class="line">&#125; DemoFeature;</span><br><span class="line"><span class="comment">//功能对象</span></span><br><span class="line"><span class="type">static</span> DemoFeature g_example = &#123;</span><br><span class="line">    .GetName = FEATURE_GetName,</span><br><span class="line">    .OnInitialize = FEATURE_OnInitialize,</span><br><span class="line">    .OnStop = FEATURE_OnStop,</span><br><span class="line">    .OnMessage = FEATURE_OnMessage,</span><br><span class="line">    DEFAULT_IUNKNOWN_ENTRY_BEGIN,</span><br><span class="line">        .AsyncCall = AsyncCall,</span><br><span class="line">        .AsyncTimeCall = AsyncTimeCall,</span><br><span class="line">        .SyncCall = SyncCall,</span><br><span class="line">        .AsyncCallBack = AsyncCallBack,</span><br><span class="line">    DEFAULT_IUNKNOWN_ENTRY_END,</span><br><span class="line">    .identity = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//向samgr注册功能接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterFeature(EXAMPLE_SERVICE, (Feature *)&amp;g_example);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterFeatureApi(EXAMPLE_SERVICE, EXAMPLE_FEATURE, GET_IUNKNOWN(g_example));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义功能初始化入口</span></span><br><span class="line">SYSEX_FEATURE_INIT(Init);</span><br></pre></td></tr></table></figure>

<h3 id="softbus-server"><a href="#softbus-server" class="headerlink" title="softbus server"></a>softbus server</h3><p>好，让我来看看软总线服务是如何定义的</p>
<p>在<code>core/frame/small/init/src/softbus_server_stub.c</code>中，有softbus的注册服务的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(WAIT_FOR_SERVER);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_samgrService);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(SOFTBUS_SERVICE, GET_IUNKNOWN(g_samgrService));</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;Init success %s&quot;</span>, SOFTBUS_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line">SYSEX_SERVICE_INIT(Init);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来是softbus服务的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SoftbusSamgrService g_samgrService = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle, </span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,</span><br><span class="line">    .Invoke = Invoke,   <span class="comment">//重要：其他进程调用的IPC，会调用这个函数</span></span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我门来关注一下Invoke：不难理解，通过funcId来索引找到对应的处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">Invoke</span><span class="params">(IServerProxy *iProxy, <span class="type">int</span> funcId, <span class="type">void</span> *origin, IpcIo *req, IpcIo *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tblSize = <span class="keyword">sizeof</span>(g_serverInvokeCmdTbl) / <span class="keyword">sizeof</span>(ServerInvokeCmd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tblSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (funcId == g_serverInvokeCmdTbl[i].id) &#123;</span><br><span class="line">            <span class="keyword">return</span> g_serverInvokeCmdTbl[i].func(origin, req, reply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以找到softbus提供的全部IPC接口拉，应该可以和sdk目录下的函数相对应的，接下来我们就从这些函数入手，来了解整个core层中的发现，连接、组网，传输是如何实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ServerInvokeCmd g_serverInvokeCmdTbl[] = &#123;</span><br><span class="line">    &#123; MANAGE_REGISTER_SERVICE, ServerRegisterService &#125;,</span><br><span class="line">    &#123; SERVER_PUBLISH_SERVICE, ServerPublishService &#125;,</span><br><span class="line">    &#123; SERVER_UNPUBLISH_SERVICE, ServerUnPublishService &#125;,</span><br><span class="line">    &#123; SERVER_START_DISCOVERY, ServerStartDiscovery &#125;,</span><br><span class="line">    &#123; SERVER_STOP_DISCOVERY, ServerStopDiscovery &#125;,</span><br><span class="line">    &#123; SERVER_JOIN_LNN, ServerJoinLNN &#125;,</span><br><span class="line">    &#123; SERVER_LEAVE_LNN, ServerLeaveLNN &#125;,</span><br><span class="line">    &#123; SERVER_GET_ALL_ONLINE_NODE_INFO, ServerGetAllOnlineNodeInfo &#125;,</span><br><span class="line">    &#123; SERVER_GET_LOCAL_DEVICE_INFO, ServerGetLocalDeviceInfo &#125;,</span><br><span class="line">    &#123; SERVER_GET_NODE_KEY_INFO, ServerGetNodeKeyInfo &#125;,</span><br><span class="line">    &#123; SERVER_START_TIME_SYNC, ServerStartTimeSync &#125;,</span><br><span class="line">    &#123; SERVER_STOP_TIME_SYNC, ServerStopTimeSync &#125;,</span><br><span class="line">    &#123; SERVER_PUBLISH_LNN, ServerPublishLNN &#125;,</span><br><span class="line">    &#123; SERVER_STOP_PUBLISH_LNN, ServerStopPublishLNN &#125;,</span><br><span class="line">    &#123; SERVER_REFRESH_LNN, ServerRefreshLNN &#125;,</span><br><span class="line">    &#123; SERVER_STOP_REFRESH_LNN, ServerStopRefreshLNN &#125;,</span><br><span class="line">    &#123; SERVER_ACTIVE_META_NODE, ServerActiveMetaNode&#125;,</span><br><span class="line">    &#123; SERVER_DEACTIVE_META_NODE, ServerDeactiveMetaNode &#125;,</span><br><span class="line">    &#123; SERVER_GET_ALL_META_NODE_INFO, ServerGetAllMetaNodeInfo &#125;,</span><br><span class="line">    &#123; SERVER_CREATE_SESSION_SERVER, ServerCreateSessionServer &#125;,</span><br><span class="line">    &#123; SERVER_REMOVE_SESSION_SERVER, ServerRemoveSessionServer &#125;,</span><br><span class="line">    &#123; SERVER_OPEN_SESSION, ServerOpenSession &#125;,</span><br><span class="line">    &#123; SERVER_OPEN_AUTH_SESSION, ServerOpenAuthSession&#125;,</span><br><span class="line">    &#123; SERVER_NOTIFY_AUTH_SUCCESS, ServerNotifyAuthSuccess&#125;,</span><br><span class="line">    &#123; SERVER_CLOSE_CHANNEL, ServerCloseChannel &#125;,</span><br><span class="line">    &#123; SERVER_SESSION_SENDMSG, ServerSendSessionMsg &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="发现：ServerStartDiscovery"><a href="#发现：ServerStartDiscovery" class="headerlink" title="发现：ServerStartDiscovery"></a>发现：ServerStartDiscovery</h3><p>我门就以ServerStartDiscovery来看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pkgName = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">SubscribeSerializer *info = (SubscribeSerializer *)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line"><span class="type">char</span> *capability = (<span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">callingUid = GetCallingUid(origin);</span><br><span class="line">DiscIpcStartDiscovery(pkgName, &amp;subscribeInfo);</span><br><span class="line">    SetCallLnnStatus(<span class="literal">false</span>);    <span class="comment">//g_isCallLnn = flag;</span></span><br><span class="line">    DiscStartDiscovery(packageName, info, &amp;g_discInnerCb);</span><br><span class="line">        DiscInfo *infoNode = CreateNewSubscribeInfoNode(info);</span><br><span class="line">        InnerStartDiscovery(packageName, infoNode, cb, SUBSCRIBE_SERVICE);</span><br><span class="line">            AddInfoToList(g_discoveryInfoList, packageName, &amp;callback, info, type);</span><br><span class="line">            DiscInterfaceByMedium(info, STARTDISCOVERTY_FUNC);</span><br><span class="line">                DiscInterfaceProcess(&amp;(info-&gt;option), g_discCoapInterface, info-&gt;mode, type);</span><br><span class="line">                    interface-&gt;StartAdvertise(&amp;(option-&gt;subscribeOption))</span><br><span class="line">                    interface-&gt;Subscribe(&amp;(option-&gt;subscribeOption))</span><br><span class="line">    ClientIpcDiscoverySuccess(packageName, info-&gt;subscribeId);</span><br></pre></td></tr></table></figure>

<p>好吧，最后是使用interface的StartAdvertise和Subscribe方法，来看看g_discCoapInterface是在哪里定义的：</p>
<p>其实例化的地方是在：disc_manager.c中的DiscMgrInit()，主要还是初始化一些结构体,在DiscCoapInit中实例化的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g_discMgrMediumCb.OnDeviceFound = DiscOnDeviceFound;</span><br><span class="line">g_discCoapInterface = DiscCoapInit(&amp;g_discMgrMediumCb);</span><br><span class="line">g_discBleInterface = DiscBleInit(&amp;g_discMgrMediumCb);</span><br><span class="line">g_publishInfoList = CreateSoftBusList();</span><br><span class="line">g_discoveryInfoList = CreateSoftBusList();    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来看看DiscCoapInit()做了什么，这一部分和我门的softbus_lite很相似，coap的东西我就不去深究，大伙知道他的协议大概是啥就行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InitCoapManager()</span><br><span class="line">DiscNstackxInit()</span><br><span class="line">DiscCoapRegisterCb(discInnerCb)</span><br><span class="line"><span class="keyword">return</span> &amp;g_discCoapFuncInterface;</span><br></pre></td></tr></table></figure>

<p>下面就是g_discCoapInterface的实例化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> DiscoveryFuncInterface g_discCoapFuncInterface = &#123;</span><br><span class="line">    .Publish = CoapPublish,</span><br><span class="line">    .StartScan = CoapStartScan,</span><br><span class="line">    .Unpublish = CoapUnPublish,</span><br><span class="line">    .StopScan = CoapStopScan,</span><br><span class="line">    .StartAdvertise = CoapStartAdvertise,</span><br><span class="line">    .Subscribe = CoapSubscribe,</span><br><span class="line">    .StopAdvertise = CoapStopAdvertise,</span><br><span class="line">    .Unsubscribe = CoapUnsubscribe,</span><br><span class="line">    .LinkStatusChanged = CoapUpdateLocalIp</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看看CoapStartAdvertise：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RegisterAllCapBitmap</span><br><span class="line">DiscCoapSetFilterCapability</span><br><span class="line">DiscCoapStopDiscovery</span><br><span class="line">DiscCoapStartDiscovery</span><br><span class="line">    NSTACKX_StartDeviceFind</span><br><span class="line">        <span class="title function_">PostEvent</span><span class="params">(&amp;g_eventNodeChain, g_epollfd, DeviceDiscoverInner, <span class="literal">NULL</span>)</span></span><br><span class="line">            DeviceDiscoverInner</span><br><span class="line">               <span class="title function_">CoapServiceDiscoverInner</span><span class="params">(INNER_DISCOVERY)</span>;</span><br><span class="line">                   SetModeInfo</span><br><span class="line">                   CoapPostServiceDiscover</span><br><span class="line">                       PrepareServiceDiscover</span><br><span class="line">                       CoapSendRequest</span><br><span class="line">                           FillCoapRequest</span><br><span class="line">                           CoapResolveAddress</span><br><span class="line">                           CoapGetSessionOnTargetServer</span><br><span class="line">                           CoapPackToPdu</span><br><span class="line">                           coap_send</span><br><span class="line">                           coap_session_release</span><br><span class="line">                   TimerSetTimeout</span><br><span class="line">               <span class="title function_">NotifyDeviceFound</span><span class="params">(<span class="literal">NULL</span>, <span class="number">0</span>)</span>;    <span class="comment">//g_parameter.onDeviceFound(deviceList, deviceCount);</span></span><br></pre></td></tr></table></figure>

<p>note：PostEvent可以简单的理解为调用DeviceDiscoverInner():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CoapServiceDiscoverInner</span><span class="params">(<span class="type">uint8_t</span> userRequest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> discoverInterval;</span><br><span class="line">    <span class="comment">//检查wifi连接</span></span><br><span class="line">    <span class="keyword">if</span> (!IsWifiApConnected() || g_context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//用户请求开启发现</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest) &#123;</span><br><span class="line">        <span class="comment">//强制进行发现</span></span><br><span class="line">        g_userRequest = NSTACKX_TRUE;</span><br><span class="line">        g_forceUpdate = NSTACKX_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (g_coapDiscoverTargetCount &gt; <span class="number">0</span> &amp;&amp; g_discoverCount &gt;= g_coapDiscoverTargetCount) &#123;</span><br><span class="line">        g_discoverCount = <span class="number">0</span>;</span><br><span class="line">        SetModeInfo(DISCOVER_MODE);</span><br><span class="line">        ClearDevices(GetDeviceDBBackup());</span><br><span class="line">        LOGW(TAG, <span class="string">&quot;clear device list backup&quot;</span>);</span><br><span class="line">        TimerSetTimeout(g_discoverTimer, <span class="number">0</span>, NSTACKX_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//g_discoverCount &gt; 0说明正在发现</span></span><br><span class="line">    <span class="keyword">if</span> (g_discoverCount) &#123;</span><br><span class="line">        <span class="comment">/* Service discover is ongoing, return. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* First discover */</span></span><br><span class="line">        <span class="comment">//备份设备数据</span></span><br><span class="line">        <span class="keyword">if</span> (BackupDeviceDB() != NSTACKX_EOK) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">&quot;backup device list fail&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清除设备</span></span><br><span class="line">        ClearDevices(GetDeviceDB());</span><br><span class="line">        LOGW(TAG, <span class="string">&quot;clear device list&quot;</span>);</span><br><span class="line">        <span class="comment">//设置最大的发现数量</span></span><br><span class="line">        g_coapDiscoverTargetCount = g_coapMaxDiscoverCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SetModeInfo(DISCOVER_MODE);</span><br><span class="line">    <span class="comment">//开始发现</span></span><br><span class="line">    <span class="keyword">if</span> (CoapPostServiceDiscover() != NSTACKX_EOK) &#123;</span><br><span class="line">        LOGE(TAG, <span class="string">&quot;failed to post service discover request&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置一些超时检查</span></span><br><span class="line">    discoverInterval = GetDiscoverInterval(g_discoverCount);</span><br><span class="line">    <span class="keyword">if</span> (TimerSetTimeout(g_discoverTimer, discoverInterval, NSTACKX_FALSE) != NSTACKX_EOK) &#123;</span><br><span class="line">        LOGE(TAG, <span class="string">&quot;failed to set timer for service discover&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++g_discoverCount;</span><br><span class="line">    LOGI(TAG, <span class="string">&quot;the first time for device discover.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CoapServiceDiscoverInner</span><br><span class="line">    GetLocalInterfaceName</span><br><span class="line">    GetIfBroadcastIp</span><br><span class="line">    <span class="title function_">sprintf_s</span><span class="params">(discoverUri, <span class="keyword">sizeof</span>(discoverUri), <span class="string">&quot;coap://%s/%s&quot;</span>, ipString, <span class="string">&quot;device_discover&quot;</span>)</span></span><br><span class="line">    <span class="title function_">PrepareServiceDiscover</span><span class="params">(NSTACKX_TRUE)</span>;</span><br><span class="line">    CoapSendRequest(COAP_MESSAGE_NON, discoverUri, data, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, SERVER_TYPE_WLANORETH);</span><br><span class="line">        FillCoapRequest(&amp;coapRequest, coapType, url, data, dataLen);</span><br><span class="line">        CoapUriParse(coapRequest.remoteUrl, &amp;coapUri)</span><br><span class="line">        CoapResolveAddress(&amp;remote, &amp;dst.addr.sa);</span><br><span class="line">        CoapGetSessionOnTargetServer(serverType, &amp;coapServerParameter);</span><br><span class="line">        CoapPackToPdu(&amp;coapRequest, &amp;coapUri, session);</span><br><span class="line">        coap_send(session, pdu);</span><br></pre></td></tr></table></figure>

<p>哥哥们，最终是调用coap_send函数发送报文的.</p>
<h3 id="组网：ServerJoinLNN"><a href="#组网：ServerJoinLNN" class="headerlink" title="组网：ServerJoinLNN"></a>组网：ServerJoinLNN</h3><p>继续我门再core目录的探险，发现设备后要组网，就在ServerJoinLNN的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pkgName = IpcIoPopString</span><br><span class="line">addrTypeLen=IpcIoPopUint32</span><br><span class="line">*addr = (<span class="type">void</span>*)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line">callingUid = GetCallingUid(origin);</span><br><span class="line">LnnIpcServerJoin(pkgName, addr, addrTypeLen);</span><br><span class="line">    LnnServerJoin(connAddr);</span><br><span class="line">        CreateConnectionAddrMsgPara(addr);</span><br><span class="line">        PostMessageToHandler(MSG_TYPE_JOIN_LNN, para)</span><br><span class="line">            CreateNetBuilderMessage(msgType, para);</span><br><span class="line">                msg-&gt;handler = &amp;g_timeSyncCtrl.handler;</span><br><span class="line">            g_netBuilder.looper-&gt;PostMessage(g_netBuilder.looper,msg);<span class="comment">//==PostMessageAtTime()</span></span><br><span class="line">                SoftBusMessageNode *newNode;<span class="comment">//设置一个SoftBusMessageNode</span></span><br><span class="line">                SoftBusCondBroadcast(&amp;context-&gt;cond);</span><br><span class="line">                    pthread_cond_broadcast((<span class="type">pthread_cond_t</span> *)*cond);    <span class="comment">//解锁指定的线程</span></span><br><span class="line">    AddJoinLNNInfo(pkgName, connAddr);     <span class="comment">//创建一个JoinLnnRequestInfo，然后加入链表</span></span><br></pre></td></tr></table></figure>

<p>好的，g_netBuilder.looper如何初始化？找了一下，发现在这里</p>
<p>looper声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftBusLooper</span> &#123;</span></span><br><span class="line">    SoftBusLooperContext *context;</span><br><span class="line">    <span class="type">bool</span> dumpable;</span><br><span class="line">    <span class="type">void</span> (*PostMessage)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg);</span><br><span class="line">    <span class="type">void</span> (*PostMessageDelay)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg, <span class="type">uint64_t</span> delayMillis);</span><br><span class="line">    <span class="type">void</span> (*RemoveMessage)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler, <span class="type">int32_t</span> what);</span><br><span class="line">    <span class="comment">// customFunc, when match, return 0</span></span><br><span class="line">    <span class="type">void</span> (*RemoveMessageCustom)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler,</span><br><span class="line">        <span class="type">int</span> (*)(<span class="type">const</span> SoftBusMessage*, <span class="type">void</span>*), <span class="type">void</span> *args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LooperInit</span><br><span class="line">    <span class="title function_">CreateNewLooper</span><span class="params">(<span class="string">&quot;Loop-default&quot;</span>)</span>;</span><br><span class="line">        looper-&gt;PostMessage = LooperPostMessage;</span><br><span class="line">        looper-&gt;PostMessageDelay = LooperPostMessageDelay;</span><br><span class="line">        looper-&gt;RemoveMessage = LooperRemoveMessage;</span><br><span class="line">        looper-&gt;RemoveMessageCustom = LoopRemoveMessageCustom;</span><br><span class="line">    SetLooper(LOOP_TYPE_DEFAULT, looper);</span><br></pre></td></tr></table></figure>

<p>LooperPostMessage如何把消息发送出去？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LooperPostMessage</span><br><span class="line">    msg-&gt;time = UptimeMicros();</span><br><span class="line">    PostMessageAtTime(looper, msg);</span><br><span class="line">        SoftBusMessageNode *newNode;</span><br><span class="line">        ListTailInsert(item, &amp;(newNode-&gt;node));</span><br><span class="line">        SoftBusCondBroadcast(&amp;context-&gt;cond);</span><br><span class="line">            pthread_cond_broadcast((<span class="type">pthread_cond_t</span> *)*cond);</span><br></pre></td></tr></table></figure>



<p>最后是使用pthread_cond_broadcast唤醒一些线程，那是什么条件，什么线程？找到了：线程就是LoopTask，再message_handler.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SoftBusCondWait(&amp;context-&gt;cond, &amp;context-&gt;lock, &amp;tv);</span><br><span class="line">ListNode *item = context-&gt;msgHead.next;</span><br><span class="line">SoftBusMessageNode *itemNode = CONTAINER_OF(item, SoftBusMessageNode, node);</span><br><span class="line">msg = itemNode-&gt;msg;</span><br><span class="line">msg-&gt;handler-&gt;HandleMessage(msg);</span><br></pre></td></tr></table></figure>

<p>看来这个线程也不是重点，重点是msg的handler，要回溯一下msg，应该是在msg-&gt;handler &#x3D; &amp;g_timeSyncCtrl.handler，而且由handler.HandleMessage &#x3D; TimeSyncMessageHandler：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProcessStartTimeSyncRequest((<span class="type">const</span> StartTimeSyncReqMsgPara *)msg-&gt;obj);</span><br><span class="line">    FindTimeSyncReqInfo(para-&gt;targetNetworkId);</span><br><span class="line">    isUpdateTimeSyncReq = TryUpdateTimeSyncReqInfo(existInfo, para-&gt;accuracy, para-&gt;period);</span><br><span class="line">    TryUpdateStartTimeSyncReq(existInfo, para)</span><br><span class="line">    LnnStartTimeSyncImpl(existInfo-&gt;targetNetworkId, existInfo-&gt;curAccuracy,existInfo-&gt;curPeriod, &amp;g_timeSyncImplCb)</span><br><span class="line">    ListAdd(&amp;g_timeSyncCtrl.reqList, &amp;existInfo-&gt;node);</span><br></pre></td></tr></table></figure>

<p>看样子应该是构建了一个请求，然后把他放到g_timeSyncCtrl.reqList，应该有一个函数来处理这个列表。。。。。所谓的组网就是时钟同步，只是如何实现的？这部分好像没有实现的代码，在core&#x2F;bus_center&#x2F;lnn&#x2F;lane_hub&#x2F;time_sync没有定义。组网的部分暂时到这。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/dsoftbus_core/" data-id="cmbcy7rho002nt8mtfy3ngqf5" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/softbus core（中）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/softbus%20core%EF%BC%88%E4%B8%AD%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.670Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="softbus-core（中）"><a href="#softbus-core（中）" class="headerlink" title="softbus core（中）"></a>softbus core（中）</h2><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>必须搞定连接，才能了解后面的传输，传输就是基于连接创建的socket接口。从哪里入手？softbus_conn_manager.c：</p>
<p>首先要知道g_connManager这个对象，它用来管理所有的类型的连接。每种类型的连接都有对应的一个ConnectFuncInterface。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*ConnectDevice)(<span class="type">const</span> ConnectOption *option, <span class="type">uint32_t</span> requestId, <span class="type">const</span> ConnectResult *result);</span><br><span class="line">    <span class="type">int32_t</span> (*PostBytes)(<span class="type">uint32_t</span> connectionId, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">int32_t</span> len, <span class="type">int32_t</span> pid, <span class="type">int32_t</span> flag);</span><br><span class="line">    <span class="type">int32_t</span> (*DisconnectDevice)(<span class="type">uint32_t</span> connectionId);</span><br><span class="line">    <span class="type">int32_t</span> (*DisconnectDeviceNow)(<span class="type">const</span> ConnectOption *option);</span><br><span class="line">    <span class="type">int32_t</span> (*GetConnectionInfo)(<span class="type">uint32_t</span> connectionId, ConnectionInfo *info);</span><br><span class="line">    <span class="type">int32_t</span> (*StartLocalListening)(<span class="type">const</span> LocalListenerInfo *info);</span><br><span class="line">    <span class="type">int32_t</span> (*StopLocalListening)(<span class="type">const</span> LocalListenerInfo *info);</span><br><span class="line">    <span class="type">bool</span> (*CheckActiveConnection)(<span class="type">const</span> ConnectOption *info);</span><br><span class="line">&#125; ConnectFuncInterface;</span><br><span class="line"></span><br><span class="line">ConnectFuncInterface *g_connManager[CONNECT_TYPE_MAX]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>连接有通道的区分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CHANNEL_TYPE_TCP_DIRECT = <span class="number">0</span>,   </span><br><span class="line">    CHANNEL_TYPE_PROXY,    <span class="comment">//啥？</span></span><br><span class="line">    CHANNEL_TYPE_UDP,</span><br><span class="line">    CHANNEL_TYPE_AUTH,</span><br><span class="line">    CHANNEL_TYPE_BUTT,</span><br><span class="line">&#125; ChannelType;</span><br></pre></td></tr></table></figure>

<p>那么从初始化看：ConnServerInit，可以发现连接的物理层可以是wifi或蓝牙</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">g_connManagerCb.OnConnected = ConnManagerConnected;</span><br><span class="line">g_connManagerCb.OnDisconnected = ConnManagerDisconnected;</span><br><span class="line">g_connManagerCb.OnDataReceived = ConnManagerRecvData;</span><br><span class="line">SoftbusGetConfig(SOFTBUS_INT_SUPPORT_TCP_PROXY, (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;isSupportTcp, <span class="keyword">sizeof</span>(isSupportTcp));<span class="comment">//查看是否支持tcp</span></span><br><span class="line">connectObj = ConnInitTcp(&amp;g_connManagerCb);</span><br><span class="line">    InitProperty()</span><br><span class="line">    InitTcpInterface();</span><br><span class="line">    g_tcpConnCallback = g_connManagerCb;</span><br><span class="line">    g_tcpConnInfoList = CreateSoftBusList();</span><br><span class="line">    <span class="keyword">return</span> &amp;g_tcpInterface;</span><br><span class="line">connectObj = ConnInitBr(&amp;g_connManagerCb);</span><br><span class="line">connectObj = ConnInitBle(&amp;g_connManagerCb);</span><br><span class="line">g_connManager[CONNECT_TCP] = connectObj;</span><br><span class="line">g_listenerList = CreateSoftBusList();</span><br></pre></td></tr></table></figure>

<p>以tcp方式为例，可以看到ConnInitTcp()的任务就是返回了一个tcp的ConnectFuncInterface，这个接口是已经定义好了的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">InitTcpInterface</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tcpInterface.ConnectDevice = TcpConnectDevice;</span><br><span class="line">    g_tcpInterface.DisconnectDevice = TcpDisconnectDevice;</span><br><span class="line">    g_tcpInterface.DisconnectDeviceNow = TcpDisconnectDeviceNow;</span><br><span class="line">    g_tcpInterface.PostBytes = TcpPostBytes;</span><br><span class="line">    g_tcpInterface.GetConnectionInfo = TcpGetConnectionInfo;</span><br><span class="line">    g_tcpInterface.StartLocalListening = TcpStartListening;</span><br><span class="line">    g_tcpInterface.StopLocalListening = TcpStopListening;</span><br><span class="line">    g_tcpInterface.CheckActiveConnection = TcpCheckActiveConnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就需要重点来看这些函数是如何实现的，可以发现其本质就是调用softbus_adapter_socket.c中的函数，这些函数实现了对socket的封装。</p>
<p>首先看看TcpConnectDevice：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fd = OpenTcpClientSocket(option-&gt;info.ipOption.ip, <span class="string">&quot;0.0.0.0&quot;</span>, (<span class="type">uint16_t</span>)option-&gt;info.ipOption.port, <span class="literal">false</span>);</span><br><span class="line">    SoftBusSocketCreate(SOFTBUS_AF_INET, SOFTBUS_SOCK_STREAM, <span class="number">0</span>, &amp;fd);</span><br><span class="line">        socket(domain, type, protocol);</span><br><span class="line">    ConnToggleNonBlockMode(fd, <span class="literal">true</span>)</span><br><span class="line">        fcntl(fd, F_SETFL, flags);</span><br><span class="line">    SetClientOption(fd);</span><br><span class="line">        SetReuseAddr(fd, <span class="number">1</span>);</span><br><span class="line">        SetNoDelay(fd, <span class="number">1</span>);</span><br><span class="line">    BindLocalIP(fd, myIp, <span class="number">0</span>);</span><br><span class="line">        SoftBusSocketBind(fd, (SoftBusSockAddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line">        bind(socketFd, &amp;sysAddr, (<span class="type">socklen_t</span>)addrLen);</span><br><span class="line">    SoftBusSocketConnect(fd, (SoftBusSockAddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line">        connect(socketFd, &amp;sysAddr, (<span class="type">socklen_t</span>)addrLen);</span><br><span class="line">TcpConnInfoNode *tcpConnInfoNode;</span><br><span class="line">AddTcpConnInfo(tcpConnInfoNode) </span><br><span class="line">AddTrigger(option-&gt;info.ipOption.moduleId, fd, WRITE_TRIGGER)</span><br><span class="line">    SoftbusBaseListenerInfo *info = g_listenerList[module].info;</span><br><span class="line">    AddTriggerToSet(fd, triggerType)</span><br><span class="line">    AddNewFdNode(info, fd)</span><br><span class="line">    g_maxFd = MaxFd(fd, g_maxFd);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么大胆的猜测TcpPostBytes()应该也是类似的，可以看到是根据connectid来确定fd的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST_FOR_EACH_ENTRY(item, &amp;g_tcpConnInfoList-&gt;<span class="built_in">list</span>, TcpConnInfoNode, node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item-&gt;connectionId == connectionId) &#123;</span><br><span class="line">        fd = item-&gt;info.info.ipInfo.fd;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SendTcpData(fd, data, len, flag);</span><br><span class="line">    WaitEvent(fd, SOFTBUS_SOCKET_OUT, USER_TIMEOUT_MS);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)SoftBusSocketSend(fd, &amp;buf[bytes], len - bytes, <span class="number">0</span>);</span><br><span class="line">        send(socketFd, buf, len, flags);</span><br><span class="line">    WaitEvent(fd, SOFTBUS_SOCKET_OUT, timeout);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么TcpStartListening也应该是类似的简单，可以发现它创建了一个socket监听端口，然后也创建一个线程ThreadPoolWorker。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListenerModule moduleId = info-&gt;info.ipListenerInfo.moduleId;</span><br><span class="line">SoftbusBaseListener *listener = CheckTcpListener(moduleId);</span><br><span class="line">    <span class="keyword">return</span> g_tcpListenerItems[i].listener;</span><br><span class="line">SetSoftbusBaseListener(moduleId, listener);</span><br><span class="line">    memcpy_s(g_listenerList[module].listener, <span class="keyword">sizeof</span>(SoftbusBaseListener),listener, <span class="keyword">sizeof</span>(SoftbusBaseListener))</span><br><span class="line">StartBaseListener(moduleId, info-&gt;info.ipListenerInfo.ip, info-&gt;info.ipListenerInfo.port, SERVER_MODE);</span><br><span class="line">    InitListenFd(module, ip, port);</span><br><span class="line">        OpenTcpServerSocket(ip, port);</span><br><span class="line">            SoftBusSocketCreate(SOFTBUS_AF_INET, SOFTBUS_SOCK_STREAM, <span class="number">0</span>, (<span class="type">int32_t</span> *)&amp;fd);</span><br><span class="line">            SetServerOption(fd);</span><br><span class="line">            BindLocalIP(fd, ip, (<span class="type">uint16_t</span>)port);</span><br><span class="line">        SoftBusSocketListen(listenerInfo-&gt;listenFd, DEFAULT_BACKLOG);</span><br><span class="line">            listen(socketFd, backLog);</span><br><span class="line">        SoftBusSocketFdSet(listenerInfo-&gt;listenFd, &amp;g_readSet);</span><br><span class="line">    PrepareBaseListener(module, modeType);</span><br><span class="line">        g_threadPool = ThreadPoolInit(THREADPOOL_THREADNUM, THREADPOOL_QUEUE_NUM);</span><br><span class="line">            CreateThreadPool(threadNum, queueMaxNum);</span><br><span class="line">            CreateThread((Runnable)ThreadPoolWorker, (<span class="type">void</span> *)pool, &amp;attr, (<span class="type">uint32_t</span> *)&amp;(pool-&gt;pthreads[i])</span><br><span class="line">        StartThread(module, modeType);</span><br><span class="line">            ThreadPoolAddJob(g_threadPool, (<span class="type">int32_t</span>(*)(<span class="type">void</span> *))SelectThread,<span class="literal">NULL</span>, PERSISTENT, (<span class="type">uintptr_t</span>)<span class="number">0</span>);</span><br><span class="line">                CheckThreadPoolAddReady(pool, callbackFunction);</span><br><span class="line">                SoftBusCondBroadcast(&amp;(pool-&gt;queueNotEmpty));</span><br><span class="line">                    pthread_cond_broadcast((<span class="type">pthread_cond_t</span> *)*cond);    <span class="comment">//解锁一些任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadPoolWorker读取队列中的数据。这部分应该需要了解一下线程池是怎么运行的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((pool-&gt;queueCurNum == <span class="number">0</span>) &amp;&amp; !pool-&gt;poolClose) &#123;</span><br><span class="line">    SoftBusCondWait(&amp;(pool-&gt;queueNotEmpty), &amp;(pool-&gt;mutex), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">JobCheck(pool, job);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;queueCurNum == <span class="number">0</span>) &#123;</span><br><span class="line">     SoftBusCondSignal(&amp;(pool-&gt;queueEmpty));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;queueCurNum == pool-&gt;queueMaxNum - <span class="number">1</span>) &#123;</span><br><span class="line">     SoftBusCondBroadcast(&amp;(pool-&gt;queueNotFull));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TcpStartListening中发现还有一个线程SelectThread，这个线程中，应该使用select读取数据，然后调用回调函数处理数据。</p>
<h2 id="会话传输"><a href="#会话传输" class="headerlink" title="会话传输"></a>会话传输</h2><p>ServerOpenSession()表示打开一个会话传输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransOpenSession(&amp;param, &amp;(transSerializer.transInfo));</span><br><span class="line">    TransOpenChannel(param, info);</span><br><span class="line">        appInfo = GetAppInfo(param);</span><br><span class="line">        TransGetLaneInfo(param, appInfo-&gt;myData.pid, &amp;object, &amp;info)</span><br><span class="line">        TransGetConnectOption(info, &amp;connOpt)</span><br><span class="line">        transInfo-&gt;channelType = TransGetChannelType(info);</span><br><span class="line">        TransOpenChannelProc((ChannelType)transInfo-&gt;channelType, appInfo, &amp;connOpt,&amp;(transInfo-&gt;channelId))</span><br><span class="line">        TransLaneMgrAddLane(transInfo-&gt;channelId, transInfo-&gt;channelType, object,appInfo-&gt;myData.pkgName)    <span class="comment">//创建一个TransLaneInfo *newLane，添加到链表</span></span><br></pre></td></tr></table></figure>

<p>那么重点就是TransOpenChannelProc()。他有三种类型的通道哦，先从简单的udp开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">TransOpenChannelProc</span><span class="params">(ChannelType type, AppInfo *appInfo, <span class="type">const</span> ConnectOption *connOpt,</span></span><br><span class="line"><span class="params">    <span class="type">int32_t</span> *channelId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == CHANNEL_TYPE_UDP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransOpenUdpChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_INFO, <span class="string">&quot;open udp channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == CHANNEL_TYPE_PROXY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransProxyOpenProxyChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;open proxy channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransOpenDirectChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;open direct channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransOpenUdpChannel：怎么就涉及认证连接了？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrepareAppInfoForUdpOpen(connOpt, appInfo, &amp;id)</span><br><span class="line">UdpChannelInfo *newChannel = NewUdpChannelByAppInfo(appInfo);</span><br><span class="line">TransAddUdpChannel(newChannel)</span><br><span class="line">OpenAuthConnForUdpNegotiation(newChannel)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来看看CHANNEL_TYPE_PROXY类型：TransProxyOpenProxyChannel</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TransProxyOpenConnChannel</span><br><span class="line">    <span class="title function_">TransGetConn</span><span class="params">(connInfo, &amp;conn)</span></span><br><span class="line">    ProxyChannelInfo *chan;</span><br><span class="line">    TransProxyCreateChanInfo(chan, chanNewId, appInfo)</span><br><span class="line">    ProxyConnInfo *connChan;</span><br><span class="line">    TransAddConnItem(connChan)</span><br><span class="line">    result.OnConnectFailed = TransOnConnectFailed;</span><br><span class="line">    result.OnConnectSuccessed = TransOnConnectSuccessed;</span><br><span class="line">    ConnConnectDevice(&amp;(connChan-&gt;connInfo), reqId, &amp;result);</span><br><span class="line">        g_connManager[info-&gt;type]-&gt;ConnectDevice(info, requestId, result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我门session已经建立了，如何发送数据，就看 ServerSendSessionMsg：<br>哦，有两种session，认证和普通的session</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">TransSendMsg</span><span class="params">(<span class="type">int32_t</span> channelId, <span class="type">int32_t</span> channelType, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">uint32_t</span> len, <span class="type">int32_t</span> msgType)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_INFO, <span class="string">&quot;send msg: id=%d, type=%d&quot;</span>, channelId, channelType);</span><br><span class="line">    <span class="keyword">switch</span> (channelType) &#123;</span><br><span class="line">        <span class="keyword">case</span> CHANNEL_TYPE_AUTH:</span><br><span class="line">            <span class="keyword">return</span> TransSendAuthMsg(channelId, data, (<span class="type">int32_t</span>)len);</span><br><span class="line">        <span class="keyword">case</span> CHANNEL_TYPE_PROXY:</span><br><span class="line">            <span class="keyword">return</span> TransProxyPostSessionData(channelId, (<span class="type">unsigned</span> <span class="type">char</span>*)data, len, (SessionPktType)msgType);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;send msg: id=%d invalid type=%d&quot;</span>, channelId, channelType);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只看普通的session：TransProxyPostPacketData</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TransProxyGetSendMsgChanInfo(channelId, chanInfo)</span><br><span class="line">TransProxyPackBytes(channelId, &amp;packDataInfo, flags, &amp;seq);</span><br><span class="line">TransProxyTransDataSendMsg(channelId, (<span class="type">char</span> *)packDataInfo.outData, (<span class="type">int32_t</span>)packDataInfo.outLen, flags);</span><br><span class="line">    TransProxyGetSendMsgChanInfo(channelId, info)</span><br><span class="line">    TransProxyTransAppNormalMsg(info, payLoad, payLoadLen, flag);</span><br><span class="line">        singleLen = TransProxyGetBufLen();</span><br><span class="line">        TransProxyPackAppNormalMsg(&amp;msgHead, &amp;slicehead, payLoad + offset, dataLen, &amp;bufLen);</span><br><span class="line">        TransProxyTransSendMsg(info-&gt;connId, buf, bufLen, ProxyTypeToConnPri(flag));</span><br><span class="line">            ConnPostBytes(connectionId, &amp;data);</span><br><span class="line">            g_connManager[type]-&gt;PostBytes(connectionId, data-&gt;buf, (<span class="type">int32_t</span>)(data-&gt;len), data-&gt;pid, data-&gt;flag);</span><br></pre></td></tr></table></figure>


































<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.icode9.com/content-4-825230.html">https://www.icode9.com/content-4-825230.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/softbus%20core%EF%BC%88%E4%B8%AD%EF%BC%89/" data-id="cmbcy7rhp002rt8mtdvrk72ik" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/stm32mp157_ir_control" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/stm32mp157_ir_control/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.670Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="STM32MP157实现红外遥控"><a href="#STM32MP157实现红外遥控" class="headerlink" title="STM32MP157实现红外遥控"></a>STM32MP157实现红外遥控</h2><p>本文介绍如何使用stm32mp157芯片的小熊派开发板实现红外遥控。</p>
<p>前提：pwm驱动的完成。irext介绍。红外遥控的介绍。</p>
<p>本文分为两个部分，分别是驱动和应用，驱动使用TIM实现定时产生&#x2F;关闭PWM，应用复制调用irext库生成编码数组。</p>
<h2 id="红外驱动"><a href="#红外驱动" class="headerlink" title="红外驱动"></a>红外驱动</h2><h4 id="1、驱动实现"><a href="#1、驱动实现" class="headerlink" title="1、驱动实现"></a>1、驱动实现</h4><p>将驱动命名为ir，使用HDF框架开发，其原理是使用STM32的TIM进行定时，设置定时器中断，并在中断中设置PWM的产生，从而控制红外载波的产生。首先创建&#x2F;bearpi&#x2F;project&#x2F;bearpi-hm_micro_small&#x2F;device&#x2F;st&#x2F;drivers&#x2F;ir目录，并开始编写stm32mp1_ir.c</p>
<p>需要使用到PWM的函数，所以需要引入头文件<code>pwm_if.h</code></p>
<p>接着是定义红外驱动的私有数据，初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红外私有数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TIM_HandleTypeDef htim;  <span class="comment">//定时器</span></span><br><span class="line">    DevHandle pwm;           <span class="comment">//hdf pwm所得到的句柄</span></span><br><span class="line">    <span class="type">uint16_t</span> *item;			 <span class="comment">//保存即将发送的红外序列</span></span><br><span class="line">    <span class="type">uint32_t</span> length;         <span class="comment">//序列长度</span></span><br><span class="line">    <span class="type">uint32_t</span> index;          <span class="comment">//当前处理的序列下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfIRDriverInit</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    ir = (<span class="keyword">struct</span> IR *)OsalMemCalloc(<span class="keyword">sizeof</span>(*ir));</span><br><span class="line">    <span class="comment">//获取pwm操作句柄</span></span><br><span class="line">    ir-&gt;pwm = PwmOpen(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//设置周期263*0.1us=26.3us=28khz</span></span><br><span class="line">    PwmSetPeriod(ir-&gt;pwm, <span class="number">263</span>);</span><br><span class="line">    PwmSetDuty(ir-&gt;pwm, <span class="number">131</span>);</span><br><span class="line">    PwmDisable(ir-&gt;pwm);</span><br><span class="line">    ir-&gt;item = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tim3_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用TIM3来产生计时中断，TIM3初始化代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tim3_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_ClkInitTypeDef clkconfig;</span><br><span class="line">    <span class="type">uint32_t</span> pFLatency;</span><br><span class="line">    <span class="type">uint32_t</span> uwTimclock;</span><br><span class="line"></span><br><span class="line">    __HAL_RCC_TIM3_CLK_ENABLE();</span><br><span class="line">    HAL_RCC_GetClockConfig(&amp;clkconfig, &amp;pFLatency);</span><br><span class="line">    uwTimclock = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_TIMG1);</span><br><span class="line">    <span class="type">uint32_t</span> Prescaler = (<span class="type">uint32_t</span>)((uwTimclock / TIM3_CNT_CLK) - <span class="number">1U</span>);</span><br><span class="line"></span><br><span class="line">    ir-&gt;htim.Instance = (TIM_TypeDef *)OsalIoRemap(TIM3BaseAddr, TIM3Size);</span><br><span class="line">    ir-&gt;htim.Init.Prescaler = Prescaler;</span><br><span class="line">    ir-&gt;htim.Init.CounterMode = TIM_COUNTERMODE_UP;</span><br><span class="line">    ir-&gt;htim.Init.Period = <span class="number">10000</span>;</span><br><span class="line">    ir-&gt;htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">    ir-&gt;htim.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ir-&gt;htim.Instance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dprintf(<span class="string">&quot;error OsalIoRemap for htim3 \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化中断</span></span><br><span class="line">    register_irq();</span><br><span class="line">    <span class="comment">//初始化定时器</span></span><br><span class="line">    HAL_TIM_Base_Init(&amp;ir-&gt;htim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向内核注册TIM3中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">register_irq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    dprintf(<span class="string">&quot;%s enter\r\n&quot;</span>, __func__);</span><br><span class="line">    ret = OsalRegisterIrq(TIM3_IRQn, <span class="number">0</span>, tim3_handler, <span class="string">&quot;tim3&quot;</span>, &amp;ir-&gt;htim);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="type">void</span>)OsalUnregisterIrq(TIM3_IRQn, &amp;ir-&gt;htim);</span><br><span class="line">        ret = OsalRegisterIrq(TIM3_IRQn, <span class="number">0</span>, tim3_handler, <span class="string">&quot;tim3&quot;</span>, &amp;ir-&gt;htim);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = OsalEnableIrq(TIM3_IRQn);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dprintf(<span class="string">&quot;%s: irq enable fail:%d!&quot;</span>, __func__, ret);</span><br><span class="line">        (<span class="type">void</span>)OsalUnregisterIrq(TIM3_IRQn, &amp;ir-&gt;htim);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断函数：实现对载波的时长控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印会影响时间，禁止打印</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">tim3_handler</span><span class="params">(<span class="type">uint32_t</span> irq, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)irq;</span><br><span class="line">    TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);</span><br><span class="line">            __HAL_TIM_DISABLE(htim);</span><br><span class="line">            __HAL_TIM_SET_COUNTER(htim, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ir-&gt;index == ir-&gt;length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭pwm</span></span><br><span class="line">                ir-&gt;index = <span class="number">0</span>;</span><br><span class="line">                PwmDisable(ir-&gt;pwm);</span><br><span class="line">                __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ir-&gt;index % <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PwmEnable(ir-&gt;pwm);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    PwmDisable(ir-&gt;pwm);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            __HAL_TIM_SET_AUTORELOAD(htim, ir-&gt;item[ir-&gt;index]);</span><br><span class="line">            ir-&gt;index++;</span><br><span class="line">            __HAL_TIM_ENABLE(htim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应用层提供的服务：</p>
<p>获取应用层提供的数组，该数组表示电平持续的时长，单位是us</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">IRDriverDispatch</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="type">int</span> cmdCode, <span class="keyword">struct</span> HdfSBuf *data, <span class="keyword">struct</span> HdfSBuf *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> *<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        HdfSbufReadBuffer(data, (<span class="type">const</span> <span class="type">void</span> **)&amp;<span class="built_in">array</span>, &amp;len);</span><br><span class="line">        <span class="comment">//获取数组</span></span><br><span class="line">        ir-&gt;length = len / <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>);</span><br><span class="line">        ir-&gt;index = <span class="number">0</span>;</span><br><span class="line">        ir-&gt;item = (<span class="type">uint16_t</span> *)OsalMemCalloc(len);</span><br><span class="line">        memcpy_s(ir-&gt;item, len, (<span class="type">void</span> *)<span class="built_in">array</span>, len);</span><br><span class="line">        <span class="comment">//开始发射</span></span><br><span class="line">        HAL_TIM_Base_Start_IT(&amp;ir-&gt;htim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (!HdfSbufWriteUint32(reply, ir-&gt;length))</span><br><span class="line">        &#123;</span><br><span class="line">            dprintf(<span class="string">&quot;replay is fail&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编辑<code>bearpi/project/bearpi-hm_micro_small/device/st/drivers/BUILD.gn</code>和<code>bearpi/project/bearpi-hm_micro_small/device/st/drivers/ir/BUILD.gn</code>，把红外驱动添加到编译系统：</p>
<p>bearpi&#x2F;project&#x2F;bearpi-hm_micro_small&#x2F;device&#x2F;st&#x2F;drivers&#x2F;BUILD.gn：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>bearpi&#x2F;project&#x2F;bearpi-hm_micro_small&#x2F;device&#x2F;st&#x2F;drivers&#x2F;ir&#x2F;BUILD.gn：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="2、驱动配置文件"><a href="#2、驱动配置文件" class="headerlink" title="2、驱动配置文件"></a>2、驱动配置文件</h4><p>编辑<code>bearpi/project/bearpi-hm_micro_small/device/st/bearpi_hm_micro/liteos_a/hdf_config/device_info/device_info.hcs</code>，添加红外节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">device_ir :: device &#123;</span><br><span class="line">    device0 :: deviceNode &#123;</span><br><span class="line">        policy = <span class="number">2</span>;</span><br><span class="line">        priority = <span class="number">12</span>;</span><br><span class="line">        permission = <span class="number">0644</span>;</span><br><span class="line">        moduleName = <span class="string">&quot;HDF_IR&quot;</span>;</span><br><span class="line">        serviceName = <span class="string">&quot;hdf_ir&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="红外应用"><a href="#红外应用" class="headerlink" title="红外应用"></a>红外应用</h2><p>本文的应用是基于JS开发的，所以需要编写JS的接口给JS应用使用。</p>
<p>参考小熊派的led教程：<a target="_blank" rel="noopener" href="https://gitee.com/bearpi/bearpi-hm_micro_small/blob/master/applications/BearPi/BearPi-HM_Micro/docs/device-dev/%E9%80%9A%E8%BF%87JS%E5%BA%94%E7%94%A8%E6%8E%A7%E5%88%B6LED%E7%81%AF.md">applications&#x2F;BearPi&#x2F;BearPi-HM_Micro&#x2F;docs&#x2F;device-dev&#x2F;通过JS应用控制LED灯.md · 小熊派开源社区&#x2F;BearPi-HM_Micro_small - 码云 - 开源中国 (gitee.com)</a></p>
<h3 id="1、添加JS-API接口"><a href="#1、添加JS-API接口" class="headerlink" title="1、添加JS API接口"></a>1、添加JS API接口</h3><p>修改<code>foundation\ace\ace_engine_lite\frameworks\src\core\modules\app_module.h</code>，加入AC_Control()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    ACE_DISALLOW_COPY_AND_MOVE(AppModule);</span><br><span class="line">    AppModule() = <span class="keyword">default</span>;</span><br><span class="line">    ~AppModule() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> JSIValue <span class="title function_">GetInfo</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span>;</span><br><span class="line">    <span class="type">static</span> JSIValue <span class="title function_">Terminate</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span>;</span><br><span class="line">	<span class="comment">//红外控制JS API</span></span><br><span class="line">    <span class="type">static</span> JSIValue <span class="title function_">AC_Control</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span>;</span><br></pre></td></tr></table></figure>

<p>在InitAppModule()中添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitAppModule</span><span class="params">(JSIValue exports)</span></span><br><span class="line">&#123;</span><br><span class="line">    JSI::SetModuleAPI(exports, <span class="string">&quot;getInfo&quot;</span>, AppModule::GetInfo);</span><br><span class="line">    JSI::SetModuleAPI(exports, <span class="string">&quot;terminate&quot;</span>, AppModule::Terminate);</span><br><span class="line">    <span class="comment">//红外控制JS API</span></span><br><span class="line">    JSI::SetModuleAPI(exports, <span class="string">&quot;ac_control&quot;</span>, AppModule::AC_Control);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FEATURE_SCREEN_ON_VISIBLE</span></span><br><span class="line">    JSI::SetModuleAPI(exports, <span class="string">&quot;screenOnVisible&quot;</span>, AppModule::ScreenOnVisible);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上诉步骤，JS应用程序就可以调用CPP代码。</p>
<h3 id="2、编写红外遥控逻辑代码"><a href="#2、编写红外遥控逻辑代码" class="headerlink" title="2、编写红外遥控逻辑代码"></a>2、编写红外遥控逻辑代码</h3><p>首先，我们会使用IREXT来进行解码操作，关于irext可参考：</p>
<p>首先把irext的代码放到<code>foundation/ace/ace_engine_lite/frameworks/src/core/modules/</code>目录下。</p>
<p>在<code>foundation\ace\ace_engine_lite\frameworks\src\core\modules\app_module.cpp</code>中加入红外遥控代码AC_Control()的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">JSIValue <span class="title function_">AppModule::AC_Control</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化好默认参数</span></span><br><span class="line">    <span class="type">static</span> t_remote_ac_status ac_status = &#123;</span><br><span class="line">        .ac_power = AC_POWER_ON,</span><br><span class="line">        .ac_temp = AC_TEMP_26,</span><br><span class="line">        .ac_mode = AC_MODE_COOL,</span><br><span class="line">        .ac_wind_dir = AC_SWING_ON,</span><br><span class="line">        .ac_wind_speed = AC_WS_LOW,</span><br><span class="line">        .ac_display = <span class="number">1</span>,</span><br><span class="line">        .ac_sleep = <span class="number">0</span>,</span><br><span class="line">        .ac_timer = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;AC_Control&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfIoService</span> *<span class="title">serv</span> =</span> HdfIoServiceBind(IR_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (serv == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;fail to get service2 %s\n&quot;</span>, IR_SERVICE);</span><br><span class="line">        <span class="keyword">return</span> JSI::CreateUndefined();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查参数</span></span><br><span class="line">    <span class="keyword">if</span> ((args == nullptr) || (argsNum == <span class="number">0</span>) || (JSI::ValueIsUndefined(args[<span class="number">0</span>])))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JSI::CreateUndefined();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JSIValue success = JSI::GetNamedProperty(args[<span class="number">0</span>], CB_SUCCESS);</span><br><span class="line">    JSIValue fail = JSI::GetNamedProperty(args[<span class="number">0</span>], CB_FAIL);</span><br><span class="line">    JSIValue complete = JSI::GetNamedProperty(args[<span class="number">0</span>], CB_COMPLETE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="type">int32_t</span> operation = (<span class="type">int32_t</span>)JSI::GetNumberProperty(args[<span class="number">0</span>], <span class="string">&quot;operation&quot;</span>);</span><br><span class="line">    <span class="type">int</span> value = (<span class="type">int</span>)JSI::GetNumberProperty(args[<span class="number">0</span>], <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = (<span class="type">char</span> *)JSI::GetStringProperty(args[<span class="number">0</span>], <span class="string">&quot;lib_dir&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (operation)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> ac_power:</span><br><span class="line">        ac_status.ac_power = t_ac_power(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ac_temp:</span><br><span class="line">        ac_status.ac_temp = t_ac_temperature(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ac_mode:</span><br><span class="line">        ac_status.ac_mode = t_ac_mode(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ac_wind_dir:</span><br><span class="line">        ac_status.ac_wind_dir = t_ac_swing(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ac_wind_speed:</span><br><span class="line">        ac_status.ac_wind_speed = t_ac_wind_speed(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解码</span></span><br><span class="line">    <span class="type">uint16_t</span> len = IR_Decode(file, &amp;ac_status);</span><br><span class="line">    <span class="comment">//发送</span></span><br><span class="line">    <span class="type">uint32_t</span> replyData = SendArray(serv, len * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">if</span>(replyData&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;fail to send ir data\n&quot;</span>);</span><br><span class="line">        JSI::CallFunction(fail, thisVal, nullptr, <span class="number">0</span>);</span><br><span class="line">        JSI::CallFunction(complete, thisVal, nullptr, <span class="number">0</span>);</span><br><span class="line">        JSI::ReleaseValueList(success, fail, complete);</span><br><span class="line">        <span class="keyword">return</span> JSI::CreateUndefined();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    JSIValue result = JSI::CreateObject();</span><br><span class="line">    JSI::SetNumberProperty(result, <span class="string">&quot;ir_status&quot;</span>, replyData);</span><br><span class="line">    JSIValue argv[<span class="number">1</span>] = &#123;result&#125;;</span><br><span class="line">    JSI::CallFunction(success, thisVal, argv, <span class="number">1</span>);</span><br><span class="line">    JSI::CallFunction(complete, thisVal, nullptr, <span class="number">0</span>);</span><br><span class="line">    JSI::ReleaseValueList(success, fail, complete, result);</span><br><span class="line">    HdfIoServiceRecycle(serv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSI::CreateUndefined();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用irext库对空调命令进行解码，得到红外序列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">IR_Decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, t_remote_ac_status *ac_status)</span></span><br><span class="line">&#123;</span><br><span class="line">    ir_file_open(REMOTE_CATEGORY_AC, SUB_CATEGORY_QUATERNARY, file);</span><br><span class="line">    <span class="keyword">if</span> (ir_file_open(REMOTE_CATEGORY_AC, SUB_CATEGORY_QUATERNARY, file) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;ir_file_open error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> decode_len = ir_decode(KEY_AC_POWER, decoded, ac_status, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (decode_len == <span class="number">0</span>)</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;ir_decode error&quot;</span>);</span><br><span class="line">    <span class="comment">//关闭irext库，释放内存</span></span><br><span class="line">    ir_close();</span><br><span class="line">    <span class="keyword">return</span> decode_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将解码得到的数据通过HDF发送到上文的IR驱动：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> decoded[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//红外二进制文件解码的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">SendArray</span><span class="params">(<span class="keyword">struct</span> HdfIoService *service, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为devoded比较大，需要特别申请</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">send_buf</span> =</span> HdfSBufObtain(len);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">recv_buf</span> =</span> HdfSBufObtainDefaultSize();</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (send_buf == <span class="literal">NULL</span> || recv_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;HdfSBufObtain fail.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!HdfSbufWriteBuffer(send_buf, decoded, len))</span><br><span class="line">    &#123;</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;write send_buf fail fail.&quot;</span>);</span><br><span class="line">        HdfSBufRecycle(send_buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = service-&gt;dispatcher-&gt;Dispatch(&amp;service-&gt;object, AC_CONTROL, send_buf, recv_buf);</span><br><span class="line">    <span class="keyword">if</span> (ret != HDF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        HILOG_ERROR(HILOG_MODULE_ACE, <span class="string">&quot;Dispatch fail.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HdfSbufReadUint32(recv_buf, &amp;ret);</span><br><span class="line"></span><br><span class="line">    HdfSBufRecycle(send_buf);</span><br><span class="line">    HdfSBufRecycle(recv_buf);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要添加一些使用到的宏和头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC_CONTROL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IR_SERVICE <span class="string">&quot;hdf_ir&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_io_service_if.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ir_decode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ac_power = <span class="number">0</span>,</span><br><span class="line">    ac_temp = <span class="number">1</span>,</span><br><span class="line">    ac_mode = <span class="number">2</span>,</span><br><span class="line">    ac_wind_dir = <span class="number">3</span>,</span><br><span class="line">    ac_wind_speed = <span class="number">4</span>,</span><br><span class="line">&#125; operations;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="3、配置编译系统"><a href="#3、配置编译系统" class="headerlink" title="3、配置编译系统"></a>3、配置编译系统</h3><p>这一步的目的是将我们上诉编写的源文件加入到编译系统。</p>
<h4 id="3-1、设置头文件路径"><a href="#3-1、设置头文件路径" class="headerlink" title="3.1、设置头文件路径"></a>3.1、设置头文件路径</h4><p>在<code>foundation\ace\ace_engine_lite\ace_lite.gni</code>中添加HDF头文件路径和irext的头文件路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ace_lite_include_dirs += [</span><br><span class="line">    <span class="string">&quot;//drivers/framework/ability/sbuf/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/utils&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/posix/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/include&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="3-2、添加源文件"><a href="#3-2、添加源文件" class="headerlink" title="3.2、添加源文件"></a>3.2、添加源文件</h4><p>在<code>foundation\ace\ace_engine_lite\ace_lite.gni</code>中添加irext的源文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ace_lite_sources = [</span><br><span class="line">    <span class="comment">//从这里开始</span></span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_apply.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_binary_parse.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_build_frame.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_control.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_parse_forbidden_info.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_parse_frame_info.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_ac_parse_parameter.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_tv_control.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_utils.c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/modules/irext_decoder/ir_decode.c&quot;</span>,</span><br><span class="line">    <span class="comment">//到这里结束</span></span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/animation/transition_impl.cpp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/base/ace_lock.cpp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/base/async_task_manager.cpp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/base/dft_impl.cpp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/base/dfx_assist.cpp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$ACE_LITE_PATH/src/core/base/event_util.cpp&quot;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-3、添加编译依赖"><a href="#3-3、添加编译依赖" class="headerlink" title="3.3、添加编译依赖"></a>3.3、添加编译依赖</h4><p>修改<code>foundation\ace\ace_engine_lite\frameworks\BUILD.gn</code>，在<code>public_deps</code>中添加以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;//drivers/adapter/uhdf/manager:hdf_core&quot;,</span><br></pre></td></tr></table></figure>

<p>修改<code>foundation\ace\ace_engine_lite\test\ace_test_config.gni</code>，在<code>extra_deps</code>中添加以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;//drivers/adapter/uhdf/manager:hdf_core&quot;,</span><br></pre></td></tr></table></figure>

<p>最后编译，烧录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/stm32mp157_ir_control/" data-id="cmbcy7rhq002tt8mt8n8lg5rb" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/bear_micro_LED" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/bear_micro_LED/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.669Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一、效果展示"><a href="#一、效果展示" class="headerlink" title="一、效果展示"></a>一、效果展示</h2><p>[video(video-1Vu774ee-1643158279760)(type-bilibili)(url-<a target="_blank" rel="noopener" href="https://player.bilibili.com/player.html?aid=808427731)(image-https://img-blog.csdnimg.cn/img_convert/7fb15a630bcd5bd3a9b5479cab150272.png)">https://player.bilibili.com/player.html?aid=808427731)(image-https://img-blog.csdnimg.cn/img_convert/7fb15a630bcd5bd3a9b5479cab150272.png)</a>(title-小熊派micro OpenHarmony3.0 鸿蒙LED应用)]</p>
<h2 id="二、led控制程序"><a href="#二、led控制程序" class="headerlink" title="二、led控制程序"></a>二、led控制程序</h2><p>本文按照小熊派官方的开发指南完成led应用程序开发，在开发指南的基础上添加一些自己的理解。</p>
<p>LED驱动虽然简单，但能帮助新手快速熟悉OpenHarmony HDF的开发框架，是非常适合新手学习实践的项目。</p>
<p>本文实现一个LED的开关控制的APP，所涉及的内容包括</p>
<ul>
<li>led驱动程序</li>
<li>C应用程序</li>
<li>JS应用程序</li>
</ul>
<h3 id="2-1、led驱动程序"><a href="#2-1、led驱动程序" class="headerlink" title="2.1、led驱动程序"></a>2.1、led驱动程序</h3><p>使用HDF框架进行驱动开发，分两个部分：驱动程序，驱动配置。</p>
<h4 id="2-1-1、驱动程序"><a href="#2-1-1、驱动程序" class="headerlink" title="2.1.1、驱动程序"></a>2.1.1、驱动程序</h4><p>驱动程序的代码在&#x2F;device&#x2F;st&#x2F;driver&#x2F;led&#x2F;led.c</p>
<p>其主要是定义驱动程序入口函数，在HDF加载时读取配置信息并初始化GPIO，定义dispatch函数，用于处理与用户层的交互逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_device_desc.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_log.h&quot;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;device_resource_if.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;osal_io.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;osal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;osal_mem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio_if.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDF_LOG_TAG led_driver</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WRITE_READ 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LedOps</span> &#123;</span></span><br><span class="line">    LED_OFF,</span><br><span class="line">    LED_ON,  </span><br><span class="line">    LED_TOGGLE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stm32Mp1ILed</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> gpioNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stm32Mp1ILed</span> <span class="title">g_Stm32Mp1ILed</span>;</span></span><br><span class="line"><span class="type">uint8_t</span> status = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 读取驱动私有配置（设备树）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">Stm32LedReadDrs</span><span class="params">(<span class="keyword">struct</span> Stm32Mp1ILed *led, <span class="type">const</span> <span class="keyword">struct</span> DeviceResourceNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DeviceResourceIface</span> *<span class="title">drsOps</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    drsOps = DeviceResourceGetIfaceInstance(HDF_CONFIG_SOURCE);</span><br><span class="line">    <span class="keyword">if</span> (drsOps == <span class="literal">NULL</span> || drsOps-&gt;GetUint32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: invalid drs ops!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读取led.hcs里面led_gpio_num的值 */</span></span><br><span class="line">    ret = drsOps-&gt;GetUint32(node, <span class="string">&quot;led_gpio_num&quot;</span>, &amp;led-&gt;gpioNum, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">if</span> (ret != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: read led gpio num fail!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch是对外提供的服务，用来处理用户态发下来的消息，同时返回数据</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">LedDriverDispatch</span><span class="params">(<span class="keyword">struct</span> HdfDeviceIoClient *client, <span class="type">int</span> cmdCode, <span class="keyword">struct</span> HdfSBuf *data, <span class="keyword">struct</span> HdfSBuf *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> contrl;</span><br><span class="line">    HDF_LOGE(<span class="string">&quot;Led driver dispatch&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="literal">NULL</span> || client-&gt;device == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;Led driver device is NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmdCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 接收到用户态发来的LED_WRITE_READ命令 */</span></span><br><span class="line">    <span class="keyword">case</span> LED_WRITE_READ:</span><br><span class="line">        <span class="comment">/* 读取data里的数据，赋值给contrl */</span></span><br><span class="line">        HdfSbufReadUint8(data,&amp;contrl);                  </span><br><span class="line">        <span class="keyword">switch</span> (contrl)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* 开灯 */</span></span><br><span class="line">        <span class="keyword">case</span> LED_ON:                                            </span><br><span class="line">            GpioWrite(g_Stm32Mp1ILed.gpioNum, GPIO_VAL_LOW);</span><br><span class="line">            status = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 关灯 */</span></span><br><span class="line">        <span class="keyword">case</span> LED_OFF:                                           </span><br><span class="line">            GpioWrite(g_Stm32Mp1ILed.gpioNum, GPIO_VAL_HIGH);</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 状态翻转 */</span></span><br><span class="line">        <span class="keyword">case</span> LED_TOGGLE:</span><br><span class="line">            <span class="keyword">if</span>(status == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                GpioWrite(g_Stm32Mp1ILed.gpioNum, GPIO_VAL_LOW);</span><br><span class="line">                status = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                GpioWrite(g_Stm32Mp1ILed.gpioNum, GPIO_VAL_HIGH);</span><br><span class="line">                status = <span class="number">0</span>;</span><br><span class="line">            &#125;                                        </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 把LED的状态值写入reply, 可被带至用户程序 */</span></span><br><span class="line">        <span class="keyword">if</span> (!HdfSbufWriteInt32(reply, status))                </span><br><span class="line">        &#123;</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;replay is fail&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动对外提供的服务能力，将相关的服务接口绑定到HDF框架</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfLedDriverBind</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *deviceObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (deviceObject == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;Led driver bind failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//定义对外提供的服务函数</span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IDeviceIoService</span> <span class="title">ledDriver</span> =</span> &#123;</span><br><span class="line">        .Dispatch = LedDriverDispatch,</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">//将服务绑定到驱动</span></span><br><span class="line">    deviceObject-&gt;service = (<span class="keyword">struct</span> IDeviceIoService *)(&amp;ledDriver);</span><br><span class="line">    HDF_LOGD(<span class="string">&quot;Led driver bind success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动自身业务初始的接口（设置IO口为输出） HDF框架在加载驱动的时候，会将私有配置信息保存在HdfDeviceObject 中的property里面</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">HdfLedDriverInit</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stm32Mp1ILed</span> *<span class="title">led</span> =</span> &amp;g_Stm32Mp1ILed;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device == <span class="literal">NULL</span> || device-&gt;property == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: device or property NULL!&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读取hcs私有属性值，gpio引脚号 */</span></span><br><span class="line">    ret = Stm32LedReadDrs(led, device-&gt;property);</span><br><span class="line">    <span class="keyword">if</span> (ret != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: get led device resource fail:%d&quot;</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将GPIO管脚配置为输出 */</span></span><br><span class="line">    ret = GpioSetDir(led-&gt;gpioNum, GPIO_DIR_OUT);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;GpioSerDir: failed, ret %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    HDF_LOGD(<span class="string">&quot;Led driver Init success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动资源释放的接口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HdfLedDriverRelease</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *deviceObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (deviceObject == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;Led driver release failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HDF_LOGD(<span class="string">&quot;Led driver release success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义驱动入口的对象，必须为HdfDriverEntry（在hdf_device_desc.h中定义）类型的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HdfDriverEntry</span> <span class="title">g_ledDriverEntry</span> =</span> &#123;</span><br><span class="line">    .moduleVersion = <span class="number">1</span>,</span><br><span class="line">    .moduleName = <span class="string">&quot;HDF_LED&quot;</span>,	<span class="comment">//必须与device_info.hcs中的字段一样，用于与驱动设备资源匹配</span></span><br><span class="line">    .Bind = HdfLedDriverBind,</span><br><span class="line">    .Init = HdfLedDriverInit,</span><br><span class="line">    .Release = HdfLedDriverRelease,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用HDF_INIT将驱动入口注册到HDF框架中</span></span><br><span class="line">HDF_INIT(g_ledDriverEntry);</span><br></pre></td></tr></table></figure>
<p>在创建完成led.c后，还要把它加入OpenHarmony的构建系统。</p>
<p>在led.c同目录下创建BUILD.gn，内容如下：</p>
<ul>
<li>导入hdf.gni：</li>
<li>定义hdf驱动：驱动的源文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;//drivers/adapter/khdf/liteos/hdf.gni&quot;</span>)</span><br><span class="line">hdf_driver(<span class="string">&quot;hdf_led&quot;</span>) &#123;</span><br><span class="line">    sources = [</span><br><span class="line">    <span class="string">&quot;led.c&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上层目录的BUILD.gn中的deps中添加”led”目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">group(<span class="string">&quot;drivers&quot;</span>) &#123;</span><br><span class="line">  deps = [</span><br><span class="line">    <span class="string">&quot;uart&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iwdg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gpio&quot;</span>,</span><br><span class="line">    <span class="string">&quot;led&quot;</span>,</span><br><span class="line">    <span class="string">&quot;stm32mp1xx_hal&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wifi/driver/hi3881&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wifi/driver:hdf_vendor_wifi&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2、驱动配置"><a href="#2-1-2、驱动配置" class="headerlink" title="2.1.2、驱动配置"></a>2.1.2、驱动配置</h4><p>HDF使用HCS文件来描述设备配置信息。驱动配置包含两个部分：</p>
<ul>
<li>HDF框架规定的驱动设备描述：device&#x2F;st&#x2F;bearpi_hm_micro&#x2F;liteos_a&#x2F;hdf_config&#x2F;device_info&#x2F;device_info.hcs</li>
<li>驱动的私有配置信息：device&#x2F;st&#x2F;bearpi_hm_micro&#x2F;liteos_a&#x2F;hdf_config&#x2F;led&#x2F;led_config.hcs</li>
</ul>
<p><strong>HDF所需的驱动设备描述：</strong></p>
<p>这些配置信息是HDF框架所需要的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   platform :: host &#123;</span><br><span class="line">       hostName = <span class="string">&quot;platform_host&quot;</span>;</span><br><span class="line">       priority = <span class="number">50</span>;</span><br><span class="line">       device_led :: device &#123;			<span class="comment">// led设备节点</span></span><br><span class="line">           device0 :: deviceNode &#123;		<span class="comment">// led驱动的DeviceNode节点</span></span><br><span class="line">               policy = <span class="number">2</span>;				<span class="comment">// policy字段是驱动服务发布的策略，在驱动服务管理章节有详细介绍</span></span><br><span class="line">               priority = <span class="number">10</span>;			<span class="comment">// 驱动启动优先级（0-200），值越大优先级越低，建议默认配100，优先级相同则不保证device的加载顺序</span></span><br><span class="line">               preload = <span class="number">1</span>;			<span class="comment">// 驱动按需加载字段</span></span><br><span class="line">permission = <span class="number">0777</span>;		<span class="comment">// 驱动创建设备节点权限</span></span><br><span class="line">               moduleName = <span class="string">&quot;HDF_LED&quot;</span>;	<span class="comment">// 驱动名称，该字段的值必须和驱动入口结构的moduleName相等</span></span><br><span class="line">               serviceName = <span class="string">&quot;hdf_led&quot;</span>;		<span class="comment">// 驱动对外发布服务的名称，必须唯一</span></span><br><span class="line">               deviceMatchAttr = <span class="string">&quot;st_stm32mp157_led&quot;</span>;		<span class="comment">// 驱动私有数据匹配的关键字，必须和驱动私有数据配置表中的match_attr值相等</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><strong>私有配置信息：</strong></p>
<p>私有配置信息是可选的，在这里我们保存着led对应的gpio管脚号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root &#123;</span><br><span class="line">    LedDriverConfig &#123;</span><br><span class="line">        led_gpio_num = <span class="number">13</span>;					<span class="comment">//gpio管脚号</span></span><br><span class="line">        match_attr = <span class="string">&quot;st_stm32mp157_led&quot;</span>;   <span class="comment">//该字段的值必须和device_info.hcs中的deviceMatchAttr值一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、C应用程序"><a href="#2-2、C应用程序" class="headerlink" title="2.2、C应用程序"></a>2.2、C应用程序</h3><p>驱动程序已经完成了，现在来编写应用程序。</p>
<p>应用程序做的是：绑定hdf驱动提供的服务（通过”hdf_led”，定义在device_info.hcs）并调用dispatch函数与驱动程序通信。通过0、1、2命令来使驱动程序输出高低电平。</p>
<p>需要注意的是应用程序不能直接读写驱动程序的变量、需要通过<code>HdfSBufObtainDefaultSize()</code>来申请内存，通过这个特殊的内存地址来跟驱动通信。</p>
<p>applications\BearPi\BearPi-HM_Micro\samples\my_led_app\my_led_app.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_io_service_if.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WRITE_READ 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SERVICE <span class="string">&quot;hdf_led&quot;</span> 	<span class="comment">//这里和hdf.hcs里的节点属性一样</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">SendEvent</span><span class="params">(<span class="keyword">struct</span> HdfIoService *service,<span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使用HdfSBufObtainDefaultSize申请内存，这种类型的内存才能用于和驱动程序交换数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">send_buf</span> =</span> HdfSBufObtainDefaultSize();</span><br><span class="line">	<span class="keyword">if</span>(send_buf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send_buf fail\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HdfSBuf</span> *<span class="title">reply</span> =</span> HdfSBufObtainDefaultSize();</span><br><span class="line">	<span class="keyword">if</span>(reply == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;reply fail\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将数据写入send_buf</span></span><br><span class="line">	<span class="keyword">if</span> (!HdfSbufWriteUint8(send_buf, data))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;write send_buf fail\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">/* 通过Dispatch发送数据到驱动，同时驱动会将数据写入reply */</span></span><br><span class="line">    <span class="type">int</span> ret = service-&gt;dispatcher-&gt;Dispatch(&amp;service-&gt;object, LED_WRITE_READ, send_buf, reply);</span><br><span class="line">	<span class="keyword">if</span>(ret != HDF_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Dispatch fail\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> replyData = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//读取reply的数据</span></span><br><span class="line">	<span class="keyword">if</span> (!HdfSbufReadInt32(reply, &amp;replyData))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to get service call reply!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//回收内存</span></span><br><span class="line">out:</span><br><span class="line">    HdfSBufRecycle(send_buf);</span><br><span class="line">    HdfSBufRecycle(reply);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error,argc &lt; 1\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取驱动提供的服务</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HdfIoService</span> *<span class="title">service</span> =</span> HdfIoServiceBind(LED_SERVICE);</span><br><span class="line">	<span class="keyword">if</span>(service == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail get service %s \r\n&quot;</span>,LED_SERVICE);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//给驱动的服务发送数据</span></span><br><span class="line">	SendEvent(service,atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//退订服务</span></span><br><span class="line">	HdfIoServiceRecycle(service);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要将my_led_app.c编译成可执行程序，并放在根文件系统。需要配置构建文件：</p>
<p>在my_led_app.c同目录下创建BUILD.gn：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;//build/lite/config/component/lite_component.gni&quot;</span>)</span><br><span class="line"></span><br><span class="line">HDF_FRAMEWORKS = <span class="string">&quot;//drivers/framework&quot;</span></span><br><span class="line"></span><br><span class="line">executable(<span class="string">&quot;led_lib&quot;</span>)&#123;</span><br><span class="line">    output_name = <span class="string">&quot;my_led&quot;</span></span><br><span class="line">    sources = [ <span class="string">&quot;my_led_app.c&quot;</span> ]</span><br><span class="line">    include_dirs = [</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/ability/sbuf/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/core/shared/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/core/host/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/core/master/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/include/core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/include/utils&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/utils/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$HDF_FRAMEWORKS/include/osal&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/posix/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//third_party/bounds_checking_function/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//base/hiviewdfx/hilog_lite/interfaces/native/innerkits&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">&quot;//base/hiviewdfx/hilog_lite/frameworks/featured:hilog_shared&quot;</span>,</span><br><span class="line">        <span class="string">&quot;//drivers/adapter/uhdf/manager:hdf_core&quot;</span>,</span><br><span class="line">        <span class="string">&quot;//drivers/adapter/uhdf/posix:hdf_posix_osal&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    cflags_c = []</span><br><span class="line">    ldflags = []</span><br><span class="line">&#125;</span><br><span class="line">lite_component(<span class="string">&quot;my_led_app&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    features = [</span><br><span class="line">        <span class="string">&quot;:led_lib&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在build&#x2F;lite&#x2F;components&#x2F;applications.json添加如下内容，将my_led_app编译成一个组件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   &#123;</span><br><span class="line">      <span class="string">&quot;component&quot;</span>: <span class="string">&quot;my_sample&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;my samples&quot;</span>,</span><br><span class="line">      <span class="string">&quot;optional&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dirs&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;applications/BearPi/BearPi-HM_Micro/samples/my_first_app&quot;</span>,</span><br><span class="line"><span class="string">&quot;applications/BearPi/BearPi-HM_Micro/samples/my_led_app&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;targets&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;//applications/BearPi/BearPi-HM_Micro/samples/my_first_app:my_app&quot;</span>,</span><br><span class="line"><span class="string">&quot;//applications/BearPi/BearPi-HM_Micro/samples/my_led_app:my_led_app&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;rom&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ram&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;output&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;adapted_kernel&quot;</span>: [ <span class="string">&quot;liteos_a&quot;</span> ],</span><br><span class="line">      <span class="string">&quot;features&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;deps&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;components&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;third_party&quot;</span>: [ ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="2-3、JS应用"><a href="#2-3、JS应用" class="headerlink" title="2.3、JS应用"></a>2.3、JS应用</h3><h4 id="2-3-1、JS代码"><a href="#2-3-1、JS代码" class="headerlink" title="2.3.1、JS代码"></a>2.3.1、JS代码</h4><p>JS程序本质上也是调用了驱动程序所提供的服务来控制Led，与上一节的区别是使用的编程语言不同。JS代码通过<code>app.ledcontrol</code>来调用C++提供的接口，实际的控制逻辑由C++提供的<code>ledcontrol</code>实现。</p>
<p>首先看应用程序的JS代码：其本质就是调用ledcontrol函数，通过传递不同的参数来实现led的控制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灯状态 0是关闭 1是开启	2是切换</span></span><br><span class="line"><span class="keyword">var</span> led = &#123;<span class="attr">open</span>:<span class="number">1</span>,<span class="attr">close</span>:<span class="number">0</span>,<span class="attr">change</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&#x27;@system.app&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;BearPi-HM Micro&#x27;</span>,</span><br><span class="line">        <span class="attr">statu</span>:<span class="string">&#x27;0&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">exit</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        app.<span class="title function_">terminate</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">open</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">        <span class="comment">//调用ledcontrol函数、传递参数code、success、fail、complete</span></span><br><span class="line">        app.<span class="title function_">ledcontrol</span>(&#123;</span><br><span class="line">            <span class="attr">code</span>:led.<span class="property">open</span>,</span><br><span class="line">            <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">                that.<span class="property">statu</span> = res.<span class="property">led_status</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">fail</span>(<span class="params">res,code</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">complete</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">close</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">        app.<span class="title function_">ledcontrol</span>(&#123;</span><br><span class="line">            <span class="attr">code</span>:led.<span class="property">close</span>,</span><br><span class="line">            <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">                that.<span class="property">statu</span> = res.<span class="property">led_status</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">fail</span>(<span class="params">res,code</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">complete</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">change</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">        app.<span class="title function_">ledcontrol</span>(&#123;</span><br><span class="line">            <span class="attr">code</span>:led.<span class="property">change</span>,</span><br><span class="line">            <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">                that.<span class="property">statu</span> = res.<span class="property">led_status</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">fail</span>(<span class="params">res,code</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">complete</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-3-2、C-接口"><a href="#2-3-2、C-接口" class="headerlink" title="2.3.2、C++接口"></a>2.3.2、C++接口</h4><p>JS代码中的app.ledcontrol要能运行起来，需要C++提供对应的函数。</p>
<p>步骤如下：</p>
<p>1、在foundation\ace\ace_engine_lite\frameworks\src\core\modules\app_module.h中public声明ToggleLed函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ACE_DISALLOW_COPY_AND_MOVE</span>(AppModule);</span><br><span class="line"><span class="built_in">AppModule</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">AppModule</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> JSIValue <span class="title">GetInfo</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> JSIValue <span class="title">Terminate</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> JSIValue <span class="title">ToggleLed</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue* args, <span class="type">uint8_t</span> argsNum)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接着在InitAppModule()中将ToggleLed注册到JS API中，这样JS代码就能通过ledcontrol接口调用ToggleLed函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">InitAppModule</span>(<span class="title class_">JSIValue</span> <span class="built_in">exports</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">JSI</span>::<span class="title class_">SetModuleAPI</span>(<span class="built_in">exports</span>, <span class="string">&quot;getInfo&quot;</span>, <span class="title class_">AppModule</span>::<span class="title class_">GetInfo</span>);</span><br><span class="line">    <span class="attr">JSI</span>::<span class="title class_">SetModuleAPI</span>(<span class="built_in">exports</span>, <span class="string">&quot;terminate&quot;</span>, <span class="title class_">AppModule</span>::<span class="title class_">Terminate</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="attr">JSI</span>::<span class="title class_">SetModuleAPI</span>(<span class="built_in">exports</span>, <span class="string">&quot;ledcontrol&quot;</span>, <span class="title class_">AppModule</span>::<span class="title class_">ToggleLed</span>);</span><br></pre></td></tr></table></figure>
<p>2、在foundation\ace\ace_engine_lite\frameworks\src\core\modules\app_module.cpp中实现ToggleLed()</p>
<p>首先添加头文件和宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hdf_io_service_if.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WRITE_READ 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SERVICE <span class="string">&quot;hdf_led&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>添加ToggleLed()的定义：将以下代码与2.2 LED应用程序比较、不难看出两者逻辑是相同的，差别在于C++这里需要处理success、fail、complete的回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">OnDevEventReceived</span><span class="params">(<span class="type">void</span> *priv, <span class="type">uint32_t</span> id, <span class="keyword">struct</span> HdfSBuf *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> value;</span><br><span class="line">    <span class="built_in">HdfSbufReadUint32</span>(data, &amp;value);</span><br><span class="line">    <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;%s: dev event received: %u %u\n&quot;</span>, (<span class="type">char</span> *)priv, id, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向led驱动发送数据并返回结果</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GpioWriteRead</span><span class="params">(<span class="keyword">struct</span> HdfIoService *serv, <span class="type">int32_t</span> eventData, <span class="type">int32_t</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = HDF_FAILURE;</span><br><span class="line">    <span class="comment">//申请内存用于和HDF驱动通信</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HdfSBuf</span> *data = <span class="built_in">HdfSBufObtainDefaultSize</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HdfSBuf</span> *reply = <span class="built_in">HdfSBufObtainDefaultSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span> || reply == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;fail to obtain sbuf data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将eventData的数据复制到data</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">HdfSbufWriteUint8</span>(data, (<span class="type">uint8_t</span>)eventData))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;fail to write sbuf\n&quot;</span>);</span><br><span class="line">        <span class="built_in">HdfSBufRecycle</span>(data);</span><br><span class="line">        <span class="built_in">HdfSBufRecycle</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用驱动的dispatch函数，向led驱动发送数据并接收返回结果。</span></span><br><span class="line">    ret = serv-&gt;dispatcher-&gt;<span class="built_in">Dispatch</span>(&amp;serv-&gt;object, LED_WRITE_READ, data, reply);</span><br><span class="line">    <span class="keyword">if</span> (ret != HDF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;fail to send service call\n&quot;</span>);</span><br><span class="line">        <span class="built_in">HdfSBufRecycle</span>(data);</span><br><span class="line">        <span class="built_in">HdfSBufRecycle</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取返回结果到reply</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">HdfSbufReadInt32</span>(reply, val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;fail to get service call reply\n&quot;</span>);</span><br><span class="line">        ret = HDF_ERR_INVALID_OBJECT;</span><br><span class="line">        <span class="built_in">HdfSBufRecycle</span>(data);</span><br><span class="line">        <span class="built_in">HdfSBufRecycle</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;Get reply is: %d\n&quot;</span>, val);</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">HdfSBufRecycle</span>(data);</span><br><span class="line">    <span class="built_in">HdfSBufRecycle</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//led控制</span></span><br><span class="line"><span class="function">JSIValue <span class="title">AppModule::ToggleLed</span><span class="params">(<span class="type">const</span> JSIValue thisVal, <span class="type">const</span> JSIValue *args, <span class="type">uint8_t</span> argsNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE, <span class="string">&quot;led button pressed.&quot;</span>);</span><br><span class="line">	<span class="comment">//获取led驱动提供的服务</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HdfIoService</span> *serv = <span class="built_in">HdfIoServiceBind</span>(LED_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (serv == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;fail to get service2 %s\n&quot;</span>, LED_SERVICE);</span><br><span class="line">        <span class="keyword">return</span> JSI::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((args == <span class="literal">nullptr</span>) || (argsNum == <span class="number">0</span>) || (JSI::<span class="built_in">ValueIsUndefined</span>(args[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSI::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取JS代码中的success、fail、complete的？</span></span><br><span class="line">    JSIValue success = JSI::<span class="built_in">GetNamedProperty</span>(args[<span class="number">0</span>], CB_SUCCESS);</span><br><span class="line">    JSIValue fail = JSI::<span class="built_in">GetNamedProperty</span>(args[<span class="number">0</span>], CB_FAIL);</span><br><span class="line">    JSIValue complete = JSI::<span class="built_in">GetNamedProperty</span>(args[<span class="number">0</span>], CB_COMPLETE);</span><br><span class="line">	<span class="comment">//获取code的值，即JS代码中的 code:led.open，也就是 0、1、2控制码</span></span><br><span class="line">    <span class="type">int32_t</span> num = (<span class="type">int32_t</span>)JSI::<span class="built_in">GetNumberProperty</span>(args[<span class="number">0</span>], <span class="string">&quot;code&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> replyData = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//将命令发送到led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GpioWriteRead</span>(serv, num, &amp;replyData))</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//驱动led失败、调用fail、complete函数</span></span><br><span class="line">        <span class="built_in">HILOG_ERROR</span>(HILOG_MODULE_ACE,<span class="string">&quot;fail to send event\n&quot;</span>);</span><br><span class="line">        JSI::<span class="built_in">CallFunction</span>(fail, thisVal, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        JSI::<span class="built_in">CallFunction</span>(complete, thisVal, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        JSI::<span class="built_in">ReleaseValueList</span>(success, fail, complete);</span><br><span class="line">        <span class="keyword">return</span> JSI::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//驱动led成功，返回结果对象</span></span><br><span class="line">    JSIValue result = JSI::<span class="built_in">CreateObject</span>();</span><br><span class="line">    <span class="comment">//设置结果对象中的led_status属性值。对应js代码中的&quot;that.statu = res.led_status&quot;</span></span><br><span class="line">    JSI::<span class="built_in">SetNumberProperty</span>(result, <span class="string">&quot;led_status&quot;</span>, replyData);</span><br><span class="line">	<span class="comment">//调用success、complete函数</span></span><br><span class="line">    JSIValue argv[ARGC_ONE] = &#123;result&#125;;</span><br><span class="line">    JSI::<span class="built_in">CallFunction</span>(success, thisVal, argv, ARGC_ONE);</span><br><span class="line">    JSI::<span class="built_in">CallFunction</span>(complete, thisVal, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    JSI::<span class="built_in">ReleaseValueList</span>(success, fail, complete, result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HdfIoServiceRecycle</span>(serv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSI::<span class="built_in">CreateUndefined</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、将编写的源文件添加到编译系统。</p>
<p>首先配置HDF头文件路径：<br>在foundation\ace\ace_engine_lite\ace_lite.gni中添加HDF头文件路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ace_lite_include_dirs += [</span><br><span class="line">    <span class="string">&quot;//drivers/framework/ability/sbuf/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/framework/include/utils&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//drivers/adapter/uhdf/posix/include&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>添加编译依赖：<br>修改foundation\ace\ace_engine_lite\frameworks\BUILD.gn，在public_deps中添加以下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;//drivers/adapter/uhdf/manager:hdf_core&quot;</span>,</span><br></pre></td></tr></table></figure>


<p>修改foundation\ace\ace_engine_lite\test\ace_test_config.gni，在extra_deps中添加以下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;//drivers/adapter/uhdf/manager:hdf_core&quot;</span>,</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/bear_micro_LED/" data-id="cmbcy7rho002mt8mt7c60br47" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/OpenHarmony/HDF_PWM_Core" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/HDF_PWM_Core/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.668Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="PWM-Core"><a href="#PWM-Core" class="headerlink" title="PWM Core"></a>PWM Core</h2><p>在上一篇中中，我们使用到了pwm_if.h，将我们实现的pwm驱动注册到pwm核心层，本文就来介绍这个pwm core是如何实现的，以及这个核心层的作用。</p>
<h3 id="PwmDev"><a href="#PwmDev" class="headerlink" title="PwmDev"></a>PwmDev</h3><p>在pwm core中，定义了一个PwmDev，它是对所有pwm外设的一个抽象的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PwmDev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IDeviceIoService</span> <span class="title">service</span>;</span>    <span class="comment">//驱动服务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HdfDeviceObject</span> *<span class="title">device</span>;</span>     <span class="comment">//驱动对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PwmConfig</span> <span class="title">cfg</span>;</span>               <span class="comment">//pwm配置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PwmMethod</span> *<span class="title">method</span>;</span>           <span class="comment">//底层pwm驱动实现的方法</span></span><br><span class="line">    <span class="type">bool</span> busy;                          <span class="comment">//忙标志</span></span><br><span class="line">    <span class="type">uint32_t</span> num;                       <span class="comment">//pwm设备编号</span></span><br><span class="line">    OsalSpinlock lock;                  <span class="comment">//自旋锁</span></span><br><span class="line">    <span class="type">void</span> *priv;                         <span class="comment">//私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该对象在pwm core中起到承上启下的作用，可以通过PwmMethod对象来调用底层的pwm驱动，实现方波的配置。对于上层，则在驱动的基础上，增加了busy标志以及自旋锁，并封装了对底层驱动服务的订阅操作，简化了内核驱动使用pwm的步骤。（省去了订阅驱动服务）</p>
<h3 id="PWM-核心层接口"><a href="#PWM-核心层接口" class="headerlink" title="PWM 核心层接口"></a>PWM 核心层接口</h3><p>在上一篇中，我们会调用PwmDeviceAdd()函数，将我们定义的PWM驱动注册到核心层，其实现是非常简单的：</p>
<p>主要的工作就是初始化自旋锁，以及将pwmdev对象和驱动服务互相绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加PWM驱动到核心层</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmDeviceAdd</span><span class="params">(<span class="keyword">struct</span> HdfDeviceObject *obj, <span class="keyword">struct</span> PwmDev *pwm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span> || pwm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: invalid parameter&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pwm-&gt;method == <span class="literal">NULL</span> || pwm-&gt;method-&gt;setConfig == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: setConfig is null&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化pwm的锁，pwm驱动在同一时间只能被一个应用使用</span></span><br><span class="line">    <span class="keyword">if</span> (OsalSpinInit(&amp;(pwm-&gt;lock)) != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: init spinlock fail&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定驱动服务和pwmdev，PwmOpen()会用到</span></span><br><span class="line">    pwm-&gt;device = obj;</span><br><span class="line">    obj-&gt;service = &amp;(pwm-&gt;service);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得核心层如何和底层pwm驱动通信吗？我们实现了一个PwmMethod的对象，这个对象会在核心层被频繁的调用，使用该对象里的函数。上一篇中，我们实现了setConfig方法，我们来看在核心层中，它是如何被使用的。具体而言，是在pwm_core.c中的PwmSetConfig():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新pwm的配置</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">PwmSetConfig</span><span class="params">(DevHandle handle, <span class="keyword">struct</span> PwmConfig *config)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PwmDev</span> *<span class="title">pwm</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: handle is NULL&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: config is NULL&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取pwmdev</span></span><br><span class="line">    pwm = (<span class="keyword">struct</span> PwmDev *)handle;</span><br><span class="line">    <span class="comment">//比较pwm-&gt;cfg和config的内容是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(config, &amp;(pwm-&gt;cfg), <span class="keyword">sizeof</span>(*config)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//配置相同，说明不需要更新，直接返回</span></span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: do not need to set config&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，需要更新pwm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查method对象，由底层实现的</span></span><br><span class="line">    <span class="keyword">if</span> (pwm-&gt;method == <span class="literal">NULL</span> || pwm-&gt;method-&gt;setConfig == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: setConfig is not support&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_ERR_NOT_SUPPORT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用底层驱动，实现设置pwm</span></span><br><span class="line">    ret = pwm-&gt;method-&gt;setConfig(pwm, config);</span><br><span class="line">    <span class="keyword">if</span> (ret != HDF_SUCCESS) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: failed, ret %d&quot;</span>, __func__, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    pwm-&gt;cfg = *config;</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心层的其他函数最终也是调用PwmSetConfig()来完成与底层驱动的沟通。</p>
<p>在对上层应用的处理上，核心层引入了PwmOpen()和PwmClose()来限制进程对pwm驱动的并发访问。当一个应用打算使用某一个pwm驱动时，它必须要先调用PwmOpen()来获取pwm驱动的使用权，在使用完成pwm驱动后，应该及时的调用PwmClose()来释放pwm驱动，以免造成资源的长期独占。</p>
<p>这么做的目的是，pwm的使用往往是有严格的时间要求，应用程序必须在这个时间内对pwm完全占有其使用权，否则pwm产生的方波就有可能出现噪声，导致应用出错。</p>
<p>PwmOpen()是如何实现对pwm驱动的独占呢，下面注释给出答案：</p>
<p>通过busy标志，来实现对pwm驱动的互斥使用。这里的自旋锁，是防止在多线程同时访问pwm-&gt;busy变量，导致程序出现严重错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开PWM，进程会占有pwm的驱动</span></span><br><span class="line">DevHandle <span class="title function_">PwmOpen</span><span class="params">(<span class="type">uint32_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line">    <span class="comment">//通过num获取到pwmdev对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PwmDev</span> *<span class="title">pwm</span> =</span> PwmGetDevByNum(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: dev is null&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入自旋锁</span></span><br><span class="line">    (<span class="type">void</span>)OsalSpinLock(&amp;(pwm-&gt;lock));</span><br><span class="line">    <span class="comment">//如果pwm的busy被置1，则表示pwm当前被其他进程使用中，返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (pwm-&gt;busy) &#123;</span><br><span class="line">        (<span class="type">void</span>)OsalSpinUnlock(&amp;(pwm-&gt;lock));</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: pwm%u is busy&quot;</span>, __func__, num);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，调用底层的open函数</span></span><br><span class="line">    <span class="keyword">if</span> (pwm-&gt;method != <span class="literal">NULL</span> &amp;&amp; pwm-&gt;method-&gt;open != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = pwm-&gt;method-&gt;open(pwm);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ret != HDF_SUCCESS) &#123;</span><br><span class="line">            (<span class="type">void</span>)OsalSpinUnlock(&amp;(pwm-&gt;lock));</span><br><span class="line">            HDF_LOGE(<span class="string">&quot;%s: open failed, ret %d&quot;</span>, __func__, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置pwm的busy标志为1，表示对pwm驱动的占有</span></span><br><span class="line">    pwm-&gt;busy = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//退出自旋锁</span></span><br><span class="line">    (<span class="type">void</span>)OsalSpinUnlock(&amp;(pwm-&gt;lock));</span><br><span class="line">    <span class="keyword">return</span> (DevHandle)pwm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PwmGetDevByNum()函数实现了对pwm驱动服务的获取。我们在实现芯片的pwm底层驱动时，在配置中，必须将pwm驱动服务的名称设置为“HDF_PLATFORM_PWM_x”，x&#x3D;0,1,2,3…，这样我们才能正确的接入pwm核心层。通过pwm驱动服务，我们就能获取到PwmDev对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> PwmDev *<span class="title function_">PwmGetDevByNum</span><span class="params">(<span class="type">uint32_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> *name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PwmDev</span> *<span class="title">pwm</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//申请字符串内存</span></span><br><span class="line">    name = (<span class="type">char</span> *)OsalMemCalloc(PWM_NAME_LEN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据num拼接字符串：如HDF_PLATFORM_PWM_1</span></span><br><span class="line">    ret = snprintf_s(name, PWM_NAME_LEN + <span class="number">1</span>, PWM_NAME_LEN, <span class="string">&quot;HDF_PLATFORM_PWM_%u&quot;</span>, num);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: snprintf_s failed&quot;</span>, __func__);</span><br><span class="line">        OsalMemFree(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过名称来获取PWM驱动服务</span></span><br><span class="line">    pwm = (<span class="keyword">struct</span> PwmDev *)DevSvcManagerClntGetService(name);</span><br><span class="line">    OsalMemFree(name);</span><br><span class="line">    <span class="keyword">return</span> pwm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PWM-Core的优势"><a href="#PWM-Core的优势" class="headerlink" title="PWM Core的优势"></a>PWM Core的优势</h3><p>以往的stm32编程中，都是直接使用pwm 库函数，为何OpenHarmony要引入一个核心层呢？我们来思考加入这个东西后，有什么优势。</p>
<p>首先就是芯片驱动和设备驱动的解耦。假设我写了一个呼吸灯的驱动程序，它会调用pwm_if.h中的函数，在某一个芯片平台上，它能够正常的运行。这时我要换一个芯片平台，因为有pwm核心层对芯片驱动的解耦，我不需要重新写一个呼吸灯的驱动程序。因为对于呼吸灯驱动来说，它调用的接口都是pwm_if.h，这个文件在所有OpenHarmony系统上都是相同的。只要新的芯片平台实现了底层的pwm驱动，那么我的呼吸灯驱动就能完美的运行。这也是OpenHarmony一次开发，多端部署的体现。</p>
<p>其次是加入了对PWM的互斥访问。单片机程序往往不需要考虑多进程共享访问的问题，而OpenHarmony是一个面向众多设备的操作系统，其有运行环境可能是多线程的。pwm核心层加入互斥锁以及busy变量，能有效的防止互斥访问的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/HDF_PWM_Core/" data-id="cmbcy7rhl002ct8mtaxpy9sv9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/FreeRTOS/2.task_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/2.task_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.662Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="任务管理（二）"><a href="#任务管理（二）" class="headerlink" title="任务管理（二）"></a>任务管理（二）</h2><p>多任务系统在同一时刻中，只有一个任务占有CPU的使用权。一个任务长期占有CPU会影响对系统的效应能力，故任务需要在空闲的时候，通过延时&#x2F;挂起来让出CPU的使用权给其他任务，这样任务调度器才能调度其他任务运行。</p>
<h3 id="一、任务延时-vTaskDelay"><a href="#一、任务延时-vTaskDelay" class="headerlink" title="一、任务延时 vTaskDelay"></a>一、任务延时 vTaskDelay</h3><p>任务延时就是当前任务将CPU让出一定时间，将任务插入延时链表中，等到延时时间到达才将任务恢复到就绪状态，等待调度运行。</p>
<p>其实质就是将任务移动到延时链表&#x2F;挂起链表。</p>
<p><strong>注意进入延时函数时，会挂起调度器，这是为了防止在插入就绪链表过程中，由于中断产生打乱了代码逻辑</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (xTicksToDelay &gt; (TickType_t)<span class="number">0U</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//TODO 挂起调度器、防止中断导致任务插入就绪链表、扰乱代码逻辑</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当调度器挂起时，任务不能插入就绪表</span></span><br><span class="line">            <span class="comment">//添加当前任务到延时链表</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复调度器、若恢复调度器时、已经完成一次任务调度、则接下来不需要再产生一次任务调度</span></span><br><span class="line">        xAlreadyYielded = xTaskResumeAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若调度器恢复时未进行任务调度，则启动一次任务调度</span></span><br><span class="line">    <span class="keyword">if</span> (xAlreadyYielded == pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvAddCurrentTaskToDelayedList</span><span class="params">(TickType_t xTicksToWait,</span></span><br><span class="line"><span class="params">                                           <span class="type">const</span> BaseType_t xCanBlockIndefinitely)</span></span><br><span class="line">&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    <span class="type">const</span> TickType_t xConstTickCount = xTickCount; <span class="comment">//保存当前时钟计数值为常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入延时链表、设置标记</span></span><br><span class="line">    pxCurrentTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先将当前任务移出就绪链表 若返回为0说明该优先级链表为空 需要重置最高优先级</span></span><br><span class="line">    <span class="keyword">if</span> (uxListRemove(&amp;(pxCurrentTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        portRESET_READY_PRIORITY(pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若延时时间最大且无限期等待，则直接加入挂起链表 任务调度器不对其管理</span></span><br><span class="line">        <span class="keyword">if</span> ((xTicksToWait == portMAX_DELAY) &amp;&amp; (xCanBlockIndefinitely != pdFALSE))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            vListInsertEnd(&amp;xSuspendedTaskList, &amp;(pxCurrentTCB-&gt;xStateListItem));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//插入延时链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算任务下次由时钟中断唤醒的时间戳 注意时钟溢出（当前时间+需要等待的时间=下次醒来的时间点）</span></span><br><span class="line">            xTimeToWake = xConstTickCount + xTicksToWait;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将时间戳设置为任务的状态节点值</span></span><br><span class="line">            listSET_LIST_ITEM_VALUE(&amp;(pxCurrentTCB-&gt;xStateListItem), xTimeToWake);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xTimeToWake &lt; xConstTickCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//延时时间溢出、任务插入延时溢出链表</span></span><br><span class="line">                vListInsert(pxOverflowDelayedTaskList, &amp;(pxCurrentTCB-&gt;xStateListItem));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//未溢出，插入当前延时链表</span></span><br><span class="line">                vListInsert(pxDelayedTaskList, &amp;(pxCurrentTCB-&gt;xStateListItem));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新xNextTaskUnblockTime</span></span><br><span class="line">                <span class="keyword">if</span> (xTimeToWake &lt; xNextTaskUnblockTime)</span><br><span class="line">                &#123;</span><br><span class="line">                    xNextTaskUnblockTime = xTimeToWake;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */</span></span><br><span class="line">        (<span class="type">void</span>)xCanBlockIndefinitely;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、绝对任务延时-xTaskDelayUntil"><a href="#二、绝对任务延时-xTaskDelayUntil" class="headerlink" title="二、绝对任务延时 xTaskDelayUntil"></a>二、绝对任务延时 xTaskDelayUntil</h3><p>另一种延时方式：延时一个任务直到指定的时间点到来。经常用于周期性的运行一个任务。</p>
<p>使用vTaskDelay()由于任务执行的时间是不确定的（可能被中断打断），故相对延时无法实现周期信运行一个任务。而使用绝对延时xTaskDelayUntil（）能保证任务在指定的时间点唤醒，延时时间由上一次运行时的时间点与所需延时频率计算。</p>
<p>该函数不同之处在于计算延时时间、最后都同样的调用prvAddCurrentTaskToDelayedList函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskDelayUntil</span><span class="params">(TickType_t *<span class="type">const</span> pxPreviousWakeTime,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> TickType_t xTimeIncrement)</span></span><br><span class="line">&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;</span><br><span class="line"></span><br><span class="line">    configASSERT(pxPreviousWakeTime);</span><br><span class="line">    configASSERT((xTimeIncrement &gt; <span class="number">0U</span>));</span><br><span class="line">    configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//TODO 挂起调度器、防止中断导致任务插入就绪链表、扰乱代码逻辑</span></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证xTickCount在本代码块内不会被修改</span></span><br><span class="line">        <span class="type">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算下次唤醒时间</span></span><br><span class="line">        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xConstTickCount &lt; *pxPreviousWakeTime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// -----cur++++++pre----- 只有当xTimeToWake在+号时才能进入延时</span></span><br><span class="line">            <span class="keyword">if</span> ((xTimeToWake &lt; *pxPreviousWakeTime) &amp;&amp; (xTimeToWake &gt; xConstTickCount))</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// +++++pre-----cur++++++ 只有当xTimeToWake在+号时才能进入延时</span></span><br><span class="line">            <span class="keyword">if</span> ((xTimeToWake &lt; *pxPreviousWakeTime) || (xTimeToWake &gt; xConstTickCount))</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新pxPreviousWakeTime</span></span><br><span class="line">        *pxPreviousWakeTime = xTimeToWake;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xShouldDelay != pdFALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY_UNTIL(xTimeToWake);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//prvAddCurrentTaskToDelayedList需要的是相对延时时间 故是xTimeToWake - xConstTickCount</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList(xTimeToWake - xConstTickCount, pdFALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复调度器、执行任务调度</span></span><br><span class="line">    xAlreadyYielded = xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xAlreadyYielded == pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xShouldDelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、终止延时"><a href="#三、终止延时" class="headerlink" title="三、终止延时"></a>三、终止延时</h3><p>有开始、就会有结束。其他任务可唤醒处于延时中的函数。其实质就是将任务移动到就绪链表、并进行任务调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskAbortDelay</span><span class="params">(TaskHandle_t xTask)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *pxTCB = xTask;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">    configASSERT(pxTCB);</span><br><span class="line">    <span class="comment">//挂起任务调度器</span></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//任务的状态为阻塞时，才能解锁</span></span><br><span class="line">        <span class="keyword">if</span> (eTaskGetState(xTask) == eBlocked)</span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从延时链表中移除</span></span><br><span class="line">            <span class="comment">//TODO  当调度器挂起时、中断不会修改任务的xStateListItem.所以在这里的操作是安全的</span></span><br><span class="line">            (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从事件链表中移除 （中断可能修改xEventListItem 故需要进入临界区）</span></span><br><span class="line">            taskENTER_CRITICAL();</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (listLIST_ITEM_CONTAINER(&amp;(pxTCB-&gt;xEventListItem)) != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">                    <span class="comment">//记录他已经解除挂起</span></span><br><span class="line">                    pxTCB-&gt;ucDelayAborted = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//退出延时后，进入就绪态（因为中断中不能访问就绪链表，故当前函数不能在中断中调用）</span></span><br><span class="line">            prvAddTaskToReadyList(pxTCB);</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//解锁任务的优先级高于当前任务优先级，发生抢占</span></span><br><span class="line">                <span class="keyword">if</span> (pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//挂起一次任务调度（因为当前调度器挂起了）</span></span><br><span class="line">                    xYieldPending = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = pdFAIL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、任务挂起"><a href="#四、任务挂起" class="headerlink" title="四、任务挂起"></a>四、任务挂起</h3><p>将指定任务挂起、该任务不会被恢复运行，除非用户代码恢复该任务。其代码逻辑就是将任务移动到挂起链表、并判断是否需要任务调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_t xTaskToSuspend)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *pxTCB;</span><br><span class="line">    <span class="comment">//进入临界区</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取任务tcb</span></span><br><span class="line">        pxTCB = prvGetTCBFromHandle(xTaskToSuspend);</span><br><span class="line"></span><br><span class="line">        traceTASK_SUSPEND(pxTCB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从就绪/阻塞链表中移除任务</span></span><br><span class="line">        <span class="keyword">if</span> (uxListRemove(&amp;(pxTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            taskRESET_READY_PRIORITY(pxTCB-&gt;uxPriority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从事件链表中移除任务</span></span><br><span class="line">        <span class="keyword">if</span> (listLIST_ITEM_CONTAINER(&amp;(pxTCB-&gt;xEventListItem)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将任务插入挂起链表</span></span><br><span class="line">        vListInsertEnd(&amp;xSuspendedTaskList, &amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xSchedulerRunning != pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//更新下次任务解锁时间。刚刚挂起的任务可能是下个解锁的任务</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            prvResetNextTaskUnblockTime();</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//挂起任务是正在运行的任务</span></span><br><span class="line">    <span class="keyword">if</span> (pxTCB == pxCurrentTCB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xSchedulerRunning != pdFALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前任务被挂起，执行一次任务调度</span></span><br><span class="line">            configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//todo 调度器关闭所以必须调整pxCurrentTCB</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (listCURRENT_LIST_LENGTH(&amp;xSuspendedTaskList) == uxCurrentNumberOfTasks)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//所有任务都被挂起 pxCurrentTCB为null，下次创建新任务时，就执行新任务</span></span><br><span class="line">                pxCurrentTCB = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新pxCurrentTCB</span></span><br><span class="line">                vTaskSwitchContext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、恢复任务"><a href="#五、恢复任务" class="headerlink" title="五、恢复任务"></a>五、恢复任务</h3><p>挂起的任务只有得到恢复才能运行。以下是函数在任务函数中调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_t xTaskToResume)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *<span class="type">const</span> pxTCB = xTaskToResume;</span><br><span class="line"></span><br><span class="line">    configASSERT(xTaskToResume);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复的任务不可能是null 并且 不可能是正在运行的任务</span></span><br><span class="line">    <span class="keyword">if</span> ((pxTCB != pxCurrentTCB) &amp;&amp; (pxTCB != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断是否真的在挂起链表中</span></span><br><span class="line">            <span class="keyword">if</span> (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                traceTASK_RESUME(pxTCB);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//移出挂起链表、加入就绪链表</span></span><br><span class="line">                (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line">                prvAddTaskToReadyList(pxTCB);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//恢复任务的优先级较高、进行任务调度</span></span><br><span class="line">                <span class="keyword">if</span> (pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、从中断中恢复任务"><a href="#六、从中断中恢复任务" class="headerlink" title="六、从中断中恢复任务"></a>六、从中断中恢复任务</h3><p>与上一次函数的区别是：</p>
<ul>
<li><p>该函数只能在中断中调用。</p>
</li>
<li><p>在中断中进入临界区使用的函数也不一样。同时，还需要注意当调度器挂起时，不能在中断中直接修改就绪链表，而是先将任务缓存到xPendingReadyList，当调度器恢复时，再将任务移动到就绪链表。</p>
</li>
<li><p>在中断中不能进行任务调度，所以该函数的返回值表示是否需要在退出中断后进行任务调度</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskResumeFromISR</span><span class="params">(TaskHandle_t xTaskToResume)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xYieldRequired = pdFALSE; <span class="comment">//任务调度标记 由于中断中不能执行上下文切换、故使用他来代替上下文切换</span></span><br><span class="line">    TCB_t *<span class="type">const</span> pxTCB = xTaskToResume;</span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line"></span><br><span class="line">    configASSERT(xTaskToResume);</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line">    <span class="comment">//进入中断级临界区</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR(); </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是否真的挂起</span></span><br><span class="line">        <span class="keyword">if</span> (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_RESUME_FROM_ISR(pxTCB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uxSchedulerSuspended == (UBaseType_t)pdFALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调度器运行中、若任务优先级更高、则产生任务调度</span></span><br><span class="line">                <span class="keyword">if</span> (pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">                &#123;</span><br><span class="line">                    xYieldRequired = pdTRUE; <span class="comment">//需要进行任务调度</span></span><br><span class="line"></span><br><span class="line">                    xYieldPending = pdTRUE; <span class="comment">//一个任务调度请求被挂起</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将任务移动到就绪链表</span></span><br><span class="line">                (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line">                prvAddTaskToReadyList(pxTCB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调度器挂起 不能在中断中直接修改就绪链表，先将任务缓存到xPendingReadyList</span></span><br><span class="line">                vListInsertEnd(&amp;(xPendingReadyList), &amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xYieldRequired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/2.task_1/" data-id="cmbcy7rgu000at8mtglf7d98s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/FreeRTOS/4.sem" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/4.sem/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.662Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><blockquote>
<p>FreeRTOS 学习仓库：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/free-rtos_-study">https://gitee.com/killerp/free-rtos_-study</a> </p>
</blockquote>
<p>在深入理解了消息队列后，信号量也就很容易学习了。因为信号量就是使用消息队列实现的。</p>
<p>信号量是特殊的消息队列，其只部分利用了队列结构体，信号量没有队列存储区域，所以信号量不能用来传递任务间的数据。但可以利用消息队列的其他特点如：对共享数据的保护，阻塞等待机制等，实现任务之间的同步，对共享数据的互斥访问。</p>
<h3 id="一、信号量的分类"><a href="#一、信号量的分类" class="headerlink" title="一、信号量的分类"></a>一、信号量的分类</h3><p>不同类型的信号量有各自的用途。</p>
<p><strong>二值信号量</strong></p>
<p>二值信号量只有 0 和 1 两个状态，通常用于任务之间、任务和中断之间的同步。二值信号量初始化时为0，当任务or中断释放二值信号量，信号量值为1，接收任务解除阻塞进入就绪。通常是一方固定释放信号量，一方固定读取信号量，实现双方的同步。</p>
<p><strong>互斥信号量</strong></p>
<p>互斥信号量主要用于对共享数据的互斥访问，也就是保证任务对资源的独占性，在同一时刻，一个共享数据只能被一个任务访问。</p>
<p>所以互斥信号量在初始化时，需要初始化为1，表示资源的存在。</p>
<p>任务获取互斥信号信号成功后，就能放心地操作资源。其他任务获取互斥信号就会失败，而进入阻塞。通常情况下，多个任务访问一个共享资源，每个任务都需要先获取互斥信号量，在处理完数据后，释放互斥信号量。这与二值信号量不一样。</p>
<p><strong>递归互斥信号量</strong></p>
<p>递归互斥信号量是在互斥信号的基础上，允许拥有信号量的任务递归地获取&#x2F;释放信号量。</p>
<p><strong>计数信号量</strong></p>
<p>计数信号量类似于互斥信号量，用于对资源的保护，通常该资源可被若干个任务同时拥有。</p>
<h3 id="二、信号量的创建、释放、获取"><a href="#二、信号量的创建、释放、获取" class="headerlink" title="二、信号量的创建、释放、获取"></a>二、信号量的创建、释放、获取</h3><p>信号量的实现依赖于队列，在FreeRTOS中，仅用一个semphr.h头文件，通过宏定义来实现信号量的创建，发送，接收。</p>
<h4 id="2-1、创建信号量"><a href="#2-1、创建信号量" class="headerlink" title="2.1、创建信号量"></a>2.1、创建信号量</h4><p>创建二值信号量 实际上就是创建一个长度为1，大小为0的队列 ，此时信号量的值为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreCreateBinary()    xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2、优先级反转"><a href="#2-2、优先级反转" class="headerlink" title="2.2、优先级反转"></a>2.2、优先级反转</h4><p>首先了解简单的优先级反转：</p>
<blockquote>
<p>A的优先级为1，B为10，C为5，A获取到信号量，正在操作资源。此时中断导致任务调度，切换到B执行，B因为请求信号量失败而进入阻塞。此时发生任务调度，C运行知道让出CPU，A继续运行释放信号量，最后B才能继续运行。</p>
</blockquote>
<p>假设没有C任务，那么A、B的运行是正常的。A首先获取资源，把资源处理完成后再由B下一步处理，这种情况下，A、B执行的时间是可确定的，符合实时操作系统的要求。</p>
<p>但是第三者C的加入，使得任务A、B的执行时间不确定了。C有时会抢占A的CPU，使A、B的执行时间变得长；有时又不止一个C、可能有其他D、E、F、G来抢占A，所以A、B的执行时间变得不可确定，这对实时操作系统是灾难性的。</p>
<p><strong>解决的办法是使用优先级继承：即把B的优先级暂时复制给A，这样C就无法插足A、B之间的感情了。需要注意的是，任务可能发生多次的优先级反转，所以优先级继承一定要继承最高优先级。</strong></p>
<h4 id="2-3、获取信号量"><a href="#2-3、获取信号量" class="headerlink" title="2.3、获取信号量"></a>2.3、获取信号量</h4><p>由于互斥信号量的优先级继承是发生在信号量获取的过程中，所以获取信号量的实现需要关注优先级继承逻辑。代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSemaphoreTake</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                TickType_t xTicksToWait )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xEntryTimeSet = pdFALSE;</span><br><span class="line">    TimeOut_t xTimeOut;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    BaseType_t xInheritanceOccurred = pdFALSE;  <span class="comment">//优先级继承是否发送的标志</span></span><br><span class="line"></span><br><span class="line">    configASSERT( ( pxQueue ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//uxItemSize为0时，队列才表示为信号量</span></span><br><span class="line">    configASSERT( pxQueue-&gt;uxItemSize == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入循环</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入临界区</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//uxMessagesWaiting 就是信号量的值</span></span><br><span class="line">            <span class="type">const</span> UBaseType_t uxSemaphoreCount = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查信号量是否有效</span></span><br><span class="line">            <span class="keyword">if</span>( uxSemaphoreCount &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_RECEIVE( pxQueue );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//信号量有效、数值减一</span></span><br><span class="line">                pxQueue-&gt;uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//若是互斥信号量，还需要做优先级继承</span></span><br><span class="line">                        <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//记录当前信号量的拥有者</span></span><br><span class="line">                            pxQueue-&gt;u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                <span class="comment">//检测是否有任务阻塞在信号量释放队列，若有则恢复任务</span></span><br><span class="line">                <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//恢复的任务优先级更高，发送抢占</span></span><br><span class="line">                        queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//成功获取 退出函数</span></span><br><span class="line">                taskEXIT_CRITICAL();</span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//信号量被使用完了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不需要阻塞等待信号量</span></span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                                 </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//若优先级反转已经发生，那么调用者必须有一个阻塞时间，故此时xInheritanceOccurred必须为false</span></span><br><span class="line">                            configASSERT( xInheritanceOccurred == pdFALSE );</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//不需要等待直接退出</span></span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line">                    traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//初始化超时结构体</span></span><br><span class="line">                    vTaskInternalSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Entry time was already set. */</span></span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">        </span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        prvLockQueue( pxQueue );    <span class="comment">//锁定队列，因为需要操作链表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//超时时间未到</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//信号量为空</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );</span><br><span class="line">                </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//若是互斥信号量、在进入阻塞前、需要做一次优先级继承</span></span><br><span class="line">                        <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                        &#123;</span><br><span class="line">                            taskENTER_CRITICAL();</span><br><span class="line">                            &#123;</span><br><span class="line">                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue-&gt;u.xSemaphore.xMutexHolder );</span><br><span class="line">                            &#125;</span><br><span class="line">                            taskEXIT_CRITICAL();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将当前任务挂起到等待链表</span></span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );</span><br><span class="line">                prvUnlockQueue( pxQueue );  <span class="comment">//解锁队列</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前任务进入等待、恢复任务调度，切换下一个任务运行</span></span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    portYIELD_WITHIN_API();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//超时时间未到且信号量有效了，重新进入循环获取信号量，这种情况可能是其他任务释放了信号量从而唤醒当前任务</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//阻塞时间到了 此时任务已被内核移出等待队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Timed out. */</span></span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若信号量仍然为空，则退出阻塞</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;                </span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//若发生了优先级反转，需要恢复任务的优先级</span></span><br><span class="line">                        <span class="keyword">if</span>( xInheritanceOccurred != pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            taskENTER_CRITICAL();</span><br><span class="line">                            &#123;</span><br><span class="line">                                UBaseType_t uxHighestWaitingPriority;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//获取队列等待链表中的最高优先级、</span></span><br><span class="line">                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );</span><br><span class="line">                                <span class="comment">//恢复队列的优先级为该最高优先级or任务自身优先级</span></span><br><span class="line">                                vTaskPriorityDisinheritAfterTimeout( pxQueue-&gt;u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );</span><br><span class="line">                            &#125;</span><br><span class="line">                            taskEXIT_CRITICAL();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                <span class="comment">//返回获取失败</span></span><br><span class="line">                <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//阻塞时间到了，但同时信号量也有效，重新进入循环获取信号量</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/*lint -restore */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="2-4、释放信号量"><a href="#2-4、释放信号量" class="headerlink" title="2.4、释放信号量"></a>2.4、释放信号量</h4><p>释放信号量就是向队列发送一个空消息、且不需要进入阻塞，队列满说明信号量有效，所以不需要阻塞。同时若是互斥信号量，则任务会恢复到原来的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreGive( xSemaphore )    xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )</span></span><br></pre></td></tr></table></figure>



<p>在中断中释放信号量与任务中的区别是：进入临界区需要保存中断状态，以及在中断中不能进入阻塞，且队列锁定时不能操作队列的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueGiveFromISR</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                              BaseType_t * <span class="type">const</span> pxHigherPriorityTaskWoken )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line">    UBaseType_t uxSavedInterruptStatus; <span class="comment">//保存中断状态</span></span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于信号量的释放，故为0</span></span><br><span class="line">    configASSERT( pxQueue-&gt;uxItemSize == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通常一个互斥信号量不会在中断中释放、而是是任务中。因为互斥信号量是资源的锁，在中断中一般不会访问共享的资源。</span></span><br><span class="line">    configASSERT( !( ( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX ) &amp;&amp; ( pxQueue-&gt;u.xSemaphore.xMutexHolder != <span class="literal">NULL</span> ) ) );</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line">    <span class="comment">//进入临界区，保存中断状态</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测是否能继续释放信号量</span></span><br><span class="line">        <span class="keyword">if</span>( uxMessagesWaiting &lt; pxQueue-&gt;uxLength )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;</span><br><span class="line"></span><br><span class="line">            traceQUEUE_SEND_FROM_ISR( pxQueue );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//信号量值+1</span></span><br><span class="line">            pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列未锁，可以操作链表</span></span><br><span class="line">            <span class="keyword">if</span>( cTxLock == queueUNLOCKED )</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//将等待信号量的任务恢复就绪</span></span><br><span class="line">                        <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//需要退出中断后进行任务调度</span></span><br><span class="line">                                <span class="keyword">if</span>( pxHigherPriorityTaskWoken != <span class="literal">NULL</span> )</span><br><span class="line">                                &#123;</span><br><span class="line">                                    *pxHigherPriorityTaskWoken = pdTRUE;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                configASSERT( cTxLock != queueINT8_MAX );</span><br><span class="line">                <span class="comment">//队列锁定 标记</span></span><br><span class="line">                pxQueue-&gt;cTxLock = ( <span class="type">int8_t</span> ) ( cTxLock + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//队列满，无法释放信号量</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );</span><br><span class="line">            xReturn = errQUEUE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出临界区 恢复中断状态</span></span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5、优先级继承相关函数"><a href="#2-5、优先级继承相关函数" class="headerlink" title="2.5、优先级继承相关函数"></a>2.5、优先级继承相关函数</h4><p><strong>a、优先级继承</strong></p>
<p>任务获取互斥信号量时，进入阻塞，需要优先级继承，信号量的拥有者继承当前任务的优先级（若当前任务优先级较高）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskPriorityInherit</span><span class="params">(TaskHandle_t <span class="type">const</span> pxMutexHolder)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *<span class="type">const</span> pxMutexHolderTCB = pxMutexHolder;  <span class="comment">//获取锁的拥有者</span></span><br><span class="line">    BaseType_t xReturn = pdFALSE;   <span class="comment">//返回值表示是否发送继承</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pxMutexHolder != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拥有锁的任务优先级低于当前（请求获取信号量）任务的优先级 需要继承优先级</span></span><br><span class="line">        <span class="keyword">if</span> (pxMutexHolderTCB-&gt;uxPriority &lt; pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若拥有锁的任务 所在的事件链表是按优先级排序的，则需要修改事件节点的值</span></span><br><span class="line">            <span class="keyword">if</span> ((listGET_LIST_ITEM_VALUE(&amp;(pxMutexHolderTCB-&gt;xEventListItem)) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE) == <span class="number">0UL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//设置节点的值为新的优先级</span></span><br><span class="line">                listSET_LIST_ITEM_VALUE(&amp;(pxMutexHolderTCB-&gt;xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)pxCurrentTCB-&gt;uxPriority); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//否则什么也不做</span></span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若拥有锁的任务是在就绪链表中，则需要将其移动到新的优先级的就绪链表</span></span><br><span class="line">            <span class="keyword">if</span> (listIS_CONTAINED_WITHIN(&amp;(pxReadyTasksLists[pxMutexHolderTCB-&gt;uxPriority]), &amp;(pxMutexHolderTCB-&gt;xStateListItem)) != pdFALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (uxListRemove(&amp;(pxMutexHolderTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    portRESET_READY_PRIORITY(pxMutexHolderTCB-&gt;uxPriority, uxTopReadyPriority);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//继承当前任务优先级 加入就绪链表</span></span><br><span class="line">                pxMutexHolderTCB-&gt;uxPriority = pxCurrentTCB-&gt;uxPriority;</span><br><span class="line">                prvAddTaskToReadyList(pxMutexHolderTCB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//拥有锁的任务不在就绪链表中，只需要继承当前任务优先级</span></span><br><span class="line">                pxMutexHolderTCB-&gt;uxPriority = pxCurrentTCB-&gt;uxPriority;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            traceTASK_PRIORITY_INHERIT(pxMutexHolderTCB, pxCurrentTCB-&gt;uxPriority);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//优先级继承发送</span></span><br><span class="line">            xReturn = pdTRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//拥有锁的任务高于当前任务的优先级，但上一次优先级小于当前任务，说明该任务之前被提升了一次优先级</span></span><br><span class="line">            <span class="keyword">if</span> (pxMutexHolderTCB-&gt;uxBasePriority &lt; pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//标记优先级反转</span></span><br><span class="line">                xReturn = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>b、重置优先级</strong></p>
<p>当等待获取互斥信号的任务阻塞时间到达，需要退出等待时，调用以下函数，重新设置信号量拥有者的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPriorityDisinheritAfterTimeout</span><span class="params">(TaskHandle_t <span class="type">const</span> pxMutexHolder,</span></span><br><span class="line"><span class="params">                                         UBaseType_t uxHighestPriorityWaitingTask)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *<span class="type">const</span> pxTCB = pxMutexHolder;</span><br><span class="line">    UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse; </span><br><span class="line">    <span class="type">const</span> UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pxMutexHolder != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT(pxTCB-&gt;uxMutexesHeld); <span class="comment">//必须拥有锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//uxPriorityToUse是新的优先级。新的优先级应该是等待锁的任务中优先级最高的那个，这样才能保证最高优先级的任务能在锁释放后第一时间得到运行</span></span><br><span class="line">        <span class="keyword">if</span> (pxTCB-&gt;uxBasePriority &lt; uxHighestPriorityWaitingTask)</span><br><span class="line">        &#123;</span><br><span class="line">            uxPriorityToUse = uxHighestPriorityWaitingTask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            uxPriorityToUse = pxTCB-&gt;uxBasePriority;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Does the priority need to change? */</span></span><br><span class="line">        <span class="comment">//优先级需要修改</span></span><br><span class="line">        <span class="keyword">if</span> (pxTCB-&gt;uxPriority != uxPriorityToUse)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pxTCB-&gt;uxMutexesHeld == uxOnlyOneMutexHeld)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                configASSERT(pxTCB != pxCurrentTCB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                traceTASK_PRIORITY_DISINHERIT(pxTCB, uxPriorityToUse);</span><br><span class="line">                <span class="comment">//保存旧优先级</span></span><br><span class="line">                uxPriorityUsedOnEntry = pxTCB-&gt;uxPriority;</span><br><span class="line">                <span class="comment">//设置新的优先级</span></span><br><span class="line">                pxTCB-&gt;uxPriority = uxPriorityToUse;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置事件节点值</span></span><br><span class="line">                <span class="keyword">if</span> ((listGET_LIST_ITEM_VALUE(&amp;(pxTCB-&gt;xEventListItem)) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE) == <span class="number">0UL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    listSET_LIST_ITEM_VALUE(&amp;(pxTCB-&gt;xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriorityToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若锁的拥有者处于就绪链表，由于改变了优先级，所以需要修改其优先级链表</span></span><br><span class="line">                <span class="keyword">if</span> (listIS_CONTAINED_WITHIN(&amp;(pxReadyTasksLists[uxPriorityUsedOnEntry]), &amp;(pxTCB-&gt;xStateListItem)) != pdFALSE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (uxListRemove(&amp;(pxTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        portRESET_READY_PRIORITY(pxTCB-&gt;uxPriority, uxTopReadyPriority);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//插入新的就绪链表</span></span><br><span class="line">                    prvAddTaskToReadyList(pxTCB);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>c、恢复优先级</strong></p>
<p>任务释放互斥信号，自己将恢复到原始的任务优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskPriorityDisinherit</span><span class="params">(TaskHandle_t <span class="type">const</span> pxMutexHolder)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *<span class="type">const</span> pxTCB = pxMutexHolder;</span><br><span class="line">    BaseType_t xReturn = pdFALSE;   <span class="comment">//返回真，需要任务调度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pxMutexHolder != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//检查输入参数</span></span><br><span class="line">        configASSERT(pxTCB == pxCurrentTCB);</span><br><span class="line">        configASSERT(pxTCB-&gt;uxMutexesHeld); <span class="comment">//必须拥有锁</span></span><br><span class="line">        (pxTCB-&gt;uxMutexesHeld)--;   <span class="comment">//拥有互斥信号的数量-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先级不同则出现了优先级反转</span></span><br><span class="line">        <span class="keyword">if</span> (pxTCB-&gt;uxPriority != pxTCB-&gt;uxBasePriority)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当不持有互斥信号时才能恢复任务优先级</span></span><br><span class="line">            <span class="keyword">if</span> (pxTCB-&gt;uxMutexesHeld == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//移出就绪链表</span></span><br><span class="line">                <span class="keyword">if</span> (uxListRemove(&amp;(pxTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    portRESET_READY_PRIORITY(pxTCB-&gt;uxPriority, uxTopReadyPriority);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                traceTASK_PRIORITY_DISINHERIT(pxTCB, pxTCB-&gt;uxBasePriority);</span><br><span class="line">                <span class="comment">//恢复优先级</span></span><br><span class="line">                pxTCB-&gt;uxPriority = pxTCB-&gt;uxBasePriority;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置事件节点的值</span></span><br><span class="line">                listSET_LIST_ITEM_VALUE(&amp;(pxTCB-&gt;xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)pxTCB-&gt;uxPriority); </span><br><span class="line">                <span class="comment">//添加到新的就绪表</span></span><br><span class="line">                prvAddTaskToReadyList(pxTCB);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Return true to indicate that a context switch is required.</span></span><br><span class="line"><span class="comment">                     * This is only actually required in the corner case whereby</span></span><br><span class="line"><span class="comment">                     * multiple mutexes were held and the mutexes were given back</span></span><br><span class="line"><span class="comment">                     * in an order different to that in which they were taken.</span></span><br><span class="line"><span class="comment">                     * If a context switch did not occur when the first mutex was</span></span><br><span class="line"><span class="comment">                     * returned, even if a task was waiting on it, then a context</span></span><br><span class="line"><span class="comment">                     * switch should occur when the last mutex is returned whether</span></span><br><span class="line"><span class="comment">                     * a task is waiting on it or not. */</span></span><br><span class="line">                <span class="comment">//todo 返回真使任务调度</span></span><br><span class="line">                xReturn = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/4.sem/" data-id="cmbcy7rgv000ct8mtfs9dfe2h" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ESP32/esp32adf_play_mp3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/esp32adf_play_mp3/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.660Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="播放本地mp3"><a href="#播放本地mp3" class="headerlink" title="播放本地mp3"></a>播放本地mp3</h2><p>参考例程<code>esp-adf\examples\player\pipeline_flash_tone</code>，其思路是在PC端将多个mp3文件合并成一个二进制的文件，并在分区别中将为文件设置<strong>flash_tone</strong>空间。最后将该文件烧录到指定的地址中，在程序中调用flash_tone的接口函数就能读取到mp3.</p>
<h3 id="一、制作二进制音频文件"><a href="#一、制作二进制音频文件" class="headerlink" title="一、制作二进制音频文件"></a>一、制作二进制音频文件</h3><p>使用ADF提供的mk_audio_bin.py脚本来生成上述二进制文件。</p>
<p><strong>mk_audio_bin.py的作用是将当前目录下的MP3和wav文件集合生成一个<code>audio-esp.bin</code>的音频文件，并在<code>main/audio</code>目录下生成audio_tone_uri.h和audio_tone_uri.c。</strong></p>
<p><a target="_blank" rel="noopener" href="https://wwe.lanzoui.com/iRoNYtdueub">mk_audio_bin.py下载地址：https://wwe.lanzoui.com/iRoNYtdueub</a></p>
<p>首先安装python2.7，将mp3文件放在mk_audio_bin.py的同一目录下，执行下面命令生成二进制文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 mk_audio_bin.py</span><br></pre></td></tr></table></figure>

<h3 id="二、修改分区表"><a href="#二、修改分区表" class="headerlink" title="二、修改分区表"></a>二、修改分区表</h3><p>在分区表partitions.csv中添加一项</p>
<blockquote>
<p>flash_tone,data, 0x04,   0x320000,  0xc800,</p>
</blockquote>
<p>表示添加一个名称为flash_tone的分区，其分区类型是data，子类型是0x4，在flash中的偏移地址是0x320000，这个地址也说烧录地址，分区大小为0xc800，也就是100k。</p>
<h3 id="三、在代码中使用"><a href="#三、在代码中使用" class="headerlink" title="三、在代码中使用"></a>三、在代码中使用</h3><p>需要在main目录下的Makefile文件中，添加audio_tone_uri.c：</p>
<blockquote>
<p>set(COMPONENT_SRCS “.&#x2F;audio&#x2F;audio_tone_uri.c”)</p>
</blockquote>
<p>代码中具体使用参考ADF的examples&#x2F;player&#x2F;pipeline_flash_tone&#x2F;main&#x2F;play_tone_mp3_example.c</p>
<h3 id="四、烧录"><a href="#四、烧录" class="headerlink" title="四、烧录"></a>四、烧录</h3><p>使用你的烧录工具，将audio-esp.bin和程序烧录到芯片。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://tools.bugscaner.com/tts/">在线文字转语音</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/deflypig/article/details/100182475">python2和python3共存 安装</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/esp32adf_play_mp3/" data-id="cmbcy7rh1000rt8mt8tzpcdeb" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ESP32/esp32_baidu_update_token" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/esp32_baidu_update_token/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.657Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>注意每个用户的token请求参数不一样，具体情况看百度开放平台的相关文档</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_TOKEN_URL <span class="string">&quot;https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=G86ZG9H52Mi1Ngf0uByK4IbA&amp;client_secret=WkelePkHg8zozxwztB2gvGq1kF9AOUgL&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> baidu_access_token[<span class="number">80</span>];</span><br></pre></td></tr></table></figure>
<p>对应以上请求。返回结果如下：我们需要提取其中的access_token的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;refresh_token&quot;</span>: <span class="string">&quot;25.150b4d6b88fed9146f2f70a9e0e5b33e.315360000.1931916550.282335-23021308&quot;</span>,</span><br><span class="line">    <span class="string">&quot;expires_in&quot;</span>: 2592000,</span><br><span class="line">    <span class="string">&quot;session_key&quot;</span>: <span class="string">&quot;9mzdWui4vXxbxI0VHwyxpuWyLrq7zYM1GAsEH+Kx3AlOhtlWkInKQ5beXw5YwbW8FHdEal+lChIfsRuJ4BmN3HJpuRGr+A==&quot;</span>,</span><br><span class="line">    <span class="string">&quot;access_token&quot;</span>: <span class="string">&quot;24.a4e1cd6302eb93afe8e6cdd4d604d68b.2592000.1619148550.282335-23021308&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;brain_enhanced_asr audio_tts_post public nlp_simnet nlp_wordemb nlp_comtag nlp_dnnlm_cn brain_nlp_lexer brain_all_scope brain_nlp_comment_tag brain_nlp_dnnlm_cn brain_nlp_word_emb_vec brain_nlp_word_emb_sim brain_nlp_sentiment_classify brain_nlp_simnet brain_nlp_depparser brain_nlp_wordembedding brain_nlp_dnnlm_cn_legacy brain_nlp_simnet_legacy brain_nlp_comment_tag_legacy brain_nlp_lexer_custom brain_nlp_keyword brain_nlp_topic brain_nlp_ecnet brain_nlp_emotion brain_nlp_comment_tag_custom brain_nlp_news_summary brain_nlp_sentiment_classify_custom brain_nlp_address wise_adapt lebo_resource_base lightservice_public hetu_basic lightcms_map_poi kaidian_kaidian ApsMisTest_Test权限 vis-classify_flower lpq_开放 cop_helloScope ApsMis_fangdi_permission smartapp_snsapi_base smartapp_mapp_dev_manage iop_autocar oauth_tp_app smartapp_smart_game_openapi oauth_sessionkey smartapp_swanid_verify smartapp_opensource_openapi smartapp_opensource_recapi fake_face_detect_开放Scope vis-ocr_虚拟人物助理 idl-video_虚拟人物助理 smartapp_component smartapp_search_plugin avatar_video_test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;session_secret&quot;</span>: <span class="string">&quot;ffbb07a7b9e1f62d56bb124f9f2b49f3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">config.url = GET_TOKEN_URL;</span><br><span class="line">config.method = HTTP_METHOD_GET;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start connect to url = %s\r\n&quot;</span>,config.url);</span><br><span class="line">client = esp_http_client_init(&amp;config);</span><br><span class="line">esp_http_client_perform(client);</span><br><span class="line">esp_http_client_close(client);</span><br><span class="line">esp_http_client_cleanup(client);</span><br><span class="line"></span><br><span class="line">cJSON *root = cJSON_Parse(http_data);</span><br><span class="line"><span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *tok = cJSON_GetObjectItem(root, <span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *newtoken = cJSON_GetStringValue(tok); <span class="comment">//获取新token</span></span><br><span class="line">    <span class="keyword">if</span>(newtoken != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(baidu_access_token, <span class="number">0</span>, <span class="number">80</span>);  <span class="comment">//清零全局变量baidu_access_token</span></span><br><span class="line">        <span class="built_in">strncpy</span>(baidu_access_token, newtoken, <span class="number">80</span>);  <span class="comment">//再更新</span></span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;new token = %s&quot;</span>, baidu_access_token);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;parse string error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;root error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cJSON_Delete(root);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/esp32_baidu_update_token/" data-id="cmbcy7rgy000kt8mtco0og60n" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
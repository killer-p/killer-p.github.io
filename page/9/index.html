<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-killer-blog/ESP32/ESP32_baidu_SpeechSynthesis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ESP32/ESP32_baidu_SpeechSynthesis/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.634Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>esp32 播放多个音频源的音频，例如播放本地flash的mp3，http或者蓝牙传来的音频流等。</p>
</blockquote>
<p>@[TOC]</p>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p>本次例程介绍更加简单的播放器初始化，并在播放器中添加<code>http_stream</code>和<code>flash_tone_stream</code>等输入流来实现 <code>百度语音合成</code> 与<code>播放本地音频</code> 的效果。</p>
<h2 id="二，播放器初始化"><a href="#二，播放器初始化" class="headerlink" title="二，播放器初始化"></a>二，播放器初始化</h2><p><strong>esp-idf提供了一套更加便捷的创建pipeline管道的api函数，接口在esp_audio.h中定义。使用这套api能更快的初始化一个音频处理管道。</strong></p>
<p>一个音频管道就是三四个部分组成，输入流-&gt;编解码-&gt;适配-&gt;输出流，而esp_audio.h中提供了几个重要的函数来实现以上：其中必须要有的element就是输入，编解码，输出。</p>
<p>几个比较重要的函数：<br><strong>1，添加音频输入源，这里添加了http和flash_tone</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_audio_input_stream_add(player, http_stream_reader);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2，添加音频输出源，这里添加了i2s流，输出到ac101播放音频</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_audio_output_stream_add(player, i2s_stream_writer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3，添加音频编解码仓库</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_audio_codec_lib_add(player, AUDIO_CODEC_TYPE_DECODER, mp3_decoder_init(&amp;mp3_dec_cfg));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体使用的流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*板子音频芯片初始化 音频引脚初始化 更换芯片或者板子时要注意*/</span></span><br><span class="line"><span class="type">esp_audio_cfg_t</span> cfg = DEFAULT_ESP_AUDIO_CONFIG();</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;audio_board_init&quot;</span>);</span><br><span class="line"><span class="comment">//音频硬件初始化</span></span><br><span class="line"><span class="type">audio_board_handle_t</span> board_handle = audio_board_init();</span><br><span class="line">cfg.vol_handle = board_handle-&gt;audio_hal;</span><br><span class="line">cfg.prefer_type = ESP_AUDIO_PREFER_MEM;</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;create player&quot;</span>);</span><br><span class="line"><span class="comment">//!对于我们的开发板，要使用48k才能正常说话（喇叭）</span></span><br><span class="line">cfg.resample_rate = <span class="number">48000</span>;  </span><br><span class="line">player = esp_audio_create(&amp;cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//音频编解码芯片ac101初始化</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;init codec&quot;</span>);</span><br><span class="line">audio_hal_ctrl_codec(board_handle-&gt;audio_hal, AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建http流</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;[2.1] Create http stream to read data&quot;</span>);</span><br><span class="line"><span class="type">http_stream_cfg_t</span> http_cfg = HTTP_STREAM_CFG_DEFAULT();</span><br><span class="line"><span class="comment">//设置http回调函数</span></span><br><span class="line">http_cfg.event_handle = _http_stream_event_handle;</span><br><span class="line">http_cfg.type = AUDIO_STREAM_READER;</span><br><span class="line"><span class="type">audio_element_handle_t</span> http_stream_reader = http_stream_init(&amp;http_cfg);</span><br><span class="line">esp_audio_input_stream_add(player, http_stream_reader);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建flash_tone流</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;create flash tone stream reader&quot;</span>);</span><br><span class="line"><span class="type">tone_stream_cfg_t</span> tone_cfg = TONE_STREAM_CFG_DEFAULT();</span><br><span class="line">tone_cfg.type = AUDIO_STREAM_READER;</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;add stream reader to player&quot;</span>);</span><br><span class="line">esp_audio_input_stream_add(player, tone_stream_init(&amp;tone_cfg));</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3解码</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;create mp3 decoder and add to player&quot;</span>);</span><br><span class="line"><span class="type">mp3_decoder_cfg_t</span>  mp3_dec_cfg  = DEFAULT_MP3_DECODER_CONFIG();</span><br><span class="line">esp_audio_codec_lib_add(player, AUDIO_CODEC_TYPE_DECODER, mp3_decoder_init(&amp;mp3_dec_cfg));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建i2s writer并添加到player的输出源</span></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;create i2s writer and add to player&quot;</span>);</span><br><span class="line"><span class="type">i2s_stream_cfg_t</span> i2s_writer = I2S_STREAM_CFG_DEFAULT();</span><br><span class="line"><span class="comment">//!注意要和player的采样率48000相同</span></span><br><span class="line">i2s_writer.i2s_config.sample_rate = <span class="number">48000</span>; </span><br><span class="line"><span class="comment">//右声道</span></span><br><span class="line">i2s_writer.i2s_config.channel_format = I2S_CHANNEL_FMT_ALL_RIGHT;   </span><br><span class="line">i2s_writer.type = AUDIO_STREAM_WRITER;</span><br><span class="line"><span class="type">audio_element_handle_t</span> i2s_stream_writer = i2s_stream_init(&amp;i2s_writer);</span><br><span class="line">esp_audio_output_stream_add(player, i2s_stream_writer);</span><br><span class="line"></span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;http_stream_reader-&gt;mp3decode-&gt;player-&gt;i2s-&gt;ac101&quot;</span>);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;flash_stream_reader-&gt;mp3decode-&gt;player-&gt;i2s-&gt;ac101&quot;</span>);</span><br><span class="line"></span><br><span class="line">esp_audio_vol_set(player, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<h2 id="三，播放音频"><a href="#三，播放音频" class="headerlink" title="三，播放音频"></a>三，播放音频</h2><h3 id="3-1-播放本地音频"><a href="#3-1-播放本地音频" class="headerlink" title="3.1 播放本地音频"></a>3.1 播放本地音频</h3><p>之前介绍过esp32 播放本地flash中的mp3，没看过的朋友可以参考一下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/107934841">ESP32 ADF 离线播放mp3 mp3烧录flash</a>；</p>
<h3 id="3-2-使用百度语音合成-实现文字转语音"><a href="#3-2-使用百度语音合成-实现文字转语音" class="headerlink" title="3.2 使用百度语音合成 实现文字转语音"></a>3.2 使用百度语音合成 实现文字转语音</h3><p><strong>语音合成是将中文合成音频，然后播放出来。</strong></p>
<p>本例程使用的是百度AI开放平台的语音合成API，具体的接口文档参考百度AI开放平台的详细介绍。<a target="_blank" rel="noopener" href="https://ai.baidu.com/ai-doc/SPEECH/yk38y8h3j">百度语音合成文档</a></p>
<p><strong>使用百度的API需要先获得<code>token</code>，然后发送GET或者POST请求，请求中写入要合成的中文字符串，获取http音频流，将http音频流添加到以上的player中播放。</strong></p>
<p>ADF为我们提供了获取百度token的代码，在ADF目录下<code>components/adf_utils/cloud_services/baidu_access_token.c</code>中，使用<code>baidu_get_access_token()</code>可以获取百度token。</p>
<p><strong>调用以下函数实现语音播放，该函数会调用_http_stream_event_handle()回调函数，该函数负责处理这次http连接的所有操作。包括请求前的参数准备，请求开始，接收数据，断开连接等。如果成功返回http音频流，则会在player中播放</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_audio_sync_play(player,<span class="string">&quot;http://tsn.baidu.com/text2audio&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在这个回调函数中我们主要处理的是http请求前的参数设置。包括token的获取，设置POST的body参数。其中text是一个全局变量，存放即将转成语音的字符串。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * http stream回调函数</span></span><br><span class="line"><span class="comment"> * 调用esp_audio_sync_play(player,BAIDU_TTS_URL, 0)会调用此回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> _http_stream_event_handle(<span class="type">http_stream_event_msg_t</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">esp_http_client_handle_t</span> http_client = (<span class="type">esp_http_client_handle_t</span>)msg-&gt;http_client;</span><br><span class="line">    <span class="keyword">switch</span>(msg-&gt;event_id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_PRE_REQUEST:</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备请求数据 检查token</span></span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_PRE_REQUEST&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (baidu_access_token == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// Must freed `baidu_access_token` after used 获得token</span></span><br><span class="line">                ESP_LOGI(TAG, <span class="string">&quot;try to get token&quot;</span>);</span><br><span class="line">                baidu_access_token = baidu_get_access_token(BAIDU_ACCESS_KEY, BAIDU_SECRET_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baidu_access_token == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;Error issuing access token&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 组装body参数：lan：语言；cuid：设备id；ctp：...;aue：文件格式;spd:语速;pit：音调；vol：音量；per：人声*/</span></span><br><span class="line">            <span class="type">int</span> data_len = <span class="built_in">snprintf</span>(request_data, <span class="number">1024</span>, <span class="string">&quot;lan=zh&amp;cuid=ppp&amp;ctp=2&amp;aue=3&amp;spd=4&amp;pit=5&amp;vol=5&amp;per=0&amp;tok=%s&amp;tex=%s&quot;</span>, baidu_access_token, text);</span><br><span class="line">            <span class="comment">//将token装填进http请求体</span></span><br><span class="line">            esp_http_client_set_post_field(http_client, request_data, data_len);</span><br><span class="line">            <span class="comment">//post</span></span><br><span class="line">            esp_http_client_set_method(http_client, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_ON_REQUEST:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_ON_REQUEST&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_ON_RESPONSE:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_ON_RESPONSE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_POST_REQUEST:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_POST_REQUEST&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_FINISH_REQUEST:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_FINISH_REQUEST&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_RESOLVE_ALL_TRACKS:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_RESOLVE_ALL_TRACKS&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_FINISH_TRACK:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_FINISH_TRACK&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HTTP_STREAM_FINISH_PLAYLIST:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;HTTP_STREAM_FINISH_PLAYLIST&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>http stream的播放并不复杂，主要的工作就是设置好http请求头，获取http流。<br>但不得不夸一下百度，他的语音合成速度非常快，实用性非常高<br><img src="/2025/05/30/hello-world/ESP32/ESP32_baidu_SpeechSynthesis/20201016001030127.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ESP32/ESP32_baidu_SpeechSynthesis/" data-id="cmbcy7rgx000it8mtbob5cpsl" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/C_CPP/c_struct" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/C_CPP/c_struct/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.633Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>考虑一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
<p>编译器按照成员列表的顺序一个个给成员分配内存，同时内存还需要满足边界对齐的要求，边界的大小就是占用内存最大的成员的大小，在这个例子中，是int类型的b，大小为4字节。所以该结构体的边界对齐要求为4字节。</p>
<ul>
<li>编译器首先给a分配一个字节的内存</li>
<li>接着由于b需要占用4个字节内存，所以分配另外3个字节的内存来满足对齐的要求，这三个字节的内存只起填充作用</li>
<li>为b分配4个字节的内存</li>
<li>最后为c分配一个字节内存，再分配额外3个字节满足对齐。<br><img src="/2025/05/30/hello-world/C_CPP/c_struct/c_struct_1.png" alt="在这里插入图片描述"><br>（绿色表示填充的内存）<br>很明显，造成了6个字节的内存浪费，合理的结构体定义应该先定义内存较大的成员：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器首先给b分配四个字节的内存</li>
<li>接着为a分配一个字节内存</li>
<li>由于c只占一个字节，所以给c分配一个字节内存</li>
<li>最后为满足对齐，分配两个字节内存作为填充<br><img src="/2025/05/30/hello-world/C_CPP/c_struct/c_struct_2.png" alt="在这里插入图片描述"></li>
</ul>
<p>这样的结构体只占用了8个字节的内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/C_CPP/c_struct/" data-id="cmbcy7rgp0001t8mtbrfj4ghg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/C_CPP/complie" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/C_CPP/complie/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.633Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一、编译步骤简介"><a href="#一、编译步骤简介" class="headerlink" title="一、编译步骤简介"></a>一、编译步骤简介</h2><p>一个.c文件，是如何“变成一个”可执行文件呢。以main.c为例，如何得到main?你会回答是通过编译器的编译后输出来的，就像以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure>
<p>gcc是一个集合了编译器，链接器，将一个输入的C文件变成可执行文件，这需要经过预编译（prepressing）、编译（compilation）、汇编（assernbly）、链接（linking）四个步骤。本文就介绍这四个步骤主要做了啥。</p>
<p>如图，整个编译过程的大概就是这么个情况：<br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><strong>预编译</strong>：main.c首先进入预编译处理器，该部分处理以“#”开始的预编译指令，如#include、宏展开等，并删除注释，添加行号，方便调试打印程序，生成main.i文件。</li>
<li><strong>词法分析</strong>：词法分析器处理main.i文件。将字符串切割成一个个记号（mark），例如：sum&#x3D;2+1;会产生五个记号：“sum”、“&#x3D;”、“2”、“+”、“1”。</li>
<li><strong>语法分析</strong>：语法分析器将产生的记号组织成一个个表达式，以表达式为节点，组织成一颗语法树。（如上图）</li>
<li><strong>语义分析</strong>：语义分析器处理声明以及数据类型、给语法树的节点赋予数据类型。</li>
<li><strong>中间代码</strong>：根据语法树生成中间代码，以上的步骤是硬件平台无关的，而中间代码之后的处理则需要根据程序运行的硬件平台来决定。</li>
<li><strong>代码生成器</strong>：代码生成器将中间代码转换成对应硬件平台的汇编代码main.s</li>
<li><strong>汇编器</strong>：汇编器根据 <strong>汇编指令与机器指令的对照表</strong> 将汇编代码翻译成机器指令，生成目标文件main.o。</li>
<li><strong>链接器</strong>：合并输入的.o文件、确定符号内存地址、进行符号重定位，输出真正的可执行文件。</li>
</ol>
<p>编译过程做的总体上说就是<strong>将高级语言翻译成机器指令，分配指令和数据的在内存中地址</strong>，使CPU能从内存中的正确位置中取出正确的指令执行正确的数据读写操作。</p>
<p><code>note：机器指令是CPU能够识别执行的二进制数据</code></p>
<h2 id="二、目标文件的组成"><a href="#二、目标文件的组成" class="headerlink" title="二、目标文件的组成"></a>二、目标文件的组成</h2><p>目标文件就是汇编代码经过翻译生成的机器指令二进制代码，就是上面的main.o，可执行文件就是由这些个目标文件经过链接组成的。所以了解目标文件非常重要。</p>
<p><strong>目标文件由若干个段（section）组成，每个段中存放不同的内容，下面介绍一个目标文件中的基本段类型：文件头、代码段、数据段、bss段、常量段、段表、符号表、重定位表。</strong></p>
<p>其结构大概就是下图这么个情况：<br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1、文件头"><a href="#1、文件头" class="headerlink" title="1、文件头"></a>1、文件头</h3><p>文件头位于目标文件开始位置，它定义了elf魔数，目标文件的属性、运行的软硬件平台、程序入口地址、段表的位置及长度、段的数量。有了文件头的信息，链接器就能知道如何处理当前的目标文件。</p>
<h3 id="2、段表"><a href="#2、段表" class="headerlink" title="2、段表"></a>2、段表</h3><p>段表：记录了目标文件中所有段的地址以及属性（读写or可执行）等信息。链接器通过文件头可找到段表，通过段表则能找到目标文件中所有段。</p>
<h3 id="3、代码段、数据段、只读数据段、bss段"><a href="#3、代码段、数据段、只读数据段、bss段" class="headerlink" title="3、代码段、数据段、只读数据段、bss段"></a>3、代码段、数据段、只读数据段、bss段</h3><ul>
<li>代码段中存放的就是<strong>机器指令</strong></li>
<li>数据段中存放 <strong>已经初始化的全局变量以及静态变量</strong></li>
<li>只读数据段存放字符串常量以及被const修饰的变量，通过硬件确保其不会被程序修改</li>
<li>bss段存放<strong>未初始化的全局变量以及静态变量所占用的内存大小</strong></li>
</ul>
<blockquote>
<p>问：为啥区分数据段和bss段？<br>    .<br>答：数据段保存了初始化了的全局变量和静态变量，可执行文件装载时需要这些数值。而未初始化的全局变量和静态变量是0，目标文件不需要记住他们的值，只需要知道这些变量占用的空间大小，在程序装载时预留出内存空间（这些空间默认是0）.</p>
</blockquote>
<h3 id="4、重定位表"><a href="#4、重定位表" class="headerlink" title="4、重定位表"></a>4、重定位表</h3><p>当一个段（代码段或数据段）中有需要重定位的符号时，就会有一个它专属的重定位表，重定位表记录了该段需要进行重定位所需的所有信息。（第三节详细介绍重定位）</p>
<h3 id="5、符号表"><a href="#5、符号表" class="headerlink" title="5、符号表"></a>5、符号表</h3><p><strong>c代码中函数和变量统称为符号，符号的值就是函数或变量的地址</strong>，符号表中记录目标文件中所定义的可供外部使用的符号。</p>
<h2 id="三、静态链接"><a href="#三、静态链接" class="headerlink" title="三、静态链接"></a>三、静态链接</h2><p>上一节分析了目标文件的组成，目标文件本质上是一个cpu能识别执行的可执行文件，那么他比真正的可执行文件差在哪里呢？本节通过简单的介绍静态链接，回答这个问题。</p>
<p>静态链接分三步走：<strong>1、分配空间与地址；2、符号地址确定；3、符号重定位</strong></p>
<h3 id="1、分配空间与地址"><a href="#1、分配空间与地址" class="headerlink" title="1、分配空间与地址"></a>1、分配空间与地址</h3><p>这里的<strong>空间是指可执行文件中每个段所在的地址及占用的空间大小</strong>。静态链接需要将若干个.o目标文件合并成一个可执行程序，合并的方式是将目标文件中相同属性的段合并到一起，如图所示：</p>
<p>a.o、b.o、c.o的代码段合并到输出文件的代码段；数据段合并到输出文件的数据段；<br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>地址是指可执行程序装载到内存上后，各个段在内存中的地址，当然这个地址是虚拟地址VMA.静态链接后，每个段在内存中的地址就被确定下来。</strong></p>
<p><strong>连接器负责将相同属性的段合并，根据运行的平台（32位or64位）确定段在内存中的虚拟地址。</strong></p>
<h3 id="2、确定符号地址"><a href="#2、确定符号地址" class="headerlink" title="2、确定符号地址"></a>2、确定符号地址</h3><p>在上一步中，我们能确定段在内存中的地址，<strong>接下来就能通过偏移量计算符号在内存中的地址</strong>。例如：</p>
<blockquote>
<p>假设main.o中定义了main函数，main符号在main.o中的.text段中的偏移地址是固定的（假设是0x1000），假设main.o段被装载到内存的虚拟地址为0x5800，那么main符号的虚拟地址也能通过计算偏移地址得到为：0x1000+0x5800&#x3D;0x6800。</p>
</blockquote>
<p>类似的，在地址空间分配完成后，<strong>所有符号的地址都能确定下来。</strong></p>
<h3 id="3、符号重定位"><a href="#3、符号重定位" class="headerlink" title="3、符号重定位"></a>3、符号重定位</h3><p>首先允许我简单的引见你两个在重定位中最重要的表：</p>
<ul>
<li><strong>重定位表</strong>：在上一节提到，重定位表中包含了重定位所需要的所有信息，包括符号名称，重定位入口地址等。</li>
<li><strong>全局符号表</strong>：链接器会读取所有输入的目标文件的符号表，合并所有符号表生成一个全局符号表。</li>
</ul>
<p>以一个例子来看符号重定位做了什么：</p>
<blockquote>
<p>假设main.o中在0x7000处调用了fuck.o中的fuck函数，在重定位之前，由于连接器不知道fuck函数的地址（定义在另一个文件中），故暂时将其符号值设置为0；当链接器开始重定位时，他读取main.o中的重定位表，得知需要重定位fuck，于是链接器到全局符号表中查找fuck，拿到fuck的地址（0x1100），然后到fuck的重定位入口(0x7000)，修改fuck符号的值为0x1100.</p>
</blockquote>
<p>所以，<strong>重定位解决了不同模块之间函数、变量引用时的地址不确定性问题，这也是链接器所做的最重要的工作</strong>。</p>
<p>经过符号重定位后，可执行程序中所有的符号的虚拟地址都确定下来了，就能将程序装载到内存中运行，这就是目标文件与可执行文件的区别。</p>
<h2 id="四、装载"><a href="#四、装载" class="headerlink" title="四、装载"></a>四、装载</h2><p>装载就是把在磁盘中的可执行文件，读取到内存中，CPU才能通过总线读取内存中的指令，程序才能真正的跑起来。</p>
<p>现代的操作系统都采用了虚拟内存的管理策略。装载程序时采用动态装载的方式。</p>
<p><strong>动态装载是指：<strong>由于</strong>程序运行的局部性原理</strong>，将程序运行时常用的部分驻留在内存中，其他不常用的数据则放入硬盘里面。当程序需要使用哪个模块时，就将该模块从硬盘中加载到内存，如果不用到，就把把放在硬盘里。	</p>
<h2 id="五、动态链接"><a href="#五、动态链接" class="headerlink" title="五、动态链接"></a>五、动态链接</h2><h3 id="1、动态链接"><a href="#1、动态链接" class="headerlink" title="1、动态链接"></a>1、动态链接</h3><p>若a.o，b.o都需要使用lib.o中的函数，在静态链接时，a,b输出文件中都有一份lib.o，当同时运行a和b两个程序时，在内存中同时存在了两份lib.o，这就造成了内存的浪费。</p>
<p>这只是静态链接的缺点之一，解决这些问题的办法就是本节的主角–动态链接。</p>
<p><strong>动态链接的基本思想是：将程序拆分成若干个模块（.so），在程序运行时才将模块链接成一个完整的程序。</strong></p>
<p><strong>动态链接器先将程序所需的所有共享模块装载到进程地址空间，确定符号的地址，然后将程序中未决议的符号绑定到共享文件进行重定位。即把在静态链接的过程延迟到装载模块之后。</strong></p>
<p>动态链接如何解决以上问题？</p>
<blockquote>
<p>首先将a.o及其所需的模块装载到内存，包括lib.o，然后链接成完整的程序；当需要运行b程序时，将b及其所需的模块装载到内存，由于lib.o已经存在于内存中了，故不需要再装载lib.o，就能直接链接成完整程序。</p>
</blockquote>
<p>动态链接的优点有：</p>
<ul>
<li>节省内存空间，减少了内存数据的换入换出</li>
<li>程序维护性：程序升级时只需要发布新模块，不需要重新编译整个程序</li>
<li>兼容性：程序可使用由不同操作系统提供的动态链接库，不需要针对不同系统编写不同的代码。</li>
</ul>
<h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><p>但是这么做有一些问题。</p>
<p><strong>问题是：静态链接时，在模块中的指令和数据中有一些绝对地址的引用，这就要求在链接产生输出文件时，要事先假设模块在虚拟内存中的地址。但是在动态链接时，不同模块的装载地址不能一样。</strong></p>
<blockquote>
<p>若A的装载地址是0x800，B的装载地址也是0x800，若一个程序同时使用A,B模块，则必然冲突。</p>
</blockquote>
<p>这就要求模块在编译时，不能假设自己在虚拟内存中的地址。</p>
<p>**那么就等动态链接器把模块装进内存后，模块的虚拟地址就确定下来了，这时候再去修改程序中的绝对地址引用，**这样就解决了模块之间的地址冲突问题。因为已经装载的两个模块的地址肯定不一样。</p>
<p>但这又产生了<strong>另一个问题：当多个程序使用同一个模块时（lib.o），同一个模块在不同进程的虚拟地址空间的地址是不一样的</strong>（例如在A程序中，lib.o模块的虚拟地址是0x100，在B程序中为0x200，通过MMU映射到同一个物理地址）。那么上述的修改绝对地址的修改是要改成0x100还是0x200呢？</p>
<p>为了解决这个问题，就需要引入地址无关代码了。</p>
<p>首先介绍一个事实：<strong>共享模块中的代码段是唯一的，而每一个进程都有一份共享模块数据段的副本</strong>（进程之间的数据肯定是不一样的啦）</p>
<p><strong>那么可以将A程序的lib.o的虚拟地址0x100放在A的数据段，B程序的lib.o的虚拟地址0x200放在B的数据段中；当B程序要访问lib.o时，就通过数据段中的0x200找到B。</strong></p>
<p>如图<br><img src="/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyMTY0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2、延迟绑定"><a href="#2、延迟绑定" class="headerlink" title="2、延迟绑定"></a>2、延迟绑定</h3><p>动态链接情况下，程序开始执行之前都需要进行动态链接，这使得程序的启动变慢了。为了解决这个问题，<strong>将一部分函数的绑定工作（符号查找及重定位）延迟，即程序开始不对这些函数进行链接，只有当这些函数需要执行时，再进行绑定。</strong></p>
<h3 id="3、动态链接器自举"><a href="#3、动态链接器自举" class="headerlink" title="3、动态链接器自举"></a>3、动态链接器自举</h3><p>动态链接器也是一个共享模块，他能帮助其他模块重定位，但是他却不能引用其他模块，因为在他起来之前，其他模块都不能重定位。<strong>所以动态链接器必须不依赖任何库，同时能完成自己对自己的符号重定位，这就是自举。</strong></p>
<h2 id="六、程序的内存分布"><a href="#六、程序的内存分布" class="headerlink" title="六、程序的内存分布"></a>六、程序的内存分布</h2><p>可执行程序加载到内存后，内存的分布如图：（linux为例）<br><img src="/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAa2lsbGVyLXA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>该图示为4G的内存分布，其中0xffffffff-0xc0000000的1G划分给linux内核，其余的3G为用户空间。上面讲的可执行文件就放在readonly中。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈在linux中是向下增长的，也就是说push操作使地址减少；ESP寄存器放的是栈顶的地址，EBP寄存器放的是栈基的地址。在一个函数中，栈基地址一般不会改变，栈顶地址会改变，通过栈基地址+偏移的方式，可访问栈内容。</p>
<p>每一个函数都有一个属于自己的<strong>栈帧</strong>，用于保存函数的返回地址、参数、非静态局部变量和上下文。栈帧如图：<br><img src="/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAa2lsbGVyLXA=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>函数调用时，使用栈来保存和传递参数，函数返回时，使用eax和edc寄存器(32位)来存储返回的结果。<strong>对于返回数据大于8个字节的，在调用函数时，会先在栈中留出块空间（可理解为参数），函数将执行结果复制到该空间，函数返回后，调用者就可以从该空间中读取到函数结果</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">demo</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title function_">fuck</span><span class="params">(<span class="type">char</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">t</span>;</span> </span><br><span class="line">	<span class="comment">//将t数组的值全部设置为x+1</span></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> x=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">demo</span> <span class="title">d</span>=</span>fuck(x);</span><br><span class="line">	you();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面代码中调用函数时栈的情况可大概由下图表示：</strong></p>
<p><strong>EBP寄存器中放的是地址，这个地址里的值是上一个栈帧的EBP的值。通过EBP，程序就能正确地在函数返回时，回到上一个函数执行时的栈帧。</strong></p>
<p>调用fuck函数时，首先将fuck()的下一个指令(you)的地址放入栈中，函数完成后返回就能继续执行main，然后将EBP的值入栈，接着是函数参数入栈，<strong>由于fuck函数的返回值大小大于8字节，所以在栈中留出32个字节的空间作为返回值的缓存</strong></p>
<p>接着将一部分会被修改的寄存器入栈保存，然后跳转到fuck执行。</p>
<p><strong>fuck函数返回时，将局部变量t的值复制到栈中留出的32个字节的地址中，然后弹出寄存器的值，并恢复EBP的值为main的EBP值，然后跳转到you执行。</strong></p>
<p><strong>CPU返回main后，会将栈中缓存的返回值复制到局部变量d中。所以整个过程中，32字节的结果被复制了两次。</strong><br><img src="/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAa2lsbGVyLXA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在上面的例子中，数据被复制了两次"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/C_CPP/complie/" data-id="cmbcy7rgq0003t8mtfwut9ra9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Android/read_from_Mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Android/read_from_Mysql/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.633Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>先看看我们的数据库<br><img src="/2025/05/30/hello-world/Android/read_from_Mysql/database.png" alt="MQTTDATA，test2"><br>我们要做的就是安卓app读取以上数据并显示部分数据</p>
<h2 id="0，导入mysql-connector-java-5-1-28-jar到Androidstudio的lib文件夹下"><a href="#0，导入mysql-connector-java-5-1-28-jar到Androidstudio的lib文件夹下" class="headerlink" title="0，导入mysql-connector-java-5.1.28.jar到Androidstudio的lib文件夹下"></a>0，导入mysql-connector-java-5.1.28.jar到Androidstudio的lib文件夹下</h2><blockquote>
<p>jar包下载链接：链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1cNneqg1Ll4fTrEUd9EJFAA">https://pan.baidu.com/s/1cNneqg1Ll4fTrEUd9EJFAA</a><br>提取码：lco3 </p>
</blockquote>
<h2 id="1，写一个ESP8266类来装载数据库的数据"><a href="#1，写一个ESP8266类来装载数据库的数据" class="headerlink" title="1，写一个ESP8266类来装载数据库的数据"></a>1，写一个ESP8266类来装载数据库的数据</h2><p>这是一个简单的类，我的想法是一行数据包括可变和固定数据，我用一个hashmap来存放可变数据。<br>可变数据就是它可以是temperature，也可以是on_off。<br>而固定数据是每行数据所必须的，包括设备的id，app的id，数据产生的时间，设备的类型，设备的网络状态，设备的备注信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ESP8266 &#123;</span><br><span class="line">    String app_id,device_id,state,type,remark,time;</span><br><span class="line">    int id;</span><br><span class="line">    HashMap data=new HashMap();</span><br><span class="line">    public int getId()&#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getApp_id()&#123;</span><br><span class="line">        return app_id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDevice_id()&#123;</span><br><span class="line">        return device_id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()&#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getType()&#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getRemark()&#123;</span><br><span class="line">        return remark;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getTime()&#123;</span><br><span class="line">        return time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2，再写一个DBUtils-java的类，实现对MySQL的具体操作"><a href="#2，再写一个DBUtils-java的类，实现对MySQL的具体操作" class="headerlink" title="2，再写一个DBUtils.java的类，实现对MySQL的具体操作"></a>2，再写一个DBUtils.java的类，实现对MySQL的具体操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">public class DBUtils &#123;</span><br><span class="line">    static List&lt;ESP8266&gt; ESPlist=new ArrayList&lt;&gt;();//存放设备的数组</span><br><span class="line">    private static ESP8266 Device=new ESP8266();//初始化数组</span><br><span class="line">    private static String driver = &quot;com.mysql.jdbc.Driver&quot;;// MySql驱动，需要驱动才能接入MySQL</span><br><span class="line"></span><br><span class="line">//    private static String url = &quot;jdbc:mysql://localhost:3306/map_designer_test_db&quot;;</span><br><span class="line"></span><br><span class="line">    private static String user = &quot;app&quot;;//  数据库的用户名</span><br><span class="line"></span><br><span class="line">    private static String password = &quot;123456&quot;;//用户名对应的 密码</span><br><span class="line"></span><br><span class="line">    //连接数据库的函数</span><br><span class="line">    private static Connection getConn(String dbName)&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(driver);// 动态加载类</span><br><span class="line">            String ip = &quot;118.31.20.121&quot;;// 这是MySQL服务器的地址，因为我买的是云主机，所以这里填的是云主机的公网地址</span><br><span class="line"></span><br><span class="line">            // 尝试建立到给定数据库URL的连接，连接格式：驱动名称+ip地址+端口号+数据库名称+用户名+密码</span><br><span class="line">            connection = DriverManager.getConnection(&quot;jdbc:mysql://&quot; + ip + &quot;:3306/&quot; + dbName,</span><br><span class="line">                    user, password);</span><br><span class="line">            //Log.e(&quot;prx&quot;,&quot;url: &quot;+&quot;jdbc:mysql://&quot; + ip + &quot;:3306/&quot; + dbName);3306为MySQL接入固定端口</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;ESP8266&gt; getInfoByID(String ID)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 根据数据库名称，建立连接</span><br><span class="line">        Connection connection = getConn(&quot;MQTTDATA&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // mysql简单的查询语句。可以使用查询，更新，删除等等，？是一个变量，在后面可以对？进行赋值，可以设置多个？</span><br><span class="line">            String sql = &quot;select * from test2 where app_id=?&quot;;</span><br><span class="line"></span><br><span class="line">            if (connection != null)&#123;</span><br><span class="line">                // connection不为null表示与数据库建立了连接</span><br><span class="line">                //预编译sql 的，例如 preparedStatement(&quot;select * from t where id = ?&quot;);</span><br><span class="line">                //然后传入参数的时候 ？ 就会替换成你所需要的参数。</span><br><span class="line">                PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">                if (ps != null)&#123;</span><br><span class="line">                    // 设置上面的sql语句中第一个？的值为ID，如果有两个？，就再写一个ps.setString(2,String),</span><br><span class="line">                    //  ?会被替换成ID所代表的值</span><br><span class="line">                    ps.setString(1, ID);</span><br><span class="line">                    // 执行sql查询语句并返回结果集  resultset 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。</span><br><span class="line">                    ResultSet rs = ps.executeQuery();</span><br><span class="line">                    //Log.e(&quot;prx&quot;,&quot;结果集：&quot; + rs);</span><br><span class="line">                    if (rs != null)&#123;</span><br><span class="line">                        //如果结果集不为空，先获取列的总数</span><br><span class="line">                        int count = rs.getMetaData().getColumnCount();</span><br><span class="line">                        Log.e(&quot;prx&quot;,&quot;列总数：&quot; + count);</span><br><span class="line">                        //int x=0;</span><br><span class="line">                        // ResultSet对象保持一个光标指向其当前的数据行。 最初，光标位于第一行之前。 next方法将光标移动到下一行，</span><br><span class="line">                        // 并且由于在ResultSet对象中没有更多行时返回false ，因此可以在while循环中使用循环来遍历结果集。</span><br><span class="line">                        while (rs.next())&#123;</span><br><span class="line">                            // 注意：下标是从1开始的</span><br><span class="line">                            for (int i = 1;i &lt;= count;i++)&#123;</span><br><span class="line">                                //获取数据表的列的名称</span><br><span class="line">                                String field = rs.getMetaData().getColumnName(i);</span><br><span class="line">                                //Log.e(&quot;esp&quot;,&quot;键:  &quot;+field);</span><br><span class="line">                                Log.e(&quot;prx&quot;,&quot;值:  &quot;+rs.getString(field));</span><br><span class="line">                                //通过键值来赋值给对应的ESP8266的元素</span><br><span class="line">                                switch (field)&#123;</span><br><span class="line">                                    case    &quot;id&quot;:</span><br><span class="line">                                        Device.id=rs.getInt(field);</span><br><span class="line">                                    case    &quot;app_id&quot;:</span><br><span class="line">                                        Device.app_id=rs.getString(field);</span><br><span class="line">                                        break;</span><br><span class="line">                                    case    &quot;device_id&quot;:</span><br><span class="line">                                        Device.device_id=rs.getString(field);</span><br><span class="line">                                        break;</span><br><span class="line">                                    case    &quot;remark&quot;:</span><br><span class="line">                                        Device.remark=rs.getString(field);</span><br><span class="line">                                        break;</span><br><span class="line">                                    case &quot;state&quot;:</span><br><span class="line">                                        Device.state=rs.getString(field);</span><br><span class="line">                                        break;</span><br><span class="line">                                    case    &quot;type&quot;:</span><br><span class="line">                                        Device.type=rs.getString(field);</span><br><span class="line">                                        break;</span><br><span class="line">                                    case &quot;time&quot;:</span><br><span class="line">                                        Device.time=rs.getString(field);</span><br><span class="line"></span><br><span class="line">                                        break;</span><br><span class="line">                                        default:Device.data.put(field,rs.getString(field));</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                            //把每个设备的保存到数组中</span><br><span class="line">                            ESPlist.add(Device);</span><br><span class="line">                            //注意每次都要重新实例化Device！！！</span><br><span class="line">                            Device=new ESP8266();</span><br><span class="line"></span><br><span class="line">                            </span><br><span class="line">                            //Log.e(&quot;esp&quot;,&quot;x=&quot;+x+&quot; DEVICE_id&quot;+Device.getDevice_id());</span><br><span class="line">                            //ESP8266 ESP=ESPlist.get(x);</span><br><span class="line">                            //Log.e(&quot;esp&quot;,x+&quot;  LIST_ID&quot;+ESP.getDevice_id());</span><br><span class="line">                            //x++;</span><br><span class="line">                            //Log.e(&quot;ESP&quot;, String.valueOf(ESPlist.size()));</span><br><span class="line">                            //x=x+1;</span><br><span class="line">                            //Log.e(&quot;esp&quot;,&quot;list  &quot;+x);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        //关闭数据库连接</span><br><span class="line">                        connection.close();</span><br><span class="line">                        ps.close();</span><br><span class="line">                        //ESP8266 ESP=ESPlist.get(3);</span><br><span class="line">                        //Log.e(&quot;esp&quot;,&quot;LIST_ID&quot;+ESP.getDevice_id());</span><br><span class="line">                        return  ESPlist;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return  null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return  null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.e(&quot;prx&quot;,&quot;异常：&quot; + e.getMessage());</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-看看MainActivity"><a href="#3-看看MainActivity" class="headerlink" title="3.看看MainActivity"></a>3.看看MainActivity</h2><p>在oncreate方法里开启新线程来读取数据库数据，通过1234（这里暂时设1234为appid）来读取数据库中appid为1234的所有数据DBUtils.getInfoByID(“1234”)返回的是一个数组。通过handler把消息告诉主线程,主线程再根据设备集合对listview进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ESP8266&gt; deviceslist=new ArrayList&lt;&gt;();//存放设备集合</span><br><span class="line">    List_Adapter adapter=null;</span><br><span class="line">    private ListView mlistview;//列表视图</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // 调用数据库工具类DBUtils的getInfoByName方法获取数据库表中数据</span><br><span class="line"></span><br><span class="line">                deviceslist=DBUtils.getInfoByID(&quot;1234&quot;);</span><br><span class="line">                //把得到设备集合的信息通知到主线程</span><br><span class="line">                Message message = handler.obtainMessage();</span><br><span class="line">                if (!deviceslist.isEmpty())&#123;</span><br><span class="line">                    message.what=0x11;</span><br><span class="line">                    handler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">   private Handler handler = new Handler()&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line"></span><br><span class="line">           switch (msg.what)&#123;</span><br><span class="line">               case 0x11:</span><br><span class="line">                   //获得设备集合，开始列表初始化</span><br><span class="line">                   Initlistview();</span><br><span class="line">                   break;</span><br><span class="line">               case 0x12:</span><br><span class="line"></span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   private void Initlistview() &#123;</span><br><span class="line">       //初始化视图</span><br><span class="line">       adapter=new List_Adapter(MainActivity.this,deviceslist);</span><br><span class="line">       mlistview.setAdapter(adapter);</span><br><span class="line">       //初始化短按键功能</span><br><span class="line"></span><br><span class="line">       //初始化长按功能</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4，最后附上我的list-adapter的代码"><a href="#4，最后附上我的list-adapter的代码" class="headerlink" title="4，最后附上我的list_adapter的代码"></a>4，最后附上我的list_adapter的代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class List_Adapter extends BaseAdapter &#123;</span><br><span class="line">    private List&lt;ESP8266&gt; list;</span><br><span class="line">    private Context mcontext;</span><br><span class="line">    private LayoutInflater mlayoutinflater;</span><br><span class="line">    public List_Adapter (Context context,List&lt;ESP8266&gt; list)&#123;</span><br><span class="line">        this.list=list;</span><br><span class="line">        this.mcontext=context;</span><br><span class="line">        mlayoutinflater= (LayoutInflater) mcontext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//完成赋值</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getItem(int position) &#123;</span><br><span class="line">        return list.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        Log.e(&quot;list&quot;,&quot;enter adapter&quot;);</span><br><span class="line">        ESP8266 device=list.get(position);</span><br><span class="line">        viewholder holder=null;                   //创建一个中转站</span><br><span class="line">        if (convertView==null)&#123;                    //如果有新项目移入屏幕</span><br><span class="line">            convertView=mlayoutinflater.inflate(R.layout.list_layout,null);//就给他加载内容</span><br><span class="line">            holder=new viewholder();</span><br><span class="line">            holder.imageView=convertView.findViewById(R.id.list_iv);//把控件地址赋值给holder</span><br><span class="line">            holder.textView1=convertView.findViewById(R.id.list_tv1);</span><br><span class="line">            holder.textView2=convertView.findViewById(R.id.list_tv2);</span><br><span class="line">            convertView.setTag(holder);         //绑定项目视图和holder</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            holder=(viewholder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        //设置备注为设备的名称</span><br><span class="line">        holder.textView1.setText(device.getRemark());</span><br><span class="line">        //Log.e(&quot;state&quot;,device.getState());</span><br><span class="line">        //显示设备状态</span><br><span class="line">        if (device.getState().equals(&quot;online&quot;))&#123;</span><br><span class="line">            holder.textView2.setText(&quot;在线&quot;);</span><br><span class="line">        &#125;else if (device.getState().equals(&quot;offline&quot;))&#123;</span><br><span class="line">            holder.textView2.setText(&quot;离线&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else holder.textView2.setText(&quot;错误！&quot;);</span><br><span class="line">        //根据设备类型设置相应图片</span><br><span class="line">        switch (device.getType()) &#123;</span><br><span class="line">            case &quot;aircondition&quot;:</span><br><span class="line">                holder.imageView.setImageResource(R.drawable.aircon);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;light&quot;:</span><br><span class="line">                holder.imageView.setImageResource(R.drawable.light1);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;sensor&quot;:</span><br><span class="line">                holder.imageView.setImageResource(R.drawable.sensor2);</span><br><span class="line">        &#125;</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line">    static class viewholder&#123;     //暂时储存数据，中转站</span><br><span class="line">        public ImageView imageView;</span><br><span class="line">        public TextView textView1,textView2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5，效果如图，根据获取的设备数据进行展示"><a href="#5，效果如图，根据获取的设备数据进行展示" class="headerlink" title="5，效果如图，根据获取的设备数据进行展示"></a>5，效果如图，根据获取的设备数据进行展示</h2><p><img src="/2025/05/30/hello-world/Android/read_from_Mysql/view.png" alt="在这里插入图片描述"><br><img src="/2025/05/30/hello-world/Android/read_from_Mysql/like.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Android/read_from_Mysql/" data-id="cmbcy7rgs0007t8mt8n6jf2zh" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/Compiler/build_gcc_cross_compiler" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Compiler/build_gcc_cross_compiler/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.633Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="构建gcc交叉工具链"><a href="#构建gcc交叉工具链" class="headerlink" title="构建gcc交叉工具链"></a>构建gcc交叉工具链</h1><h2 id="一、交叉工具链简介"><a href="#一、交叉工具链简介" class="headerlink" title="一、交叉工具链简介"></a>一、交叉工具链简介</h2><p>工具链就是一系列用于编译的程序，以特定的顺序组织在一起，一个程序的结果输出到下一个程序，直到最终编译出目标程序。而运行工具链的计算机和运行目标程序的计算机不一样时，这个工具链就叫交叉工具链。</p>
<p>使用最广泛的就是gnu gcc交叉工具链，该工具链包含了c、c++等语言的编译器，汇编器，连接器等，是一个工具集合。</p>
<h2 id="二、生成gcc交叉工具链"><a href="#二、生成gcc交叉工具链" class="headerlink" title="二、生成gcc交叉工具链"></a>二、生成gcc交叉工具链</h2><p>工具链的组成：GUN将构建软件过程中的工具分别包含在3个软件包中：Binutils、GCC、Glibc。</p>
<ul>
<li>编译器：用于把源码编译成汇编代码，例如gcc、g++</li>
<li>汇编器：用于把汇编代码汇编成机器码</li>
<li>链接器：把各个机器码链接成最终的可执行机器码。汇编器和链接器都存在于binutils</li>
<li>C库：提供抽象层来运行基本的任务如内存管理、输入输出、管理文件。</li>
<li>kernel：C库的生成需要linux kernel头文件提供一些特性信息。</li>
</ul>
<p>GUN将编译器和C库分开放在两个软件包里，好处是比较灵活，方便在工具链中可以选择不同的C库，比如Glibc、uClibc等。但是，也带来了编译器和C库的循环依赖问题：编译C库需要C编译器，但是C编译器又依赖C库。</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C编译器为何依赖C库？</span><br><span class="line">C编译器需要根据C库的某此特性来决定自己支持哪些特性，因此C编译器要依赖C库的头文件。</span><br><span class="line">C++的库和编译器需要C库支持，比如异常处理和栈回溯部分。</span><br><span class="line">GCC不仅包含编译器，还包含一些库，这些库通常依赖C库</span><br><span class="line">C编译器本身也会使用C库的一些函数。</span><br><span class="line">Glibc基本是自包含的，可能有小部分地方使用了GCC的代码。</span><br></pre></td></tr></table></figure></blockquote>
<p>由于上述原因，编译的过程如下：</p>
<ul>
<li>1、使用host的gcc构建Binutils</li>
<li>2、使用host的gcc构建第一阶段的gcc</li>
<li>3、安装target机器的内核头文件</li>
<li>4、使用第一阶段的gcc构建glibc库</li>
<li>5、使用第一阶段的gcc和glibc构建完整的gcc</li>
</ul>
<h2 id="三、crosstool-ng"><a href="#三、crosstool-ng" class="headerlink" title="三、crosstool-ng"></a>三、crosstool-ng</h2><p>上述是通用的GCC工具链构建方法，步骤比较复杂，所以有人就做出了一个脚本工具，叫做crosstool-ng来简化上述步骤。他将上述过程合并成一个步骤，我们只需要配置好参数，然后一键就能生成gcc工具链。</p>
<h3 id="3-1、安装crosstool-ng"><a href="#3-1、安装crosstool-ng" class="headerlink" title="3.1、安装crosstool-ng"></a>3.1、安装crosstool-ng</h3><p>使用wget下载最新源码压缩包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.25.0.tar.xz</span><br><span class="line">tar -xvf crosstool-ng-1.25.0.tar.xz</span><br></pre></td></tr></table></figure>

<p>创建crosstool-ng的安装目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> crosstool-ng</span><br></pre></td></tr></table></figure>

<p>开始安装crosstool-ng:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> crosstool-ng-1.25.0 <span class="comment">#进入源码目录</span></span><br><span class="line"><span class="built_in">sudo</span> apt install gcc flex texinfo gawk make libtool-bin libncurses5-dev bison g++ git#需要使用到这些工具来帮助安装</span><br><span class="line">./configure --prefix=/home/prx/crosstool-ng <span class="comment">#设置安装路径</span></span><br><span class="line"><span class="comment"># 开始安装</span></span><br><span class="line"><span class="built_in">sudo</span> make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/home/prx/crosstool-ng/bin：<span class="variable">$&#123;PATH&#125;</span>:&quot;</span> <span class="comment">#把crosstool-ng的路径添加到环境变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<code>ct-ng -v</code>能打印出信息说明在crosstool-ng目录下安装成功。</p>
<h3 id="3-2、配置"><a href="#3-2、配置" class="headerlink" title="3.2、配置"></a>3.2、配置</h3><p>我们要使用crosstool-ng来制作gcc交叉工具链，首先需要确定gcc工具链的配置参数，参数与目标机器的架构很大关系。crosstool-ng提供了一些常用的参数配置模板，以及一个图像化配置界面来帮助配置。</p>
<p>首先创建一个work-space目录来存放crosstool-ng的配置文件,进入work-space目录。</p>
<p>执行<code>ct-ng list-samples</code>可以列出所有的模板，选择合适的配置模板，因为I6C是ARMV7-a cortex-a7，我们可以使用：<code>armv7-rpi2-linux-gnueabihf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">prx@ubuntu:~$ <span class="built_in">mkdir</span> work-space </span><br><span class="line">prx@ubuntu:~$ <span class="built_in">cd</span> work-space</span><br><span class="line">prx@ubuntu:~/work-space$ ct-ng list-samples</span><br><span class="line">Status  Sample name</span><br><span class="line">[G...]   aarch64-ol7u9-linux-gnu</span><br><span class="line">[G...]   aarch64-rpi3-linux-gnu</span><br><span class="line">[G...]   aarch64-rpi4-linux-gnu</span><br><span class="line">[G..X]   aarch64-unknown-linux-android</span><br><span class="line">[G...]   aarch64-unknown-linux-gnu</span><br><span class="line">[G...]   aarch64-unknown-linux-uclibc</span><br><span class="line">[G...]   alphaev56-unknown-linux-gnu</span><br><span class="line">[G...]   alphaev67-unknown-linux-gnu</span><br><span class="line">[G...]   arc-arc700-linux-uclibc</span><br><span class="line">[G...]   arc-archs-linux-gnu</span><br><span class="line">[G...]   arc-multilib-elf32</span><br><span class="line">[G...]   arc-multilib-linux-gnu</span><br><span class="line">[G...]   arc-multilib-linux-uclibc</span><br><span class="line">[G...]   arm-bare_newlib_cortex_m3_nommu-eabi</span><br><span class="line">[G...]   arm-cortex_a15-linux-gnueabihf</span><br><span class="line">[G..X]   arm-cortexa5-linux-uclibcgnueabihf</span><br><span class="line">[G...]   arm-cortex_a8-linux-gnueabi</span><br><span class="line">[G..X]   arm-cortexa9_neon-linux-gnueabihf</span><br><span class="line">[G..X]   x86_64-w64-mingw32,arm-cortexa9_neon-linux-gnueabihf</span><br><span class="line">[G...]   armeb-unknown-eabi</span><br><span class="line">[G...]   armeb-unknown-linux-gnueabi</span><br><span class="line">[G...]   armeb-unknown-linux-uclibcgnueabi</span><br><span class="line">[G...]   arm-multilib-linux-uclibcgnueabi</span><br><span class="line">[G...]   arm-nano-eabi</span><br><span class="line">[G...]   arm-ol7u9-linux-gnueabi</span><br><span class="line">[G...]   arm-ol7u9-linux-gnueabihf</span><br><span class="line">[G...]   arm-picolibc-eabi</span><br><span class="line">[G...]   arm-unknown-eabi</span><br><span class="line">[G...]   arm-unknown-linux-gnueabi</span><br><span class="line">[G..X]   arm-unknown-linux-musleabi</span><br><span class="line">[G...]   arm-unknown-linux-uclibcgnueabi</span><br><span class="line">[G..X]   arm-unknown-linux-uclibcgnueabihf</span><br><span class="line">[G...]   armv6-nommu-linux-uclibcgnueabi</span><br><span class="line">[G...]   armv6-unknown-linux-gnueabi</span><br><span class="line">[G...]   armv6-unknown-linux-gnueabihf</span><br><span class="line">[G...]   armv7-rpi2-linux-gnueabihf</span><br><span class="line">[G...]   armv8-rpi3-linux-gnueabihf</span><br><span class="line">[G...]   armv8-rpi4-linux-gnueabihf</span><br></pre></td></tr></table></figure>

<p>执行<code>ct-ng armv7-rpi2-linux-gnueabihf</code>选择该配置，然后执行<code>ct-ng menuconfig</code>进入配置界面，对配置进行微调。</p>
<h4 id="3-2-1、配置corsstool-ng"><a href="#3-2-1、配置corsstool-ng" class="headerlink" title="3.2.1、配置corsstool-ng"></a>3.2.1、配置corsstool-ng</h4><p>构建过程会使用到很多工具，这些工具可以安装在指定目录下，也可以使用默认配置：</p>
<ul>
<li><p>Local tarballs directory：指定存放编译gcc所需的工具</p>
</li>
<li><p>Working directory：存放.config配置文件</p>
</li>
<li><p>Prefix Directory：存放生成的gcc交叉工具链</p>
</li>
<li><p>选中Debug crosstool-NG： 选择save intermediate step: 当编译出错时，再次编译会从出错的地方开始，节省编译时间</p>
</li>
<li><p>Number of parallel jobs：选择并行编译的内核数量 -j</p>
</li>
</ul>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/1.png" alt="image-20220714103217558"></p>
<h4 id="3-2-2、配置Target-option"><a href="#3-2-2、配置Target-option" class="headerlink" title="3.2.2、配置Target option"></a>3.2.2、配置Target option</h4><p>这里的选项用于配置目标cpu的具体信息：</p>
<ol>
<li>Target Architecture: 目标架构，选择arm</li>
<li>Suffix to the arch-part：架构的后缀，可以是指令集版本v7，和Target Architecture一起组成arm-v7</li>
<li>bitness：指令集位数：只有aarch64才有64bit</li>
<li>architecture level：目标架构，可理解为指令集</li>
<li>emit assembly for cpu：目标cpu的具体架构和特性</li>
<li>tune for cpu：cpu的具体架构</li>
<li>Use specific FPU : FPU型号</li>
</ol>
<p><strong>note：4、5、6在最后GCC配置选项有详细说明</strong></p>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/2.png" alt="image-20220715142100586"></p>
<h4 id="3-2-3、配置toolchain"><a href="#3-2-3、配置toolchain" class="headerlink" title="3.2.3、配置toolchain"></a>3.2.3、配置toolchain</h4><p>配置生成的toolchain的功能、名称</p>
<p>Tuple vendor string：厂商名称，例如是sigmastar，则生成的工具链就是：armv7-sigmastar-linux-gnueabihf</p>
<p>sysroot：根文件系统，工具链会生成一个最小的根文件系统，里面有c库等</p>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/3.png" alt="image-20220713165014460"></p>
<h4 id="3-2-4、配置内核信息"><a href="#3-2-4、配置内核信息" class="headerlink" title="3.2.4、配置内核信息"></a>3.2.4、配置内核信息</h4><p>指定内核版本，如果menuconfig上没有所需要的内核版本，可以直接修改.config文件，最终都会去linux官网下载对应的内核压缩包。也可以在这里指定linux的下载地址。</p>
<p>由于I6和I7内核版本都是5.10.61，所以修改 .config 文件，把 <code>CT_LINUX_VERSION</code>设置为5.10.61</p>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/4.png" alt="image-20220713165246913"></p>
<h4 id="3-2-5、配置glibc"><a href="#3-2-5、配置glibc" class="headerlink" title="3.2.5、配置glibc"></a>3.2.5、配置glibc</h4><ul>
<li>选择glibc的版本号为2.33，以I6C为例</li>
<li>enable -Werror during the build 设置为n，防止一些报错</li>
</ul>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/5.png" alt="image-20220714171138996"></p>
<h4 id="3-2-6、配置gcc"><a href="#3-2-6、配置gcc" class="headerlink" title="3.2.6、配置gcc"></a>3.2.6、配置gcc</h4><p>选择gcc版本，若menuconfig中没有想要的版本，可以设置从网络下载。例如下载gcc-11.1.0：</p>
<ol>
<li>source of gcc：gcc的源，选择vendor&#x2F;custom repository 远程仓库</li>
<li>vcs type ：网络协议，选择git</li>
<li>repository url：仓库的url，<a target="_blank" rel="noopener" href="https://gcc.gnu.org/git/gcc.git">https://gcc.gnu.org/git/gcc.git</a></li>
<li>branch&#x2F;tag to check out：分支&#x2F;标签，例如releases&#x2F;gcc-11.1.0</li>
</ol>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/6.png" alt="image-20220713165654609"></p>
<h4 id="3-2-7、其他"><a href="#3-2-7、其他" class="headerlink" title="3.2.7、其他"></a>3.2.7、其他</h4><p>首先关闭debug facilities -&gt; gdb，否则会产生INVALID_CONFIGURATION错误，暂时未找到原因；</p>
<p>完成配置后，执行<code>ct-ng build</code>开始生成工具链。</p>
<h3 id="3-3、构建过程"><a href="#3-3、构建过程" class="headerlink" title="3.3、构建过程"></a>3.3、构建过程</h3><p>crosstool-ng会首先下载所需的软件压缩包，并解压：</p>
<ul>
<li>linux-5.10.61</li>
<li>zlib</li>
<li>gmp</li>
<li>mpfr</li>
<li>isl</li>
<li>mpc</li>
<li>ncurses</li>
<li>libiconv</li>
<li>gettext</li>
<li>binutils</li>
<li>gcc-11.1.0</li>
<li>glibc-2.33</li>
</ul>
<p>然后开始安装上面的软件：</p>
<ol>
<li>ncurses</li>
<li>zlib</li>
<li>gmp</li>
<li>mpfr</li>
<li>isl</li>
<li>mpc</li>
<li>libiconv</li>
<li>gettext</li>
<li>binutils ：编译binutils</li>
<li>kernel header</li>
<li>gcc：编译第一阶段gcc</li>
<li>glibc：编译glibc</li>
<li>gcc：生成最终的gcc</li>
</ol>
<p>出现以下信息说明gcc成功生成：</p>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/7.png" alt="image-20220713180502100"></p>
<h2 id="四、详细补充"><a href="#四、详细补充" class="headerlink" title="四、详细补充"></a>四、详细补充</h2><h3 id="什么是交叉工具链"><a href="#什么是交叉工具链" class="headerlink" title="什么是交叉工具链"></a>什么是交叉工具链</h3><p>工具链就是一系列用于编译的程序，以特定的顺序组织在一起，一个程序的结果输出到下一个程序，直到最终编译出目标程序。而运行工具链的计算机和运行目标程序的计算机不一样时，这个工具链就叫交叉工具链。</p>
<h3 id="工具链有哪些组件？"><a href="#工具链有哪些组件？" class="headerlink" title="工具链有哪些组件？"></a>工具链有哪些组件？</h3><ol>
<li>编译器：用于把源码编译成汇编代码，例如gcc、g++</li>
<li>汇编器：用于把汇编代码汇编成机器码</li>
<li>链接器：把各个机器码链接成最终的可执行机器码。汇编器和链接器都存在于binutils</li>
<li>C库：提供抽象层来运行基本的任务如内存管理、输入输出、管理文件。</li>
<li>kernel：C库的生成需要linux kernel头文件提供一些特性信息。</li>
</ol>
<h3 id="这些组件如何工作？"><a href="#这些组件如何工作？" class="headerlink" title="这些组件如何工作？"></a>这些组件如何工作？</h3><p>note：我们把想要生成的gcc工具链称为 终极gcc</p>
<ol>
<li>编译出一个终极gcc，需要一个C库</li>
<li>编译一个C库，需要使用gcc</li>
</ol>
<p>这是一个鸡生蛋的问题，解决办法是：首先构建一个不需要C库的临时gcc，称他为pass2 gcc</p>
<p>所以流程是这样：</p>
<ol>
<li>编译出一个终极gcc，需要一个C库</li>
<li>编译一个C库，需要使用pass2 gcc</li>
<li>pass2 gcc要编译C库，需要知道C库的头文件和启动文件</li>
</ol>
<p>所以我们需要构建一个只有头文件和启动文件的C库，构建这个C库需要一个gcc编译器，所以我们还需要一个pass1 gcc来构建这样的一样C库，而且C库需要kernel头文件，所以流程如下：</p>
<ol>
<li>编译出一个终极gcc，需要一个C库</li>
<li>编译一个C库，需要使用pass2 gcc</li>
<li>pass2 gcc要编译C库，需要知道C库的头文件和启动文件</li>
<li>需要pass1 gcc来构建C库头文件和启动文件，kernel 头文件</li>
</ol>
<p>构建pass1 gcc需要使用汇编器、链接器等，这些由binutils提供。幸好binutils不依赖其他软件，我们可以使用本地的gcc直接构建binutils，新的流程如下：</p>
<ol>
<li>编译出一个终极gcc，需要一个C库</li>
<li>编译一个C库，需要使用pass2 gcc</li>
<li>pass2 gcc要编译C库，需要知道C库的头文件和启动文件</li>
<li>需要pass1 gcc来构建C库头文件和启动文件，kernel 头文件</li>
<li>构建pass1 gcc需要binutils</li>
</ol>
<p>最后，gcc还需要一些额外的库来支持大量算术计算、编译、链接优化等，这些库互相依赖，有一定的构建顺序，所以最终的流程如下：</p>
<ol>
<li>编译出一个终极gcc，需要一个C库</li>
<li>编译一个C库，需要使用pass2 gcc</li>
<li>pass2 gcc要编译C库，需要知道C库的头文件和启动文件</li>
<li>需要pass1 gcc来构建C库头文件和启动文件，kernel 头文件</li>
<li>构建pass1 gcc需要binutils</li>
<li>需要构建GMP、MPFR、MPC、PPL、ISL、CLooG 、libelf</li>
</ol>
<p>补充，对crosstoo-ng来说，还需要一些额外的工具来帮助构建：</p>
<ul>
<li>elf2flt：将gcc转换成flat bin</li>
<li>zlib：用于压缩</li>
<li>libiconv、gettext：本地化工具链需要</li>
</ul>
<h3 id="最终的构建流程"><a href="#最终的构建流程" class="headerlink" title="最终的构建流程"></a>最终的构建流程</h3><p>crosstool-ng会下载、解压所需的所有软件源码，所以按顺序进行配置、构建、安装所需的软件：</p>
<ol>
<li>ncurses</li>
<li>zlib</li>
<li>gmp</li>
<li>mpfr</li>
<li>isl</li>
<li>mpc</li>
<li>libiconv</li>
<li>gettext</li>
<li>binutils </li>
<li>kernel header</li>
<li>pass1 gcc </li>
<li>pass2 gcc </li>
<li>glibc</li>
<li>终极gcc</li>
</ol>
<h2 id="GCC配置选项"><a href="#GCC配置选项" class="headerlink" title="GCC配置选项"></a>GCC配置选项</h2><p>这里先分析arch、cpu、tune选项，其余大部分可以再<a target="_blank" rel="noopener" href="https://gcc.gnu.org/install/configure.html%E4%B8%AD%E6%9F%A5%E7%9C%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%9C%A8gcc-11.x">https://gcc.gnu.org/install/configure.html中查看，以及在gcc-11.x</a> manual 第三章gcc command options 中查看。</p>
<p>gcc command options 是 在使用gcc编译代码时带的选项，这些选项帮助我们生成特定的机器指令。我们就从arch、cpu、tune这些选项入手，分析crosstool-ng如何配置这些选项的。</p>
<h3 id="march"><a href="#march" class="headerlink" title="-march"></a>-march</h3><p>在manual手册的定义如下：</p>
<blockquote>
<p>-march&#x3D;name</p>
<p>Specify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form ‘-march&#x3D;arch{+[no]feature}*’.<br>The table below summarizes the permissible values for arch and the features<br>that they enable by default:</p>
<table>
<thead>
<tr>
<th>arch value</th>
<th>Architecture</th>
<th>feature Includes by default</th>
</tr>
</thead>
<tbody><tr>
<td>‘armv8-a’</td>
<td>armv8-a</td>
<td>‘+fp’, ‘+simd’</td>
</tr>
<tr>
<td>‘armv8.1-a’</td>
<td>armv8.1-a</td>
<td>‘armv8-a’, ‘+crc’, ‘+lse’, ‘+rdma’</td>
</tr>
<tr>
<td>‘armv8.2-a’</td>
<td>armv8.2-a</td>
<td>‘armv8.1-a’</td>
</tr>
<tr>
<td>‘armv8.3-a’</td>
<td>armv8.3-a</td>
<td>‘armv8.2-a’, ‘+pauth’</td>
</tr>
<tr>
<td>‘armv8.4-a’</td>
<td>armv8.4-a</td>
<td>‘armv8.3-a’, ‘+flagm’, ‘+fp16fml’, ‘+dotprod’</td>
</tr>
<tr>
<td>‘armv8.5-a’</td>
<td>armv8.5-a</td>
<td>‘armv8.4-a’, ‘+sb’, ‘+ssbs’, ‘+predres’</td>
</tr>
<tr>
<td>‘armv8.6-a’</td>
<td>armv8.6-a</td>
<td>‘armv8.5-a’, ‘+bf16’, ‘+i8mm’</td>
</tr>
<tr>
<td>‘armv8-r’</td>
<td>armv8-r</td>
<td>‘armv8-r’</td>
</tr>
</tbody></table>
<p>The value ‘native’ is available on native AArch64 GNU&#x2F;Linux and causes the<br>compiler to pick the architecture of the host system. This option has no effect<br>if the compiler is unable to recognize the architecture of the host system,<br>The permissible values for feature are listed in the sub-section on [‘-march’ and<br>‘-mcpu’ Feature Modifiers], page 285. Where conflicting feature modifiers are<br>specified, the right-most feature is used.<br>GCC uses name to determine what kind of instructions it can emit when generating assembly code. If ‘-march’ is specified without either of ‘-mtune’ or<br>‘-mcpu’ also being specified, the code is tuned to perform well across a range of<br>target processors implementing the target architecture.</p>
</blockquote>
<p>简单来说就是：</p>
<p><strong>-march指定了目标处理器的架构，GCC使用名称来决定产生特定指令集的汇编代码，如何-mtune和-mcpu没有值，那么gcc就会产生适合该系列处理器的汇编代码</strong></p>
<p>在crosstool-ng中如图所示有其对应的选项：</p>
<p><code>architecture level</code>的值对应于GCC命令行选项中的<code>-march</code>，只有当<code>emit assembly for cpu</code> 和<code>tune for cpu</code>不填时，这个选项才有效。</p>
<p><img src="/image-20220715121513331.png" alt="image-20220715121513331"></p>
<h3 id="mtune"><a href="#mtune" class="headerlink" title="-mtune"></a>-mtune</h3><p>定义如下：</p>
<blockquote>
<p>Specify the name of the target processor for which GCC should tune<br>the performance of the code. Permissible values for this option are:  </p>
<p>‘generic’, ‘cortex-a35’, ‘cortex-a53’, ‘cortex-a55’, ‘cortex-a57’,<br>‘cortex-a72’, ‘cortex-a73’, ‘cortex-a75’, ‘cortex-a76’, ‘cortex-a76ae’,<br>‘cortex-a77’, ‘cortex-a65’, ‘cortex-a65ae’, ‘cortex-a34’, ‘cortex-a78’,<br>‘cortex-a78ae’, ‘cortex-a78c’, ‘ares’, ‘exynos-m1’, ‘emag’, ‘falkor’,<br>‘neoverse-512tvb’, ‘neoverse-e1’, ‘neoverse-n1’, ‘neoverse-n2’,<br>‘neoverse-v1’, ‘qdf24xx’, ‘saphira’, ‘phecda’, ‘xgene1’, ‘vulcan’,<br>‘octeontx’, ‘octeontx81’, ‘octeontx83’, ‘octeontx2’, ‘octeontx2t98’,<br>‘octeontx2t96’ ‘octeontx2t93’, ‘octeontx2f95’, ‘octeontx2f95n’,<br>‘octeontx2f95mm’, ‘a64fx’, ‘thunderx’, ‘thunderxt88’, ‘thunderxt88p1’,<br>‘thunderxt81’, ‘tsv110’, ‘thunderxt83’, ‘thunderx2t99’, ‘thunderx3t110’,<br>‘zeus’, ‘cortex-a57.cortex-a53’, ‘cortex-a72.cortex-a53’,<br>‘cortex-a73.cortex-a35’, ‘cortex-a73.cortex-a53’, ‘cortex-a75.cortex-a55’,<br>‘cortex-a76.cortex-a55’, ‘cortex-r82’, ‘cortex-x1’, ‘ampere1’, ‘native’.<br>The values ‘cortex-a57.cortex-a53’, ‘cortex-a72.cortex-a53’,<br>‘cortex-a73.cortex-a35’, ‘cortex-a73.cortex-a53’, ‘cortex-a75.cortex-a55’,<br>‘cortex-a76.cortex-a55’ specify that GCC should tune for a big.LITTLE<br>system.<br>The value ‘neoverse-512tvb’ specifies that GCC should tune for Neoverse cores<br>that (a) implement SVE and (b) have a total vector bandwidth of 512 bits per<br>cycle. In other words, the option tells GCC to tune for Neoverse cores that can<br>execute 4 128-bit Advanced SIMD arithmetic instructions a cycle and that can<br>execute an equivalent number of SVE arithmetic instructions per cycle (2 for<br>256-bit SVE, 4 for 128-bit SVE). This is more general than tuning for a specific<br>core like Neoverse V1 but is more specific than the default tuning described<br>below.<br>Additionally on native AArch64 GNU&#x2F;Linux systems the value ‘native’ tunes<br>performance to the host system. This option has no effect if the compiler is<br>unable to recognize the processor of the host system.<br>Where none of ‘-mtune&#x3D;’, ‘-mcpu&#x3D;’ or ‘-march&#x3D;’ are specified, the code is tuned<br>to perform well across a range of target processors.<br>This option cannot be suffixed by feature modifiers.  </p>
</blockquote>
<p><strong>简单来说就是：指定目标处理器，gcc应该优化这个处理器的代码。这些处理器可以是：</strong></p>
<blockquote>
<p>‘generic’, ‘cortex-a35’, ‘cortex-a53’, ‘cortex-a55’, ‘cortex-a57’,<br>‘cortex-a72’, ‘cortex-a73’, ‘cortex-a75’, ‘cortex-a76’, ‘cortex-a76ae’,<br>‘cortex-a77’, ‘cortex-a65’, ‘cortex-a65ae’, ‘cortex-a34’, ‘cortex-a78’,<br>‘cortex-a78ae’, ‘cortex-a78c’, ‘ares’, ‘exynos-m1’, ‘emag’, ‘falkor’,<br>‘neoverse-512tvb’, ‘neoverse-e1’, ‘neoverse-n1’, ‘neoverse-n2’,<br>‘neoverse-v1’, ‘qdf24xx’, ‘saphira’, ‘phecda’, ‘xgene1’, ‘vulcan’,<br>‘octeontx’, ‘octeontx81’, ‘octeontx83’, ‘octeontx2’, ‘octeontx2t98’,<br>‘octeontx2t96’ ‘octeontx2t93’, ‘octeontx2f95’, ‘octeontx2f95n’,<br>‘octeontx2f95mm’, ‘a64fx’, ‘thunderx’, ‘thunderxt88’, ‘thunderxt88p1’,<br>‘thunderxt81’, ‘tsv110’, ‘thunderxt83’, ‘thunderx2t99’, ‘thunderx3t110’,<br>‘zeus’, ‘cortex-a57.cortex-a53’, ‘cortex-a72.cortex-a53’,<br>‘cortex-a73.cortex-a35’, ‘cortex-a73.cortex-a53’, ‘cortex-a75.cortex-a55’,<br>‘cortex-a76.cortex-a55’, ‘cortex-r82’, ‘cortex-x1’, ‘ampere1’, ‘native’.<br>The values ‘cortex-a57.cortex-a53’, ‘cortex-a72.cortex-a53’,<br>‘cortex-a73.cortex-a35’, ‘cortex-a73.cortex-a53’, ‘cortex-a75.cortex-a55’,<br>‘cortex-a76.cortex-a55’ specify that GCC should tune for a big.LITTLE<br>system.</p>
</blockquote>
<p>在crosstool-ng的menuconfig中对应<code>tune for cpu</code></p>
<h3 id="mcpu"><a href="#mcpu" class="headerlink" title="-mcpu"></a>-mcpu</h3><p>定义如下：</p>
<blockquote>
<p>-mcpu&#x3D;name<br>Specify the name of the target processor, optionally suffixed by one or more<br>feature modifiers. This option has the form ‘-mcpu&#x3D;cpu{+[no]feature}*’, where<br>the permissible values for cpu are the same as those available for ‘-mtune’. The<br>permissible values for feature are documented in the sub-section on [‘-march’<br>and ‘-mcpu’ Feature Modifiers], page 285. Where conflicting feature modifiers<br>are specified, the right-most feature is used.<br>GCC uses name to determine what kind of instructions it can emit when generating assembly code (as if by ‘-march’) and to determine the target processor<br>for which to tune for performance (as if by ‘-mtune’). Where this option is used<br>in conjunction with ‘-march’ or ‘-mtune’, those options take precedence over<br>the appropriate part of this option.<br>‘-mcpu&#x3D;neoverse-512tvb’ is special in that it does not refer to a specific core,<br>but instead refers to all Neoverse cores that (a) implement SVE and (b) have<br>a total vector bandwidth of 512 bits a cycle. Unless overridden by ‘-march’,<br>‘-mcpu&#x3D;neoverse-512tvb’ generates code that can run on a Neoverse V1 core,<br>since Neoverse V1 is the first Neoverse core with these properties. Unless overridden by ‘-mtune’, ‘-mcpu&#x3D;neoverse-512tvb’ tunes code in the same way as<br>for ‘-mtune&#x3D;neoverse-512tvb’  </p>
</blockquote>
<p><strong>简单来说，就是在-mtune的基础上，可以增加额外的feature，同时会覆盖-march和-mtune</strong></p>
<p>在crosstool-ng的menuconfig中对应<code>emit assembly for cpu</code></p>
<h3 id="feature的取值"><a href="#feature的取值" class="headerlink" title="feature的取值"></a>feature的取值</h3><p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/8.png" alt="image-20220715133741905"></p>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/9.png" alt="image-20220715133812235"></p>
<p><img src="/2025/05/30/hello-world/Compiler/build_gcc_cross_compiler/10.png" alt="image-20220715133824472"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>能适应-mcpu则尽量指明，因为：</p>
<ul>
<li>-mcpu：指出cpu指令集，具体架构，特性</li>
<li>-mtune：指出cpu指令集，具体架构</li>
<li>-march：指出指令集</li>
</ul>
<p>优先级：</p>
<p>-mcpu &gt; -mtune &gt; -march</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Compiler/build_gcc_cross_compiler/" data-id="cmbcy7rgt0008t8mtbks8gplz" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ARM/ARM-CortexA7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ARM/ARM-CortexA7/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.632Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ARM-Cortex-A7-MPCore"><a href="#ARM-Cortex-A7-MPCore" class="headerlink" title="ARM Cortex A7 MPCore"></a>ARM Cortex A7 MPCore</h2><p>专业术语查询：<a target="_blank" rel="noopener" href="http://infocenter.arm.com/help/topic/com.arm.doc.aeg0014-/index.html">http://infocenter.arm.com/help/topic/com.arm.doc.aeg0014-/index.html</a></p>
<p>参考书籍：</p>
<ul>
<li>ARM® Architecture Reference Manual ARMv7-A and ARMv7-R edition</li>
<li>ARM Generic Interrupt Controller Architecture Specification</li>
<li>Cortex-A Series Programmer’s Guide</li>
</ul>
<h3 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h3><p>Crotex-A7 MPCore 是基于armv7-a 架构，是高性能和低功耗的平衡。支持1-4个处理器核心，L1缓存以及可选的GICv2.0、L2缓存，如图:</p>
<p><img src="/2025/05/30/hello-world/ARM/ARM-CortexA7/armv7-a_arch.png" alt="image-20220616101432614"></p>
<p>外部接口：</p>
<ul>
<li>ACE：AMBA4 AXI</li>
<li>APB：AMBA3 APB</li>
<li>ETM：Embedded Trace Macrocell</li>
<li>DFT：Design For Test</li>
<li>MBIST：Memory Built In Self Test</li>
</ul>
<h3 id="第二章-功能模块"><a href="#第二章-功能模块" class="headerlink" title="第二章 功能模块"></a>第二章 功能模块</h3><p>Cortex-A7 MPCore的功能模块如下所示，下面对各个功能进行介绍：</p>
<p><img src="/2025/05/30/hello-world/ARM/ARM-CortexA7/arm-process.png" alt="image-20220616115203899"></p>
<h4 id="DPU"><a href="#DPU" class="headerlink" title="DPU"></a>DPU</h4><p>DPU是处理器的中心，包含通用寄存器、状态寄存器和控制寄存器，他负责解码和执行指令，操作寄存器内的数据。他从PFU中获取指令，并将数据输出到STB（写缓存）和DCU（数据缓存）。</p>
<h4 id="CP15"><a href="#CP15" class="headerlink" title="CP15"></a>CP15</h4><p>内存配置</p>
<h4 id="指令存储"><a href="#指令存储" class="headerlink" title="指令存储"></a>指令存储</h4><p>指令存储系统包含两个部分：</p>
<ul>
<li>指令cache：指令cache控制器和buff，8-64KB</li>
<li>指令预取：从指令cache或者内存中获取指令，并作出分支预测，将结果输出到DPU</li>
</ul>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>数据存储系统包含三个部分</p>
<ul>
<li>数据cache：多处理器共享的一些机制，8-64KB</li>
<li>STB：写缓冲</li>
<li>BIU和SCU：对STB和cache进行解耦</li>
</ul>
<h3 id="第三章-编程模型"><a href="#第三章-编程模型" class="headerlink" title="第三章 编程模型"></a>第三章 编程模型</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ARM/ARM-CortexA7/" data-id="cmbcy7rgr0004t8mthpa4gcti" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/ARM/GICv2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ARM/GICv2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.632Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="GIC-V2"><a href="#GIC-V2" class="headerlink" title="GIC-V2"></a>GIC-V2</h2><p>参考文章：<a target="_blank" rel="noopener" href="http://www.wowotech.net/linux_kenrel/gic_driver.html">linux kernel的中断子系统之（七）：GIC代码分析 (wowotech.net)</a></p>
<p>arm_gic_architecture_specification.pdf</p>
<p>GIC关于支持安全扩展、虚拟化的部分就不分析，先了解最基本的中断功能。</p>
<h3 id="gic初始"><a href="#gic初始" class="headerlink" title="gic初始"></a>gic初始</h3><p>gic_v2_acpi_init()</p>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>GIC与外设，CPU的关系可如简化：</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICv2-1.png" alt="未命名文件 (5)"></p>
<p>GIC是ARM的中断控制器，用于接收soc上外设的中断信号，并通知cpu进行处理。GIC可分为两个部分：distributor和cpu interface。</p>
<p>distributor负责配置中断优先级并将中断信号发送 到cpu interface，cpu interface与cpu进行物理连接，负责优先级屏蔽和抢占处理。GIC中有一个distributor和最多8个cpu interface，他们的寄存器都映射到内存中读写，寄存器的地址由GICD_prefix和GICCprefix定义。如下是GIC的框架图</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICv2-2.png" alt="image-20220625094512755"></p>
<h4 id="1-1、distributor"><a href="#1-1、distributor" class="headerlink" title="1.1、distributor"></a>1.1、distributor</h4><p>distributor收集所有外设的中断信号，决定他们的优先级，并将最高优先级的中断传输给cpu。distributor提供的编程接口有：</p>
<ul>
<li>使能全局中断</li>
<li>使能具体外设中断</li>
<li>设置中断优先级</li>
<li>设置中断的目标cpu</li>
<li>设置中断为边沿触发or电平触发</li>
<li>设置中断分组（安全扩展）</li>
</ul>
<p>另外，distributor还提供了一个中断状态机，用于设置or清除外设中断。如图：</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICV2-3.png" alt="image-20220620132505469"></p>
<ul>
<li>Inactive：没有中断产生</li>
<li>Pending：中断产生（边沿触发）</li>
<li>Active：中断产生并且正在处理</li>
<li>Active and Pending：（电平触发）</li>
</ul>
<h4 id="1-2、中断id"><a href="#1-2、中断id" class="headerlink" title="1.2、中断id"></a>1.2、中断id</h4><p>GIC支持最多1020个中断id，每一个中断id代表一个中断信号线。其中0-31是私有id，对应指定的cpu，32-1019是共享id，所有cpu都可见。这些id就是硬件中断号。</p>
<h4 id="1-3-cpu-interface"><a href="#1-3-cpu-interface" class="headerlink" title="1.3 cpu interface"></a>1.3 cpu interface</h4><p>cpu interface 一共有8个，每一个对接一个cpu，提供的编程接口有：</p>
<ul>
<li>使能具体外设中断信号传输到cpu</li>
<li>应答中断</li>
<li>指示中断处理完成</li>
<li>设置中断优先级屏蔽</li>
<li>设置优先级抢占规则</li>
<li>将最高优先级的pengding中断提供给cpu</li>
</ul>
<p>应答中断：就是gic产生的中断信号使cpu成功进入irq mode，cpu读取gic 的寄存器，获取最高优先级的pending中断id，此时distributor的状态机就会从pending变成active，表示中断正在处理。此时，假如产生另一个中断，cpu interface就可以再次产生新的中断来抢占当前active的中断。</p>
<p>指示中断处理完成：当cpu的中断处理函数运行完成后，需要两个步骤结束整个中断：</p>
<ol>
<li>priority drop：CPU将中断id写入EOI寄存器，这个中断就会从runing优先级恢复到原来的优先级，cpu此时就能响应其他的中断</li>
<li>interruption deactivation：cpu写GICC_DIR寄存器，distributor的状态机变成inactive，中断处理完成</li>
</ol>
<h3 id="二、中断处理流程和优先级"><a href="#二、中断处理流程和优先级" class="headerlink" title="二、中断处理流程和优先级"></a>二、中断处理流程和优先级</h3><h4 id="2-1-中断处理流程"><a href="#2-1-中断处理流程" class="headerlink" title="2.1 中断处理流程"></a>2.1 中断处理流程</h4><p>GIC中断处理的流程和状态机很有关系，流程如下</p>
<ol>
<li>GIC使能每个中断</li>
<li>GIC查出 enabled和pending 的中断对应的cpu</li>
<li>distributor 查找最高优先级的pending 中断，发送到对应cpu interface</li>
<li>cpu interface 判断该中断是否具有sufficient 优先级，若有则触发cpu的中断</li>
<li>cpu进入中断，从中断向量表中跳转到中断处理程序，读取GICC_IAR寄存器，获取中断id，应答中断，跳转到对应外设中断处理函数执行。中断状态机变成active</li>
<li>外设中断函数处理完成，向GIC的EOI寄存器写入中断id，恢复优先级，能响应其他中断。向GICC_DIR寄存器写入，将状态机变成inactive。</li>
</ol>
<blockquote>
<p>note</p>
<p>running 优先级，当前cpu interface的active中断的最高优先级，若没有active中断，则是idle优先级。</p>
</blockquote>
<h4 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2 优先级"></a>2.2 优先级</h4><p>GIC将中断优先级分为两个部分：分组优先级和子优先级。当中断产生时，会先比较分组优先级，分组优先级高的话可以抢占当前的中断，分组优先级相同时，再比较子优先级。</p>
<p>中断的优先级保存在寄存器 GICD_IPRIORITYRn 中，数值越小，优先级越大。优先级是一个8bit的数值，每一个位的意义如下：</p>
<p> GICC_BPR 寄存器将GICD_IPRIORITYRn 中的8bit分成两个部分：</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICV2-4.png" alt="image-20220625134245519"></p>
<p>只有分组优先级高于 GICC_PMR 寄存器定义时，中断才会被响应。 GICC_PMR 寄存器用于屏蔽优先级。</p>
<h3 id="三、中断寄存器"><a href="#三、中断寄存器" class="headerlink" title="三、中断寄存器"></a>三、中断寄存器</h3><p>参考《arm_gic_architecture_specification.pdf》第四章</p>
<p>gic的地址在复位时会被采样PERIPHEBASE[39:15]，gic支持32bit、16bit、8bit的小端模式访问。</p>
<p>distributor的寄存器：</p>
<ul>
<li>Distributor Control Register：全局开关：distribute向interface发送信号</li>
<li>Interrupt Controller Type Register：安全扩展开关，CPU接口数量，支持的中断数量（32*(N+1)）</li>
<li>Distributor Implementer Identification Register：distribute的版本信息</li>
<li>Interrupt Set-Enable Registers:每一个bit表示中断从distribute到interface的开关，一个寄存器支持32个中断</li>
<li>Interrupt Clear-Enable Registers：与Interrupt Set-Enable Registers相反</li>
<li>Interrupt Set-Pending Registers：设置一个中断状态为pending，边缘触发和电平触发的pending处理是不一样的</li>
<li>Interrupt Clear-Pending Registers：中断pending清除</li>
<li>Interrupt Set-Active Registers：Writing to a Set-active bit Activates the corresponding interrupt</li>
<li>Interrupt Clear-Active Registers：Writing to a Clear-active bit Deactivates the corresponding interrupt.</li>
<li>Interrupt Priority Registers：记录每个中断的8位的优先级，值越小优先级越大</li>
<li>Interrupt Processor Targets Registers：决定将中断信号传递给哪些cpu interface</li>
<li>Interrupt Configuration Registers：配置边沿或电平触发</li>
<li>Software Generated Interrupt Register：软件中断的产生和配置</li>
<li>SGI Clear-Pending Registers：清除软件中断pending</li>
<li>SGI Set-Pending Registers：设置软件中断pending</li>
</ul>
<p>cpu interface 的寄存器：</p>
<ul>
<li><p>CPU Interface Control Register：全局中断信号开关</p>
</li>
<li><p>Interrupt Priority Mask Register：优先级过滤器，优先级高的中断才能被传递到cpu</p>
</li>
<li><p>Binary Point Register：将中断优先级分为两个部分，优先级和子优先级</p>
</li>
<li><p>Interrupt Acknowledge Register：cpu读取这个寄存器获取当前中断id，并认为是对这个中断ack，会使中断的状态从pending编程active，或者变成pending and active（电平触发）</p>
</li>
<li><p>End of Interrupt Register：写入中断号到该寄存器，表示中断处理完成</p>
</li>
<li><p>Running Priority Register：当前cpu接口的中断优先级</p>
</li>
<li><p>Highest Priority Pending Interrupt Register：就像他的名字说的</p>
</li>
<li><p>Deactivate Interrupt Register：把中断状态从active变成inactive</p>
</li>
</ul>
<blockquote>
<p>如上图，为GIC里面的中断对应的状态，当没有任何中断的时候状态为inactive。外设触发中断，distributor会将状态改为pending。当ARM处理器响应中断服务（中断服务程序响应之前，由GIC驱动会产生一个ACK信号给控制器）的时候，cpu interface在收到ACK信号后，将状态改为active或者active+pending，什么情况下是active呢？比如，外部中断是一个gpio按钮产生，假如是低电平有效，当用户按下按钮时，电平变为低电平，此时在GIC上产生电信号变化，GIC将状态改为penging，如果此时，用户突然松开了手，那么cpu interface只将状态改为active。但是如果用户没有松开手，那么cpu interface则将状态改为active+pending。所以可以了解到如果外设持续产生中断信号，那么就会出现active+pending的状态。这就是为什么绝大部分外设驱动在中断服务程序里面都会有一个清除pending状态的动作，如果不清除，即使中断服务程序处理结束返回，也会继续触发新的无用中断。<br>  另外，当中断服务程序处理结束后，通常GIC驱动还需要做一个动作叫做EOI，这个EOI一般是将两个操作合并成了一个（GICv1就是这样），但是到了GICv2，它允许将两个操作分开。那么是哪两个操作呢？即priority drop和deactivation。<br>  priority drop叫做优先级还原，即把当前中断的优先级从running priority改为响应中断之前的优先级。比如，我们给中断配置了一个优先级5，running priority数字为0， 那么肯定0的优先级高于5。当这个优先级为5的中断被CPU响应时，CPU会临时将这个中断的优先级改为0（running priority），这样可以防止被同组内的其它高优先级抢占而破坏中断流程，影响关键数据读取。当这个中断服务处理完成后，GIC又通过EOI的步骤将这个优先级变回原来的优先级5。<br>  deactivation叫做失效，即因为在GIC驱动ACK应答GIC控制器的时候，GIC控制器会把中断状态改为active或者active+penging，因此，这个deactivation可以将状态active改为inactive状态或者active+penging改为penging。<br>  在GICv2当中，它允许将两个方法分开，由软件控制，通过配置GICC_CTLR寄存器的EOImode位达到目的。如果分开，软件在中断服务程序结束后，需要做两个动作：1、写EOIR寄存器，释放running优先级；2、写GICC_DIR寄存器，修改中断状态。如果不分开，那么久只需要做一个写写EOIR寄存器的动作就可以了。</p>
</blockquote>
<h2 id="Linux中断系统"><a href="#Linux中断系统" class="headerlink" title="Linux中断系统"></a>Linux中断系统</h2><p>参考另一篇文章</p>
<h3 id="一、设备树"><a href="#一、设备树" class="headerlink" title="一、设备树"></a>一、设备树</h3><p>在imx6ul.dti中可以找到intc节点，表示GIC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;  <span class="comment">//子节点需要3个cell，eg:interrupts = &lt;GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH&gt;;</span></span></span><br><span class="line">	interrupt-controller;  <span class="comment">//中断控制器</span></span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,  <span class="comment">//distributor内存地址</span></span><br><span class="line">	      &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;   <span class="comment">//cpu interface 内存地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、驱动程序"><a href="#二、驱动程序" class="headerlink" title="二、驱动程序"></a>二、驱动程序</h3><p>GIC的驱动程序，猜测应该需要实现irq_domain，中断服务程序，初始化GIC寄存器。</p>
<h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>搜索设备树的compatible属性，确定驱动程序在irq-gic.c 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> gic_cnt __initdata;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init</span><br><span class="line"><span class="title function_">gic_of_init</span><span class="params">(<span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base;</span><br><span class="line">	<span class="type">void</span> __iomem *dist_base;</span><br><span class="line">	u32 percpu_offset;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//distributor基地址0x00a01000</span></span><br><span class="line">	dist_base = of_iomap(node, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//interface基地址0x00a02000</span></span><br><span class="line">	cpu_base = of_iomap(node, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_u32(node, <span class="string">&quot;cpu-offset&quot;</span>, &amp;percpu_offset))</span><br><span class="line">		percpu_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//初始化硬件寄存器</span></span><br><span class="line">	gic_init_bases(gic_cnt, <span class="number">-1</span>, dist_base, cpu_base, percpu_offset, node);</span><br><span class="line">    <span class="comment">//本例子中gic_cnt=0</span></span><br><span class="line">	<span class="keyword">if</span> (!gic_cnt)</span><br><span class="line">		gic_init_physaddr(node);</span><br><span class="line">	<span class="comment">//gic一般不会有parent</span></span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">		irq = irq_of_parse_and_map(node, <span class="number">0</span>);</span><br><span class="line">		gic_cascade_irq(gic_cnt, irq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//CONFIG_ARM_GIC_V2M is not set</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ARM_GIC_V2M))</span><br><span class="line">		gicv2m_of_init(node, gic_data[gic_cnt].domain);</span><br><span class="line">	<span class="comment">//每一个gic控制器都会记录</span></span><br><span class="line">	gic_cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从设备树中获取distributor和interface的基地址，然后调用gic_init_bases：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">gic_init_bases</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gic_nr, <span class="type">int</span> irq_start,</span></span><br><span class="line"><span class="params">			   <span class="type">void</span> __iomem *dist_base, <span class="type">void</span> __iomem *cpu_base,</span></span><br><span class="line"><span class="params">			   u32 percpu_offset, <span class="keyword">struct</span> device_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq_base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span>;</span></span><br><span class="line">	<span class="type">int</span> gic_irqs, irq_base, i;</span><br><span class="line">	<span class="comment">//从全局数组中获取gic对象</span></span><br><span class="line">	gic = &amp;gic_data[gic_nr];</span><br><span class="line">    </span><br><span class="line">	&#123;			<span class="comment">/* Normal, sane GIC... */</span></span><br><span class="line">		WARN(percpu_offset,</span><br><span class="line">		     <span class="string">&quot;GIC_NON_BANKED not enabled, ignoring %08x offset!&quot;</span>,</span><br><span class="line">		     percpu_offset);</span><br><span class="line">        <span class="comment">//保存地址</span></span><br><span class="line">		gic-&gt;dist_base.common_base = dist_base;</span><br><span class="line">		gic-&gt;cpu_base.common_base = cpu_base;</span><br><span class="line">		gic_set_base_accessor(gic, gic_get_common_base);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the CPU interface map to all CPUs.</span></span><br><span class="line"><span class="comment">	 * It will be refined as each CPU probes its ID.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_GIC_CPU_IF; i++)</span><br><span class="line">		gic_cpu_map[i] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find out how many interrupts are supported.</span></span><br><span class="line"><span class="comment">	 * The GIC only supports up to 1020 interrupt sources.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//获取GIC支持的中断数量</span></span><br><span class="line">	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) &amp; <span class="number">0x1f</span>;</span><br><span class="line">	gic_irqs = (gic_irqs + <span class="number">1</span>) * <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">if</span> (gic_irqs &gt; <span class="number">1020</span>)</span><br><span class="line">		gic_irqs = <span class="number">1020</span>;</span><br><span class="line">	gic-&gt;gic_irqs = gic_irqs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node) &#123;		<span class="comment">/*只考虑设备树的情况 */</span></span><br><span class="line">        <span class="comment">//添加一个irq_domain，对应GIC</span></span><br><span class="line">		gic-&gt;domain = irq_domain_add_linear(node, gic_irqs,</span><br><span class="line">						    &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">						    gic);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gic_nr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//handle_arch_irq会把handle_arch_irq指向gic_handle_irq</span></span><br><span class="line">		set_handle_irq(gic_handle_irq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置寄存器</span></span><br><span class="line">	gic_dist_init(gic);</span><br><span class="line">	gic_cpu_init(gic);</span><br><span class="line">	gic_pm_init(gic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这个GIC进行默认的配置，写寄存器</p>
<ul>
<li>gic_dist_init</li>
<li>gic_cpu_init</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">gic_dist_init</span><span class="params">(<span class="keyword">struct</span> gic_chip_data *gic)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	u32 cpumask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gic_irqs = gic-&gt;gic_irqs;  <span class="comment">//中断数量</span></span><br><span class="line">	<span class="type">void</span> __iomem *base = gic_data_dist_base(gic);  <span class="comment">//distributor基地址</span></span><br><span class="line"></span><br><span class="line">	writel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL);  <span class="comment">//关闭全局的中断传递</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set all global interrupts to this CPU only.</span></span><br><span class="line"><span class="comment">	 * 把所有中断都输出到这个cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpumask = gic_get_cpumask(gic);  <span class="comment">//获取所使用的cpu接口</span></span><br><span class="line">	cpumask |= cpumask &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	cpumask |= cpumask &lt;&lt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">4</span>)</span><br><span class="line">		writel_relaxed(cpumask, base + GIC_DIST_TARGET + i * <span class="number">4</span> / <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//默认中断配置</span></span><br><span class="line">	gic_dist_config(base, gic_irqs, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启全局的中断传递</span></span><br><span class="line">	writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">gic_dist_config</span><span class="params">(<span class="type">void</span> __iomem *base, <span class="type">int</span> gic_irqs,</span></span><br><span class="line"><span class="params">			    <span class="type">void</span> (*sync_access)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置所有中断为低电平触发</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">16</span>)</span><br><span class="line">		writel_relaxed(GICD_INT_ACTLOW_LVLTRIG,</span><br><span class="line">					base + GIC_DIST_CONFIG + i / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置默认优先级中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">4</span>)</span><br><span class="line">		writel_relaxed(GICD_INT_DEF_PRI_X4, base + GIC_DIST_PRI + i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关闭所有中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">32</span>)</span><br><span class="line">		writel_relaxed(GICD_INT_EN_CLR_X32,</span><br><span class="line">					base + GIC_DIST_ENABLE_CLEAR + i / <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sync_access)</span><br><span class="line">		sync_access();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-domain-ops"><a href="#2-2-domain-ops" class="headerlink" title="2.2 domain_ops"></a>2.2 domain_ops</h4><p>GIC作为一个中断控制器，必须要实现一个irq_domain对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> <span class="title">gic_irq_domain_hierarchy_ops</span> =</span> &#123;</span><br><span class="line">	.xlate = gic_irq_domain_xlate,  <span class="comment">//从设备树中获取硬件中断号</span></span><br><span class="line">	.alloc = gic_irq_domain_alloc,  <span class="comment">//为下一个中断控制器分配irq_domain</span></span><br><span class="line">	.<span class="built_in">free</span> = irq_domain_free_irqs_top,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从设备树中获取hw_irq</span></span><br><span class="line"><span class="comment">//interrupts = &lt;GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH&gt;;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_xlate</span><span class="params">(<span class="keyword">struct</span> irq_domain *d,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> device_node *controller,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> u32 *intspec, <span class="type">unsigned</span> <span class="type">int</span> intsize,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> *out_hwirq, <span class="type">unsigned</span> <span class="type">int</span> *out_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 跳过16个SGI eg 114+16*/</span></span><br><span class="line">	*out_hwirq = intspec[<span class="number">1</span>] + <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For SPIs, we need to add 16 more to get the GIC irq ID number */</span></span><br><span class="line">    <span class="comment">//GIC_SPI == 0，当是SPI时，需要+16 eg:114+16+16</span></span><br><span class="line">	<span class="keyword">if</span> (!intspec[<span class="number">0</span>])</span><br><span class="line">		*out_hwirq += <span class="number">16</span>;</span><br><span class="line">	<span class="comment">//中断触发类型</span></span><br><span class="line">	*out_type = intspec[<span class="number">2</span>] &amp; IRQ_TYPE_SENSE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为下一个中断控制器分配irq_domain</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_phandle_args</span> *<span class="title">irq_data</span> =</span> arg;</span><br><span class="line">	<span class="comment">//获取硬件中断号</span></span><br><span class="line">	ret = gic_irq_domain_xlate(domain, irq_data-&gt;np, irq_data-&gt;args,</span><br><span class="line">				   irq_data-&gt;args_count, &amp;hwirq, &amp;type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">//硬件中断号与虚拟中断号建立映射关系</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++)</span><br><span class="line">		gic_irq_domain_map(domain, virq + i, hwirq + i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//专属中断</span></span><br><span class="line">	<span class="keyword">if</span> (hw &lt; <span class="number">32</span>) &#123;</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic_chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		set_irq_flags(irq, IRQF_VALID | IRQF_NOAUTOEN);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//spi</span></span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic_chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-中断处理函数"><a href="#2-3-中断处理函数" class="headerlink" title="2.3 中断处理函数"></a>2.3 中断处理函数</h4><p>当cpu接收到GIC传来的中断信号时，会进入IRQ模式，跳转到中断向量表irq_handler处执行中断处理：</p>
<p>entry-armv.S</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro	irq_handler  <span class="comment">//定义irq_handler宏</span></span><br><span class="line">ldr	r1, =handle_arch_irq  <span class="comment">//handle_arch_irq 地址复制到r1</span></span><br><span class="line">mov	r0, sp  <span class="comment">//sp复制r0</span></span><br><span class="line">adr	lr, BSYM(<span class="number">9997f</span>)  </span><br><span class="line">ldr	pc, [r1]  <span class="comment">//跳转handle_arch_irq</span></span><br></pre></td></tr></table></figure>

<p>而set_handle_irq()函数就是将handle_arch_irq指向gic_handle_irq，也就是当中断产生时，gic_handle_irq会首先得到执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exception_irq_entry <span class="title function_">gic_handle_irq</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 irqstat, irqnr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> &amp;gic_data[<span class="number">0</span>];</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base = gic_data_cpu_base(gic);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//读取中断ID</span></span><br><span class="line">		irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);</span><br><span class="line">        <span class="comment">//掩码过滤掉reserved</span></span><br><span class="line">		irqnr = irqstat &amp; GICC_IAR_INT_ID_MASK;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (likely(irqnr &gt; <span class="number">15</span> &amp;&amp; irqnr &lt; <span class="number">1021</span>)) &#123;</span><br><span class="line">            <span class="comment">//将hw_irq转换成irq，并调用对应irq_desc的handler进行处理</span></span><br><span class="line">			handle_domain_irq(gic-&gt;domain, irqnr, regs);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (irqnr &lt; <span class="number">16</span>) &#123;</span><br><span class="line">			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">			handle_IPI(irqnr, regs);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断描述符什么时候进行分配？答案是在驱动程序调用 irq_of_parse_and_map()的时候：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">irq_of_parse_and_map()-&gt;</span><br><span class="line">  of_irq_parse_one()</span><br><span class="line">  irq_create_of_mapping()-&gt;</span><br><span class="line">    irq_create_mapping()-&gt;</span><br><span class="line">      irq_domain_alloc_descs()-&gt;</span><br><span class="line">        irq_alloc_descs()  <span class="comment">//分配描述符</span></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ARM/GICv2/" data-id="cmbcy7rgs0006t8mt8d0zaltx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_guide" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_guide/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.677Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]<br>lwip基础部分：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/114103768">lwip源码分析 之 内存池管理</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/114106606">lwip源码分析 之 内存堆</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111090269">lwip协议栈源码分析之pbuf</a></p>
</blockquote>
<p>lwip协议栈  网络层</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111658238">lwip源码分析 之 IP协议 数据输出</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111638632">lwip源码分析 之 IP协议 数据输入（一）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111655386">lwip源码分析 之 IP协议 数据输入 （二）</a></p>
</blockquote>
<p>lwip协议栈 传输层</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111492504">lwip源码分析 之 UDP协议</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111369134">lwip源码分析 之 TCP协议 数据输出 （一）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111403705">lwip源码分析之 TCP协议 数据输出（二）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111339566">lwip源码分析之 TCP协议 数据输入 （一）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111357509">lwip源码分析之 TCP协议 数据输入 （二）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111329821">lwip源码分析 之 TCP协议 数据输入 （三）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111396150">lwip源码解析之 TCP协议 定时器 tcp_slowtmr()；和tcp_fasttmr()；</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/111405712">lwip源码分析之 TCP层</a></p>
</blockquote>
<p>lwip协议栈 应用层</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/114048135">lwip源码分析 之 DHCP协议实现（一）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/114077628">lwip源码分析 之 DHCP协议 （二）</a></p>
</blockquote>
<p>移植lwip</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/113997147">一文搞定stm32移植LWIP及代码逻辑</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_guide/" data-id="cmbcy7rhw003et8mtdefgh2jb" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/cJSON/5.modify_copy_compare_cjson" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/cJSON/5.modify_copy_compare_cjson/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.675Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>cJSON系列：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110395913">零基础学习cJSON 源码详解与应用（一）如何学习cJSON</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110406265">零基础学习cJSON 源码详解与应用（二）创建json数据</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110475966">零基础学习cJSON 源码详解与应用 （三）cJSON_Print()；打印json
</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110481533">零基础学习cJSON 源码详解与应用 （四）cJSON_Parse()；解析json字符串</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44821644/article/details/110499109">零基础学习cJSON 源码详解与应用 （五）修改，复制，比较cjson</a></li>
</ul>
</blockquote>
<h2 id="一，cjson的其他函数"><a href="#一，cjson的其他函数" class="headerlink" title="一，cjson的其他函数"></a>一，cjson的其他函数</h2><p><strong>1,将新的item插入数组.</strong></p>
<blockquote>
<p>CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)</p>
</blockquote>
<p><strong>2,将item从cjson链表中的节点脱离，成功则返回脱离的item指针,注意脱离后的item的内存不会被释放，使用完后要记得释放内存。</strong></p>
<blockquote>
<p>CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);</p>
</blockquote>
<p><strong>3，使用replacement替换parent中的子节点中的item</strong></p>
<blockquote>
<p>CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);</p>
<p><strong>4,复制船新一个item，recurse表示是否有递归json对象，返回复制的新的item</strong><br>CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);</p>
<p><strong>5，比较两个json是否相同。case_sensitive表示是否大小写敏感</strong><br>CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);</p>
</blockquote>
<p><strong>6，将json字符串最小化，删除一些没有意义的特殊字符。</strong></p>
<blockquote>
<p>CJSON_PUBLIC(void) cJSON_Minify(char *json);</p>
</blockquote>
<h2 id="二，学习cJSON的收获"><a href="#二，学习cJSON的收获" class="headerlink" title="二，学习cJSON的收获"></a>二，学习cJSON的收获</h2><p>cjson简单易学，是一个非常适合新手的开源c项目。</p>
<h3 id="2-1-结构体的使用"><a href="#2-1-结构体的使用" class="headerlink" title="2.1 结构体的使用"></a>2.1 结构体的使用</h3><p>第一个想到的收获就是，如何构造一个结构体，可以灵活的表示他所对应的对象的特征。<br>在cjson中，以<code>键-值</code>对为最小单元来构造cjson结构体，体现了它的灵活性。一个优秀的数据结构能节省很多算法上的复杂度。</p>
<h3 id="2-2-链表的使用"><a href="#2-2-链表的使用" class="headerlink" title="2.2 链表的使用"></a>2.2 链表的使用</h3><p>增强了对链表使用的认识。</p>
<h3 id="2-3-字符串的处理"><a href="#2-3-字符串的处理" class="headerlink" title="2.3 字符串的处理"></a>2.3 字符串的处理</h3><p>是难点也是收获。特别是特殊字符，转义字符的转换，都是之前没考虑过的东西。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/cJSON/5.modify_copy_compare_cjson/" data-id="cmbcy7rhr002xt8mthzh397fy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-killer-blog/lwip/lwip_IP_data_in_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_IP_data_in_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.675Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="一-导读"><a href="#一-导读" class="headerlink" title="一 导读"></a>一 导读</h2><p>ip层是lwip代码的核心领域，它负责将以太网数据传递上来的数据整理并传递给传输层，或者将数据转发到其他网络。其中涉及ICMP,IGMP,DHCP等辅助协议。这章先介绍ip层的输入函数，搞清楚以太网将数据传递给ip层后，ip层如何将数据整理或转发。</p>
<h2 id="二，输入代码"><a href="#二，输入代码" class="headerlink" title="二，输入代码"></a>二，输入代码</h2><h3 id="1，接口函数"><a href="#1，接口函数" class="headerlink" title="1，接口函数"></a>1，接口函数</h3><p>网络接口接收到数据后，调用以下函数将数据传递给ip层。该函数将根据ipv4 or ipv6 调用真正的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以太网调用该函数</span></span><br><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">ip_input</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IP_HDR_GET_VERSION(p-&gt;payload) == <span class="number">6</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ip6_input(p, inp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip4_input(p, inp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERR_VAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，ipv4-输入"><a href="#2，ipv4-输入" class="headerlink" title="2，ipv4 输入"></a>2，ipv4 输入</h3><p><strong>该函数首先检查输入ip数据报的首部各项是否正确，再判断是否给本地的数据，最后将数据交给传输层。详细的逻辑看代码注释</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="comment">//pbuf的payload指向ip首部，inp：数据传入的接口</span></span><br><span class="line">ip4_input(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_hdr</span> *<span class="title">iphdr</span>;</span> <span class="comment">//输入分组的首部</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span>;</span>  </span><br><span class="line">  <span class="type">u16_t</span> iphdr_hlen;   <span class="comment">//首部长度</span></span><br><span class="line">  <span class="type">u16_t</span> iphdr_len;  <span class="comment">//总长度</span></span><br><span class="line">  <span class="type">int</span> check_ip_src = <span class="number">1</span>;	<span class="comment">//是否检查ip数据源地址</span></span><br><span class="line"></span><br><span class="line">  iphdr = (<span class="keyword">struct</span> ip_hdr *)p-&gt;payload;  <span class="comment">//获取ip首部</span></span><br><span class="line">  <span class="comment">//判断ip首部是否是ipv4</span></span><br><span class="line">  <span class="keyword">if</span> (IPH_V(iphdr) != <span class="number">4</span>) &#123;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iphdr_hlen = IPH_HL(iphdr); <span class="comment">//获取首部长度（字为单位）</span></span><br><span class="line">  iphdr_hlen *= <span class="number">4</span>;  <span class="comment">//将ip首部转换为字节单位</span></span><br><span class="line">  iphdr_len = lwip_ntohs(IPH_LEN(iphdr)); <span class="comment">//获取ip总字节数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//若pbuf的总长度大于ip首部标志的总长度，则修剪pbuf的长度（因为其中有ip的填充数据）</span></span><br><span class="line">  <span class="keyword">if</span> (iphdr_len &lt; p-&gt;tot_len) &#123;</span><br><span class="line">    pbuf_realloc(p, iphdr_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查ip首部是否错误：1，ip首部的数据必须放在一个pbuf中。2，ip首部长度符合？</span></span><br><span class="line">  <span class="keyword">if</span> ((iphdr_hlen &gt; p-&gt;len) || (iphdr_len &gt; p-&gt;tot_len) || (iphdr_hlen &lt; IP_HLEN)) &#123;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_CHECK_IP</span></span><br><span class="line"> 	<span class="comment">//检验ip分组的校验和</span></span><br><span class="line">  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inet_chksum(iphdr, iphdr_hlen) != <span class="number">0</span>) &#123; </span><br><span class="line">      pbuf_free(p);</span><br><span class="line">      <span class="keyword">return</span> ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将输入数据的ip源和目的地址复制到全局变量中，方便处理</span></span><br><span class="line">  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr-&gt;dest);</span><br><span class="line">  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr-&gt;src);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接下来确定网络接口netif</span></span><br><span class="line">  <span class="keyword">if</span> (ip4_addr_ismulticast(ip4_current_dest_addr())) &#123;</span><br><span class="line">    <span class="comment">//ip分组的目的地址是多播地址</span></span><br><span class="line">    <span class="comment">//TODO inp接口开启了IGMP且加入了该组播，则该分组就是给inp的</span></span><br><span class="line">    <span class="keyword">if</span> ((inp-&gt;flags &amp; NETIF_FLAG_IGMP) &amp;&amp; (igmp_lookfor_group(inp, ip4_current_dest_addr()))) &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="type">ip4_addr_t</span> allsystems;</span><br><span class="line">      IP4_ADDR(&amp;allsystems, <span class="number">224</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">//224.0.0.1代表本地子网所有主机；</span></span><br><span class="line">      <span class="keyword">if</span> (ip4_addr_cmp(ip4_current_dest_addr(), &amp;allsystems) &amp;&amp;</span><br><span class="line">          ip4_addr_isany(ip4_current_src_addr()))</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="comment">//报文dest = 224.0.0.1 ;src =0.0.0.0 说明是网络中的路由器发送的数据</span></span><br><span class="line">        check_ip_src = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      netif = inp;  <span class="comment">//inp就是ip分组对应的接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      netif = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//不是多播地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先判断接收到该分组的接口是否就是分组的目的地址，再从netif链表中遍历，确定netif</span></span><br><span class="line">    netif = inp;  </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">//接口已经使能且配置完成？</span></span><br><span class="line">      <span class="keyword">if</span> ((netif_is_up(netif)) &amp;&amp; (!ip4_addr_isany_val(*netif_ip4_addr(netif))))&#123;</span><br><span class="line">        <span class="comment">//若分组目的地址是 单播给该接口 或 广播地址 或是netif中的广播地址 则确定就是该netif接口</span></span><br><span class="line">        <span class="keyword">if</span> (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||</span><br><span class="line">            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)</span><br><span class="line">            ) &#123;</span><br><span class="line">          <span class="keyword">break</span>;  <span class="comment">//netif就是对应的接口，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_AUTOIP</span></span><br><span class="line">        <span class="comment">/* connections to link-local addresses must persist after changing</span></span><br><span class="line"><span class="comment">           the netif&#x27;s address (RFC3927 ch. 1.9) */</span></span><br><span class="line">        <span class="keyword">if</span> (autoip_accept_packet(netif, ip4_current_dest_addr())) &#123;</span><br><span class="line">          LWIP_DEBUGF(IP_DEBUG, (<span class="string">&quot;ip4_input: LLA packet accepted on interface %c%c\n&quot;</span>,</span><br><span class="line">              netif-&gt;name[<span class="number">0</span>], netif-&gt;name[<span class="number">1</span>]));</span><br><span class="line">          <span class="comment">/* break out of for loop */</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_AUTOIP */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        <span class="comment">//开始遍历netif链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF</span></span><br><span class="line">        <span class="comment">/* Packets sent to the loopback address must not be accepted on an</span></span><br><span class="line"><span class="comment">         * interface that does not have the loopback address assigned to it,</span></span><br><span class="line"><span class="comment">         * unless a non-loopback interface is used for loopback traffic. */</span></span><br><span class="line">        <span class="comment">//对于loopback 特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (ip4_addr_isloopback(ip4_current_dest_addr())) &#123;</span><br><span class="line">          netif = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        netif = netif_list; <span class="comment">//获取netif_list的第一个接口</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        netif = netif-&gt;next;  <span class="comment">//匹配下一个接口</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (netif == inp) &#123;</span><br><span class="line">        netif = netif-&gt;next;  <span class="comment">//跳过inp，因为之前已经匹配失败</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (netif != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IP_ACCEPT_LINK_LAYER_ADDRESSING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//dhcp消息：使用udp传输，dhcp服务端口67，客户端口68</span></span><br><span class="line">  <span class="comment">//之前的步骤匹配不到对应接口，判断是否是dhcp服务器发送的dhcp消息</span></span><br><span class="line">  <span class="keyword">if</span> (netif == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//该分组是udp数据</span></span><br><span class="line">    <span class="keyword">if</span> (IPH_PROTO(iphdr) == IP_PROTO_UDP) &#123; </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">udp_hdr</span> *<span class="title">udphdr</span> =</span> (<span class="keyword">struct</span> udp_hdr *)((<span class="type">u8_t</span> *)iphdr + iphdr_hlen);  <span class="comment">//获取udp首部</span></span><br><span class="line">      <span class="comment">//且udp目的端口是68，说明这时服务器发送的dhcp消息</span></span><br><span class="line">      <span class="keyword">if</span> (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr-&gt;dest)) &#123;</span><br><span class="line">        netif = inp;</span><br><span class="line">        check_ip_src = <span class="number">0</span>; <span class="comment">//不检查分组的源地址</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查源地址合法性</span></span><br><span class="line">  <span class="keyword">if</span> (check_ip_src &amp;&amp; !ip4_addr_isany_val(*ip4_current_src_addr())) <span class="comment">//源地址不是0.0.0.0；正常的ip数据</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//若数据源地址是广播数据，不合法</span></span><br><span class="line">    <span class="keyword">if</span> ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||</span><br><span class="line">        (ip4_addr_ismulticast(ip4_current_src_addr()))) &#123;</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">      <span class="keyword">return</span> ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//没有对应的接口，分组不是给本地的，转发</span></span><br><span class="line">  <span class="keyword">if</span> (netif == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">//不是广播的数据才能转发</span></span><br><span class="line">    <span class="keyword">if</span> (!ip4_addr_isbroadcast(ip4_current_dest_addr(), inp)) &#123;</span><br><span class="line">      ip4_forward(p, iphdr, inp); <span class="comment">//转发分组</span></span><br><span class="line">    &#125; </span><br><span class="line">    pbuf_free(p); <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//到这，说明数据报是给本地的</span></span><br><span class="line">  <span class="comment">//数据包是否是一个分片？（根据MF标志和分片偏移判断）</span></span><br><span class="line">  <span class="keyword">if</span> ((IPH_OFFSET(iphdr) &amp; PP_HTONS(IP_OFFMASK | IP_MF)) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!嵌入式互联网中的数据量较小，一般不会有数据分片</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IP_REASSEMBLY <span class="comment">/* packet fragment reassembly code present? */</span></span></span><br><span class="line">    p = ip4_reass(p); <span class="comment">//重组ip分片</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    iphdr = (<span class="keyword">struct</span> ip_hdr *)p-&gt;payload;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    pbuf_free(p); <span class="comment">//不重装ip分组</span></span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新全局变量</span></span><br><span class="line">  ip_data.current_netif = netif;</span><br><span class="line">  ip_data.current_input_netif = inp;</span><br><span class="line">  ip_data.current_ip4_header = iphdr;</span><br><span class="line">  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_RAW</span></span><br><span class="line">  <span class="comment">/* raw input did not eat the packet? */</span></span><br><span class="line">  <span class="keyword">if</span> (raw_input(p, inp) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_RAW */</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//移动payload后移到上层数据首部</span></span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)iphdr_hlen); <span class="comment">/* Move to payload, no check necessary. */</span></span><br><span class="line">    <span class="comment">//传递给上层协议</span></span><br><span class="line">    <span class="keyword">switch</span> (IPH_PROTO(iphdr)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_UDP</span></span><br><span class="line">    <span class="keyword">case</span> IP_PROTO_UDP:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_UDPLITE</span></span><br><span class="line">    <span class="keyword">case</span> IP_PROTO_UDPLITE:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_UDPLITE */</span></span></span><br><span class="line">      udp_input(p, inp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_UDP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">    <span class="keyword">case</span> IP_PROTO_TCP:</span><br><span class="line"></span><br><span class="line">      tcp_input(p, inp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_ICMP</span></span><br><span class="line">    <span class="keyword">case</span> IP_PROTO_ICMP:</span><br><span class="line">     </span><br><span class="line">      icmp_input(p, inp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_ICMP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IGMP</span></span><br><span class="line">    <span class="keyword">case</span> IP_PROTO_IGMP:</span><br><span class="line">      igmp_input(p, inp, ip4_current_dest_addr());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IGMP */</span></span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_ICMP</span></span><br><span class="line">	  <span class="comment">//发送icmp协议不可达报文，除非对方是个广播</span></span><br><span class="line">      <span class="keyword">if</span> (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &amp;&amp;</span><br><span class="line">          !ip4_addr_ismulticast(ip4_current_dest_addr())) &#123;</span><br><span class="line">        pbuf_header_force(p, iphdr_hlen); <span class="comment">//将payload重新指向ip首部</span></span><br><span class="line">        p-&gt;payload = iphdr;</span><br><span class="line">        icmp_dest_unreach(p, ICMP_DUR_PROTO);<span class="comment">//发送协议不可达报文</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_ICMP */</span></span></span><br><span class="line">      pbuf_free(p);	<span class="comment">//最后释放报文</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* @todo: this is not really necessary... */</span></span><br><span class="line">  ip_data.current_netif = <span class="literal">NULL</span>;</span><br><span class="line">  ip_data.current_input_netif = <span class="literal">NULL</span>;</span><br><span class="line">  ip_data.current_ip4_header = <span class="literal">NULL</span>;</span><br><span class="line">  ip_data.current_ip_header_tot_len = <span class="number">0</span>;</span><br><span class="line">  ip4_addr_set_any(ip4_current_src_addr());</span><br><span class="line">  ip4_addr_set_any(ip4_current_dest_addr());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3，ipv6-输入"><a href="#3，ipv6-输入" class="headerlink" title="3，ipv6 输入"></a>3，ipv6 输入</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_IP_data_in_1/" data-id="cmbcy7rht0031t8mthbjg8jst" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
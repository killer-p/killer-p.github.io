<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Linux中断系统（三）中断控制器一、irq_chip_generic在中断系统的软硬件实现中，中断控制器是最核心的部分。多个中断信号输入到控制器，控制器管理这些中断信号的优先级、开关、触发方式，并输出一个中断信号给下一级处理。例如通用中断控制器GIC，在芯片中负责管理所有的外设中断，并将中断信号传递给CPU。按键按下，GPIO1控制器产生中断信号到GIC中断控制器，条件合理时，GIC将产生中断信">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/05/31/killer-blog/Linux/Linux_isr_3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Linux中断系统（三）中断控制器一、irq_chip_generic在中断系统的软硬件实现中，中断控制器是最核心的部分。多个中断信号输入到控制器，控制器管理这些中断信号的优先级、开关、触发方式，并输出一个中断信号给下一级处理。例如通用中断控制器GIC，在芯片中负责管理所有的外设中断，并将中断信号传递给CPU。按键按下，GPIO1控制器产生中断信号到GIC中断控制器，条件合理时，GIC将产生中断信">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-31T17:16:20.235Z">
<meta property="article:modified_time" content="2025-06-01T00:19:46.385Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/Linux/Linux_isr_3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/Linux/Linux_isr_3/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T17:16:20.235Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux中断系统（三）中断控制器"><a href="#Linux中断系统（三）中断控制器" class="headerlink" title="Linux中断系统（三）中断控制器"></a>Linux中断系统（三）中断控制器</h1><h2 id="一、irq-chip-generic"><a href="#一、irq-chip-generic" class="headerlink" title="一、irq_chip_generic"></a>一、irq_chip_generic</h2><p>在中断系统的软硬件实现中，中断控制器是最核心的部分。多个中断信号输入到控制器，控制器管理这些中断信号的优先级、开关、触发方式，并输出一个中断信号给下一级处理。<br>例如通用中断控制器GIC，在芯片中负责管理所有的外设中断，并将中断信号传递给CPU。按键按下，GPIO1控制器产生中断信号到GIC中断控制器，条件合理时，GIC将产生中断信号给CPU。CPU需要通过一层层的读取中断控制器，来确定最终的中断源，也就是GPIO1_2对应的按键中断。</p>
<p>另外像GPIO控制器、IIC控制器、UART控制器等，这些控制器也能实现中断的控制功能，都可以设置、使能、产生中断信号，这些也是中断控制器，在linux中用<code>srruct irq_chip_generic</code>来抽象描述有类似功能的中断控制器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_generic</span> &#123;</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="type">void</span> __iomem		*reg_base;  <span class="comment">//中断芯片虚拟基地址</span></span><br><span class="line">	u32			(*reg_readl)(<span class="type">void</span> __iomem *addr);  <span class="comment">//读写寄存器的函数</span></span><br><span class="line">	<span class="type">void</span>			(*reg_writel)(u32 val, <span class="type">void</span> __iomem *addr);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_base;  <span class="comment">//中断起始号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_cnt;  <span class="comment">//中断数量</span></span><br><span class="line">	u32			mask_cache;  <span class="comment">//一些寄存器的缓存</span></span><br><span class="line">	u32			type_cache;</span><br><span class="line">	u32			polarity_cache;</span><br><span class="line">	u32			wake_enabled;</span><br><span class="line">	u32			wake_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		num_ct;  <span class="comment">//chip_types的数量</span></span><br><span class="line">	<span class="type">void</span>			*private;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		installed;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		unused;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">domain</span>;</span>  <span class="comment">//管理硬件中断号到软件中断号的映射</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span>	<span class="title">chip_types</span>[0];</span>  <span class="comment">//保存中断寄存器、中断处理函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用中断芯片就是需要去读写其寄存器来配置中断，这可以用两个结构体来描述。<br><code>struct irq_chip_type</code> 和 <code>struct irq_chip</code></p>
<p>一般来说，一个<code>irq_chip_generic</code> 就有一个<code> irq_chip_type</code>，描述了中断芯片的功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		<span class="title">chip</span>;</span>  <span class="comment">//控制器的回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_regs</span>	<span class="title">regs</span>;</span>  <span class="comment">//寄存器的偏移地址</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handler;  <span class="comment">//中断流处理函数</span></span><br><span class="line">	u32			type;</span><br><span class="line">	u32			mask_cache_priv;</span><br><span class="line">	u32			*mask_cache;  <span class="comment">//指向cached mask register</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当初始化一个通用中断控制器时，我们设置了寄存器信息，回调函数，中断流处理函数。当中断产生时，中断流处理函数会执行，获取具体外设的中断号，去执行对应的irqaction。并调用中断芯片提供的api接口，去设置寄存器的ack位，响应中断。</p>
<p>这里的芯片api接口，就是由<code>irq_chip</code>结构体来描述的，这个结构体定义了许多接口函数，驱动需要根据实际情况，按需实现函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_chip - hardware interrupt chip descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @name:		name for /proc/interrupts</span></span><br><span class="line"><span class="comment"> * @irq_startup:	start up the interrupt (defaults to -&gt;enable if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_shutdown:	shut down the interrupt (defaults to -&gt;disable if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_enable:		enable the interrupt (defaults to chip-&gt;unmask if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_disable:	disable the interrupt</span></span><br><span class="line"><span class="comment"> * @irq_ack:		start of a new interrupt</span></span><br><span class="line"><span class="comment"> * @irq_mask:		mask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_mask_ack:	ack and mask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_unmask:		unmask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_eoi:		end of interrupt</span></span><br><span class="line"><span class="comment"> * @irq_set_affinity:	set the CPU affinity on SMP machines</span></span><br><span class="line"><span class="comment"> * @irq_retrigger:	resend an IRQ to the CPU</span></span><br><span class="line"><span class="comment"> * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ</span></span><br><span class="line"><span class="comment"> * @irq_set_wake:	enable/disable power-management wake-on of an IRQ</span></span><br><span class="line"><span class="comment"> * @irq_bus_lock:	function to lock access to slow bus (i2c) chips</span></span><br><span class="line"><span class="comment"> * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips</span></span><br><span class="line"><span class="comment"> * @irq_cpu_online:	configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment"> * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment"> * @irq_suspend:	function called from core code on suspend once per chip</span></span><br><span class="line"><span class="comment"> * @irq_resume:		function called from core code on resume once per chip</span></span><br><span class="line"><span class="comment"> * @irq_pm_shutdown:	function called from core code on shutdown once per chip</span></span><br><span class="line"><span class="comment"> * @irq_calc_mask:	Optional function to set irq_data.mask for special cases</span></span><br><span class="line"><span class="comment"> * @irq_print_chip:	optional to print special chip info in show_interrupts</span></span><br><span class="line"><span class="comment"> * @irq_request_resources:	optional to request resources before calling</span></span><br><span class="line"><span class="comment"> *				any other callback related to this irq</span></span><br><span class="line"><span class="comment"> * @irq_release_resources:	optional to release resources acquired with</span></span><br><span class="line"><span class="comment"> *				irq_request_resources</span></span><br><span class="line"><span class="comment"> * @irq_compose_msi_msg:	optional to compose message content for MSI</span></span><br><span class="line"><span class="comment"> * @irq_write_msi_msg:	optional to write message content for MSI</span></span><br><span class="line"><span class="comment"> * @irq_get_irqchip_state:	return the internal state of an interrupt</span></span><br><span class="line"><span class="comment"> * @irq_set_irqchip_state:	set the internal state of a interrupt</span></span><br><span class="line"><span class="comment"> * @flags:		chip specific flags</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>	<span class="params">(*irq_startup)</span><span class="params">(<span class="keyword">struct</span> irq_data *data)</span>;  </span><br><span class="line">	<span class="type">void</span>		(*irq_shutdown)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_enable)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_disable)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_ack)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_mask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_mask_ack)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_unmask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_eoi)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		(*irq_set_affinity)(<span class="keyword">struct</span> irq_data *data, <span class="type">const</span> <span class="keyword">struct</span> cpumask *dest, <span class="type">bool</span> force);</span><br><span class="line">	<span class="type">int</span>		(*irq_retrigger)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">int</span>		(*irq_set_type)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> flow_type);</span><br><span class="line">	<span class="type">int</span>		(*irq_set_wake)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> on);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_bus_lock)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_bus_sync_unlock)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_cpu_online)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_cpu_offline)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_suspend)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_resume)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_pm_shutdown)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_calc_mask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_print_chip)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> seq_file *p);</span><br><span class="line">	<span class="type">int</span>		(*irq_request_resources)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_release_resources)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_compose_msi_msg)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> msi_msg *msg);</span><br><span class="line">	<span class="type">void</span>		(*irq_write_msi_msg)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> msi_msg *msg);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		(*irq_get_irqchip_state)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="type">bool</span> *state);</span><br><span class="line">	<span class="type">int</span>		(*irq_set_irqchip_state)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="type">bool</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>irq_chip</code>这些接口函数，可以利用linux中提供的一些实现：<br>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		<span class="title">chip</span></span></span><br><span class="line"><span class="class"> 	<span class="title">chip</span>.<span class="title">irq_ack</span> =</span> irq_gc_ack_set_bit;</span><br><span class="line">	chip.irq_mask = irq_gc_mask_clr_bit;</span><br><span class="line">	chip.irq_unmask = irq_gc_mask_set_bit;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//ack指定中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_gc_ack_set_bit</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//通过irq_data获取中断芯片对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_generic</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span> *<span class="title">ct</span> =</span> irq_data_get_chip_type(d);</span><br><span class="line">	u32 mask = d-&gt;mask;</span><br><span class="line"></span><br><span class="line">	irq_gc_lock(gc);</span><br><span class="line">	<span class="comment">//将mask的值写入寄存器regs.ack</span></span><br><span class="line">	irq_reg_writel(gc, mask, ct-&gt;regs.ack);</span><br><span class="line">	irq_gc_unlock(gc);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(irq_gc_ack_set_bit);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//清除mask寄存器的某个位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_gc_mask_clr_bit</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_generic</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span> *<span class="title">ct</span> =</span> irq_data_get_chip_type(d);</span><br><span class="line">	u32 mask = d-&gt;mask;</span><br><span class="line"></span><br><span class="line">	irq_gc_lock(gc);</span><br><span class="line">	*ct-&gt;mask_cache &amp;= ~mask;</span><br><span class="line">	irq_reg_writel(gc, *ct-&gt;mask_cache, ct-&gt;regs.mask);</span><br><span class="line">	irq_gc_unlock(gc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置mask寄存器的某个位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_gc_mask_set_bit</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_generic</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span> *<span class="title">ct</span> =</span> irq_data_get_chip_type(d);</span><br><span class="line">	u32 mask = d-&gt;mask;</span><br><span class="line"></span><br><span class="line">	irq_gc_lock(gc);</span><br><span class="line">	*ct-&gt;mask_cache |= mask;</span><br><span class="line">	irq_reg_writel(gc, *ct-&gt;mask_cache, ct-&gt;regs.mask);</span><br><span class="line">	irq_gc_unlock(gc);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(irq_gc_mask_set_bit);</span><br></pre></td></tr></table></figure>

<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>linux提供 <code>irq_alloc_generic_chip</code> 和 <code>irq_setup_generic_chip</code> 来初始化generic_chip：</p>
<p>irq_alloc_generic_chip，初始化需要提供参数：</p>
<ol>
<li>name：irq_chip的名称</li>
<li>num_cnt：chip_type的数量，一般是1</li>
<li>irq_base：中断号</li>
<li>reg_base：寄存器基地址</li>
<li>handler：中断流处理函数，即中断控制器响应自身中断的逻辑<br>该函数主要实现了初始化 irq_chip_generic 对象，设置成员变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> irq_chip_generic *<span class="title function_">irq_alloc_generic_chip</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> num_ct, <span class="type">unsigned</span> <span class="type">int</span> irq_base,<span class="type">void</span> __iomem *reg_base, <span class="type">irq_flow_handler_t</span> handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_generic</span> *<span class="title">gc</span>;</span></span><br><span class="line">	<span class="comment">//计算需要的内存 irq_chip_type 的影响</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sz = <span class="keyword">sizeof</span>(*gc) + num_ct * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> irq_chip_type);</span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	gc = kzalloc(sz, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (gc) &#123;</span><br><span class="line">		<span class="comment">//初始化结构体</span></span><br><span class="line">		irq_init_generic_chip(gc, name, num_ct, irq_base, reg_base,</span><br><span class="line">				      handler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很简单，设置generic_chip结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_init_generic_chip</span><span class="params">(<span class="keyword">struct</span> irq_chip_generic *gc, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		      <span class="type">int</span> num_ct, <span class="type">unsigned</span> <span class="type">int</span> irq_base,</span></span><br><span class="line"><span class="params">		      <span class="type">void</span> __iomem *reg_base, <span class="type">irq_flow_handler_t</span> handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	raw_spin_lock_init(&amp;gc-&gt;lock);</span><br><span class="line">	gc-&gt;num_ct = num_ct;</span><br><span class="line">	gc-&gt;irq_base = irq_base;</span><br><span class="line">	gc-&gt;reg_base = reg_base;</span><br><span class="line">	gc-&gt;chip_types-&gt;chip.name = name;</span><br><span class="line">	gc-&gt;chip_types-&gt;handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>irq_setup_generic_chip</code>用于建立&#x2F;使能控制器中的中断信号。msk参数以位掩码的形式表示哪些中断被使能。例如0b1100，表示 irq为gc-&gt;irq_base+3，gc-&gt;irq_base+4 的中断信号被使能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据配置设置中断芯片下所有的irqdesc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_setup_generic_chip</span><span class="params">(<span class="keyword">struct</span> irq_chip_generic *gc, u32 msk,</span></span><br><span class="line"><span class="params">			    <span class="keyword">enum</span> irq_gc_flags flags, <span class="type">unsigned</span> <span class="type">int</span> clr,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span> *<span class="title">ct</span> =</span> gc-&gt;chip_types;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> =</span> &amp;ct-&gt;chip;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//把gc添加到全局的gc链表</span></span><br><span class="line">	raw_spin_lock(&amp;gc_lock);</span><br><span class="line">	list_add_tail(&amp;gc-&gt;<span class="built_in">list</span>, &amp;gc_list);</span><br><span class="line">	raw_spin_unlock(&amp;gc_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据flags初始化mask_cache</span></span><br><span class="line">	irq_gc_init_mask_cache(gc, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历整个mask的bits，i表示的是irq number虚拟中断号</span></span><br><span class="line">	<span class="keyword">for</span> (i = gc-&gt;irq_base; msk; msk &gt;&gt;= <span class="number">1</span>, i++) &#123;</span><br><span class="line">		<span class="comment">//若mask上的bit未使能，则跳过</span></span><br><span class="line">		<span class="keyword">if</span> (!(msk &amp; <span class="number">0x01</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; IRQ_GC_INIT_NESTED_LOCK)</span><br><span class="line">			irq_set_lockdep_class(i, &amp;irq_nested_lock_class);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; IRQ_GC_NO_MASK)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">d</span> =</span> irq_get_irq_data(i);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (chip-&gt;irq_calc_mask)</span><br><span class="line">				chip-&gt;irq_calc_mask(d);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				d-&gt;mask = <span class="number">1</span> &lt;&lt; (i - gc-&gt;irq_base);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//设置对应irqdesc的irq_chip和中断处理函数、chip_data</span></span><br><span class="line">		irq_set_chip_and_handler(i, chip, ct-&gt;handler);</span><br><span class="line">		irq_set_chip_data(i, gc);</span><br><span class="line">		irq_modify_status(i, clr, <span class="built_in">set</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算实际使用的irq数量</span></span><br><span class="line">	gc-&gt;irq_cnt = i - gc-&gt;irq_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//设置mask寄存器的某个位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_gc_mask_set_bit</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//清除mask寄存器的某个位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_gc_mask_clr_bit</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ack指定中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_gc_ack_set_bit</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="二、irq-domain"><a href="#二、irq-domain" class="headerlink" title="二、irq_domain"></a>二、irq_domain</h2><blockquote>
<p>中断控制器是负责输入多个中断信号，管理这些中断信号的优先级、开关、触发方式，并输出一个中断信号给下一级处理。<br>例如通用中断控制器GIC，在芯片中负责管理所有的外设中断，并将中断信号传递给CPU。按键按下，GPIO1控制器产生中断信号到GIC中断控制器，条件合理时，GIC将产生中断信号给CPU。CPU需要通过一层层的读取中断控制器，来确定最终的中断源，也就是GPIO1_2对应的按键中断。</p>
</blockquote>
<p>中断信号一般由这样的过程构成：</p>
<ol>
<li>中断源，比如按键</li>
<li>外设控制器，比如GPIO控制器</li>
<li>GIC，通用中断控制器</li>
<li>CPU</li>
</ol>
<p>对应在软件上，中断的一般处理流程如下：</p>
<ol>
<li>CPU产生IRQ中断，跳转到IRQ_Handler</li>
<li>IRQ_Handler中读取GIC状态寄存器，判断是哪个具体的外设产生的中断，跳转到GPIOx_handler</li>
<li>GPIOx_handler：读取该GPIO控制器的寄存器，判断哪个IO产生的中断，拿到对应的irqdesc</li>
<li>执行irqdesc中驱动设置的中断回调函数irqaction</li>
</ol>
<p>软件的中断处理就是硬件中断信号的逆过程。软件需要通过一层层地读取中断控制器的寄存器来确定具体的中断源。<br>这里有一个问题：在确定中断源是GPIO1_2后，如何找到我们之前注册的按键中断处理函数？</p>
<p>答案就是中断号。我们可以通过中断号来找到irqdesc，irqdesc对象中就有中断处理函数。</p>
<p>但是还有一个问题，就是在一个系统中，hw_irq（硬件中断号）并不是唯一的（因为GIC支持从0-1020的中断号，而GPIO1控制器支持0-31的中断号，GPIO2控制器也支持0-31的中断号），而在linux内核中，每一个irqdesc都必须由唯一的irq来区别。</p>
<p><strong>linux的解决方法是：将一个中断控制器管理的所有中断的集合称为domain（领域、范围），一个中断控制器有一个domain，领域内的每个中断号唯一。domain的作用是将hw_irq转换成linux内核中唯一的irq，这个irq称为虚拟中断号。转换的方法由开发者实现。</strong></p>
<p>这样，在同一个domain下，他们的hw_irq肯定不同；hw_irq相同时，所属的domain不同，转换的方法也不同，得到的irq也就不一样，这样就能保证irq是唯一的。</p>
<p>linux中使用<code>irq_domain</code>抽象上述的场景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_domain - Hardware interrupt number translation object</span></span><br><span class="line"><span class="comment"> * @link: Element in global irq_domain list.</span></span><br><span class="line"><span class="comment"> * @name: Name of interrupt domain</span></span><br><span class="line"><span class="comment"> * @ops: pointer to irq_domain methods</span></span><br><span class="line"><span class="comment"> * @host_data: private data pointer for use by owner.  Not touched by irq_domain</span></span><br><span class="line"><span class="comment"> *             core code.</span></span><br><span class="line"><span class="comment"> * @flags: host per irq_domain flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Optional elements</span></span><br><span class="line"><span class="comment"> * @of_node: Pointer to device tree nodes associated with the irq_domain. Used</span></span><br><span class="line"><span class="comment"> *           when decoding device tree interrupt specifiers.</span></span><br><span class="line"><span class="comment"> * @gc: Pointer to a list of generic chips. There is a helper function for</span></span><br><span class="line"><span class="comment"> *      setting up one or more generic chips for interrupt controllers</span></span><br><span class="line"><span class="comment"> *      drivers using the generic chip library which uses this pointer.</span></span><br><span class="line"><span class="comment"> * @parent: Pointer to parent irq_domain to support hierarchy irq_domains</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Revmap data, used internally by irq_domain</span></span><br><span class="line"><span class="comment"> * @revmap_direct_max_irq: The largest hwirq that can be set for controllers that</span></span><br><span class="line"><span class="comment"> *                         support direct mapping</span></span><br><span class="line"><span class="comment"> * @revmap_size: Size of the linear map table @linear_revmap[]</span></span><br><span class="line"><span class="comment"> * @revmap_tree: Radix map tree for hwirqs that don&#x27;t fit in the linear map</span></span><br><span class="line"><span class="comment"> * @linear_revmap: Linear table of hwirq-&gt;virq reverse mappings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span>    <span class="comment">//连接到全局domain表</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>;</span>    <span class="comment">//domain的操作接口</span></span><br><span class="line">	<span class="type">void</span> *host_data;	<span class="comment">//私有数据</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Optional data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span>	<span class="comment">//对应的设备树节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_chip_generic</span> *<span class="title">gc</span>;</span>	<span class="comment">//对中断控制器的抽象</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">parent</span>;</span>	<span class="comment">//上一级的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reverse map data. The linear map gets appended to the irq_domain */</span></span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq_max;			<span class="comment">//domain下的中断信号数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> revmap_direct_max_irq;	<span class="comment">//数组的最大中断号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> revmap_size;	<span class="comment">//linear_revmap[]的长度</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">revmap_tree</span>;</span>	<span class="comment">//存放映射关系的树</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> linear_revmap[];	<span class="comment">//存放映射关系的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要关注的成员有：</p>
<ul>
<li>const struct irq_domain_ops* ops：domain的操作接口</li>
<li>irq_hw_number_t hwirq_max：domain下的中断信号数量</li>
<li>struct radix_tree_root revmap_tree：存放映射关系的树</li>
<li>unsigned int linear_revmap[]：存放映射关系的数组</li>
</ul>
<p>domain的主要功能是hw_irq到irq的转换，就需要有数据结构存放映射关系。有radix_tree 和数组两种存储方法。比较重点的是irq_domain_ops：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//irq_domain的所有功能在此实现，每个函数需要根据中断控制器具体实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*match)(<span class="keyword">struct</span> irq_domain *d, <span class="keyword">struct</span> device_node *node);  <span class="comment">//匹配一个中断控制器到irq_domain</span></span><br><span class="line">	<span class="type">int</span> (*<span class="built_in">map</span>)(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> virq, <span class="type">irq_hw_number_t</span> hw);  <span class="comment">//创建或更新硬件中断号和虚拟中断号的映射</span></span><br><span class="line">	<span class="type">void</span> (*unmap)(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> virq);  <span class="comment">//取消映射</span></span><br><span class="line">	<span class="comment">//解析出设备树中的硬件中断号和中断类型</span></span><br><span class="line">	<span class="type">int</span> (*xlate)(<span class="keyword">struct</span> irq_domain *d, <span class="keyword">struct</span> device_node *node,  </span><br><span class="line">		     <span class="type">const</span> u32 *intspec, <span class="type">unsigned</span> <span class="type">int</span> intsize,</span><br><span class="line">		     <span class="type">unsigned</span> <span class="type">long</span> *out_hwirq, <span class="type">unsigned</span> <span class="type">int</span> *out_type);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="comment">/* 支持中断控制器级联 */</span></span><br><span class="line">	<span class="comment">//在当前irqdomain下分配一个新的子domain</span></span><br><span class="line">	<span class="type">int</span> (*alloc)(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> virq,</span><br><span class="line">		     <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg);</span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> virq,</span><br><span class="line">		     <span class="type">unsigned</span> <span class="type">int</span> nr_irqs);</span><br><span class="line">	<span class="comment">//使能domain</span></span><br><span class="line">	<span class="type">void</span> (*activate)(<span class="keyword">struct</span> irq_domain *d, <span class="keyword">struct</span> irq_data *irq_data);</span><br><span class="line">	<span class="type">void</span> (*deactivate)(<span class="keyword">struct</span> irq_domain *d, <span class="keyword">struct</span> irq_data *irq_data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="api-1"><a href="#api-1" class="headerlink" title="api"></a>api</h5><p>irq_domain.c 中提供函数 <code>__irq_domain_add</code> 实现创建和添加irq_domain的功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __irq_domain_add() - Allocate a new irq_domain data structure</span></span><br><span class="line"><span class="comment"> * @of_node: optional device-tree node of the interrupt controller</span></span><br><span class="line"><span class="comment"> * @size: Size of linear map; 0 for radix mapping only</span></span><br><span class="line"><span class="comment"> * @hwirq_max: Maximum number of interrupts supported by controller</span></span><br><span class="line"><span class="comment"> * @direct_max: Maximum value of direct maps; Use ~0 for no limit; 0 for no</span></span><br><span class="line"><span class="comment"> *              direct mapping</span></span><br><span class="line"><span class="comment"> * @ops: domain callbacks</span></span><br><span class="line"><span class="comment"> * @host_data: Controller private data pointer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocates and initialize and irq_domain structure.</span></span><br><span class="line"><span class="comment"> * Returns pointer to IRQ domain, or NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *__<span class="title">irq_domain_add</span>(<span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>, <span class="title">int</span> <span class="title">size</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">irq_hw_number_t</span> <span class="title">hwirq_max</span>, <span class="title">int</span> <span class="title">direct_max</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">void</span> *<span class="title">host_data</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为irq_domain的linear_revmap[]数组大小和size一样，所以需要额外的size </span></span><br><span class="line">	domain = kzalloc_node(<span class="keyword">sizeof</span>(*domain) + (<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) * size),</span><br><span class="line">			      GFP_KERNEL, of_node_to_nid(of_node));</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!domain))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill structure 填充对象*/</span></span><br><span class="line">	INIT_RADIX_TREE(&amp;domain-&gt;revmap_tree, GFP_KERNEL);</span><br><span class="line">	domain-&gt;ops = ops;</span><br><span class="line">	domain-&gt;host_data = host_data;</span><br><span class="line">	domain-&gt;of_node = of_node_get(of_node);</span><br><span class="line">	domain-&gt;hwirq_max = hwirq_max;  <span class="comment">//该domain下的中断信号数量</span></span><br><span class="line">	domain-&gt;revmap_size = size;  <span class="comment">//数组的大小</span></span><br><span class="line">	domain-&gt;revmap_direct_max_irq = direct_max;</span><br><span class="line">	irq_domain_check_hierarchy(domain);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//所住全局链表irq_domain_list</span></span><br><span class="line">	mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">	<span class="comment">//将domain插入链表</span></span><br><span class="line">	list_add(&amp;domain-&gt;link, &amp;irq_domain_list);</span><br><span class="line">	mutex_unlock(&amp;irq_domain_mutex);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Added domain %s\n&quot;</span>, domain-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__irq_domain_add);</span><br></pre></td></tr></table></figure>


<p>irq_domain.c 中提供函数 <code>irq_domain_associate</code> 实现建立irq和hw_irq的映射关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立irq和hw_irq的映射关系</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_domain_associate</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_hw_number_t</span> hwirq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//由irq_data来代表irq进行映射</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">irq_data</span> =</span> irq_get_irq_data(virq);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN(hwirq &gt;= domain-&gt;hwirq_max,</span><br><span class="line">		 <span class="string">&quot;error: hwirq 0x%x is too large for %s\n&quot;</span>, (<span class="type">int</span>)hwirq, domain-&gt;name))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (WARN(!irq_data, <span class="string">&quot;error: virq%i is not allocated&quot;</span>, virq))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (WARN(irq_data-&gt;domain, <span class="string">&quot;error: virq%i is already associated&quot;</span>, virq))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">	<span class="comment">//初始化irq_data</span></span><br><span class="line">	irq_data-&gt;hwirq = hwirq;</span><br><span class="line">	irq_data-&gt;domain = domain;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (domain-&gt;ops-&gt;<span class="built_in">map</span>) &#123;</span><br><span class="line">		<span class="comment">//建立映射关系</span></span><br><span class="line">		ret = domain-&gt;ops-&gt;<span class="built_in">map</span>(domain, virq, hwirq);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If map() returns -EPERM, this interrupt is protected</span></span><br><span class="line"><span class="comment">			 * by the firmware or some other service and shall not</span></span><br><span class="line"><span class="comment">			 * be mapped. Don&#x27;t bother telling the user about it.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (ret != -EPERM) &#123;</span><br><span class="line">				pr_info(<span class="string">&quot;%s didn&#x27;t like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\n&quot;</span>,</span><br><span class="line">				       domain-&gt;name, hwirq, virq, ret);</span><br><span class="line">			&#125;</span><br><span class="line">			irq_data-&gt;domain = <span class="literal">NULL</span>;</span><br><span class="line">			irq_data-&gt;hwirq = <span class="number">0</span>;</span><br><span class="line">			mutex_unlock(&amp;irq_domain_mutex);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If not already assigned, give the domain the chip&#x27;s name */</span></span><br><span class="line">		<span class="keyword">if</span> (!domain-&gt;name &amp;&amp; irq_data-&gt;chip)</span><br><span class="line">			domain-&gt;name = irq_data-&gt;chip-&gt;name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保存映射关系</span></span><br><span class="line">	<span class="comment">//线性映射时hwirq&lt;revmap_size</span></span><br><span class="line">	<span class="keyword">if</span> (hwirq &lt; domain-&gt;revmap_size) &#123;</span><br><span class="line">		<span class="comment">//保存到linear_revmap数组</span></span><br><span class="line">		domain-&gt;linear_revmap[hwirq] = virq;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//树映射时，revmap_size==0，保存到树</span></span><br><span class="line">		mutex_lock(&amp;revmap_trees_mutex);</span><br><span class="line">		radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);</span><br><span class="line">		mutex_unlock(&amp;revmap_trees_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;irq_domain_mutex);</span><br><span class="line">	<span class="comment">//设置irqdesc的状态</span></span><br><span class="line">	irq_clear_status_flags(virq, IRQ_NOREQUEST);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(irq_domain_associate);</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用设备树中的信息来建立映射关系：</p>
<p>驱动程序使用 <code>irq_of_parse_and_map</code> 解析和映射中断时，该函数实际是调用<code>irq_create_of_mapping</code>，用于建立hw_irq和irq映射关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用设备树创建映射</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_create_of_mapping</span><span class="params">(<span class="keyword">struct</span> of_phandle_args *irq_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="type">int</span> virq;</span><br><span class="line">	<span class="comment">//找到domain</span></span><br><span class="line">	domain = irq_data-&gt;np ? irq_find_host(irq_data-&gt;np) : irq_default_domain;</span><br><span class="line">	<span class="keyword">if</span> (!domain) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;no irq domain found for %s !\n&quot;</span>,</span><br><span class="line">			of_node_full_name(irq_data-&gt;np));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If domain has no translation, then we assume interrupt line */</span></span><br><span class="line">	<span class="keyword">if</span> (domain-&gt;ops-&gt;xlate == <span class="literal">NULL</span>)</span><br><span class="line">		hwirq = irq_data-&gt;args[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//xlate负责从设备树中获取hw中断号</span></span><br><span class="line">		<span class="keyword">if</span> (domain-&gt;ops-&gt;xlate(domain, irq_data-&gt;np, irq_data-&gt;args,</span><br><span class="line">					irq_data-&gt;args_count, &amp;hwirq, &amp;type))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//domain是否支持级联</span></span><br><span class="line">	<span class="keyword">if</span> (irq_domain_is_hierarchy(domain)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we&#x27;ve already configured this interrupt,</span></span><br><span class="line"><span class="comment">		 * don&#x27;t do it again, or hell will break loose.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		 <span class="comment">//根据domain和hw_irq找到irq</span></span><br><span class="line">		virq = irq_find_mapping(domain, hwirq);</span><br><span class="line">		<span class="comment">//如果非0，说明映射关系已经建立，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (virq)</span><br><span class="line">			<span class="keyword">return</span> virq;</span><br><span class="line">		<span class="comment">//结果为0，说明映射关系未建立</span></span><br><span class="line">		<span class="comment">//分配一个新的irqdesc，并添加到domain下</span></span><br><span class="line">		virq = irq_domain_alloc_irqs(domain, <span class="number">1</span>, NUMA_NO_NODE, irq_data);</span><br><span class="line">		<span class="keyword">if</span> (virq &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Create mapping */</span></span><br><span class="line">		virq = irq_create_mapping(domain, hwirq);</span><br><span class="line">		<span class="keyword">if</span> (!virq)</span><br><span class="line">			<span class="keyword">return</span> virq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set type if specified and different than the current one */</span></span><br><span class="line">	<span class="keyword">if</span> (type != IRQ_TYPE_NONE &amp;&amp;</span><br><span class="line">	    type != irq_get_trigger_type(virq))</span><br><span class="line">		irq_set_irq_type(virq, type);</span><br><span class="line">	<span class="keyword">return</span> virq;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(irq_create_of_mapping);</span><br></pre></td></tr></table></figure>

<p>其他API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除domain</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_domain_remove</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//给domain中的中断信号分配irqdesc</span></span><br><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">			    <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">			    <span class="type">bool</span> <span class="built_in">realloc</span>);</span><br><span class="line">			</span><br></pre></td></tr></table></figure>




<h2 id="四、-中断系统初始化"><a href="#四、-中断系统初始化" class="headerlink" title="四、 中断系统初始化"></a>四、 中断系统初始化</h2><p>以上我们了解了中断的处理流程以及使用的主要结构体，那么接下来就来了解这些对象是如何初始化的。</p>
<p>中断子系统涉及到的重要的结构体有:</p>
<ol>
<li>irqdesc</li>
<li>irqdomain</li>
<li>irqaction</li>
<li>genneric_chip</li>
</ol>
<p>合理的猜测,linux启动过程初始化中断时，势必会初始化这些对象,才能使用整个中断子系统.</p>
<p>我们从内核启动函数 <code>start_kernel</code> 开始追踪,可以发现其调用了两个中断相关的函数:</p>
<ol>
<li>early_irq_init</li>
<li>init_IRQ</li>
</ol>
<p><code>early_irq_init</code>函数在前文irqdesc中已经分析过,他的作用就是初始化好irqdesc对象.</p>
<p><code>init_IRQ</code>则与芯片架构相关,ARM架构下该函数定义在 arch&#x2F;arm&#x2F;kernel&#x2F;irq.c </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARM初始化IRQ</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">init_IRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">//是否使用设备树 </span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; !machine_desc-&gt;init_irq)</span><br><span class="line">		<span class="comment">//初始化中断控制器</span></span><br><span class="line">		irqchip_init();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		machine_desc-&gt;init_irq();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; IS_ENABLED(CONFIG_CACHE_L2X0) &amp;&amp;</span><br><span class="line">	    (machine_desc-&gt;l2c_aux_mask || machine_desc-&gt;l2c_aux_val)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!outer_cache.write_sec)</span><br><span class="line">			outer_cache.write_sec = machine_desc-&gt;l2c_write_sec;</span><br><span class="line">		ret = l2x0_of_init(machine_desc-&gt;l2c_aux_val,</span><br><span class="line">				   machine_desc-&gt;l2c_aux_mask);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			pr_err(<span class="string">&quot;L2C: failed to init: %d\n&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>irqchip_init 函数的目的就是初始化中断控制器,而soc上有多少的中断控制器,可以从设备树中确定.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化中断控制器</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">irqchip_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化设备树中的中断控制器，__irqchip_of_table是一个程序段</span></span><br><span class="line">	of_irq_init(__irqchip_of_table);</span><br><span class="line"></span><br><span class="line">	acpi_irq_init(); <span class="comment">//应该没有用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题是__irqchip_of_table 是什么东西呢?这里直接给出答案,在irq-gic.c中,有这样的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRQCHIP_DECLARE(cortex_a7_gic, <span class="string">&quot;arm,cortex-a7-gic&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>

<p>IRQCHIP_DECLARE宏展开后,最终可以得到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_cortex_a7_gic</span> __<span class="title">used__section</span>(__<span class="title">irqchip_of_table</span>) =</span> 		</span><br><span class="line">&#123; </span><br><span class="line">    .compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>,		<span class="comment">//匹配字符串名称,与设备树中compatible相同		</span></span><br><span class="line">	.data = gic_of_init,    <span class="comment">//gic初始化函数(设备树版)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>__irqchip_of_table 中存放的就是 of_device_id 数组</p>
<p>在GIC驱动程序中,使用了多个IRQCHIP_DECLARE,__irqchip_of_table中就有很多的of_device_id</p>
<p>有了这个了解,我们就可以继续学习 <code>of_irq_init</code>,这个函数逻辑有点乱,但我们只需要明白:</p>
<p><strong>这个函数扫描设备树中的中断控制器节点，并从最上层的控制器开始调用注册的初始化函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_irq_init - Scan and init matching interrupt controllers in DT</span></span><br><span class="line"><span class="comment"> * @matches: 0 terminated array of nodes to match and init function to call</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function scans the device tree for matching interrupt controller nodes,</span></span><br><span class="line"><span class="comment"> * and calls their initialization functions in order with parents first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//扫描设备树中的中断控制器节点，并从最上层的控制器开始初始化</span></span><br><span class="line"> <span class="comment">//match是一个数组，其成员包含了初始化函数</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">of_irq_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>, *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">intc_desc</span> *<span class="title">desc</span>, *<span class="title">temp_desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">intc_desc_list</span>, <span class="title">intc_parent_list</span>;</span></span><br><span class="line">	<span class="comment">//中断控制器链表</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_desc_list);</span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_parent_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//寻找设备树中定义的中断控制器，将他加入intc_desc_list</span></span><br><span class="line">	for_each_matching_node(np, matches) &#123;</span><br><span class="line">		<span class="comment">//寻找设备树节点中有&quot;interrupt-controller&quot;属性的节点，保存到np</span></span><br><span class="line">		<span class="keyword">if</span> (!of_find_property(np, <span class="string">&quot;interrupt-controller&quot;</span>, <span class="literal">NULL</span>) ||</span><br><span class="line">				!of_device_is_available(np))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Here, we allocate and populate an intc_desc with the node</span></span><br><span class="line"><span class="comment">		 * pointer, interrupt-parent device_node etc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		 <span class="comment">//分配一个irqdesc给中断控制器，并绑定设备树节点</span></span><br><span class="line">		desc = kzalloc(<span class="keyword">sizeof</span>(*desc), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!desc))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">		desc-&gt;dev = np;</span><br><span class="line">		desc-&gt;interrupt_parent = of_irq_find_parent(np);</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</span><br><span class="line">			desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//插入链表</span></span><br><span class="line">		list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The root irq controller is the one without an interrupt-parent.</span></span><br><span class="line"><span class="comment">	 * That one goes first, followed by the controllers that reference it,</span></span><br><span class="line"><span class="comment">	 * followed by the ones that reference the 2nd level controllers, etc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">//从root中断控制器开始初始化</span></span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Process all controllers with the current &#x27;parent&#x27;.</span></span><br><span class="line"><span class="comment">		 * First pass will be looking for NULL as the parent.</span></span><br><span class="line"><span class="comment">		 * The assumption is that NULL parent means a root controller.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">			<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span>		<span class="comment">//当前控制器对应的of_device_id</span></span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			<span class="type">of_irq_init_cb_t</span> irq_init_cb;	<span class="comment">//中断控制器的初始化函数</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//desc是不是孤儿，直到找到一个孤儿，也就是root intr</span></span><br><span class="line">			<span class="keyword">if</span> (desc-&gt;interrupt_parent != parent)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//从intc_desc_list删除</span></span><br><span class="line">			list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">			<span class="comment">//匹配节点，获取对应的of_device_id</span></span><br><span class="line">			match = of_match_node(matches, desc-&gt;dev);</span><br><span class="line">			<span class="keyword">if</span> (WARN(!match-&gt;data,</span><br><span class="line">			    <span class="string">&quot;of_irq_init: no init function for %s\n&quot;</span>,</span><br><span class="line">			    match-&gt;compatible)) &#123;</span><br><span class="line">				kfree(desc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pr_debug(<span class="string">&quot;of_irq_init: init %s @ %p, parent %p\n&quot;</span>,</span><br><span class="line">				 match-&gt;compatible,</span><br><span class="line">				 desc-&gt;dev, desc-&gt;interrupt_parent);</span><br><span class="line">			<span class="comment">//获取初始化函数 gic_of_init</span></span><br><span class="line">			irq_init_cb = (<span class="type">of_irq_init_cb_t</span>)match-&gt;data;</span><br><span class="line">			<span class="comment">//调用中断控制器的初始化函数 gic_of_init(desc-&gt;dev, desc-&gt;interrupt_parent)</span></span><br><span class="line">			ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent);</span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				kfree(desc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This one is now set up; add it to the parent list so</span></span><br><span class="line"><span class="comment">			 * its children can get processed in a subsequent pass.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			 <span class="comment">//将root intr插入intc_parent_list</span></span><br><span class="line">			list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get the next pending parent that might have children */</span></span><br><span class="line">		desc = list_first_entry_or_null(&amp;intc_parent_list,</span><br><span class="line">						<span class="keyword">typeof</span>(*desc), <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;of_irq_init: children remain, but no parents\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		parent = desc-&gt;dev;</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">err:</span><br><span class="line">	list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我使用的设备树如下,那么对应初始化函数就是<code>gic_of_init</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">	      &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gic_of_init 会根据设备树的配置信息,去初始化GIC.这里需要对GIC的编程方法有一定了解.就是对GIC的地址进行映射,然后调用gic_init_bases,以及处理多核和父节点存在的情况.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gic初始化函数</span></span><br><span class="line"><span class="comment">//node：中断控制器节点</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gic_of_init</span><span class="params">(<span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base;</span><br><span class="line">	<span class="type">void</span> __iomem *dist_base;</span><br><span class="line">	u32 percpu_offset;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!node))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	<span class="comment">//对distribute的地址进行映射</span></span><br><span class="line">	dist_base = of_iomap(node, <span class="number">0</span>);</span><br><span class="line">	WARN(!dist_base, <span class="string">&quot;unable to map gic dist registers\n&quot;</span>);</span><br><span class="line">	<span class="comment">//对cpu interface的地址进行映射</span></span><br><span class="line">	cpu_base = of_iomap(node, <span class="number">1</span>);</span><br><span class="line">	WARN(!cpu_base, <span class="string">&quot;unable to map gic cpu registers\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_u32(node, <span class="string">&quot;cpu-offset&quot;</span>, &amp;percpu_offset))</span><br><span class="line">		percpu_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//初始化gic</span></span><br><span class="line">	gic_init_bases(gic_cnt, <span class="number">-1</span>, dist_base, cpu_base, percpu_offset, node);</span><br><span class="line">	<span class="keyword">if</span> (!gic_cnt)</span><br><span class="line">		gic_init_physaddr(node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有父节点的情况</span></span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">		irq = irq_of_parse_and_map(node, <span class="number">0</span>);</span><br><span class="line">		gic_cascade_irq(gic_cnt, irq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不考虑了</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ARM_GIC_V2M))</span><br><span class="line">		gicv2m_of_init(node, gic_data[gic_cnt].domain);</span><br><span class="line"></span><br><span class="line">	gic_cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gic_init_bases 实现了irq_domain的创建,这个domain对应GIC，是整个系统中的根domain。另外函数还使用向GIC CPU interface的寄存器写入初始值，使能GIC。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">gic_init_bases</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gic_nr, <span class="type">int</span> irq_start,</span></span><br><span class="line"><span class="params">			   <span class="type">void</span> __iomem *dist_base, <span class="type">void</span> __iomem *cpu_base,</span></span><br><span class="line"><span class="params">			   u32 percpu_offset, <span class="keyword">struct</span> device_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq_base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span>;</span></span><br><span class="line">	<span class="type">int</span> gic_irqs, irq_base, i;</span><br><span class="line"></span><br><span class="line">	BUG_ON(gic_nr &gt;= MAX_GIC_NR);</span><br><span class="line"></span><br><span class="line">	gic = &amp;gic_data[gic_nr];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GIC_NON_BANKED</span></span><br><span class="line">	<span class="keyword">if</span> (percpu_offset) &#123; <span class="comment">/* Frankein-GIC without banked registers... */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">		gic-&gt;dist_base.percpu_base = alloc_percpu(<span class="type">void</span> __iomem *);</span><br><span class="line">		gic-&gt;cpu_base.percpu_base = alloc_percpu(<span class="type">void</span> __iomem *);</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!gic-&gt;dist_base.percpu_base ||</span><br><span class="line">			    !gic-&gt;cpu_base.percpu_base)) &#123;</span><br><span class="line">			free_percpu(gic-&gt;dist_base.percpu_base);</span><br><span class="line">			free_percpu(gic-&gt;cpu_base.percpu_base);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			u32 mpidr = cpu_logical_map(cpu);</span><br><span class="line">			u32 core_id = MPIDR_AFFINITY_LEVEL(mpidr, <span class="number">0</span>);</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> offset = percpu_offset * core_id;</span><br><span class="line">			*per_cpu_ptr(gic-&gt;dist_base.percpu_base, cpu) = dist_base + offset;</span><br><span class="line">			*per_cpu_ptr(gic-&gt;cpu_base.percpu_base, cpu) = cpu_base + offset;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gic_set_base_accessor(gic, gic_get_percpu_base);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123;			<span class="comment">/* Normal, sane GIC... */</span></span><br><span class="line">		WARN(percpu_offset,</span><br><span class="line">		     <span class="string">&quot;GIC_NON_BANKED not enabled, ignoring %08x offset!&quot;</span>,</span><br><span class="line">		     percpu_offset);</span><br><span class="line">		<span class="comment">//保存地址到gic对象</span></span><br><span class="line">		gic-&gt;dist_base.common_base = dist_base;</span><br><span class="line">		gic-&gt;cpu_base.common_base = cpu_base;</span><br><span class="line">		<span class="comment">//设置访问gic的方法</span></span><br><span class="line">		gic_set_base_accessor(gic, gic_get_common_base);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the CPU interface map to all CPUs.</span></span><br><span class="line"><span class="comment">	 * It will be refined as each CPU probes its ID.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">//多核相关的</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_GIC_CPU_IF; i++)</span><br><span class="line">		gic_cpu_map[i] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find out how many interrupts are supported.</span></span><br><span class="line"><span class="comment">	 * The GIC only supports up to 1020 interrupt sources.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">//获取gic支持的中断数量</span></span><br><span class="line">	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) &amp; <span class="number">0x1f</span>;</span><br><span class="line">	gic_irqs = (gic_irqs + <span class="number">1</span>) * <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">if</span> (gic_irqs &gt; <span class="number">1020</span>)</span><br><span class="line">		gic_irqs = <span class="number">1020</span>;</span><br><span class="line">	gic-&gt;gic_irqs = gic_irqs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化irqdesc</span></span><br><span class="line">	<span class="keyword">if</span> (node) &#123;		</span><br><span class="line">		<span class="comment">//使用设备树时，只需要创建irq_domain</span></span><br><span class="line">		<span class="comment">//使用线性映射,重要的是gic_irq_domain_hierarchy_ops</span></span><br><span class="line">		gic-&gt;domain = irq_domain_add_linear(node, gic_irqs,</span><br><span class="line">						    &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">						    gic);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;		</span><br><span class="line">		<span class="comment">//不带设备树的方法，不分析了</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For primary GICs, skip over SGIs.</span></span><br><span class="line"><span class="comment">		 * For secondary GICs, skip over PPIs, too.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (gic_nr == <span class="number">0</span> &amp;&amp; (irq_start &amp; <span class="number">31</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			hwirq_base = <span class="number">16</span>;</span><br><span class="line">			<span class="keyword">if</span> (irq_start != <span class="number">-1</span>)</span><br><span class="line">				irq_start = (irq_start &amp; ~<span class="number">31</span>) + <span class="number">16</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			hwirq_base = <span class="number">32</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gic_irqs -= hwirq_base; <span class="comment">/* calculate # of irqs to allocate */</span></span><br><span class="line"></span><br><span class="line">		irq_base = irq_alloc_descs(irq_start, <span class="number">16</span>, gic_irqs,</span><br><span class="line">					   numa_node_id());</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR_VALUE(irq_base)) &#123;</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">&quot;Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n&quot;</span>,</span><br><span class="line">			     irq_start);</span><br><span class="line">			irq_base = irq_start;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gic-&gt;domain = irq_domain_add_legacy(node, gic_irqs, irq_base,</span><br><span class="line">					hwirq_base, &amp;gic_irq_domain_ops, gic);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!gic-&gt;domain))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gic_nr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">		set_smp_cross_call(gic_raise_softirq);</span><br><span class="line">		register_cpu_notifier(&amp;gic_cpu_notifier);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		set_handle_irq(gic_handle_irq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对gic的distributor，cpu interface pm的初始化，写寄存器</span></span><br><span class="line">	gic_dist_init(gic);</span><br><span class="line">	gic_cpu_init(gic);</span><br><span class="line">	gic_pm_init(gic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>domain分为使用设备树和不使用设备树的情况，当使用设备树时，domain的接口是<code>gic_irq_domain_hierarchy_ops</code>.目前他提供的以下三个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//irq_domain的方法</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> <span class="title">gic_irq_domain_hierarchy_ops</span> =</span> &#123;</span><br><span class="line">	.xlate = gic_irq_domain_xlate,  <span class="comment">//获取设备树节点的中断信息</span></span><br><span class="line">	.alloc = gic_irq_domain_alloc,	<span class="comment">//设置domain下irq_desc的成员</span></span><br><span class="line">	.<span class="built_in">free</span> = irq_domain_free_irqs_top,  <span class="comment">//清除domain下irqdesc的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先是 <code>gic_irq_domain_xlate</code>可以获取domain节点下中断的hw_irq,例如:interrupts &#x3D; &lt;GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH&gt;;是gic的子节点.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intspec[]=&#123;GIC_SPI,86,IRQ_TYPE_LEVEL_HIGH&#125;;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_xlate</span><span class="params">(<span class="keyword">struct</span> irq_domain *d,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> device_node *controller,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> u32 *intspec, <span class="type">unsigned</span> <span class="type">int</span> intsize,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> *out_hwirq, <span class="type">unsigned</span> <span class="type">int</span> *out_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d-&gt;of_node != controller)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (intsize &lt; <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the interrupt number and add 16 to skip over SGIs */</span></span><br><span class="line">	<span class="comment">//获取中断号，加16跳过sgis</span></span><br><span class="line">	*out_hwirq = intspec[<span class="number">1</span>] + <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For SPIs, we need to add 16 more to get the GIC irq ID number */</span></span><br><span class="line">	<span class="comment">//gic_spi类型还要再跳过16</span></span><br><span class="line">	<span class="keyword">if</span> (!intspec[<span class="number">0</span>])</span><br><span class="line">		*out_hwirq += <span class="number">16</span>;</span><br><span class="line">	<span class="comment">//获取类型</span></span><br><span class="line">	*out_type = intspec[<span class="number">2</span>] &amp; IRQ_TYPE_SENSE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gic_irq_domain_alloc</code>是初始化domain下的irqdesc,主要是设置中断流处理函数<code>desc-&gt;handle_irq = handle_fasteoi_irq</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置中断信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_phandle_args</span> *<span class="title">irq_data</span> =</span> arg;</span><br><span class="line">	<span class="comment">//获取硬件中断号</span></span><br><span class="line">	ret = gic_irq_domain_xlate(domain, irq_data-&gt;np, irq_data-&gt;args,</span><br><span class="line">				   irq_data-&gt;args_count, &amp;hwirq, &amp;type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">//设置对应中断信息</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++)</span><br><span class="line">		gic_irq_domain_map(domain, virq + i, hwirq + i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、参考博客"><a href="#五、参考博客" class="headerlink" title="五、参考博客"></a>五、参考博客</h2><p><a target="_blank" rel="noopener" href="https://www.twblogs.net/a/5cca2fa2bd9eee1ac2edaf2a">Linux中斷子系統框架流程詳解（基於Kernel 3.16，arm，設備樹） - 台部落 (twblogs.net)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/sort/irq_subsystem">中断子系统 - 蜗窝科技 (wowotech.net)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/Linux/Linux_isr_3/" data-id="cmbcy7rh40013t8mtdy948uf6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/31/killer-blog/Linux/Linux_source_setup_env/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/05/31/killer-blog/picture/weixin.png/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
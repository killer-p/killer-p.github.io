<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="@[toc] 软总线本文简单介绍softbus_lite的部分实现。代码来自openharmony 3.0 foundation&#x2F;commucation&#x2F;softbus_lite。 softbus_lite是L0和L1设备所采用的软总线的实现，相比于标准设备的dsoftbus，功能有所减少。例如softbus_lite只实现被动接收Session连接的功能，无法主动发起sess">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/05/31/killer-blog/OpenHarmony/softbus_lite/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@[toc] 软总线本文简单介绍softbus_lite的部分实现。代码来自openharmony 3.0 foundation&#x2F;commucation&#x2F;softbus_lite。 softbus_lite是L0和L1设备所采用的软总线的实现，相比于标准设备的dsoftbus，功能有所减少。例如softbus_lite只实现被动接收Session连接的功能，无法主动发起sess">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-31T02:36:45.831Z">
<meta property="article:modified_time" content="2025-06-01T00:19:46.495Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/OpenHarmony/softbus_lite" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/softbus_lite/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.831Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h2 id="软总线"><a href="#软总线" class="headerlink" title="软总线"></a>软总线</h2><p>本文简单介绍softbus_lite的部分实现。代码来自openharmony 3.0 foundation&#x2F;commucation&#x2F;softbus_lite。</p>
<p>softbus_lite是L0和L1设备所采用的软总线的实现，相比于标准设备的dsoftbus，功能有所减少。例如softbus_lite只实现被动接收Session连接的功能，无法主动发起session连接以及发现服务。</p>
<p>softbus_lite更多的应用场景是作为边缘设备，通过在局域网内发布服务，等待标准设备的订阅。</p>
<h2 id="一、会话传输"><a href="#一、会话传输" class="headerlink" title="一、会话传输"></a>一、会话传输</h2><p>L0,L1系统属于lite系统，无法主动打开session，只能创建session server，然后等待远程设备来打开会话。在会话回调函数中，可获取会话id。通过session id可用来发送和接收数据。</p>
<h3 id="1-1、CreateSessionServer"><a href="#1-1、CreateSessionServer" class="headerlink" title="1.1、CreateSessionServer"></a>1.1、CreateSessionServer</h3><p>CreateSessionServer：session server的作用只是用来管理listenerMap，即监听的功能，回调函数的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ISessionListener</span> &#123;</span></span><br><span class="line">	<span class="comment">//当会话被打开时回调，sessionId表示本地会话id，也就是tcp连接的句柄，发送和接收数据时会使用到</span></span><br><span class="line">    <span class="type">int</span> (*onSessionOpened)(<span class="type">int</span> sessionId);</span><br><span class="line">    <span class="type">void</span> (*onSessionClosed)(<span class="type">int</span> sessionId);</span><br><span class="line">	<span class="comment">//接受到会话的数据</span></span><br><span class="line">    <span class="type">void</span> (*onBytesReceived)(<span class="type">int</span> sessionId, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">int</span> dataLen);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建g_sessionMgr，保存参数信息到全局数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateSessionServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* moduleName, <span class="type">const</span> <span class="type">char</span>* sessionName, <span class="keyword">struct</span> ISessionListener *listener)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = CreateSessionServerInner(moduleName, sessionName, listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将listener保存到全局数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">CreateSessionServerInner</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* moduleName, <span class="type">const</span> <span class="type">char</span>* sessionName, <span class="keyword">struct</span> ISessionListener *listener)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建g_sessionMgr</span></span><br><span class="line">    <span class="keyword">if</span> (g_sessionMgr == <span class="literal">NULL</span> &amp;&amp; InitGSessionMgr() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> TRANS_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在serverListenerMap中找一个空位置</span></span><br><span class="line">    <span class="type">int</span> findIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SESSION_SERVER_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_sessionMgr-&gt;serverListenerMap[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            findIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (findIndex &gt;= <span class="number">0</span> &amp;&amp; findIndex &lt; MAX_SESSION_SERVER_NUM) &#123;</span><br><span class="line">        g_sessionMgr-&gt;serverListenerMap[findIndex] = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(SessionListenerMap));</span><br><span class="line">        <span class="comment">//把参数信息保存到数组</span></span><br><span class="line">        SessionListenerMap *listenerMap = g_sessionMgr-&gt;serverListenerMap[findIndex];</span><br><span class="line">        <span class="keyword">if</span> (strncpy_s(listenerMap-&gt;sessionName, NAME_LENGTH, sessionName, <span class="built_in">strlen</span>(sessionName)) ||</span><br><span class="line">            strncpy_s(listenerMap-&gt;moduleName, NAME_LENGTH, moduleName, <span class="built_in">strlen</span>(moduleName))) &#123;</span><br><span class="line">            <span class="built_in">free</span>(listenerMap);</span><br><span class="line">            listenerMap = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> TRANS_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//把回调函数保存到全局数组</span></span><br><span class="line">        listenerMap-&gt;listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、SendBytes"><a href="#1-2、SendBytes" class="headerlink" title="1.2、SendBytes"></a>1.2、SendBytes</h3><p>向会话对端发送字节数据，实际上是调用socket接口 进行发送。</p>
<p>sessionfd就是通过回调函数获取到的sessionid，其实就是tcp端口的句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SendBytes</span><span class="params">(<span class="type">int</span> sessionfd, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取session</span></span><br><span class="line">    TcpSession *session = GetSessionById(sessionfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包数据到cipherBuf</span></span><br><span class="line">    <span class="type">char</span> *cipherBuf = (<span class="type">char</span> *)TransPackBytes(session, buf, size, &amp;cipherLen);</span><br><span class="line">    <span class="type">int32_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    fd_set writefds;</span><br><span class="line">    FD_ZERO(&amp;writefds);</span><br><span class="line">    FD_SET(sessionfd, &amp;writefds);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">msTimeout</span>;</span></span><br><span class="line">    <span class="comment">//设置超时时间</span></span><br><span class="line">    msTimeout.tv_sec = DEFAULT_TIMEOUT / ONE_SEC;</span><br><span class="line">    msTimeout.tv_usec = (DEFAULT_TIMEOUT % ONE_SEC) * ONE_SEC;</span><br><span class="line">    <span class="comment">//阻塞等待socket就绪</span></span><br><span class="line">    <span class="type">int</span> err = select(sessionfd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;writefds, <span class="literal">NULL</span>, &amp;msTimeout);</span><br><span class="line">	<span class="comment">//使用socket发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (FD_ISSET(sessionfd, &amp;writefds) &amp;&amp; bytes &lt; (<span class="type">int32_t</span>)cipherLen &amp;&amp; (sessionfd) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int32_t</span> rc = send(sessionfd, cipherBuf + bytes, cipherLen - bytes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((rc == <span class="number">-1</span>) &amp;&amp; (errno == EAGAIN)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bytes == <span class="number">0</span>) &#123;</span><br><span class="line">                bytes = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes += rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(cipherBuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="二、设备发现"><a href="#二、设备发现" class="headerlink" title="二、设备发现"></a>二、设备发现</h2><p>用户使用发现功能来自动发现周围的OpenHarmony设备时，需要保证发现端设备与被发现端设备在同一个局域网内，并且互相能收到对方以下流程的报文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）发现端设备，发起discover请求后，使用coap协议在局域网内发送广播。</span><br><span class="line">（<span class="number">2</span>）被发现端设备使用PublishService接口发布服务，接收端收到广播后，发送coap协议单播给发现端。</span><br><span class="line">（<span class="number">3</span>）发现端设备收到报文会更新设备信息。    </span><br></pre></td></tr></table></figure>

<p>设备发现的最终目的就是发现局域网内的设备，更新周围的设备id。</p>
<p>目前L0、L1系统，也就是lite系统，不支持作为发现端。只能作为被发现端。通过使用PublishService接口发布服务，就能被标准设备发现。</p>
<p>发现服务的工作原理是这样的：</p>
<ul>
<li><p>首先由本地A设备,远程B设备。A设备调用PublishService发布服务，会创建一个udp服务器，监听一个广播端口。</p>
</li>
<li><p>B设备调用StartDiscovery开始发现设备，会创建一个udp客户端，向局域网广播。（B是L2设备）</p>
</li>
<li><p>A收到B的广播消息后，创建一个udp客户端，给B发送响应消息，响应消息中包含A的设备信息。</p>
</li>
<li><p>B收到响应后，会执行回调函数，函数参数就是A的设备信息。</p>
</li>
<li><p>B接下来可对A进行会话连接等。</p>
</li>
</ul>
<p>下面的结构体表示服务提供的设备信息：这个信息会一直传递到对端设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送给对端的本地设备信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PublishInfo</span> &#123;</span></span><br><span class="line">    <span class="comment">//服务id，如何确定？</span></span><br><span class="line">    <span class="type">int</span> publishId;</span><br><span class="line">    <span class="comment">//L0,L1设备只能是DISCOVER_MODE_PASSIVE 被动发现</span></span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">    <span class="comment">//协议：COAP协议</span></span><br><span class="line">    ExchangeMedium medium;</span><br><span class="line">    <span class="comment">//报文发送频率</span></span><br><span class="line">    ExchangeFreq freq;</span><br><span class="line">    <span class="comment">/** 服务发布的能力. 见下文 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *capability;</span><br><span class="line">    <span class="comment">/** 服务的数据。见下文 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *capabilityData;</span><br><span class="line">    <span class="comment">/** Maximum length of the capability data for service publishing (2 bytes) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dataLen;</span><br><span class="line">&#125; PublishInfo;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 服务的能力枚举，具体是什么意思？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/** MeeTime */</span></span><br><span class="line">    HICALL_CAPABILITY_BITMAP = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/** Video reverse connection in the smart domain */</span></span><br><span class="line">    PROFILE_CAPABILITY_BITMAP = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** Gallery in Vision */</span></span><br><span class="line">    HOMEVISIONPIC_CAPABILITY_BITMAP = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">/** cast+ */</span></span><br><span class="line">    CASTPLUS_CAPABILITY_BITMAP,</span><br><span class="line">    <span class="comment">/** Input method in Vision */</span></span><br><span class="line">    AA_CAPABILITY_BITMAP,</span><br><span class="line">    <span class="comment">/** Device virtualization tool package */</span></span><br><span class="line">    DVKIT_CAPABILITY_BITMAP,</span><br><span class="line">    <span class="comment">/** Distributed middleware */</span></span><br><span class="line">    DDMP_CAPABILITY_BITMAP</span><br><span class="line">&#125; DataBitMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将服务的能力和字符串绑定</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> CapabilityMap g_capabilityMap[] = &#123;</span><br><span class="line">    &#123;HICALL_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;hicall&quot;</span>&#125;,</span><br><span class="line">    &#123;PROFILE_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;profile&quot;</span>&#125;,</span><br><span class="line">    &#123;CASTPLUS_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;castPlus&quot;</span>&#125;,</span><br><span class="line">    &#123;HOMEVISIONPIC_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;homevisionPic&quot;</span>&#125;,</span><br><span class="line">    &#123;AA_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;aaCapability&quot;</span>&#125;,</span><br><span class="line">    &#123;DVKIT_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;dvKit&quot;</span>&#125;,</span><br><span class="line">    &#123;DDMP_CAPABILITY_BITMAP, (<span class="type">char</span> *)<span class="string">&quot;ddmpCapability&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2-1、发布服务"><a href="#2-1、发布服务" class="headerlink" title="2.1、发布服务"></a>2.1、发布服务</h3><p>即设备在局域网内发布上述的服务，这些服务就能被发现和调用。其本质就是将PublishInfo保存到全局变量中，并创建coap server监听端口，等待服务被发现和调用。当收到发现报文时，将PublishInfo里的信息通过coap报文，发送给发现者。</p>
<p>PublishService用于发布服务，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PublishService</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *moduleName, <span class="type">const</span> <span class="keyword">struct</span> PublishInfo *info, <span class="type">const</span> <span class="keyword">struct</span> IPublishCallback *cb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//检查是否有软总线权限</span></span><br><span class="line">    <span class="keyword">if</span> (SoftBusCheckPermission(SOFTBUS_PERMISSION) != <span class="number">0</span> || info == <span class="literal">NULL</span> || cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化全局服务</span></span><br><span class="line">    <span class="keyword">if</span> (InitService() != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化module</span></span><br><span class="line">    PublishModule *findModule = AddPublishModule(moduleName, info);</span><br><span class="line">    <span class="comment">//设置全局变量</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;capability == <span class="literal">NULL</span> || info-&gt;capabilityData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="type">void</span>)CoapRegisterDefualtService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = DoRegistService(info-&gt;medium);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行用户回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ERROR_SUCCESS) &#123;</span><br><span class="line">        PublishCallback(info-&gt;publishId, PUBLISH_FAIL_REASON_UNKNOWN, findModule, cb);</span><br><span class="line">        <span class="keyword">return</span> ERROR_FAIL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//call back</span></span><br><span class="line">        PublishCallback(info-&gt;publishId, ERROR_SUCCESS, findModule, cb);</span><br><span class="line">        <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化全局服务，是主要的初始化代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化服务：初始化设备信息ip地址、注册wifi回调函数、coap初始化。在连接到wifi后，启动soft bus、注册设备信息到softbus</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitService</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化 g_deviceInfo、g_publishModule、g_capabilityData、g_wifiCallback等全局变量</span></span><br><span class="line">    InitCommonManager();</span><br><span class="line"></span><br><span class="line">    g_publishModule = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(PublishModule) * MAX_MODULE_COUNT);</span><br><span class="line">    g_capabilityData = <span class="built_in">calloc</span>(<span class="number">1</span>, MAX_SERVICE_DATA_LEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册wifi事件回调函数，具体见下文</span></span><br><span class="line">    RegisterWifiCallback(WifiEventTrigger);</span><br><span class="line">    <span class="comment">//初始化coap服务器，处理coap报文逻辑</span></span><br><span class="line">    <span class="type">int</span> ret = CoapInit();</span><br><span class="line">    <span class="comment">//给wifi队列写入消息，本质是使能WifiEventTrigger()函数</span></span><br><span class="line">    CoapWriteMsgQueue(UPDATE_IP_EVENT);</span><br><span class="line">    <span class="comment">//设置设备信息</span></span><br><span class="line">    ret = CoapRegisterDeviceInfo();</span><br><span class="line">    <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整个发现服务流程中，以下全局变量经常使用到，有必要简单的了解下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局模块 对应一个上层的应用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> package[MAX_PACKAGE_NAME];	<span class="comment">//上层应用packagename</span></span><br><span class="line">    <span class="type">int</span> publishId;					</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> medium;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> capabilityBitmap;</span><br><span class="line">    <span class="type">char</span> *capabilityData;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> dataLength;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used;</span><br><span class="line">&#125; PublishModule;</span><br><span class="line">g_publishModule;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *g_capabilityData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设备信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceInfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> deviceName[MAX_DEV_NAME_LEN];</span><br><span class="line">    <span class="type">char</span> deviceId[MAX_DEV_ID_LEN];</span><br><span class="line">    <span class="type">char</span> deviceIp[MAX_DEV_IP_LEN];</span><br><span class="line">    <span class="type">char</span> version[MAX_DEV_VERSION_LEN];</span><br><span class="line">    <span class="type">char</span> softwareVersion[MAX_SOFTWARE_VERSION_LEN];	<span class="comment">//软件版本</span></span><br><span class="line">    <span class="type">char</span> networkName[MAX_DEV_NETWORK_LEN];</span><br><span class="line">    <span class="type">int</span> deviceType;</span><br><span class="line">    <span class="type">int</span> devicePort;</span><br><span class="line">    NetworkState networkState;</span><br><span class="line">    <span class="type">int</span> isAccountTrusted;</span><br><span class="line">&#125; DeviceInfo;</span><br><span class="line">g_deviceInfo;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1、wifi事件"><a href="#2-1-1、wifi事件" class="headerlink" title="2.1.1、wifi事件"></a>2.1.1、wifi事件</h4><p>WifiEventTrigger()是一个回调函数，他的执行环境是线程CoapWifiEventThread（待会解释）。当连接到wifi后，CoapWifiEventThread就会调用WifiEventTrigger()，其参数para&#x3D;1，表示连接到wifi。表示网络已连接，那么就可用开始软总线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WIFI事件回调 state=1:UPDATE_IP_EVENT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WifiEventTrigger</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> para)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceInfo *localDev = GetCommonDeviceInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//para=state=1 连接上wifi</span></span><br><span class="line">    <span class="keyword">if</span> (para) &#123;</span><br><span class="line">        <span class="comment">//获取ip</span></span><br><span class="line">        <span class="type">char</span> wifiIp[MAX_DEV_IP_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        CoapGetIp(wifiIp, MAX_DEV_IP_LEN, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(wifiIp, <span class="string">&quot;0.0.0.0&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = memcpy_s(localDev-&gt;deviceIp, <span class="keyword">sizeof</span>(localDev-&gt;deviceIp), wifiIp, <span class="keyword">sizeof</span>(wifiIp));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//清除ip，断开网络连接</span></span><br><span class="line">        ret = memset_s(localDev-&gt;deviceIp, <span class="keyword">sizeof</span>(localDev-&gt;deviceIp), <span class="number">0</span>, <span class="keyword">sizeof</span>(localDev-&gt;deviceIp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启软总线</span></span><br><span class="line">    <span class="keyword">if</span> (BusManager(para) != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化本地设备信息</span></span><br><span class="line">    <span class="keyword">if</span> (CoapRegisterDeviceInfo() != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册capablity 和 g_capabilityData 到nstackx </span></span><br><span class="line">    <span class="keyword">if</span> (DoRegistService(COAP) != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2、coap服务器"><a href="#2-1-2、coap服务器" class="headerlink" title="2.1.2、coap服务器"></a>2.1.2、coap服务器</h4><p>coapInit()最终是调用CoapInitDiscovery() 来建立coap协议所需的资源：</p>
<ul>
<li>udp server：用于监听coap报文</li>
<li>wifi消息队列：缓存wifi状态消息</li>
<li>CoapWifiEventThread：处理wifi消息队列</li>
<li>CreateCoapListenThread：处理coap报文交互逻辑</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化coap协议所需资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CoapInitDiscovery</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立udp server 监听5684端口（coap协议默认端口）</span></span><br><span class="line">    <span class="type">int</span> ret = CoapInitSocket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建wifi消息队列</span></span><br><span class="line">    ret = CoapInitWifiEvent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 CoapWifiEventThread 线程</span></span><br><span class="line">    <span class="keyword">if</span> (CreateMsgQueThread() != NSTACKX_EOK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NSTACKX_EFAILED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建CoapReadHandle 线程</span></span><br><span class="line">    <span class="keyword">return</span> CreateCoapListenThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoapWifiEventThread线程：其本质内容就是执行wifi事件回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理wifi队列的消息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CoapWifiEventThread</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> uwParam1, <span class="type">unsigned</span> <span class="type">int</span> uwParam2, <span class="type">unsigned</span> <span class="type">int</span> uwParam3, <span class="type">unsigned</span> <span class="type">int</span> uwParam4)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_wifiTaskStart = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (g_wifiTaskStart) &#123;</span><br><span class="line">        <span class="comment">//读取队列消息的消息： handler（WifiEventTrigger）</span></span><br><span class="line">        ret = ReadMsgQue(g_wifiQueueId, &amp;handle, &amp;readSize);</span><br><span class="line">        <span class="keyword">if</span> ((ret == <span class="number">0</span>) &amp;&amp; (readSize == <span class="keyword">sizeof</span>(AddressEventHandler))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle.handler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行回调函数（WifiEventTrigger）</span></span><br><span class="line">            handle.handler(handle.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoapReadHandle：读取udp server接收的数据，并处理数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CoapReadHandle</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> uwParam1, <span class="type">unsigned</span> <span class="type">int</span> uwParam2, <span class="type">unsigned</span> <span class="type">int</span> uwParam3, <span class="type">unsigned</span> <span class="type">int</span> uwParam4)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取之间创建的udp server</span></span><br><span class="line">    <span class="type">int</span> serverFd = GetCoapServerSocket();</span><br><span class="line">    <span class="keyword">while</span> (g_terminalFlag) &#123;</span><br><span class="line">        FD_ZERO(&amp;readSet);</span><br><span class="line">        FD_SET(serverFd, &amp;readSet);</span><br><span class="line">        <span class="comment">//读取udp server接收的数据</span></span><br><span class="line">        ret = select(serverFd + <span class="number">1</span>, &amp;readSet, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(serverFd, &amp;readSet)) &#123;</span><br><span class="line">                <span class="comment">//处理接收数据</span></span><br><span class="line">                HandleReadEvent(serverFd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SOFTBUS_PRINT(<span class="string">&quot;[DISCOVERY]ret:%d,error:%d\n&quot;</span>, ret, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>处理udp server数据的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理udp数据报事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">HandleReadEvent</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> socketFd = fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *recvBuffer = <span class="built_in">calloc</span>(<span class="number">1</span>, COAP_MAX_PDU_SIZE + <span class="number">1</span>);</span><br><span class="line">    <span class="type">ssize_t</span> nRead;</span><br><span class="line">    <span class="comment">//读取coap报文</span></span><br><span class="line">    nRead = CoapSocketRecv(socketFd, recvBuffer, COAP_MAX_PDU_SIZE);</span><br><span class="line">	</span><br><span class="line">    COAP_Packet decodePacket;</span><br><span class="line">    (<span class="type">void</span>)memset_s(&amp;decodePacket, <span class="keyword">sizeof</span>(COAP_Packet), <span class="number">0</span>, <span class="keyword">sizeof</span>(COAP_Packet));</span><br><span class="line">    decodePacket.protocol = COAP_UDP;</span><br><span class="line">    <span class="comment">//解析coap报文的数据，封装成decodePacket</span></span><br><span class="line">    COAP_SoftBusDecode(&amp;decodePacket, recvBuffer, nRead);</span><br><span class="line">    <span class="comment">//响应远程发现者</span></span><br><span class="line">    PostServiceDiscover(&amp;decodePacket);</span><br><span class="line">    <span class="built_in">free</span>(recvBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>响应的内容是什么？具体来看PostServiceDiscover()：</p>
<p>从对端发来的coap报文中，可解析出对端的ip地址和url，然后将本地设备信息和对端地址组成coap报文，发送给对端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给远程设备发送响应</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostServiceDiscover</span><span class="params">(<span class="type">const</span> COAP_Packet *pkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *remoteUrl = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//从pkt中，可获取对端设备的ip等信息，封装成deviceinfo</span></span><br><span class="line">    DeviceInfo deviceInfo;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)memset_s(&amp;deviceInfo, <span class="keyword">sizeof</span>(deviceInfo), <span class="number">0</span>, <span class="keyword">sizeof</span>(deviceInfo));</span><br><span class="line">    <span class="comment">//解析pkt-&gt;payload.buffer数据到deviceInfo</span></span><br><span class="line">    <span class="keyword">if</span> (GetServiceDiscoverInfo(pkt-&gt;payload.buffer, pkt-&gt;payload.len, &amp;deviceInfo, &amp;remoteUrl) != NSTACKX_EOK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取对端的ip地址</span></span><br><span class="line">    <span class="type">char</span> wifiIpAddr[NSTACKX_MAX_IP_STRING_LEN];</span><br><span class="line">    (<span class="type">void</span>)memset_s(wifiIpAddr, <span class="keyword">sizeof</span>(wifiIpAddr), <span class="number">0</span>, <span class="keyword">sizeof</span>(wifiIpAddr));</span><br><span class="line">    (<span class="type">void</span>)inet_ntop(AF_INET, &amp;deviceInfo.netChannelInfo.wifiApInfo.ip, wifiIpAddr, <span class="keyword">sizeof</span>(wifiIpAddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remoteUrl != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//利用deviceinfo，发送coap报文给对端</span></span><br><span class="line">        CoapResponseService(pkt, remoteUrl, wifiIpAddr);</span><br><span class="line">        <span class="built_in">free</span>(remoteUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送CoapRequest到remoteIp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">CoapResponseService</span><span class="params">(<span class="type">const</span> COAP_Packet *pkt, <span class="type">const</span> <span class="type">char</span>* remoteUrl, <span class="type">const</span> <span class="type">char</span>* remoteIp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">//初始化CoapRequest</span></span><br><span class="line">    CoapRequest coapRequest;</span><br><span class="line">    coapRequest.remoteUrl = remoteUrl;  <span class="comment">//资源地址</span></span><br><span class="line">    coapRequest.remoteIp = remoteIp;    <span class="comment">//ip地址</span></span><br><span class="line">    <span class="comment">//payload包含了本地设备的信息</span></span><br><span class="line">    <span class="type">char</span> *payload = PrepareServiceDiscover();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下就是构建coapRequest</span></span><br><span class="line">    COAP_ReadWriteBuffer sndPktBuff = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    sndPktBuff.readWriteBuf = <span class="built_in">calloc</span>(<span class="number">1</span>, COAP_MAX_PDU_SIZE);</span><br><span class="line">    sndPktBuff.size = COAP_MAX_PDU_SIZE;</span><br><span class="line">    sndPktBuff.len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根据pkt和ip构建coap报文sndPktBuff</span></span><br><span class="line">    ret = BuildSendPkt(pkt, remoteIp, payload, &amp;sndPktBuff);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line">    coapRequest.data = sndPktBuff.readWriteBuf;</span><br><span class="line">    coapRequest.dataLength = sndPktBuff.len;</span><br><span class="line">    <span class="comment">//创建udp客户端并发送coap报文</span></span><br><span class="line">    ret = CoapSendRequest(&amp;coapRequest);</span><br><span class="line">    <span class="built_in">free</span>(sndPktBuff.readWriteBuf);</span><br><span class="line">    sndPktBuff.readWriteBuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>payload的内容就是设备信息，其json格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;deviceId&quot;</span>:[device ID, <span class="built_in">string</span>],</span><br><span class="line">  <span class="string">&quot;deviceName&quot;</span>:[device name, <span class="built_in">string</span>],</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: [device type, number],</span><br><span class="line">  <span class="string">&quot;version&quot;</span>:[hicom version, <span class="built_in">string</span>],</span><br><span class="line">  <span class="string">&quot;wlanIp&quot;</span>:[WLAN IP address, <span class="built_in">string</span>],</span><br><span class="line">  <span class="string">&quot;capabilityBitmap&quot;</span>:[bitmap, bitmap, bitmap, ...]</span><br><span class="line">  <span class="string">&quot;coapUri&quot;</span>:[coap uri <span class="keyword">for</span> discover, <span class="built_in">string</span>]   &lt;-- optional. When present, means it<span class="string">&#x27;s broadcast request.</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>对端在收到这个消息后，就可以会触发回调函数：该函数在dsoftbus中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*OnDeviceFound)(<span class="type">const</span> DeviceInfo *device);</span><br></pre></td></tr></table></figure>

<p>该函数的参数device中就包含了payload中的信息，这样对端就了解了局域网内有什么设备。</p>
<h3 id="2-2、软总线"><a href="#2-2、软总线" class="headerlink" title="2.2、软总线"></a>2.2、软总线</h3><p>上一节的WifiEventTrigger()中，在连接到wifi后，会启动软总线，创建软总线运行所需的资源：</p>
<ul>
<li>回调函数OnConnectEvent：初始化认证相关的结构体</li>
<li>回调函数OnDataEvent：认证数据的处理逻辑（详）</li>
<li>WaitProcess线程：读取g_listenFd，执行回调函数，处理软总线的事务</li>
<li>SelectSessionLoop线程：处理tcp session的事务</li>
<li>AuthManager：设备认证事务</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StartBus</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置软总线的回调函数</span></span><br><span class="line">    g_baseLister.onConnectEvent = OnConnectEvent;</span><br><span class="line">    g_baseLister.onDataEvent = OnDataEvent;</span><br><span class="line">    <span class="comment">//创建 tcp server、WaitProcess线程 用于执行回调函数</span></span><br><span class="line">    <span class="type">int</span> authPort = StartListener(&amp;g_baseLister, info-&gt;deviceIp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建tcp server、SelectSessionLoop线程、用于实现session的回调</span></span><br><span class="line">    <span class="type">int</span> sessionPort = StartSession(info-&gt;deviceIp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存两个tcp server的端口</span></span><br><span class="line">    AuthMngInit(authPort, sessionPort);</span><br><span class="line">    g_busStartFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="2-2-1、SelectSessionLoop"><a href="#2-2-1、SelectSessionLoop" class="headerlink" title="2.2.1、SelectSessionLoop"></a>2.2.1、SelectSessionLoop</h4><p>SelectSessionLoop线程：监听所有session的数据，并处理这些数据。</p>
<p>session是一个建立在tcp传输上的概念，创建一个session的过程如下：</p>
<p>首先A创建一个tcp server，监听连接。B与A建立TCP连接，能够正常传输TCP数据。接着发送特定的TCP数据，建立session连接。所以这里涉及到了两个连接，一个是tcp层的，一个session层的连接。tcp 层的连接建立完成后可以初始化session结构体，其实现在ProcessConnection().Session层的连接在ProcessSesssionData()中完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SelectSessionLoop</span><span class="params">(TcpSessionMgr *tsm)</span></span><br><span class="line">&#123;</span><br><span class="line">    tsm-&gt;isSelectLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        fd_set readfds;	<span class="comment">//用于读取数据</span></span><br><span class="line">        fd_set exceptfds;</span><br><span class="line">        <span class="comment">//等待readfds的消息</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxFd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, &amp;exceptfds, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//处理数据</span></span><br><span class="line">            ProcessData(tsm, &amp;readfds);</span><br><span class="line">    &#125;</span><br><span class="line">    tsm-&gt;isSelectLoopRunning = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理session数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ProcessData</span><span class="params">(TcpSessionMgr *tsm, fd_set *rfds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//listenFd的消息，则表示需要创建tcp session连接</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(tsm-&gt;listenFd, rfds)) &#123;</span><br><span class="line">        ProcessConnection(tsm);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，是tcp session数据</span></span><br><span class="line">    ProcessSesssionData(tsm, rfds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessConnection：完成tcp连接，并初始化session结构体，方便下一阶段建立session使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ProcessConnection</span><span class="params">(TcpSessionMgr *tsm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立tcp 连接</span></span><br><span class="line">    <span class="type">int</span> cfd = accept(tsm-&gt;listenFd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建tcp session</span></span><br><span class="line">    TcpSession *session = CreateTcpSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把authConn的deivceid复制到session</span></span><br><span class="line">    AuthConn* authConn = GetOnLineAuthConnByIp(inet_ntoa(addr.sin_addr));</span><br><span class="line">    <span class="keyword">if</span> (authConn != <span class="literal">NULL</span> &amp;&amp; strncpy_s(session-&gt;deviceId, MAX_DEV_ID_LEN, authConn-&gt;deviceId,</span><br><span class="line">        <span class="built_in">strlen</span>(authConn-&gt;deviceId)) != <span class="number">0</span>) &#123;</span><br><span class="line">        SOFTBUS_PRINT(<span class="string">&quot;[TRANS] Error on copy deviceId of session.&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(session);</span><br><span class="line">        CloseSession(cfd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把tcp连接添加session</span></span><br><span class="line">    session-&gt;fd = cfd;</span><br><span class="line">    <span class="comment">//把session给sessionmgr管理</span></span><br><span class="line">    <span class="type">int</span> result = AddSession(tsm, session);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessSesssionData：初始化完成session后，接收到session数据。有两种session数据类型，一种是请求建立session，一种是正常的session数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ProcessSesssionData</span><span class="params">(<span class="type">const</span> TcpSessionMgr *tsm, <span class="type">const</span> fd_set *rfds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历所有的tcp session，找到fd对应的session</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SESSION_SUM_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tsm-&gt;sessionMap_[i] != <span class="literal">NULL</span> &amp;&amp; tsm-&gt;sessionMap_[i]-&gt;fd != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            FD_ISSET(tsm-&gt;sessionMap_[i]-&gt;fd, rfds) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//处理对应session数据</span></span><br><span class="line">            <span class="keyword">if</span> (!OnProcessDataAvailable(tsm-&gt;sessionMap_[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理tcp session的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">OnProcessDataAvailable</span><span class="params">(TcpSession *session)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//name是softbus_Lite_unknown 说明是对方发起session连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(session-&gt;sessionName, <span class="string">&quot;softbus_Lite_unknown&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//处理session连接请求，响应请求，执行回调函数onSessionOpened</span></span><br><span class="line">        <span class="type">bool</span> isSuccess = HandleRequestMsg(session);</span><br><span class="line">        <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">            CloseSession(session-&gt;fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//已经建立了session 正常接收数据</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* buf = <span class="built_in">calloc</span>(<span class="number">1</span>, RECIVED_BUFF_SIZE);</span><br><span class="line"></span><br><span class="line">        SessionListenerMap *sessionListener = GetSessionListenerByName(session-&gt;sessionName,</span><br><span class="line">            <span class="built_in">strlen</span>(session-&gt;sessionName));</span><br><span class="line">        <span class="keyword">if</span> (sessionListener != <span class="literal">NULL</span> &amp;&amp; sessionListener-&gt;listener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//读取session数据</span></span><br><span class="line">            <span class="type">int</span> recvLen = TcpSessionRecv(session, (<span class="type">char</span> *)buf, RECIVED_BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行session的回调函数，处理 接收数据</span></span><br><span class="line">            sessionListener-&gt;listener-&gt;onBytesReceived(session-&gt;fd, buf, recvLen);</span><br><span class="line">            <span class="built_in">free</span>(buf);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2、WaitProcess"><a href="#2-2-2、WaitProcess" class="headerlink" title="2.2.2、WaitProcess"></a>2.2.2、WaitProcess</h4><p>WaitProcess线程，他的任务是监听g_listenFd，并处理软总线上的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待建立socket，并回调成功建立</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">WaitProcess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//等待g_listenFd 的数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(g_maxFd + <span class="number">1</span>, &amp;readSet, <span class="literal">NULL</span>, &amp;readSet, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//处理g_listenFd的数据</span></span><br><span class="line">            <span class="keyword">if</span> (!ProcessAuthData(g_listenFd, &amp;readSet)) &#123;</span><br><span class="line">                StopListener();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理softbus数据 建立socket 回调g_baseLister</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">ProcessAuthData</span><span class="params">(<span class="type">int</span> listenFd, <span class="type">const</span> fd_set *readSet)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//listenFd是否在readSet，即listenFd是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenFd, readSet)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrClient</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">socklen_t</span> addrLen = <span class="keyword">sizeof</span>(addrClient);</span><br><span class="line">        <span class="comment">//建立tcp连接</span></span><br><span class="line">        g_dataFd = accept(listenFd, (<span class="keyword">struct</span> sockaddr *)(&amp;addrClient), &amp;addrLen);</span><br><span class="line">        <span class="comment">//更新g_dataFd</span></span><br><span class="line">        RefreshMaxFd(g_dataFd);</span><br><span class="line">        <span class="comment">//执行回调函数： 连接成功 OnConnectEvent</span></span><br><span class="line">        <span class="keyword">if</span> (g_callback-&gt;onConnectEvent(g_dataFd, inet_ntoa(addrClient.sin_addr)) != <span class="number">0</span>) &#123;</span><br><span class="line">            CloseAuthSessionFd(g_dataFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行回调函数：数据接收 OnDataEvent</span></span><br><span class="line">    <span class="keyword">if</span> (g_dataFd &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(g_dataFd, readSet)) &#123;</span><br><span class="line">        g_callback-&gt;onDataEvent(g_dataFd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3、OnConnectEvent"><a href="#2-2-3、OnConnectEvent" class="headerlink" title="2.2.3、OnConnectEvent"></a>2.2.3、OnConnectEvent</h4><p>重要的结构体，负责认证的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AuthConn</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> authId[MAX_AUTH_ID_LEN];	<span class="comment">//？</span></span><br><span class="line">    <span class="type">char</span> deviceId[MAX_DEV_ID_LEN];</span><br><span class="line">    <span class="type">char</span> deviceIp[MAX_DEV_IP_LEN];</span><br><span class="line">    <span class="type">int</span> busVersion;</span><br><span class="line">    <span class="type">int</span> authPort;					<span class="comment">//软总线上的认证tcp端口</span></span><br><span class="line">    <span class="type">int</span> sessionPort;				<span class="comment">//软总线上的session端口</span></span><br><span class="line">    <span class="type">int</span> authState;					</span><br><span class="line">    <span class="type">int</span> onlineState;</span><br><span class="line">    DataBuffer db;</span><br><span class="line">&#125; AuthConn;</span><br></pre></td></tr></table></figure>



<p>软总线在收到连接事件后，回调OnDataEvent()，设置aconn对象的ip和fd。aconn会在OnDataEvent()中大放异彩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将fd、ip赋值给对应的AuthConn</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessConnectEvent</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    SOFTBUS_PRINT(<span class="string">&quot;[AUTH] ProcessConnectEvent fd = %d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || ip == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取 aconn,若不为NULL，说明已经认证过了</span></span><br><span class="line">    AuthConn *aconn = FindAuthConnByFd(fd);</span><br><span class="line">    <span class="keyword">if</span> (aconn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        CloseConn(aconn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//还未认证，设置aconn</span></span><br><span class="line">    aconn = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(AuthConn));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制ip、fd给aconn</span></span><br><span class="line">    <span class="type">int</span> ret = strcpy_s(aconn-&gt;deviceIp, <span class="keyword">sizeof</span>(aconn-&gt;deviceIp), ip);</span><br><span class="line">    </span><br><span class="line">    aconn-&gt;fd = fd;</span><br><span class="line">    <span class="comment">//把 aconn 添加到 g_fdMap 数组</span></span><br><span class="line">    ret = AddAuthConnToList(aconn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4、OnDataEvent"><a href="#2-2-4、OnDataEvent" class="headerlink" title="2.2.4、OnDataEvent"></a>2.2.4、OnDataEvent</h4><p>当软总线建立与设备的authconn后就可进行认证，具体的方式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从tcp端口读取数据包，并解析</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessDataEvent</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取authconn</span></span><br><span class="line">    AuthConn *conn = FindAuthConnByFd(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请buf</span></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;db.buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        conn-&gt;db.buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(DEFAULT_BUF_SIZE);</span><br><span class="line">        (<span class="type">void</span>)memset_s(conn-&gt;db.buf, DEFAULT_BUF_SIZE, <span class="number">0</span>, DEFAULT_BUF_SIZE);</span><br><span class="line">        conn-&gt;db.size = DEFAULT_BUF_SIZE;</span><br><span class="line">        conn-&gt;db.used = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataBuffer *db = &amp;conn-&gt;db;</span><br><span class="line">    <span class="type">char</span> *buf = db-&gt;buf;</span><br><span class="line">    <span class="type">int</span> used = db-&gt;used;</span><br><span class="line">    <span class="type">int</span> size = db-&gt;size;</span><br><span class="line">    <span class="comment">//接收认证数据到buf</span></span><br><span class="line">    <span class="type">int</span> rc = AuthConnRecv(fd, buf, used, size - used, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    used += rc;</span><br><span class="line">    <span class="comment">//解析tcp包头，处理包内信息</span></span><br><span class="line">    <span class="type">int</span> processed = ProcessPackets(conn, buf, size, used);</span><br><span class="line"></span><br><span class="line">    db-&gt;used = used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessPackets：根据module参数对软总线的数据分支处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析tcp包头，处理包内信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ProcessPackets</span><span class="params">(AuthConn *conn, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">int</span> used)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (processed + PACKET_HEAD_SIZE &lt; used) &#123;</span><br><span class="line">        <span class="comment">//将buf首部数据转换成packet</span></span><br><span class="line">        Packet *pkt = ParsePacketHead(buf, processed, used - processed, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有效数据长度</span></span><br><span class="line">        <span class="type">int</span> len = pkt-&gt;dataLen;</span><br><span class="line">        <span class="comment">//处理了buf的首部数据 </span></span><br><span class="line">        processed += PACKET_HEAD_SIZE;</span><br><span class="line">        <span class="comment">//处理payload数据</span></span><br><span class="line">        OnDataReceived(conn, pkt, buf + processed);</span><br><span class="line">        processed += len;</span><br><span class="line">        <span class="built_in">free</span>(pkt);</span><br><span class="line">        pkt = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分支处理对端发来的认证数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OnDataReceived</span><span class="params">(AuthConn *conn, <span class="type">const</span> Packet *pkt, <span class="type">const</span> <span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//module == MODULE_AUTH_SDK</span></span><br><span class="line">    <span class="keyword">if</span> ((pkt-&gt;module &gt; MODULE_HICHAIN) &amp;&amp; (pkt-&gt;module &lt;= MODULE_AUTH_SDK)) &#123;</span><br><span class="line">        <span class="comment">//建立AuthSession，处理认证逻辑</span></span><br><span class="line">        AuthInterfaceOnDataReceived(conn, pkt-&gt;module, pkt-&gt;seq, data, pkt-&gt;dataLen);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cJSON *msg = DecryptMessage(pkt-&gt;module, data, pkt-&gt;dataLen);</span><br><span class="line">    <span class="comment">//建立连接或完成认证</span></span><br><span class="line">    OnModuleMessageReceived(conn, pkt-&gt;module, pkt-&gt;flags, pkt-&gt;seq, msg);</span><br><span class="line">    cJSON_Delete(msg);</span><br><span class="line">    msg = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AuthInterfaceOnDataReceived"><a href="#AuthInterfaceOnDataReceived" class="headerlink" title="AuthInterfaceOnDataReceived"></a>AuthInterfaceOnDataReceived</h5><p>完成设备认证，其过程是：对端设备发送数据给本地的安全子系统的设备认证模块，设备认证模块负责处理数据，判断是否通过认证。</p>
<p>这里数据传输的方式就是使用 就是session</p>
<p>module的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_TRUST_ENGINE 1    <span class="comment">//可信类型，直接进行数据传输</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_HICHAIN 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_AUTH_SDK 3    <span class="comment">//加密数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_HICHAIN_SYNC 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_CONNECTION 5	<span class="comment">//进行ip及设备认证</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_SESSION 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_SMART_COMM 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_AUTH_CHANNEL 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_AUTH_MSG 9</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立认证session，处理认证逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AuthInterfaceOnDataReceived</span><span class="params">(<span class="type">const</span> AuthConn *conn, <span class="type">int</span> module, <span class="type">long</span> <span class="type">long</span> seqId, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> dataLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建authsession数组，authsession是一个会话，负责认证逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (AuthSessionMapInit() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化指定auth session</span></span><br><span class="line">    AuthSession *auth = AuthGetAuthSessionBySeqId(seqId);</span><br><span class="line">    <span class="keyword">if</span> (auth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//获取失败，将conn添加到g_authSessionMap</span></span><br><span class="line">        auth = AuthGetNewAuthSession(conn, seqId, g_authSessionId);</span><br><span class="line">        ++g_authSessionId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对不同模组使用不同认证方式</span></span><br><span class="line">    <span class="keyword">switch</span> (module) &#123;</span><br><span class="line">        <span class="keyword">case</span> MODULE_AUTH_SDK:</span><br><span class="line">            <span class="comment">//使用hichain处理auth数据</span></span><br><span class="line">            AuthProcessReceivedData(auth-&gt;sessionId, data, dataLen);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用安全子系统的设备认证模块，来完成对端设备的数据的认证</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AuthProcessReceivedData</span><span class="params">(<span class="type">uint32_t</span> sessionId, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> dataLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (g_hcHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化hichain，hichain是设备认证模块要使用的对象</span></span><br><span class="line">        <span class="keyword">if</span> (AuthInitHiChain(sessionId) != <span class="number">0</span>) &#123;</span><br><span class="line">            AuthDelAuthSessionBySessionId(sessionId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uint8_buff</span> <span class="title">request</span> =</span> &#123;(<span class="type">uint8_t</span> *)data, dataLen, dataLen&#125;;</span><br><span class="line">    <span class="comment">//把数据传递给安全认证子系统，处理的结果会通过回调函数反馈</span></span><br><span class="line">    <span class="keyword">if</span> (receive_data(g_hcHandle, &amp;request) != HC_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="OnModuleMessageReceived"><a href="#OnModuleMessageReceived" class="headerlink" title="OnModuleMessageReceived"></a>OnModuleMessageReceived</h5><p>处理可信设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理module消息</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OnModuleMessageReceived</span><span class="params">(AuthConn *conn, <span class="type">int</span> module, <span class="type">int</span> flags, <span class="type">long</span> <span class="type">long</span> seq, <span class="type">const</span> cJSON *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (module) &#123;</span><br><span class="line">        <span class="comment">//可信类型，能直接进行数据传输</span></span><br><span class="line">        <span class="keyword">case</span> MODULE_TRUST_ENGINE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (((<span class="type">unsigned</span> <span class="type">int</span>)flags &amp; FLAG_REPLY) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//通过发送本地deviceid 使通道建立？</span></span><br><span class="line">                OnMsgOpenChannelReq(conn, seq, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接类型，需要进行ip及设备认证</span></span><br><span class="line">        <span class="keyword">case</span> MODULE_CONNECTION: &#123;</span><br><span class="line">            OnMessageReceived(conn, seq, msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证设备的ip或deviceid</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OnMessageReceived</span><span class="params">(AuthConn *conn, <span class="type">long</span> <span class="type">long</span> seq, <span class="type">const</span> cJSON *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *codeJson = cJSON_GetObjectItem(msg, <span class="string">&quot;CODE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> code = codeJson-&gt;valueint;</span><br><span class="line">    <span class="comment">//回复对端</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> CODE_VERIIFY_IP: &#123;</span><br><span class="line">            OnVerifyIp(conn, seq, msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CODE_VERIFY_DEVID: &#123;</span><br><span class="line">            OnVerifyDeviceId(conn, seq, msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题待解决"><a href="#问题待解决" class="headerlink" title="问题待解决"></a>问题待解决</h2><h4 id="hichain的认证过程"><a href="#hichain的认证过程" class="headerlink" title="hichain的认证过程"></a>hichain的认证过程</h4><p>hichain的认证目前没有找到文档，只能通过源码，猜测以下内容：初始化hichain所需要的对象，软总线作为一个媒介，在hichain和对端设备之间传递数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化hichain</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">AuthInitHiChain</span><span class="params">(<span class="type">uint32_t</span> sessionId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">session_identity</span> <span class="title">serverIdentity</span> =</span> &#123;</span><br><span class="line">        sessionId,</span><br><span class="line">        &#123;AUTH_DEFAULT_ID_LEN, AUTH_DEFAULT_ID&#125;,</span><br><span class="line">        &#123;AUTH_DEFAULT_ID_LEN, AUTH_DEFAULT_ID&#125;,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//定义设备认证回调函数，会在安全子系统中得到执行 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hc_call_back</span> <span class="title">hiChainCallback</span> =</span> &#123;</span><br><span class="line">        AuthOnTransmit,         <span class="comment">//发送hichain的数据</span></span><br><span class="line">        AuthGetProtocolParams,  <span class="comment">//获取会话id</span></span><br><span class="line">        AuthSetSessionKey,      <span class="comment">//保存hc_session_key</span></span><br><span class="line">        AuthSetServiceResult,   <span class="comment">//认证结果回调</span></span><br><span class="line">        AuthConfirmReceiveRequest</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//获取hichain，HC_ACCESSORY表示本地是附属设备，收超级终端控制</span></span><br><span class="line">    g_hcHandle = get_instance(&amp;serverIdentity, HC_ACCESSORY, &amp;hiChainCallback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcp-server-连接过程"><a href="#tcp-server-连接过程" class="headerlink" title="tcp server 连接过程"></a>tcp server 连接过程</h4><p>OnModuleMessageReceived()函数处理的是什么逻辑？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/softbus_lite/" data-id="cmbcy7rhp002pt8mt9z4d77kt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/31/killer-blog/OpenHarmony/tmp/netdev/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/05/31/killer-blog/OpenHarmony/purple_pi_build/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
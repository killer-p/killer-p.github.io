<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="net框架openharmony使用netdev来描述所有的网络设备。源码在&#x2F;drivers&#x2F;framework&#x2F;model&#x2F;network&#x2F;common&#x2F; NetDevice抽象的描述网络设备：Defines a network device, including the network interface category and n">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/05/31/killer-blog/OpenHarmony/tmp/netdev/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="net框架openharmony使用netdev来描述所有的网络设备。源码在&#x2F;drivers&#x2F;framework&#x2F;model&#x2F;network&#x2F;common&#x2F; NetDevice抽象的描述网络设备：Defines a network device, including the network interface category and n">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-31T02:36:45.833Z">
<meta property="article:modified_time" content="2025-06-01T00:19:46.499Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/OpenHarmony/tmp/netdev" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/tmp/netdev/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.833Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="net框架"><a href="#net框架" class="headerlink" title="net框架"></a>net框架</h2><p>openharmony使用netdev来描述所有的网络设备。源码在&#x2F;drivers&#x2F;framework&#x2F;model&#x2F;network&#x2F;common&#x2F;</p>
<h3 id="NetDevice"><a href="#NetDevice" class="headerlink" title="NetDevice"></a>NetDevice</h3><p>抽象的描述网络设备：Defines a network device, including the network interface category and name, and network port type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> &#123;</span></span><br><span class="line">    NetIfCategory netifCateg;                 <span class="comment">/**&lt; LITE_OS or FULL_OS */</span></span><br><span class="line">    <span class="type">char</span> name[IFNAMSIZ];                      <span class="comment">/**&lt; Network device name &#123;@link IFNAMSIZ&#125; */</span></span><br><span class="line">    NetLinkType LinkLayerType;                <span class="comment">/**&lt; Data link layer type：ETHERNET_LINK or WIFI_LINK */</span></span><br><span class="line">    IfType funType;                           <span class="comment">/**&lt; Network port type */</span></span><br><span class="line">    <span class="type">uint8_t</span> macAddr[MAC_ADDR_SIZE];           <span class="comment">/**&lt; MAC address &#123;@link MAC_ADDR_SIZE&#125; */</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceInterFace</span> *<span class="title">netDeviceIf</span>;</span>   <span class="comment">/**&lt; Network device interface */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">owner</span>;</span>                  <span class="comment">/**&lt; Network device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevStats</span> <span class="title">stats</span>;</span>                 <span class="comment">/**&lt; Network statistics */</span></span><br><span class="line">&#125; NetDevice;</span><br></pre></td></tr></table></figure>

<h3 id="NetDeviceInterFace"><a href="#NetDeviceInterFace" class="headerlink" title="NetDeviceInterFace"></a>NetDeviceInterFace</h3><p>NetDeviceInterFace是负责对接 wifi芯片驱动程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Defines interfaces that need to be implemented externally by network devices, including initializing,</span></span><br><span class="line"><span class="comment"> * opening, and closing a network device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceInterFace</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*init)(<span class="keyword">struct</span> NetDevice *netDev);  <span class="comment">/**&lt; Initializes a network device to be added. */</span></span><br><span class="line">    <span class="type">void</span> (*deInit)(<span class="keyword">struct</span> NetDevice *netDev);   <span class="comment">/**&lt; Deinitializes a network device to be delete. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*open)(<span class="keyword">struct</span> NetDevice *netDev);  <span class="comment">/**&lt; Opens the data link layer. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*stop)(<span class="keyword">struct</span> NetDevice *netDev);  <span class="comment">/**&lt; Closes the data link layer. */</span></span><br><span class="line">    NetDevTxResult (*xmit)(<span class="keyword">struct</span> NetDevice *netDev, NetBuf *netBuff);        <span class="comment">/**&lt; Sends data. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*ioctl)(<span class="keyword">struct</span> NetDevice *netDev, IfReq *req, <span class="type">int32_t</span> cmd);      <span class="comment">/**&lt; Used for the control command word. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*setMacAddr)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">void</span> *addr);              <span class="comment">/**&lt; Sets the MAC address. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevStats</span> *(*<span class="title">getStats</span>)(<span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netDev</span>);</span>                <span class="comment">/**&lt; Obtains the statistics. */</span></span><br><span class="line">    <span class="type">void</span> (*setNetIfStatus)(<span class="keyword">struct</span> NetDevice *netDev, NetIfStatus status);     <span class="comment">/**&lt; Sets the network port status. */</span></span><br><span class="line">    <span class="type">uint16_t</span> (*selectQueue)(<span class="keyword">struct</span> NetDevice *netDev, NetBuf *netBuff);       <span class="comment">/**&lt; Selects a priority queue. */</span></span><br><span class="line">    <span class="type">uint32_t</span> (*netifNotify)(<span class="keyword">struct</span> NetDevice *netDev, NetDevNotify *notify);  <span class="comment">/**&lt; Notifies the network port status. */</span></span><br><span class="line">    <span class="type">int32_t</span> (*changeMtu)(<span class="keyword">struct</span> NetDevice *netDev, <span class="type">int32_t</span> newMtu);           <span class="comment">/**&lt; Changes the maximum number of</span></span><br><span class="line"><span class="comment">                                                                               * transmission units.</span></span><br><span class="line"><span class="comment">                                                                               */</span></span><br><span class="line">    <span class="type">void</span> (*linkStatusChanged)(<span class="keyword">struct</span> NetDevice *netDev);    <span class="comment">/**&lt; Detects the change of</span></span><br><span class="line"><span class="comment">                                                             * the Ethernet port connection status.</span></span><br><span class="line"><span class="comment">                                                             */</span></span><br><span class="line">    ProcessingResult (*specialEtherTypeProcess)(<span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDev, NetBuf *buff);</span><br><span class="line">                                                                              <span class="comment">/**&lt; Performs private processing without</span></span><br><span class="line"><span class="comment">                                                                               * involving network-layer data.</span></span><br><span class="line"><span class="comment">                                                                               */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="NetDeviceImpl"><a href="#NetDeviceImpl" class="headerlink" title="NetDeviceImpl"></a>NetDeviceImpl</h3><p>NetDeviceImpl 包括 NetDevice，以及 NetDeviceImplOp ，NetDeviceImplOp的作用是对接lwip协议栈。</p>
<p>所以NetDeviceImpl 就是芯片驱动程序 和 lwip协议栈沟通的中介。</p>
<p>为什么需要这个东西呢？因为lwip处理的数据类型是pbuf，而在opneharmony中处理网络数据的类型netbuf，lwip对网口的定义是netif，而openharmony对网口的定义是netdev,所以这中间需要有一个互相转换，NetDeviceImpl就是干这事。</p>
<p>该部分的代码在bearpi_micro&#x2F;drivers&#x2F;adapter&#x2F;khdf&#x2F;liteos&#x2F;network&#x2F;src&#x2F;net_device_adapter.c，net_device_adapter顾名思义就是把net_device的适配器，适配到lwip。同理netbuf_adapter.c实现的就是把netbuf转换成pbuf。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImpl</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netDevice</span>;</span>	<span class="comment">//netDevice-&gt;NetDeviceInterFace 调用芯片驱动程序接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImplOp</span> *<span class="title">interFace</span>;</span>	<span class="comment">//调用lwip的接口</span></span><br><span class="line">    <span class="type">void</span> *osPrivate;	<span class="comment">//指向 lwip的netif对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImplOp</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*init)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*deInit)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*add)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*delete)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*setStatus)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetIfStatus status);</span><br><span class="line">    <span class="type">int32_t</span> (*setLinkStatus)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetIfLinkStatus status);</span><br><span class="line">    <span class="type">int32_t</span> (*getLinkStatus)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetIfLinkStatus *status);</span><br><span class="line">    <span class="type">int32_t</span> (*receive)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, NetBuf *buff, ReceiveFlag flag);</span><br><span class="line">    <span class="type">int32_t</span> (*setIpAddr)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, <span class="type">const</span> IpV4Addr *ipAddr, <span class="type">const</span> IpV4Addr *netMask,</span><br><span class="line">        <span class="type">const</span> IpV4Addr *gw);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpsStart)(<span class="keyword">struct</span> NetDeviceImpl *netDevice, <span class="type">char</span> *ip, <span class="type">uint16_t</span> ipNum);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpsStop)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpStart)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpStop)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*dhcpIsBound)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">    <span class="type">int32_t</span> (*changeMacAddr)(<span class="keyword">struct</span> NetDeviceImpl *netDevice);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImplOp</span> <span class="title">g_liteNdImplOps</span> =</span> &#123;</span><br><span class="line">    .init = LiteNetDevInit,</span><br><span class="line">    .deInit = LiteNetDevDeInit,</span><br><span class="line">    .add = LiteNetDevAdd,</span><br><span class="line">    .delete = LiteNetDevDelete,</span><br><span class="line">    .setStatus = LiteNetDevSetStatus,</span><br><span class="line">    .setLinkStatus = LiteNetDevSetLinkStatus,</span><br><span class="line">    .getLinkStatus = LiteNetDevGetLinkStatus,</span><br><span class="line">    .receive = LiteNetDevReceive,</span><br><span class="line">    .setIpAddr = LiteNetSetIpAddr,</span><br><span class="line">    .dhcpsStart = LiteNetDhcpsStart,</span><br><span class="line">    .dhcpsStop = LiteNetDhcpsStop,</span><br><span class="line">    .dhcpStart = LiteNetDhcpStart,</span><br><span class="line">    .dhcpStop = LiteNetDhcpStop,</span><br><span class="line">    .dhcpIsBound = LiteNetDhcpIsBound,</span><br><span class="line">    .changeMacAddr = LiteNetChangeMacAddr,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="数据输入到lwip"><a href="#数据输入到lwip" class="headerlink" title="数据输入到lwip"></a>数据输入到lwip</h3><p>把网卡驱动程序接受到的数据传递给lwip协议栈</p>
<p>在数据链路层接受到以太网数据包后，调用 NetDeviceImplOp-&gt;receive()：</p>
<p>将netbuff类型的数据转换成lwip能处理的pbuf类型数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevReceive</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl, <span class="keyword">struct</span> NetBuf *buff, ReceiveFlag flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">lwipNf</span> =</span> GetNetIfFromDevImpl(netDeviceImpl);</span><br><span class="line">    ProcessingResult ret = LiteNetDevDataFilter(netDeviceImpl, buff);</span><br><span class="line">    <span class="keyword">if</span> (ret == PROCESSING_CONTINUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> LiteNetDevDataReceive(netDeviceImpl, buff);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == PROCESSING_COMPLETE) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevDataReceive</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl, <span class="keyword">struct</span> NetBuf *buff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">lwipNf</span> =</span> GetNetIfFromDevImpl(netDeviceImpl);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">pBuff</span> =</span> ConverNetBufToPBuf(buff);</span><br><span class="line"></span><br><span class="line">    driverif_input(lwipNf, pBuff);</span><br><span class="line">    NetBufFree(buff);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用driverif_input将数据传递给lwip协议线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function should be called by network driver to pass the input packet to LwIP.</span></span><br><span class="line"><span class="comment"> * Before calling this API, driver has to keep the packet in pbuf structure. Driver has to</span></span><br><span class="line"><span class="comment"> * call pbuf_alloc() with type as PBUF_RAM to create pbuf structure. Then driver</span></span><br><span class="line"><span class="comment"> * has to pass the pbuf structure to this API. This will add the pbuf into the TCPIP thread.</span></span><br><span class="line"><span class="comment"> * Once this packet is processed by TCPIP thread, pbuf will be freed. Driver is not required to</span></span><br><span class="line"><span class="comment"> * free the pbuf.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param netif the lwip network interface structure for this driverif</span></span><br><span class="line"><span class="comment"> * @param p packet in pbuf structure format</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">driverif_input</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> pbuf *p)</span></span><br></pre></td></tr></table></figure>

<p>回溯：LiteNetDevReceive()的调用需要跟踪到NetDeviceImplOp，NetDeviceImplOp需要跟踪到NetDeviceImpl</p>
<p>而GetImplByNetDevice()可以获取到NetDeviceImpl，所以追踪GetImplByNetDevice()，可以找到函数NetIfRxImpl</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">NetIfRxImpl</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDevice, NetBuf *buff, ReceiveFlag flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImpl</span> *<span class="title">ndImpl</span> =</span> GetImplByNetDevice(netDevice);</span><br><span class="line">    ProcessingResult ret = PROCESSING_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to do driver special process */</span></span><br><span class="line">    <span class="keyword">if</span> (netDevice-&gt;netDeviceIf != <span class="literal">NULL</span> &amp;&amp; netDevice-&gt;netDeviceIf-&gt;specialEtherTypeProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = netDevice-&gt;netDeviceIf-&gt;specialEtherTypeProcess(netDevice, buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Sent to TCP/IP Stack. */</span></span><br><span class="line">    <span class="keyword">if</span> (ret == PROCESSING_CONTINUE) &#123;</span><br><span class="line">        <span class="comment">//call LiteNetDevReceive()</span></span><br><span class="line">        <span class="keyword">return</span> ndImpl-&gt;interFace-&gt;receive(ndImpl, buff, flag);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == PROCESSING_COMPLETE) &#123;</span><br><span class="line">        HDF_LOGI(<span class="string">&quot;NetIfRxImpl specialEtherType Process not need TCP/IP stack!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s: NetIfRxImpl specialEtherType Process error&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Transfers the input data packets from the network side to a protocol stack.</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">NetIfRx</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDevice, NetBuf *buff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NetIfRxImpl(netDevice, buff, IN_INTERRUPT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Transfers data packets from the network side to a protocol stack in an interrupt processing thread.</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">NetIfRxNi</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDevice, NetBuf *buff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NetIfRxImpl(netDevice, buff, NO_IN_INTERRUPT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hcc_to_hmac_control_event_dispatch-&gt;hcc_hmac_rx_event_handle-&gt;hmac_from_dmac_rx_data_handle-&gt;g_ast_hmac_wlan_drx_event_sub_table[DMAC_WLAN_DRX_EVENT_SUB_TYPE_RX_AP].func &#x3D; hmac_rx_process_data_ap;</p>
<p>hmac_rx_process_data_ap()-&gt;hmac_rx_process_data_ap_tcp_ack_opt()-&gt;hmac_rx_lan_frame_classify()-&gt;hmac_rx_msdu_frame_classify()-&gt;hmac_rx_transmit_msdu_to_lan()-&gt;oal_netif_rx_ni()-&gt;NetIfRx()-&gt;NetIfRxImpl()-&gt;GetImplByNetDevice()-&gt;NetDeviceImpl()-&gt;&gt;LiteNetDevReceive()</p>
<h4 id="flow-control-调用链"><a href="#flow-control-调用链" class="headerlink" title="flow control 调用链"></a>flow control 调用链</h4><p>fcm-&gt;op-&gt;rxDataPacket(q, fcm-&gt;fcmPriv, rxPriorityId);</p>
<p>.rxDataPacket &#x3D; hcc_host_proc_rx_queue_impl</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">hi_s32 <span class="title function_">hcc_host_proc_rx_queue_impl</span><span class="params">(oal_netbuf_head_stru *head, <span class="type">void</span> *handler, <span class="type">int32_t</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    hcc_handler_stru *hcc_handler = (hcc_handler_stru *)handler;</span><br><span class="line">    hi_s32 count = <span class="number">0</span>;</span><br><span class="line">    hi_s32 pre_ret = HI_SUCCESS;</span><br><span class="line">    hi_u8 *pre_context = HI_NULL;</span><br><span class="line">    oal_netbuf_head_stru *netbuf_head = HI_NULL;</span><br><span class="line">    oal_netbuf_stru *netbuf = HI_NULL;</span><br><span class="line">    hcc_header_stru *hcc_hdr = HI_NULL;</span><br><span class="line">    hcc_netbuf_stru hcc_netbuf;</span><br><span class="line">    hcc_rx_action_stru *rx_action = HI_NULL;</span><br><span class="line">    netbuf_head = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        netbuf = oal_netbuf_delist(netbuf_head);</span><br><span class="line">        <span class="keyword">if</span> (netbuf == HI_NULL) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hcc_hdr = (hcc_header_stru *)oal_netbuf_data(netbuf);</span><br><span class="line">        <span class="keyword">if</span> (hcc_host_check_header_vaild(hcc_hdr) != HI_TRUE) &#123;</span><br><span class="line">            oal_print_hex_dump((hi_u8 *)hcc_hdr, HCC_HDR_TOTAL_LEN, <span class="number">16</span>, <span class="string">&quot;invalid hcc header: &quot;</span>); <span class="comment">/* 16进制 */</span></span><br><span class="line">            oam_error_log0(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;hcc_host_send_rx_queue:: invalid hcc_header&quot;</span>);</span><br><span class="line">            count++;</span><br><span class="line">            oal_netbuf_free(netbuf);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        rx_action = &amp;hcc_handler-&gt;hcc_transer_info.rx_action_info.action[hcc_hdr-&gt;main_type];</span><br><span class="line">        pre_ret = HI_SUCCESS;</span><br><span class="line">        <span class="keyword">if</span> (rx_action-&gt;pre_do != HI_NULL) &#123;</span><br><span class="line">            hcc_netbuf.pst_netbuf = netbuf;</span><br><span class="line">            hcc_netbuf.len = (hi_s32)oal_netbuf_len(netbuf);</span><br><span class="line">            pre_ret = rx_action-&gt;pre_do(hcc_hdr-&gt;sub_type, &amp;hcc_netbuf, &amp;pre_context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre_ret == HI_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hcc_host_rx(hcc_handler, netbuf) == HI_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rx_action-&gt;post_do != HI_NULL) &#123;</span><br><span class="line">                    hcc_netbuf.pst_netbuf = netbuf;</span><br><span class="line">                    hcc_netbuf.len = (hi_s32)oal_netbuf_len(netbuf);</span><br><span class="line">                    rx_action-&gt;post_do(hcc_hdr-&gt;sub_type, &amp;hcc_netbuf, pre_context);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    oam_error_log2(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;hcc_host_send_rx_queue:: post_do is null, hcc_main_type[%d], sub_type[%d]&quot;</span>,</span><br><span class="line">                        hcc_hdr-&gt;main_type, hcc_hdr-&gt;sub_type);</span><br><span class="line">                    oal_print_hex_dump((hi_u8 *)hcc_hdr, HCC_HDR_TOTAL_LEN, <span class="number">32</span>, <span class="string">&quot;hcc invalid header: &quot;</span>); <span class="comment">/* len 32 */</span></span><br><span class="line">                    oal_print_hex_dump(oal_netbuf_data(netbuf), (hi_s32)oal_netbuf_len(netbuf), <span class="number">32</span>,</span><br><span class="line">                        <span class="string">&quot;hcc invalid header(payload): &quot;</span>); <span class="comment">/* 32 进制 */</span></span><br><span class="line">                    oal_netbuf_free(netbuf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oal_netbuf_free(netbuf);</span><br><span class="line">            &#125;</span><br><span class="line">            hcc_handler-&gt;hcc_transer_info.hcc_queues[HCC_RX].queues[type].total_pkts++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* keep the netbuf in list and skip the loop */</span></span><br><span class="line">            oal_netbuf_addlist(netbuf_head, netbuf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="lwip数据输出到网卡"><a href="#lwip数据输出到网卡" class="headerlink" title="lwip数据输出到网卡"></a>lwip数据输出到网卡</h3><p>首先介绍如何创建一个lwip下的抽象的网卡设备netif</p>
<p>调用 NetDeviceImplOp-&gt;add()来创建一个新的netif，并给这个netif设置mac地址，netif的发送函数、设置mac地址函数，并添加到lwip协议栈中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">LiteNetDevAdd</span><span class="params">(<span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceAdapterLite</span> *<span class="title">liteNdPri</span> =</span> (<span class="keyword">struct</span> NetDeviceAdapterLite *)netDeviceImpl-&gt;osPrivate;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">lwipNd</span> =</span> netDeviceImpl-&gt;netDevice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">lwipNf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    lwipNf = CreateLwipNetIf(netDeviceImpl, lwipNd);</span><br><span class="line">    <span class="type">ip4_addr_t</span> gw, ipaddr, netmask;</span><br><span class="line">    IP4_ADDR(&amp;gw, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    IP4_ADDR(&amp;ipaddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    IP4_ADDR(&amp;netmask, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = netifapi_netif_add(lwipNf, &amp;ipaddr, &amp;netmask, &amp;gw)) != ERR_OK) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s : netifapi_netif_add fail!,ret=%d&quot;</span>, __func__, ret);</span><br><span class="line">        DestroyLwipNetIf(lwipNf);</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* copy MAC ADDR TO LWIP */</span></span><br><span class="line">    <span class="keyword">if</span> (memcpy_s(lwipNf-&gt;hwaddr, NETIF_MAX_HWADDR_LEN, lwipNd-&gt;macAddr, MAC_ADDR_SIZE) != EOK) &#123;</span><br><span class="line">        <span class="keyword">return</span> HDF_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    liteNdPri-&gt;lwipNetif = lwipNf;</span><br><span class="line">    IpV6SpecialProc(lwipNd, lwipNf);</span><br><span class="line">    <span class="comment">/* set netif default status */</span></span><br><span class="line">    netifapi_netif_set_default(lwipNf);</span><br><span class="line">    netif_set_link_callback(lwipNf, LiteNetifLinkChangeCallback);</span><br><span class="line">    HDF_LOGI(<span class="string">&quot;%s success!!&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> HDF_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> netif *<span class="title function_">CreateLwipNetIf</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> NetDeviceImpl *netDeviceImpl, <span class="type">const</span> <span class="keyword">struct</span> NetDevice *netDev)</span></span><br><span class="line">&#123;</span><br><span class="line">    lwipNf = (<span class="keyword">struct</span> netif *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> netif));</span><br><span class="line">    (<span class="type">void</span>)memset_s(lwipNf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> netif), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> netif));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register netif to lwip */</span></span><br><span class="line">    lwipNf-&gt;state = (<span class="type">void</span> *)netDeviceImpl;</span><br><span class="line">    lwipNf-&gt;drv_send = LwipSend;</span><br><span class="line">    lwipNf-&gt;drv_set_hwaddr = LwipSetHwaddr;</span><br><span class="line">    lwipNf-&gt;link_layer_type = netDev-&gt;LinkLayerType;</span><br><span class="line">    lwipNf-&gt;hwaddr_len = MAC_ADDR_SIZE;</span><br><span class="line">    lwipNf-&gt;drv_config = LwipDrvConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lwipNf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>把lwip协议栈的数据传递给网卡驱动程序发送；</p>
<p>将lwip的pbuf类型数据转换成网卡驱动使用的netbuf类型数据。调用网卡的接口函数xmit将数据发送</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LwipSend</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> pbuf *lwipBuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceImpl</span> *<span class="title">ndImpl</span> =</span> (<span class="keyword">struct</span> NetDeviceImpl *)netif-&gt;state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDevice</span> *<span class="title">netDev</span> =</span> ndImpl-&gt;netDevice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetDeviceInterFace</span> *<span class="title">netDevIf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NetBuf</span> *<span class="title">netBuff</span> =</span> ConverPbuffToNetBuf(netDev, lwipBuf);</span><br><span class="line">	netDevIf-&gt;xmit(netDev, netBuff);</span><br><span class="line">    netDevIf = netDev-&gt;netDeviceIf;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xmit &#x3D; hmac_bridge_vap_xmit(),hmac_bridge_vap_xmit()通过下面这一系列的函数调用，最终把netbuf传递给flowcontrol module的队列中缓存，然后唤醒线程进行发送。</p>
<p> hmac_bridge_vap_xmit()-&gt;hmac_tx_lan_to_wlan-&gt;hmac_tx_lan_to_wlan_no_tcp_opt_to_dmac()-&gt;hcc_hmac_tx_data_event()-&gt;hcc_host_tx_data_adapt_pre_do()-&gt;hcc_host_tx_data_adapt()-&gt;hcc_tx_netbuf_normal()-&gt;hcc_host_tx(),hcc_host_tx会调用flow_control</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hcc sdio host tx */</span></span><br><span class="line">hi_u32 <span class="title function_">hcc_host_tx</span><span class="params">(hcc_handler_stru *hcc_handler, oal_netbuf_stru *netbuf, <span class="type">const</span> hcc_transfer_param *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlowControlModule</span> *<span class="title">fcm</span> =</span> HI_NULL;</span><br><span class="line">    <span class="comment">/* 1. build hcc header */</span></span><br><span class="line">    err_code = hcc_hmac_tx_hcc_hdr_init(netbuf, param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. init hcc cb ctrl */</span></span><br><span class="line">    hcc_cb = (hcc_tx_cb_stru *)oal_netbuf_cb(netbuf);</span><br><span class="line">    hcc_cb-&gt;destroy = hcc_tx_netbuf_destroy;</span><br><span class="line">    hcc_cb-&gt;magic = HCC_TX_WAKELOCK_MAGIC;</span><br><span class="line">    <span class="keyword">if</span> (param-&gt;queue_id == DATA_LO_QUEUE) &#123;</span><br><span class="line">        dmac_tx_ctl_stru *dmac_tx_ctrl = HI_NULL;</span><br><span class="line">        hi_u8 *hcc_hdr = (hi_u8 *)oal_netbuf_data(netbuf);</span><br><span class="line">        dmac_tx_ctrl = (dmac_tx_ctl_stru *)(hcc_hdr + HCC_HDR_LEN + <span class="keyword">sizeof</span>(frw_hcc_extend_hdr_stru));</span><br><span class="line">        <span class="keyword">if</span> (dmac_tx_ctrl != HI_NULL &amp;&amp;</span><br><span class="line">            dmac_tx_ctrl-&gt;is_vipframe != HI_TRUE &amp;&amp; dmac_tx_ctrl-&gt;high_prio_sch != HI_TRUE &amp;&amp;</span><br><span class="line">            hcc_list_overflow()) &#123;</span><br><span class="line">            <span class="comment">/* 非关键帧 */</span></span><br><span class="line">            oal_netbuf_free(netbuf);</span><br><span class="line">            <span class="keyword">return</span> HI_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dmac_tx_ctrl != HI_NULL &amp;&amp;</span><br><span class="line">            (dmac_tx_ctrl-&gt;is_vipframe == HI_TRUE || dmac_tx_ctrl-&gt;high_prio_sch == HI_TRUE)) &#123;</span><br><span class="line">            is_vipframe = HI_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_vipframe &amp;&amp; hcc_discard_key_frame()) &#123;</span><br><span class="line">            oal_netbuf_free(netbuf);</span><br><span class="line">            <span class="keyword">return</span> HI_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//get flowcontrolmodule</span></span><br><span class="line">    fcm = GetFlowControlModule();</span><br><span class="line">    <span class="keyword">if</span> (fcm != <span class="literal">NULL</span> &amp;&amp; fcm-&gt;op != <span class="literal">NULL</span> &amp;&amp; fcm-&gt;op-&gt;getTxQueueId != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        para.queueType = param-&gt;queue_id;</span><br><span class="line">        para.isVip = is_vipframe;</span><br><span class="line">        FlowControlQueueID id = fcm-&gt;op-&gt;getTxQueueId((<span class="type">void</span> *)(&amp;para));</span><br><span class="line">        <span class="comment">//send netbuf to fcm</span></span><br><span class="line">        fcm-&gt;interface-&gt;sendBuffToFCM(fcm, netbuf, id, FLOW_TX);</span><br><span class="line">        <span class="comment">//call txthread to send netbuf</span></span><br><span class="line">        fcm-&gt;interface-&gt;schedFCM(fcm, FLOW_TX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>flow control提供给外部的接口：</p>
<ul>
<li>sendBuffToFCM：发送数据到flowcontrol</li>
<li>schedFCM：调度线程（即让发送&#x2F;接受开始运行）</li>
</ul>
<h3 id="创建netdev"><a href="#创建netdev" class="headerlink" title="创建netdev"></a>创建netdev</h3><p>在bearpi_micro&#x2F;drivers&#x2F;framework&#x2F;model&#x2F;network&#x2F;common&#x2F;netdevice&#x2F;netdevice.c 中定义了netdevice</p>
<p>该函数会创建netdev对象，netdeviceimpl对象，以及netif对象等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> NetDevice *<span class="title function_">NetDeviceInit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifName, <span class="type">uint32_t</span> len, NetLinkType type, NetIfCategory ifCategory)</span></span><br><span class="line">&#123;</span><br><span class="line">    netDevice = (NetDevice *)OsalMemCalloc(<span class="keyword">sizeof</span>(NetDevice));</span><br><span class="line">	<span class="comment">//复制名称，名称一般是wlan0,wlan1,eth0,eth1</span></span><br><span class="line">    <span class="keyword">if</span> (strcpy_s(netDevice-&gt;name, IFNAMSIZ, ifName) != EOK) &#123;</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s fail: strcpy_s fail!&quot;</span>, __func__);</span><br><span class="line">        OsalMemFree(netDevice);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    netDevice-&gt;netifCateg = ifCategory;</span><br><span class="line">    <span class="comment">//实例化 ndImpl</span></span><br><span class="line">    ndImpl = InitNetDeviceImpl(netDevice, ifCategory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FindAvailableTable(&amp;index)) &#123;</span><br><span class="line">        AddNetDeviceImplToTable(index, ndImpl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DeInitNetDeviceImpl(ndImpl);</span><br><span class="line">        HDF_LOGE(<span class="string">&quot;%s fail: Not extra table.&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* INIT OSPrivate */</span></span><br><span class="line">    ret = HDF_FAILURE;</span><br><span class="line">    <span class="keyword">if</span> (ndImpl-&gt;interFace != <span class="literal">NULL</span> &amp;&amp; ndImpl-&gt;interFace-&gt;init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用g_liteNdImplOps-&gt;init() 也就是LiteNetDevInit()</span></span><br><span class="line">        ret = ndImpl-&gt;interFace-&gt;init(ndImpl);</span><br><span class="line">    &#125;</span><br><span class="line">	netDevice-&gt;LinkLayerType = type;</span><br><span class="line">    <span class="keyword">return</span> netDevice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> NetDeviceImpl *<span class="title function_">InitNetDeviceImpl</span><span class="params">(NetDevice *nd, NetIfCategory ifCategory)</span></span><br><span class="line">&#123;</span><br><span class="line">    ndImpl = (<span class="keyword">struct</span> NetDeviceImpl *)OsalMemCalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> NetDeviceImpl));</span><br><span class="line"></span><br><span class="line">    ndImpl-&gt;netDevice = nd;</span><br><span class="line">    <span class="comment">//注册ndImpl，就是 ndImpl-&gt;interFace = &amp;g_liteNdImplOps;</span></span><br><span class="line">    <span class="keyword">if</span> (RegisterNetDeviceImpl(ndImpl) != HDF_SUCCESS) &#123;</span><br><span class="line">        ndImpl = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ndImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/tmp/netdev/" data-id="cmbcy7ri2003vt8mt1q778bvf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/31/killer-blog/picture/weixin.png/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/05/31/killer-blog/OpenHarmony/softbus_lite/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="dsoftbus core（上）好，现在压力给到了core目录，这里是服务端的实现，代码应该会复杂很多，我门应该从哪里入手？softbus服务必须向samgr注册，那么就从这个入手。 了解一下samgr这个是如何使用的。 samgr这个samgr的使用还有复杂，建议直接看readme：https:&#x2F;&#x2F;gitee.com&#x2F;openharmony&#x2F;distributedschedule_samgr_l">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/05/31/killer-blog/OpenHarmony/3.dsoftbus_core_1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="dsoftbus core（上）好，现在压力给到了core目录，这里是服务端的实现，代码应该会复杂很多，我门应该从哪里入手？softbus服务必须向samgr注册，那么就从这个入手。 了解一下samgr这个是如何使用的。 samgr这个samgr的使用还有复杂，建议直接看readme：https:&#x2F;&#x2F;gitee.com&#x2F;openharmony&#x2F;distributedschedule_samgr_l">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-31T02:36:45.815Z">
<meta property="article:modified_time" content="2025-06-01T00:19:46.490Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/OpenHarmony/3.dsoftbus_core_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/OpenHarmony/3.dsoftbus_core_1/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.815Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dsoftbus-core（上）"><a href="#dsoftbus-core（上）" class="headerlink" title="dsoftbus core（上）"></a>dsoftbus core（上）</h2><p>好，现在压力给到了core目录，这里是服务端的实现，代码应该会复杂很多，我门应该从哪里入手？softbus服务必须向samgr注册，那么就从这个入手。</p>
<p>了解一下samgr这个是如何使用的。</p>
<h3 id="samgr"><a href="#samgr" class="headerlink" title="samgr"></a>samgr</h3><p>这个samgr的使用还有复杂，建议直接看readme：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony/distributedschedule_samgr_lite">https://gitee.com/openharmony/distributedschedule_samgr_lite</a></p>
<h4 id="开发服务"><a href="#开发服务" class="headerlink" title="开发服务"></a>开发服务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义服务</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ExampleService</span> &#123;</span></span><br><span class="line">    INHERIT_SERVICE;</span><br><span class="line">    INHERIT_IUNKNOWNENTRY(DefaultFeatureApi);</span><br><span class="line">    Identity identity;</span><br><span class="line">&#125; ExampleService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="type">static</span> ExampleService g_example = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle,</span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,</span><br><span class="line">        .Invoke = <span class="literal">NULL</span>,</span><br><span class="line">        .SyncCall = SyncCall,</span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向samgr注册接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_example);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(EXAMPLE_SERVICE, GET_IUNKNOWN(g_example));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义服务初始化入口</span></span><br><span class="line">SYSEX_SERVICE_INIT(Init);</span><br></pre></td></tr></table></figure>

<h4 id="开发服务子功能"><a href="#开发服务子功能" class="headerlink" title="开发服务子功能"></a>开发服务子功能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义功能</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DemoFeature</span> &#123;</span></span><br><span class="line">    INHERIT_FEATURE;</span><br><span class="line">    INHERIT_IUNKNOWNENTRY(DemoApi);</span><br><span class="line">    Identity identity;</span><br><span class="line">    Service *parent;</span><br><span class="line">&#125; DemoFeature;</span><br><span class="line"><span class="comment">//功能对象</span></span><br><span class="line"><span class="type">static</span> DemoFeature g_example = &#123;</span><br><span class="line">    .GetName = FEATURE_GetName,</span><br><span class="line">    .OnInitialize = FEATURE_OnInitialize,</span><br><span class="line">    .OnStop = FEATURE_OnStop,</span><br><span class="line">    .OnMessage = FEATURE_OnMessage,</span><br><span class="line">    DEFAULT_IUNKNOWN_ENTRY_BEGIN,</span><br><span class="line">        .AsyncCall = AsyncCall,</span><br><span class="line">        .AsyncTimeCall = AsyncTimeCall,</span><br><span class="line">        .SyncCall = SyncCall,</span><br><span class="line">        .AsyncCallBack = AsyncCallBack,</span><br><span class="line">    DEFAULT_IUNKNOWN_ENTRY_END,</span><br><span class="line">    .identity = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//向samgr注册功能接口</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterFeature(EXAMPLE_SERVICE, (Feature *)&amp;g_example);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterFeatureApi(EXAMPLE_SERVICE, EXAMPLE_FEATURE, GET_IUNKNOWN(g_example));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义功能初始化入口</span></span><br><span class="line">SYSEX_FEATURE_INIT(Init);</span><br></pre></td></tr></table></figure>

<h3 id="looper"><a href="#looper" class="headerlink" title="looper"></a>looper</h3><p>looper是一种循环处理消息队列中消息的办法。</p>
<p>创建一个looper，应该会有一个对应的线程，在这个线程中去处理消息，如下创建了一个LoopTask</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SoftBusLooper *<span class="title function_">CreateNewLooper</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLooper *looper = (SoftBusLooper *)SoftBusCalloc(<span class="keyword">sizeof</span>(SoftBusLooper));</span><br><span class="line">    SoftBusLooperContext *context = SoftBusCalloc(<span class="keyword">sizeof</span>(SoftBusLooperContext));</span><br><span class="line">    <span class="keyword">if</span> (memcpy_s(context-&gt;name, <span class="keyword">sizeof</span>(context-&gt;name), name, <span class="built_in">strlen</span>(name)) != EOK) &#123;</span><br><span class="line">        SoftBusFree(looper);</span><br><span class="line">        SoftBusFree(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListInit(&amp;context-&gt;msgHead);</span><br><span class="line">    <span class="comment">// init context</span></span><br><span class="line">    pthread_mutex_init(&amp;context-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;context-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;context-&gt;condRunning, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init looper</span></span><br><span class="line">    looper-&gt;context = context;</span><br><span class="line">    looper-&gt;PostMessage = LooperPostMessage;</span><br><span class="line">    looper-&gt;PostMessageDelay = LooperPostMessageDelay;</span><br><span class="line">    looper-&gt;RemoveMessage = LooperRemoveMessage;</span><br><span class="line">    looper-&gt;RemoveMessageCustom = LoopRemoveMessageCustom;</span><br><span class="line">    <span class="type">int</span> ret = StartNewLooperThread(looper);</span><br><span class="line">    <span class="keyword">return</span> looper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">StartNewLooperThread</span><span class="params">(SoftBusLooper *looper)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINLOOP_STACK_SIZE 5120</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> threadAttr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;threadAttr);</span><br><span class="line">    pthread_attr_setstacksize(&amp;threadAttr, MAINLOOP_STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;threadAttr, LoopTask, looper) != <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;create DeathProcTask failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loopTask 的代码逻辑上就是 ：</p>
<ol>
<li>读取looper的上下文</li>
<li>从上下文中读取消息</li>
<li>调用消息的handler处理消息本身</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">LoopTask</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLooper *looper = arg;</span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    SoftBusLooperContext *context = looper-&gt;context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;context-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;lock failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context-&gt;running = <span class="number">1</span>;</span><br><span class="line">    g_isThreadStarted = <span class="number">1</span>;</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;context-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_ERROR, <span class="string">&quot;lock failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait 检查线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (context-&gt;stop == <span class="number">1</span>) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], stop ==1&quot;</span>, context-&gt;name);</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_isNeedDestroy == <span class="number">1</span>) &#123;</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上下文没有消息，进入等待</span></span><br><span class="line">        <span class="keyword">if</span> (IsListEmpty(&amp;context-&gt;msgHead)) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s] wait msg list empty&quot;</span>, context-&gt;name);</span><br><span class="line">            pthread_cond_wait(&amp;context-&gt;cond, &amp;context-&gt;lock);</span><br><span class="line">            (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//有消息需要处理了</span></span><br><span class="line">        <span class="type">uint64_t</span> now = UptimeMicros();</span><br><span class="line">        ListNode *item = context-&gt;msgHead.next;</span><br><span class="line">        SoftBusMessage *msg = <span class="literal">NULL</span>;</span><br><span class="line">        SoftBusMessageNode *itemNode = CONTAINER_OF(item, SoftBusMessageNode, node);</span><br><span class="line">        <span class="type">uint64_t</span> time = itemNode-&gt;msg-&gt;time;</span><br><span class="line">        <span class="comment">//当前时间大于消息发送的时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt;= time) &#123;</span><br><span class="line">            <span class="comment">//获取消息 </span></span><br><span class="line">            msg = itemNode-&gt;msg;</span><br><span class="line">            ListDelete(item);    <span class="comment">//移除链表</span></span><br><span class="line">            SoftBusFree(itemNode);</span><br><span class="line">            context-&gt;msgSize--;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], get message. handle=%s,what=%d,msgSize=%u&quot;</span>,</span><br><span class="line">                context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what, context-&gt;msgSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> timespec tv;</span><br><span class="line">            tv.tv_sec = time / TIME_THOUSANDS_MULTIPLIER / TIME_THOUSANDS_MULTIPLIER;</span><br><span class="line">            tv.tv_nsec = time % (TIME_THOUSANDS_MULTIPLIER * TIME_THOUSANDS_MULTIPLIER) * TIME_THOUSANDS_MULTIPLIER;</span><br><span class="line">            pthread_cond_timedwait(&amp;context-&gt;cond, &amp;context-&gt;lock, &amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        context-&gt;currentMsg = msg;</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], HandleMessage message. handle=%s,what=%d&quot;</span>,</span><br><span class="line">            context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what);</span><br><span class="line">		<span class="comment">//使用消息的handler去处理消息本身</span></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;handler-&gt;HandleMessage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            msg-&gt;handler-&gt;HandleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], after HandleMessage message. handle=%s,what=%d&quot;</span>,</span><br><span class="line">            context-&gt;name, msg-&gt;handler-&gt;name, msg-&gt;what);</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_lock(&amp;context-&gt;lock);</span><br><span class="line">        FreeSoftBusMsg(msg);</span><br><span class="line">        context-&gt;currentMsg = <span class="literal">NULL</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_lock(&amp;context-&gt;lock);</span><br><span class="line">    context-&gt;running = <span class="number">0</span>;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;LoopTask[%s], running =0&quot;</span>, context-&gt;name);</span><br><span class="line">    pthread_cond_broadcast(&amp;context-&gt;cond);</span><br><span class="line">    pthread_cond_broadcast(&amp;context-&gt;condRunning);</span><br><span class="line">    (<span class="type">void</span>)pthread_mutex_unlock(&amp;context-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (g_isNeedDestroy == <span class="number">1</span>) &#123;</span><br><span class="line">        LooperDeinit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么looper上下文中的消息是怎么来的呢，看looper中定义了消息的发送和撤回。所以我们猜测looper的使用方法：</p>
<p>首先调用CreateNewLooper()创建一个looper结构体和一个线程，然后将一些需要执行的代码封装成消息，looper发送消息，looper会自动的处理这些代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftBusLooper</span> &#123;</span></span><br><span class="line">    SoftBusLooperContext *context;</span><br><span class="line">    <span class="type">void</span> (*PostMessage)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg);   <span class="comment">//想looper发送消息</span></span><br><span class="line">    <span class="type">void</span> (*PostMessageDelay)(<span class="type">const</span> SoftBusLooper *looper, SoftBusMessage *msg, <span class="type">uint64_t</span> delayMillis);</span><br><span class="line">    <span class="type">void</span> (*RemoveMessage)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler, <span class="type">int32_t</span> what);    <span class="comment">//撤回消息</span></span><br><span class="line">    <span class="comment">// customFunc, when match, return 0</span></span><br><span class="line">    <span class="type">void</span> (*RemoveMessageCustom)(<span class="type">const</span> SoftBusLooper *looper, <span class="type">const</span> SoftBusHandler *handler,</span><br><span class="line">        <span class="type">int</span> (*)(<span class="type">const</span> SoftBusMessage*, <span class="type">void</span>*), <span class="type">void</span> *args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="softbus-server-进程"><a href="#softbus-server-进程" class="headerlink" title="softbus server 进程"></a>softbus server 进程</h3><p>好，让我来看看软总线服务是如何定义的，以及如何启动的</p>
<p>在core&#x2F;frame中的build.gn中，指示了该目录下的代码是如何编译成可执行文件和共享库的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_library(<span class="string">&quot;softbus_server_frame&quot;</span>)</span><br><span class="line">executable(<span class="string">&quot;softbus_server&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>liteosa生成一个共享库和可执行文件，softbus_server以一个进程的方式运行。需要手动去运行。</p>
<p>分析一下这个程序会执行什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitSoftBusServer();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InitSoftBusServer()会依次初始化以下：</p>
<ol>
<li>启动bootstrap</li>
<li>创建默认looper</li>
<li>连接server</li>
<li>传输server</li>
<li>设备认证server</li>
<li>发现server</li>
<li>软总线server</li>
</ol>
<p>looper是什么作用？</p>
<p>初始化完成后，该进程具备什么样的功能？应用要具备软总线的所有的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">SoftbusConfigInit    <span class="comment">//设置g_configItems</span></span><br><span class="line">ServerStubInit</span><br><span class="line">    <span class="title function_">HOS_SystemInit</span><span class="params">()</span>;    <span class="comment">// SAMGR_Bootstrap(); 启动服务框架，需要服务框架支持</span></span><br><span class="line">    SERVER_InitClient()    <span class="comment">//create g_clientInfoList</span></span><br><span class="line">SoftBusTimerInit    <span class="comment">//使用标准的timer_create()等函数实现对g_timerFunList[]函数的回调执行</span></span><br><span class="line">LooperInit    <span class="comment">//create Loop-default，并放入全局数组</span></span><br><span class="line">ConnServerInit()-&gt;    <span class="comment">// 连接 init a ConnectFuncInterface</span></span><br><span class="line">        ConnInitTcp()   <span class="comment">//tcp的相关函数</span></span><br><span class="line">TransServerInit   <span class="comment">//传输</span></span><br><span class="line">    TransPermissionInit    <span class="comment">//LoadPermissionJson(PERMISSION_JSON_FILE)</span></span><br><span class="line">    TransSessionMgrInit    <span class="comment">//create g_sessionServerList</span></span><br><span class="line">    TransChannelInit    <span class="comment">//传输通道初始化，设置一些回调函数和链表</span></span><br><span class="line">        IServerChannelCallBack *cb = TransServerGetChannelCb();    <span class="comment">//return &amp;g_channelCallBack;</span></span><br><span class="line">        TransLaneMgrInit    <span class="comment">// CREATE g_channelLaneList</span></span><br><span class="line">        TransAuthInit(cb)</span><br><span class="line">        TransProxyManagerInit(cb)</span><br><span class="line">            TransProxySetCallBack</span><br><span class="line">            TransProxyTransInit</span><br><span class="line">            g_proxyChannelList = CreateSoftBusList();</span><br><span class="line">            PendingInit</span><br><span class="line">            <span class="title function_">RegisterTimeoutCallback</span><span class="params">(SOFTBUS_PROXYCHANNEL_TIMER_FUN, TransProxyTimerProc)</span>  <span class="comment">// channel的超时处理，添加到链表</span></span><br><span class="line">        <span class="title function_">TransTcpDirectInit</span><span class="params">(cb)</span>    <span class="comment">//设置tcp直连的通道回调函数和超时处理</span></span><br><span class="line">        <span class="title function_">TransUdpChannelInit</span><span class="params">(cb)</span>    <span class="comment">//udp通道初始化（udp主要是用于处理连接）</span></span><br><span class="line">            <span class="title function_">AuthTransDataRegCallback</span><span class="params">(TRANS_UDP_DATA, &amp;transUdpCb)</span>    <span class="comment">//注册udp数据回调函数</span></span><br><span class="line">                decryptData = (<span class="type">uint8_t</span> *)SoftBusCalloc(info-&gt;len - AuthGetEncryptHeadLen() + <span class="number">1</span>);</span><br><span class="line">                AuthDecrypt(option, CLIENT_SIDE_FLAG, (<span class="type">uint8_t</span> *)info-&gt;data, info-&gt;len, &amp;buf)</span><br><span class="line">                TransOnExchangeUdpInfo(authId, info-&gt;flags, info-&gt;seq, json, option);</span><br><span class="line">AuthInit    <span class="comment">//设备认证</span></span><br><span class="line">    AuthCallbackInit(MODULE_NUM)</span><br><span class="line">    AuthGetAbility();</span><br><span class="line">    AuthListInit();</span><br><span class="line">    RegisterConnCallback    <span class="comment">//设置认证回调函数</span></span><br><span class="line">    AuthLooperInit    <span class="comment">//looper是什么 Looper是一种单个线程中持续处理消息的的方式。</span></span><br><span class="line">        g_authHandler.HandleMessage = AuthTimeout;</span><br><span class="line">        g_authHandler.looper = GetLooper(LOOP_TYPE_DEFAULT);   <span class="comment">//获取到之前创建的Loop-default，消息处理函数是AuthTimeout()</span></span><br><span class="line">    UniqueIdInit    <span class="comment">//由时间生成id</span></span><br><span class="line">    HichainServiceInit    <span class="comment">//hichain是用于设备认证的一个安全子系统的,我们关注g_hichainCallback</span></span><br><span class="line">        InitDeviceAuthService    <span class="comment">//base\security\deviceauth\frameworks\src\ipc_sdk.c</span></span><br><span class="line">            InitProxyAdapt() <span class="comment">//请求deviceauth_server</span></span><br><span class="line">DiscServerInit    <span class="comment">//发现</span></span><br><span class="line">    DiscMgrInit    </span><br><span class="line">            g_discMgrMediumCb.OnDeviceFound = DiscOnDeviceFound;</span><br><span class="line">            g_discCoapInterface = DiscCoapInit(&amp;g_discMgrMediumCb);</span><br><span class="line">                InitCoapManager()</span><br><span class="line">                DiscNstackxInit()</span><br><span class="line">                    InitLocalInfo()</span><br><span class="line">                    NSTACKX_Init(&amp;g_nstackxCallBack)   <span class="comment">//注册了一个回调函数OnDeviceFound</span></span><br><span class="line">                        g_epollfd = CreateEpollDesc();</span><br><span class="line">                        PthreadCreate(&amp;g_tid, <span class="literal">NULL</span>, NstackMainLoop, <span class="literal">NULL</span>);</span><br><span class="line">                        InternalInit(g_epollfd);</span><br><span class="line">                            EventModuleInit(&amp;g_eventNodeChain, g_epollfd);</span><br><span class="line">                            DeviceModuleInit(epollfd);   <span class="comment">//初始化数据库、超时处理函数</span></span><br><span class="line">                            P2pUsbTimerInit(epollfd);</span><br><span class="line">                            CoapServerInit()     <span class="comment">//启动libcoap</span></span><br><span class="line">                            CoapDiscoverInit()   <span class="comment">//设置一些发现的定时器</span></span><br><span class="line">                DiscCoapRegisterCb(g_discMgrMediumCb)</span><br><span class="line">BusCenterServerInit    <span class="comment">//软总线服务</span></span><br><span class="line">    LnnInitLocalLedger    <span class="comment">//设置本地的信息</span></span><br><span class="line">    LnnInitDistributedLedger    <span class="comment">//Init Distributed Info</span></span><br><span class="line">    LnnInitSyncLedgerItem    <span class="comment">//设置g_netChanlistener，负责通道打开，消息处理回调</span></span><br><span class="line">    LnnInitEventMonitor</span><br><span class="line">    LnnInitDiscoveryManager   <span class="comment">//设置DeviceFound函数，如下构造一个msg，发送给looper-default</span></span><br><span class="line">        para = CreateConnectionAddrMsgPara(addr);</span><br><span class="line">        PostMessageToHandler(MSG_TYPE_DISCOVERY_DEVICE, para)</span><br><span class="line">            SoftBusMessage *msg = CreateNetBuilderMessage(msgType, para);</span><br><span class="line">            g_netBuilder.looper-&gt;PostMessage(g_netBuilder.looper, msg);</span><br><span class="line">    LnnInitNetworkManager</span><br><span class="line">        LnnInitIpNetwork</span><br><span class="line">            <span class="title function_">LnnRegisterEventHandler</span><span class="params">(LNN_MONITOR_EVENT_IP_ADDR_CHANGED, IpAddrChangeEventHandler)</span> <span class="comment">//注册网络状态的回调函数</span></span><br><span class="line">            <span class="title function_">LnnRegisterEventHandler</span><span class="params">(LNN_MONITOR_EVENT_WIFI_STATE_CHANGED, WifiStateChangeEventHandler)</span></span><br><span class="line">            <span class="title function_">GetUpdateLocalIp</span><span class="params">(ipAddr, IP_LEN, ifName, NET_IF_NAME_LEN, <span class="literal">false</span>)</span>  <span class="comment">//更新ip</span></span><br><span class="line">            <span class="title function_">SetLocalIpInfo</span><span class="params">(ipAddr, ifName)</span></span><br><span class="line">            <span class="title function_">DiscLinkStatusChanged</span><span class="params">(LINK_STATUS_UP, COAP)</span>;   <span class="comment">//最终执行SetLocalDeviceInfo();</span></span><br><span class="line">            OpenIpLink()    <span class="comment">//设置认证相关函数</span></span><br><span class="line">                OpenAuthPort();   <span class="comment">//执行OpenAuthServer，设置回调函数AuthOnConnectEvent和AuthOnDataEvent 处理认证的数据</span></span><br><span class="line">                OpenSessionPort()    <span class="comment">//设置session回调函数</span></span><br><span class="line">            LnnStartDiscovery()    <span class="comment">//通过DiscoveryFuncInterface来触发软总线发现</span></span><br><span class="line">                RestartPublish()</span><br><span class="line">                    DiscStartScan()    <span class="comment">//(DiscoveryFuncInterface)interface-&gt;StartScan()</span></span><br><span class="line">                LnnStartCoapDiscovery()</span><br><span class="line">                    DiscSetDiscoverCallback()</span><br><span class="line">                    DiscStartAdvertise()    <span class="comment">//(DiscoveryFuncInterface)interface-&gt;Subscribe</span></span><br><span class="line">    LnnInitNetBuilder   <span class="comment">//创建一个handler：NetBuilderMessageHandler，传递给looper-default，处理各种软总线的消息g_messageProcessor</span></span><br><span class="line">    LnnLanesInit</span><br><span class="line">    LnnTimeSyncInit     <span class="comment">//创建一个handler：TimeSyncMessageHandler，传递给looper-default，处理软总线的同步</span></span><br></pre></td></tr></table></figure>



<h3 id="softbus-服务"><a href="#softbus-服务" class="headerlink" title="softbus 服务"></a>softbus 服务</h3><p>请先了解一下鸿蒙的服务框架，在openharmony中注册一个softbus服务。</p>
<p>在<code>core/frame/small/init/src/softbus_server_stub.c</code>中，有softbus的注册服务的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(WAIT_FOR_SERVER);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterService((Service *)&amp;g_samgrService);</span><br><span class="line">    SAMGR_GetInstance()-&gt;RegisterDefaultFeatureApi(SOFTBUS_SERVICE, GET_IUNKNOWN(g_samgrService));</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_COMM, SOFTBUS_LOG_INFO, <span class="string">&quot;Init success %s&quot;</span>, SOFTBUS_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line">SYSEX_SERVICE_INIT(Init);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来是softbus服务的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SoftbusSamgrService g_samgrService = &#123;</span><br><span class="line">    .GetName = GetName,</span><br><span class="line">    .Initialize = Initialize,</span><br><span class="line">    .MessageHandle = MessageHandle, </span><br><span class="line">    .GetTaskConfig = GetTaskConfig,</span><br><span class="line">    SERVER_IPROXY_IMPL_BEGIN,</span><br><span class="line">    .Invoke = Invoke,   <span class="comment">//重要：其他进程调用的IPC，会调用这个函数</span></span><br><span class="line">    IPROXY_END,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我门来关注一下Invoke：不难理解，通过funcId来索引找到对应的处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">Invoke</span><span class="params">(IServerProxy *iProxy, <span class="type">int</span> funcId, <span class="type">void</span> *origin, IpcIo *req, IpcIo *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tblSize = <span class="keyword">sizeof</span>(g_serverInvokeCmdTbl) / <span class="keyword">sizeof</span>(ServerInvokeCmd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tblSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (funcId == g_serverInvokeCmdTbl[i].id) &#123;</span><br><span class="line">            <span class="keyword">return</span> g_serverInvokeCmdTbl[i].func(origin, req, reply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以找到softbus提供的全部IPC接口拉，应该可以和sdk目录下的函数相对应的，接下来我们就从这些函数入手，来了解整个core层中的发现，连接、组网，传输是如何实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ServerInvokeCmd g_serverInvokeCmdTbl[] = &#123;</span><br><span class="line">    &#123; MANAGE_REGISTER_SERVICE, ServerRegisterService &#125;,</span><br><span class="line">    &#123; SERVER_PUBLISH_SERVICE, ServerPublishService &#125;,</span><br><span class="line">    &#123; SERVER_UNPUBLISH_SERVICE, ServerUnPublishService &#125;,</span><br><span class="line">    &#123; SERVER_START_DISCOVERY, ServerStartDiscovery &#125;,</span><br><span class="line">    &#123; SERVER_STOP_DISCOVERY, ServerStopDiscovery &#125;,</span><br><span class="line">    &#123; SERVER_JOIN_LNN, ServerJoinLNN &#125;,</span><br><span class="line">    &#123; SERVER_LEAVE_LNN, ServerLeaveLNN &#125;,</span><br><span class="line">    &#123; SERVER_GET_ALL_ONLINE_NODE_INFO, ServerGetAllOnlineNodeInfo &#125;,</span><br><span class="line">    &#123; SERVER_GET_LOCAL_DEVICE_INFO, ServerGetLocalDeviceInfo &#125;,</span><br><span class="line">    &#123; SERVER_GET_NODE_KEY_INFO, ServerGetNodeKeyInfo &#125;,</span><br><span class="line">    &#123; SERVER_START_TIME_SYNC, ServerStartTimeSync &#125;,</span><br><span class="line">    &#123; SERVER_STOP_TIME_SYNC, ServerStopTimeSync &#125;,</span><br><span class="line">    &#123; SERVER_PUBLISH_LNN, ServerPublishLNN &#125;,</span><br><span class="line">    &#123; SERVER_STOP_PUBLISH_LNN, ServerStopPublishLNN &#125;,</span><br><span class="line">    &#123; SERVER_REFRESH_LNN, ServerRefreshLNN &#125;,</span><br><span class="line">    &#123; SERVER_STOP_REFRESH_LNN, ServerStopRefreshLNN &#125;,</span><br><span class="line">    &#123; SERVER_ACTIVE_META_NODE, ServerActiveMetaNode&#125;,</span><br><span class="line">    &#123; SERVER_DEACTIVE_META_NODE, ServerDeactiveMetaNode &#125;,</span><br><span class="line">    &#123; SERVER_GET_ALL_META_NODE_INFO, ServerGetAllMetaNodeInfo &#125;,</span><br><span class="line">    &#123; SERVER_CREATE_SESSION_SERVER, ServerCreateSessionServer &#125;,</span><br><span class="line">    &#123; SERVER_REMOVE_SESSION_SERVER, ServerRemoveSessionServer &#125;,</span><br><span class="line">    &#123; SERVER_OPEN_SESSION, ServerOpenSession &#125;,</span><br><span class="line">    &#123; SERVER_OPEN_AUTH_SESSION, ServerOpenAuthSession&#125;,</span><br><span class="line">    &#123; SERVER_NOTIFY_AUTH_SUCCESS, ServerNotifyAuthSuccess&#125;,</span><br><span class="line">    &#123; SERVER_CLOSE_CHANNEL, ServerCloseChannel &#125;,</span><br><span class="line">    &#123; SERVER_SESSION_SENDMSG, ServerSendSessionMsg &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="发现：ServerStartDiscovery"><a href="#发现：ServerStartDiscovery" class="headerlink" title="发现：ServerStartDiscovery"></a>发现：ServerStartDiscovery</h3><p>我门就以ServerStartDiscovery来看看，discovery包括了Advertise和Subscribe两个部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先是获取函数参数</span></span><br><span class="line">pkgName = (<span class="type">const</span> <span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">SubscribeSerializer *info = (SubscribeSerializer *)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line"><span class="type">char</span> *capability = (<span class="type">char</span> *)IpcIoPopString(req, &amp;len);</span><br><span class="line">callingUid = GetCallingUid(origin);</span><br><span class="line">DiscIpcStartDiscovery(pkgName, &amp;subscribeInfo);</span><br><span class="line">    SetCallLnnStatus(<span class="literal">false</span>);    <span class="comment">//g_isCallLnn = flag;</span></span><br><span class="line">    DiscStartDiscovery(packageName, info, &amp;g_discInnerCb);    <span class="comment">//g_discInnerCb = ClientIpcOnDeviceFound</span></span><br><span class="line">        DiscInfo *infoNode = CreateNewSubscribeInfoNode(info);</span><br><span class="line">        InnerStartDiscovery(packageName, infoNode, cb, SUBSCRIBE_SERVICE);</span><br><span class="line">            AddInfoToList(g_discoveryInfoList, packageName, &amp;callback, info, type);</span><br><span class="line">            DiscInterfaceByMedium(info, STARTDISCOVERTY_FUNC);</span><br><span class="line">                DiscInterfaceProcess(&amp;(info-&gt;option), g_discCoapInterface, info-&gt;mode, type);</span><br><span class="line">                    interface-&gt;StartAdvertise(&amp;(option-&gt;subscribeOption))</span><br><span class="line">                    interface-&gt;Subscribe(&amp;(option-&gt;subscribeOption))</span><br><span class="line">    ClientIpcDiscoverySuccess(packageName, info-&gt;subscribeId);</span><br></pre></td></tr></table></figure>

<p>好吧，最后是使用interface的StartAdvertise和Subscribe方法，g_discCoapInterface是在disc_manager.c中的DiscMgrInit()完成初始化的，DiscMgrInit()就在我们的softbus_server进程中被调用。</p>
<p>下面就是g_discCoapInterface的实例化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> DiscoveryFuncInterface g_discCoapFuncInterface = &#123;</span><br><span class="line">    .Publish = CoapPublish,</span><br><span class="line">    .StartScan = CoapStartScan,</span><br><span class="line">    .Unpublish = CoapUnPublish,</span><br><span class="line">    .StopScan = CoapStopScan,</span><br><span class="line">    .StartAdvertise = CoapStartAdvertise,</span><br><span class="line">    .Subscribe = CoapSubscribe,</span><br><span class="line">    .StopAdvertise = CoapStopAdvertise,</span><br><span class="line">    .Unsubscribe = CoapUnsubscribe,</span><br><span class="line">    .LinkStatusChanged = CoapUpdateLocalIp</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看看CoapStartAdvertise，字面意思应该就是使用coap进行广播。首先会注册能力位图，这是什么？（应该是一个数据，然后每一位上表示某个特性是否使能）然后使用postevent去执行DeviceDiscoverInner。DeviceDiscoverInner中是真正的去发coap请求包，并设置超时回调函数，以及设备发现回调函数。</p>
<p>CoapStartAdvertise函数调用流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RegisterAllCapBitmap</span><br><span class="line">DiscCoapSetFilterCapability</span><br><span class="line">DiscCoapStopDiscovery</span><br><span class="line">DiscCoapStartDiscovery</span><br><span class="line">    NSTACKX_StartDeviceFind</span><br><span class="line">        <span class="title function_">PostEvent</span><span class="params">(&amp;g_eventNodeChain, g_epollfd, DeviceDiscoverInner, <span class="literal">NULL</span>)</span>	<span class="comment">//执行DeviceDiscoverInner</span></span><br><span class="line">            DeviceDiscoverInner</span><br><span class="line">               <span class="title function_">CoapServiceDiscoverInner</span><span class="params">(INNER_DISCOVERY)</span>;</span><br><span class="line">                   SetModeInfo</span><br><span class="line">                   CoapPostServiceDiscover</span><br><span class="line">                       PrepareServiceDiscover</span><br><span class="line">                       CoapSendRequest</span><br><span class="line">                           FillCoapRequest</span><br><span class="line">                           CoapResolveAddress</span><br><span class="line">                           CoapGetSessionOnTargetServer</span><br><span class="line">                           CoapPackToPdu</span><br><span class="line">                           coap_send</span><br><span class="line">                           coap_session_release</span><br><span class="line">                   TimerSetTimeout</span><br><span class="line">               <span class="title function_">NotifyDeviceFound</span><span class="params">(<span class="literal">NULL</span>, <span class="number">0</span>)</span>;    <span class="comment">//g_parameter.onDeviceFound(deviceList, deviceCount);</span></span><br></pre></td></tr></table></figure>

<p>note：PostEvent可以简单的理解为调用DeviceDiscoverInner():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CoapServiceDiscoverInner</span><span class="params">(<span class="type">uint8_t</span> userRequest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> discoverInterval;</span><br><span class="line">    <span class="comment">//检查wifi连接</span></span><br><span class="line">    <span class="keyword">if</span> (!IsWifiApConnected() || g_context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//用户请求开启发现</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest) &#123;</span><br><span class="line">        <span class="comment">//强制进行发现</span></span><br><span class="line">        g_userRequest = NSTACKX_TRUE;</span><br><span class="line">        g_forceUpdate = NSTACKX_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (g_coapDiscoverTargetCount &gt; <span class="number">0</span> &amp;&amp; g_discoverCount &gt;= g_coapDiscoverTargetCount) &#123;</span><br><span class="line">        g_discoverCount = <span class="number">0</span>;</span><br><span class="line">        SetModeInfo(DISCOVER_MODE);</span><br><span class="line">        ClearDevices(GetDeviceDBBackup());</span><br><span class="line">        LOGW(TAG, <span class="string">&quot;clear device list backup&quot;</span>);</span><br><span class="line">        TimerSetTimeout(g_discoverTimer, <span class="number">0</span>, NSTACKX_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//g_discoverCount &gt; 0说明正在发现</span></span><br><span class="line">    <span class="keyword">if</span> (g_discoverCount) &#123;</span><br><span class="line">        <span class="comment">/* Service discover is ongoing, return. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* First discover */</span></span><br><span class="line">        <span class="comment">//备份设备数据</span></span><br><span class="line">        <span class="keyword">if</span> (BackupDeviceDB() != NSTACKX_EOK) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">&quot;backup device list fail&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清除设备</span></span><br><span class="line">        ClearDevices(GetDeviceDB());</span><br><span class="line">        LOGW(TAG, <span class="string">&quot;clear device list&quot;</span>);</span><br><span class="line">        <span class="comment">//设置最大的发现数量</span></span><br><span class="line">        g_coapDiscoverTargetCount = g_coapMaxDiscoverCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SetModeInfo(DISCOVER_MODE);</span><br><span class="line">    <span class="comment">//开始发现流程</span></span><br><span class="line">    <span class="keyword">if</span> (CoapPostServiceDiscover() != NSTACKX_EOK) &#123;</span><br><span class="line">        LOGE(TAG, <span class="string">&quot;failed to post service discover request&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置一些超时检查</span></span><br><span class="line">    discoverInterval = GetDiscoverInterval(g_discoverCount);</span><br><span class="line">    <span class="keyword">if</span> (TimerSetTimeout(g_discoverTimer, discoverInterval, NSTACKX_FALSE) != NSTACKX_EOK) &#123;</span><br><span class="line">        LOGE(TAG, <span class="string">&quot;failed to set timer for service discover&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++g_discoverCount;</span><br><span class="line">    LOGI(TAG, <span class="string">&quot;the first time for device discover.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始发现流程</span></span><br><span class="line">CoapPostServiceDiscover</span><br><span class="line">    GetLocalInterfaceName    <span class="comment">//获取网卡</span></span><br><span class="line">    GetIfBroadcastIp         <span class="comment">//获取广播ip</span></span><br><span class="line">    <span class="comment">//设置请求的uri</span></span><br><span class="line">    sprintf_s(discoverUri, <span class="keyword">sizeof</span>(discoverUri), <span class="string">&quot;coap://%s/%s&quot;</span>, ipString, <span class="string">&quot;device_discover&quot;</span>)</span><br><span class="line">    PrepareServiceDiscover(NSTACKX_TRUE);    <span class="comment">//构建json数据，格式见下文</span></span><br><span class="line">    CoapSendRequest(COAP_MESSAGE_NON, discoverUri, data, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, SERVER_TYPE_WLANORETH);</span><br><span class="line">        FillCoapRequest(&amp;coapRequest, coapType, url, data, dataLen);</span><br><span class="line">        CoapUriParse(coapRequest.remoteUrl, &amp;coapUri)</span><br><span class="line">        CoapResolveAddress(&amp;remote, &amp;dst.addr.sa);</span><br><span class="line">        CoapGetSessionOnTargetServer(serverType, &amp;coapServerParameter);</span><br><span class="line">        CoapPackToPdu(&amp;coapRequest, &amp;coapUri, session);</span><br><span class="line">        coap_send(session, pdu);</span><br><span class="line">json数据格式：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Service Discover JSON format</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   &quot;deviceId&quot;:[device ID, string],</span></span><br><span class="line"><span class="comment"> *   &quot;deviceName&quot;:[device name, string],</span></span><br><span class="line"><span class="comment"> *   &quot;type&quot;: [device type, number],</span></span><br><span class="line"><span class="comment"> *   &quot;version&quot;:[hicom version, string],</span></span><br><span class="line"><span class="comment"> *   &quot;wlanIp&quot;:[WLAN IP address, string],</span></span><br><span class="line"><span class="comment"> *   &quot;capabilityBitmap&quot;:[bitmap, bitmap, bitmap, ...]</span></span><br><span class="line"><span class="comment"> *   &quot;coapUri&quot;:[coap uri for discover, string]   &lt;-- optional. When present, means it&#x27;s broadcast request.</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>最终是调用coap_send函数发送报文的.当coap的发现报文成功发送到另一台设备时，设备会响应，这个响应报文的处理应该是 ClientIpcOnDeviceFound这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">ClientIpcOnDeviceFound</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkgName, <span class="type">const</span> DeviceInfo *device)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_INFO, <span class="string">&quot;ondevice found ipc server push.&quot;</span>);</span><br><span class="line">    IpcIo io;</span><br><span class="line">    <span class="type">uint8_t</span> tmpData[MAX_SOFT_BUS_IPC_LEN_EX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化ipc的栈</span></span><br><span class="line">    IpcIoInit(&amp;io, tmpData, MAX_SOFT_BUS_IPC_LEN_EX, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把DeviceInfo入栈</span></span><br><span class="line">    IpcIoPushFlatObj(&amp;io, (<span class="type">const</span> <span class="type">void</span>*)device, <span class="keyword">sizeof</span>(DeviceInfo));</span><br><span class="line">    SvcIdentity svc = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//获取服务的id</span></span><br><span class="line">    <span class="keyword">if</span> (GetSvcIdentityByPkgName(pkgName, &amp;svc) != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_ERROR, <span class="string">&quot;ondevice found callback get svc failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送ipc请求给服务</span></span><br><span class="line">    <span class="type">int32_t</span> ans = SendRequest(<span class="literal">NULL</span>, svc, CLIENT_DISCOVERY_DEVICE_FOUND, &amp;io, <span class="literal">NULL</span>, LITEIPC_FLAG_ONEWAY, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans != SOFTBUS_OK) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_DISC, SOFTBUS_LOG_ERROR, <span class="string">&quot;ondevice found callback SendRequest failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在softbus 服务里的ClientOnDeviceFound函数就会来处理这个请求，这个函数通过函数指针一路回调到sdk层的，StartDiscovery函数里用户定义的回调函数。</p>
<p>发现的过程就到此。</p>
<h3 id="组网：ServerJoinLNN"><a href="#组网：ServerJoinLNN" class="headerlink" title="组网：ServerJoinLNN"></a>组网：ServerJoinLNN</h3><p>发现设备后要进行组网，就在ServerJoinLNN实现：首先是获取地址信息，组装成一个softbus message，然后发送给LoopTask线程，LoopTask的作用就是执行msg-&gt;handler-&gt;HandleMessage(msg);</p>
<h4 id="ServerJoinLNN"><a href="#ServerJoinLNN" class="headerlink" title="ServerJoinLNN"></a>ServerJoinLNN</h4><p>ServerJoinLNN函数执行流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是获取参数</span></span><br><span class="line">pkgName = IpcIoPopString</span><br><span class="line">addrTypeLen=IpcIoPopUint32</span><br><span class="line">*addr = (<span class="type">void</span>*)IpcIoPopFlatObj(req, &amp;size);</span><br><span class="line">callingUid = GetCallingUid(origin);</span><br><span class="line">LnnIpcServerJoin(pkgName, addr, addrTypeLen);</span><br><span class="line">    LnnServerJoin(connAddr);</span><br><span class="line">        para = CreateConnectionAddrMsgPara(addr);    <span class="comment">//para保存着地址信息</span></span><br><span class="line">        PostMessageToHandler(MSG_TYPE_JOIN_LNN, para)    <span class="comment">//把加入网络的消息发送到looper（注意PostMessageToHandler有两个实现）</span></span><br><span class="line">            SoftBusMessage *msg = CreateNetBuilderMessage(msgType, para);    <span class="comment">//创建消息</span></span><br><span class="line">                msg-&gt;handler = &amp;g_netBuilder.handler;   <span class="comment">//NetBuilderMessageHandler：到一个函数数组g_messageProcessor去处理消息</span></span><br><span class="line">            g_netBuilder.looper-&gt;PostMessage(g_netBuilder.looper,msg);  <span class="comment">//发消息让looper执行</span></span><br><span class="line">    AddJoinLNNInfo(pkgName, connAddr);     <span class="comment">//创建一个JoinLnnRequestInfo，然后加入链表</span></span><br></pre></td></tr></table></figure>

<p>所以这里的重点是NetBuilderMessageHandler，该函数比较简单，就是去调用对应的消息处理函数。这些函数被放到一个数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> NetBuilderMessageProcess g_messageProcessor[MSG_TYPE_MAX] = &#123;</span><br><span class="line">    ProcessJoinLNNRequest,</span><br><span class="line">    ProcessDevDiscoveryRequest,</span><br><span class="line">    ProcessCleanConnectionFsm,</span><br><span class="line">    ProcessAuthKeyGenerated,</span><br><span class="line">    ProcessAuthDone,</span><br><span class="line">    ProcessSyncDeviceInfoDone,</span><br><span class="line">    ProcessDeviceNotTrusted,</span><br><span class="line">    ProcessAuthDisconnect,</span><br><span class="line">    ProcessLeaveLNNRequest,</span><br><span class="line">    ProcessSyncOfflineFinish,</span><br><span class="line">    ProcessNodeStateChanged,</span><br><span class="line">    ProcessMasterElect,</span><br><span class="line">    ProcessLeaveInvalidConn,</span><br><span class="line">    ProcessLeaveByAddrType,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>MSG_TYPE_JOIN_LNN 对应的是 下标0 ，即 ProcessJoinLNNRequest()，其参数就是para，包含ip地址信息。</p>
<p>ProcessJoinLNNRequest调用TrySendJoinLNNRequest，进而调用PostJoinRequestToConnFsm：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LnnConnectionFsm *connFsm = StartNewConnectionFsm(addr);</span><br><span class="line">    connFsm = LnnCreateConnectionFsm(addr);</span><br><span class="line">    InitConnectionStateMachine()</span><br><span class="line">        fsm-&gt;looper = GetLooper(LOOP_TYPE_DEFAULT);</span><br><span class="line">    	fsm-&gt;handler.name = name;</span><br><span class="line">    	fsm-&gt;handler.HandleMessage = FsmStateMsgHandler;</span><br><span class="line">    	fsm-&gt;handler.looper = fsm-&gt;looper;</span><br><span class="line">    	fsm-&gt;deinitCallback = cb;</span><br><span class="line">    	connFsm-&gt;connInfo.addr = *target;</span><br><span class="line">LnnSendJoinRequestToConnFsm(connFsm) </span><br><span class="line">    LnnFsmPostMessage(&amp;connFsm-&gt;fsm, FSM_MSG_TYPE_JOIN_LNN, <span class="literal">NULL</span>);</span><br><span class="line">        PostMessageToFsm(&amp;connFsm-&gt;fsm, FSM_CTRL_MSG_DATA, FSM_MSG_TYPE_JOIN_LNN, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            msg = CreateFsmHandleMsg(&amp;connFsm-&gt;fsm, FSM_CTRL_MSG_DATA, FSM_MSG_TYPE_JOIN_LNN, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            fsm-&gt;looper-&gt;PostMessage(fsm-&gt;looper, msg);</span><br></pre></td></tr></table></figure>

<p>可以发现这个函数是使用了LnnConnectionFsm，这个是连接状态机。然后构造一个消息给looper运行，我们只需要关注消息的handler就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg的handler就是状态机的handler</span></span><br><span class="line">msg-&gt;handler = &amp;fsm-&gt;handler;</span><br><span class="line">fsm-&gt;handler.HandleMessage = FsmStateMsgHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// msg-&gt;what == FSM_CTRL_MSG_DATA</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FsmStateMsgHandler</span><span class="params">(SoftBusMessage *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what) &#123;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_START:</span><br><span class="line">            ProcessStartMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_DATA:</span><br><span class="line">            ProcessDataMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_STOP:</span><br><span class="line">            ProcessStopMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FSM_CTRL_MSG_DEINIT:</span><br><span class="line">            ProcessDeinitMessage(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ProcessDataMessage</span><span class="params">(SoftBusMessage *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    FsmCtrlMsgObj *ctrlMsgObj = msg-&gt;obj;</span><br><span class="line">    FsmStateMachine *fsm = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//由于msg-&gt;obj == NULL，所以在这里会返回</span></span><br><span class="line">    <span class="keyword">if</span> (ctrlMsgObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fsm = ctrlMsgObj-&gt;fsm;</span><br><span class="line">    <span class="keyword">if</span> (fsm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fsm-&gt;curState == <span class="literal">NULL</span> || (fsm-&gt;flag &amp; FSM_FLAG_RUNNING) == <span class="number">0</span>) &#123;</span><br><span class="line">        SoftBusLog(SOFTBUS_LOG_LNN, SOFTBUS_LOG_ERROR, <span class="string">&quot;unexpected state in data msg(%d) process, flag=0x%x&quot;</span>,</span><br><span class="line">            (<span class="type">int32_t</span>)msg-&gt;arg1, fsm-&gt;flag);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fsm-&gt;curState-&gt;process != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fsm-&gt;curState-&gt;process(fsm, (<span class="type">int32_t</span>)msg-&gt;arg1, ctrlMsgObj-&gt;obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/OpenHarmony/3.dsoftbus_core_1/" data-id="cmbcy7rhk002at8mt57i85b8i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/31/killer-blog/Linux/vm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/05/31/killer-blog/OpenHarmony/5.softbus_server/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
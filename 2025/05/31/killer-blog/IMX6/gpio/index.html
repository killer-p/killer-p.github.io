<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="gpio以gpio1控制器为例，来分析gpio子系统。首先从设备树节点入手 设备树节点 compatible：表示该gpio控制器的类型，fsl使用一个同用的驱动程序来设置gpio控制器 reg：表示gpio1的起始地址和范围 interrupts：表示中断类型、中断号、触发方式，每16个gpio口共用一个中断号，所以有32&#x2F;16&#x3D;2个中断号 gpio-controller：表">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/05/31/killer-blog/IMX6/gpio/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="gpio以gpio1控制器为例，来分析gpio子系统。首先从设备树节点入手 设备树节点 compatible：表示该gpio控制器的类型，fsl使用一个同用的驱动程序来设置gpio控制器 reg：表示gpio1的起始地址和范围 interrupts：表示中断类型、中断号、触发方式，每16个gpio口共用一个中断号，所以有32&#x2F;16&#x3D;2个中断号 gpio-controller：表">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-31T02:36:45.799Z">
<meta property="article:modified_time" content="2025-06-01T00:19:46.348Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/IMX6/gpio" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/31/killer-blog/IMX6/gpio/" class="article-date">
  <time class="dt-published" datetime="2025-05-31T02:36:45.799Z" itemprop="datePublished">2025-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="gpio"><a href="#gpio" class="headerlink" title="gpio"></a>gpio</h2><p>以gpio1控制器为例，来分析gpio子系统。首先从设备树节点入手</p>
<h3 id="设备树节点"><a href="#设备树节点" class="headerlink" title="设备树节点"></a>设备树节点</h3><ul>
<li>compatible：表示该gpio控制器的类型，fsl使用一个同用的驱动程序来设置gpio控制器</li>
<li>reg：表示gpio1的起始地址和范围</li>
<li>interrupts：表示中断类型、中断号、触发方式，每16个gpio口共用一个中断号，所以有32&#x2F;16&#x3D;2个中断号</li>
<li>gpio-controller：表示节点是一个gpio-controller，可以被gpio子系统识别</li>
<li>interrupt-controller：表示节点是一个interrupt-controller，会被中断子系统识别。</li>
<li>#interrupt-cells &#x3D; &lt;2&gt;;表示需要用2个cell描述一个gpio中断请求的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">		     &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>gpio驱动的代码在drivers\gpio\gpio-mxc.c，可以发现其是一个platform_driver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mxc_gpio_driver</span> =</span> &#123;</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;gpio-mxc&quot;</span>,</span><br><span class="line">		.of_match_table = mxc_gpio_dt_ids,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe		= mxc_gpio_probe,</span><br><span class="line">	.id_table	= mxc_gpio_devtype,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在linux中，一般将gpio控制器看成是 一个gpio芯片和一个中断控制芯片，所以开发gpio控制器需要对接linux的gpio子系统和中断子系统。</p>
<p>主要的代码在probe函数，初始化一个gpio控制器有以下部分：</p>
<ul>
<li>获取设备树资源</li>
<li>设置gpio_chip，接入gpio子系统</li>
<li>设置中断回调函数，irq_chip_generic，接入中断子系统</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxc_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxc_gpio_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">iores</span>;</span></span><br><span class="line">	<span class="type">int</span> irq_base;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="comment">//获取fsl,imx35-gpio对应的硬件信息</span></span><br><span class="line">	mxc_gpio_get_hw(pdev);</span><br><span class="line">	<span class="comment">//申请一个mxc_gpio_port 结构体，代表一个gpio端口</span></span><br><span class="line">	port = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*port), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!port)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">//获取gpio控制器的内存地址 并转换成虚拟地址</span></span><br><span class="line">	iores = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	port-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, iores);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(port-&gt;base);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取gpio控制器在GIC控制器中的两个中断号</span></span><br><span class="line">	port-&gt;irq_high = platform_get_irq(pdev, <span class="number">1</span>);</span><br><span class="line">	port-&gt;irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (port-&gt;irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> port-&gt;irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭中断，清除中断标志位</span></span><br><span class="line">	writel(<span class="number">0</span>, port-&gt;base + GPIO_IMR);</span><br><span class="line">	writel(~<span class="number">0</span>, port-&gt;base + GPIO_ISR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*给GPIO控制器设置中断处理函数 mx2_gpio_irq_handler</span></span><br><span class="line"><span class="comment">	  GPIO控制器的中断处理函数是chained类型，就是不能request、probe、thread</span></span><br><span class="line"><span class="comment">	  当gpio控制器产生中断时，中断函数会触发执行，在中断函数中检查是具体那个控制器那个引脚产生的中断</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (mxc_gpio_hwtype == IMX21_GPIO) &#123;</span><br><span class="line">		irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		irq_set_chained_handler(port-&gt;irq, mx3_gpio_irq_handler);</span><br><span class="line">		irq_set_handler_data(port-&gt;irq, port);</span><br><span class="line">		<span class="keyword">if</span> (port-&gt;irq_high &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* setup handler for GPIO 16 to 31 */</span></span><br><span class="line">			irq_set_chained_handler(port-&gt;irq_high,</span><br><span class="line">						mx3_gpio_irq_handler);</span><br><span class="line">			irq_set_handler_data(port-&gt;irq_high, port);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化bgpio_chip，初始化gpio_chip的函数，因为这些函数就是操作寄存器，所有有很大的通用性，故抽象成bgpio</span></span><br><span class="line">	err = bgpio_init(&amp;port-&gt;bgc, &amp;pdev-&gt;dev, <span class="number">4</span>,</span><br><span class="line">			 port-&gt;base + GPIO_PSR,</span><br><span class="line">			 port-&gt;base + GPIO_DR, <span class="literal">NULL</span>,</span><br><span class="line">			 port-&gt;base + GPIO_GDIR, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line">	<span class="comment">//设置函数</span></span><br><span class="line">	port-&gt;bgc.gc.to_irq = mxc_gpio_to_irq;</span><br><span class="line">	port-&gt;bgc.gc.base = (pdev-&gt;id &lt; <span class="number">0</span>) ? of_alias_get_id(np, <span class="string">&quot;gpio&quot;</span>) * <span class="number">32</span> :</span><br><span class="line">					     pdev-&gt;id * <span class="number">32</span>;</span><br><span class="line">	<span class="comment">//将gpio_chip添加到gpio子系统</span></span><br><span class="line">	err = gpiochip_add(&amp;port-&gt;bgc.gc);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgpio_remove;</span><br><span class="line">	<span class="comment">//动态申请中断描述符，一共32个，对应32个gpio，从0到31</span></span><br><span class="line">	irq_base = irq_alloc_descs(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">32</span>, numa_node_id());</span><br><span class="line">	<span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = irq_base;</span><br><span class="line">		<span class="keyword">goto</span> out_gpiochip_remove;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 添加注册一个irq domian来代表gpio中断控制器</span></span><br><span class="line"><span class="comment">	 np:表示中断控制器节点</span></span><br><span class="line"><span class="comment">	 32表示domain支持的irq_number的数量</span></span><br><span class="line"><span class="comment">	 irq_base 是第一个irq_number</span></span><br><span class="line"><span class="comment">     0 第一个hw_irq</span></span><br><span class="line"><span class="comment">	 irq_domain_simple_ops 映射回调函数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	port-&gt;domain = irq_domain_add_legacy(np, <span class="number">32</span>, irq_base, <span class="number">0</span>,</span><br><span class="line">					     &amp;irq_domain_simple_ops, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!port-&gt;domain) &#123;</span><br><span class="line">		err = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out_irqdesc_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化GPIO控制器对应的irq_chip_generic结构体</span></span><br><span class="line">	mxc_gpio_init_gc(port, irq_base);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入gpio端口列表</span></span><br><span class="line">	list_add_tail(&amp;port-&gt;node, &amp;mxc_gpio_ports);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_irqdesc_free:</span><br><span class="line">	irq_free_descs(irq_base, <span class="number">32</span>);</span><br><span class="line">out_gpiochip_remove:</span><br><span class="line">	gpiochip_remove(&amp;port-&gt;bgc.gc);</span><br><span class="line">out_bgpio_remove:</span><br><span class="line">	bgpio_remove(&amp;port-&gt;bgc);</span><br><span class="line">out_bgio:</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;%s failed with errno %d\n&quot;</span>, __func__, err);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="gpio-chip"><a href="#gpio-chip" class="headerlink" title="gpio_chip"></a>gpio_chip</h3><p>为了使用gpio子系统，需要完成gpio_chip结构体。gpio_chip用于描述gpio控制器，驱动程序需要实现该gpio_chip结构体的成员，并添加到gpio子系统中。</p>
<p>由于不同gpio控制器其实有许多相同的地方，所以可以使用gpio-generic.c中提供的<code>bgpio_init</code>来辅助完成gpio_chip对象。该函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 初始化bgc</span></span><br><span class="line"><span class="comment"> sz: 8 * sz 为寄存器的位数 一般为32位</span></span><br><span class="line"><span class="comment"> dat:gpio状态寄存器</span></span><br><span class="line"><span class="comment"> set:设置gpio状态</span></span><br><span class="line"><span class="comment"> clr:清除gpio</span></span><br><span class="line"><span class="comment"> dirout:设置gpio为输出</span></span><br><span class="line"><span class="comment"> dirin:设置gpio为输入</span></span><br><span class="line"><span class="comment"> flag:标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bgpio_init</span><span class="params">(<span class="keyword">struct</span> bgpio_chip *bgc, <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">	       <span class="type">unsigned</span> <span class="type">long</span> sz, <span class="type">void</span> __iomem *dat, <span class="type">void</span> __iomem *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">	       <span class="type">void</span> __iomem *clr, <span class="type">void</span> __iomem *dirout, <span class="type">void</span> __iomem *dirin,</span></span><br><span class="line"><span class="params">	       <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br></pre></td></tr></table></figure>

<p>不同的CPU的GPIO控制器是可以抽象出许多共同点的，一般来说，一个控制器会控制若干个PIN，主要由以下的寄存器：</p>
<ul>
<li>输出寄存器：每一位表示PIN脚的输出电平</li>
<li>输入寄存器：每一位表示PIN脚的输入电平</li>
<li>方向寄存器：每一位表示PIN脚是输出&#x2F;输入</li>
<li>中断配置寄存器：配置PIN脚中断触发方式</li>
<li>中断使能寄存器：每一位表示PIN脚的中断使能开关</li>
<li>中断状态寄存器：每一位表示PIN脚的中断状态</li>
</ul>
<p>gpio_chip结构体的成员函数本质就是通过读写这些寄存器来实现的。</p>
<p>所以驱动开发只需要提供寄存器的相关信息，并了解bgpio的函数接口，就能完成gpio_chip对象的实现。例如上面的probe函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化bgpio_chip，其实就是初始化gpio_chip的成员</span></span><br><span class="line">err = bgpio_init(&amp;port-&gt;bgc, &amp;pdev-&gt;dev, <span class="number">4</span>,</span><br><span class="line">		 port-&gt;base + GPIO_PSR,</span><br><span class="line">		 port-&gt;base + GPIO_DR, <span class="literal">NULL</span>,</span><br><span class="line">		 port-&gt;base + GPIO_GDIR, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置函数</span></span><br><span class="line">port-&gt;bgc.gc.to_irq = mxc_gpio_to_irq;</span><br><span class="line">port-&gt;bgc.gc.base = (pdev-&gt;id &lt; <span class="number">0</span>) ? of_alias_get_id(np, <span class="string">&quot;gpio&quot;</span>) * <span class="number">32</span> :</span><br><span class="line">				     pdev-&gt;id * <span class="number">32</span>;</span><br><span class="line"><span class="comment">//将gpio_chip添加到gpio子系统</span></span><br><span class="line">err = gpiochip_add(&amp;port-&gt;bgc.gc);</span><br></pre></td></tr></table></figure>



<p>当我们开发按键驱动程序时，需要使用GPIO子系统的接口，就可以直接使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请一个gpio，设置为输入，传入gpio的引脚编号作为参数</span></span><br><span class="line">gpio_request(keyirq.gpio,<span class="string">&quot;keyirq&quot;</span>);</span><br><span class="line">gpio_direction_input(keyirq.gpio);</span><br></pre></td></tr></table></figure>





<h3 id="gpio中断控制器"><a href="#gpio中断控制器" class="headerlink" title="gpio中断控制器"></a>gpio中断控制器</h3><p>当我们使用中断时，往往只需要以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把硬件中断hw_irq映射到irq_number</span></span><br><span class="line">keyirq.irq_num = irq_of_parse_and_map(keyirq.nd,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//注册中断函数</span></span><br><span class="line"><span class="keyword">if</span>(request_irq(keyirq.irq_num,key0_handler,IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING,<span class="string">&quot;keyirq&quot;</span>,&amp;keyirq) &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq fail\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>理解这些需要比较深入了解linux的驱动子系统。推荐: <a target="_blank" rel="noopener" href="http://www.wowotech.net/irq_subsystem/interrupt_subsystem_architecture.html">Linux kernel的中断子系统之（一）：综述 (wowotech.net)</a></p>
<p>先把上面的代码搁置，首先从硬件来了解中断的处理：</p>
<p>中断信号一般由这样的过程构成：</p>
<ol>
<li>中断源，比如按键</li>
<li>gpio控制器</li>
<li>GIC，通用中断控制器</li>
<li>CPU</li>
</ol>
<p>而软件上的中断需要经过这样的处理：</p>
<ol>
<li>CPU产生IRQ中断，跳转到IRQ_Handler</li>
<li>IRQ_Handler中读取GIC寄存器，判断是gpio控制器产生的中断，跳转到gpio_handler</li>
<li>gpio_handler读取gpio控制器的寄存器，判断是哪个PIN产生的中断</li>
<li>跳转到特点PIN的中断处理函数</li>
</ol>
<p>软件的中断处理就是硬件中断信号的逆过程。实际上可以把gpio控制器也看成是一个类似于GIC的中断控制器，linux中正是这么做的。这样就像把多个GIC串联起来。</p>
<h4 id="中断号"><a href="#中断号" class="headerlink" title="中断号"></a>中断号</h4><p>这里补充一个中断号的点。假设有一个GIC，他能处理120个中断，那么他就会把中断编号成0-119，假设系统有另一个相同的GIC，他也有一样的中断编号0-119，但是所对应的硬件显然是不一样的。这对于软件开发而言是很麻烦的，我们需要去区别这个中断编号是哪个GIC下的。</p>
<p>对于软件开发来说，最理想的情况就是，一个中断源对应一个中断号，一个中断号有一个中断处理函数。而实际的硬件中断编号是无法满足我们的要求的。</p>
<p>linux提出了domain的结构体来应对这个情况。domain的作用就是把硬件中断号转换成一个虚拟的中断号。linux把硬件中断号称为hw_irq，虚拟中断号称为irq_number。一般来说，一个中断控制器就拥有一个domain，在GIC1的domain1下，有0-119中断号，在GIC2的domain2下，有0-119中断号.domain1和domain2把这些hw_irq转换成唯一的irq_number。</p>
<p>有了这个机制，软件使用中断时，只需要把设备树中的hw_irq转换到irq_number，然后注册中断服务函数到irq_number就可以。非常方便</p>
<h4 id="初始化中断服务函数"><a href="#初始化中断服务函数" class="headerlink" title="初始化中断服务函数"></a>初始化中断服务函数</h4><p>而对于中断控制器来说，中断的初始化就复杂了些。</p>
<p>前面说过，gpio端口控制器也是一个中断控制器，可以设置中断，查看中断状态。所以，就需要创建一个domain，来将hw_irq转换成irq_number。这一部分，在probe函数中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态申请中断描述符，一共32个，对应32个gpio，从0到31，返回irq_number的第一个</span></span><br><span class="line">irq_base = irq_alloc_descs(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">32</span>, numa_node_id());</span><br><span class="line"><span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	err = irq_base;</span><br><span class="line">	<span class="keyword">goto</span> out_gpiochip_remove;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 添加注册一个irq domian来将hw_irq转换成irq_number</span></span><br><span class="line"><span class="comment"> np:表示中断控制器节点</span></span><br><span class="line"><span class="comment"> 32表示domain支持的irq_number的数量</span></span><br><span class="line"><span class="comment"> irq_base 是第一个irq_number</span></span><br><span class="line"><span class="comment">    0 第一个hw_irq</span></span><br><span class="line"><span class="comment"> irq_domain_simple_ops 映射回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">port-&gt;domain = irq_domain_add_legacy(np, <span class="number">32</span>, irq_base, <span class="number">0</span>,</span><br><span class="line">				     &amp;irq_domain_simple_ops, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>linux中使用中断描述符来表示一个具体的中断，一个gpio端口有32个中断源，所以需要32个中断描述符。</p>
<p>irq_alloc_descs()返回的是创建的中断描述符的irq_number</p>
<p>irq_domain_add_legacy 则创建一个domain，并建立irq_number和hw_irq的关系，irq_domain_simple_ops 结构体中含有把hw_irq转换成irq_number的代码。</p>
<p>除此之外，还要实现第三点 <strong>gpio_handler读取gpio控制器的寄存器，判断是哪个PIN产生的中断</strong>，所以需要设置gpio控制器的中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给GPIO控制器设置中断处理函数 mx2_gpio_irq_handler</span></span><br><span class="line"><span class="comment">  GPIO控制器的中断处理函数是chained类型，就是不能request、probe、thread</span></span><br><span class="line"><span class="comment">  当gpio控制器产生中断时，中断函数会触发执行，在中断函数中检查是具体那个控制器那个引脚产生的中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (mxc_gpio_hwtype == IMX21_GPIO) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setup one handler for all GPIO interrupts. Actually setting</span></span><br><span class="line"><span class="comment">	 * the handler is needed only once, but doing it for every port</span></span><br><span class="line"><span class="comment">	 * is more robust and easier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* setup one handler for each entry */</span></span><br><span class="line">	irq_set_chained_handler(port-&gt;irq, mx3_gpio_irq_handler);</span><br><span class="line">	irq_set_handler_data(port-&gt;irq, port);</span><br><span class="line">	<span class="keyword">if</span> (port-&gt;irq_high &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* setup handler for GPIO 16 to 31 */</span></span><br><span class="line">		irq_set_chained_handler(port-&gt;irq_high,</span><br><span class="line">					mx3_gpio_irq_handler);</span><br><span class="line">		irq_set_handler_data(port-&gt;irq_high, port);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gpio端口中断函数：</p>
<p>在gpio端口中断函数中，需要读取状态寄存器，确定哪个PIN脚产生的中断，以及其对应的hw_irq。然后使用gpio端口的domain，将hw_irq转换成irq_number，进而调用对应的中断描述符的中断服务函数，例如按键中断服务函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gpio端口中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mx3_gpio_irq_handler</span><span class="params">(u32 irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 irq_stat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxc_gpio_port</span> *<span class="title">port</span> =</span> irq_get_handler_data(irq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> =</span> irq_get_chip(irq);</span><br><span class="line"></span><br><span class="line">	chained_irq_enter(chip, desc);</span><br><span class="line">	<span class="comment">//读取端口的中断状态</span></span><br><span class="line">	irq_stat = readl(port-&gt;base + GPIO_ISR) &amp; readl(port-&gt;base + GPIO_IMR);</span><br><span class="line">	<span class="comment">//处理具体PIN的中断</span></span><br><span class="line">	mxc_gpio_irq_handler(port, irq_stat);</span><br><span class="line"></span><br><span class="line">	chained_irq_exit(chip, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理端口上的PIN中断</span></span><br><span class="line"><span class="comment">//irq_stat 保存的是中断状态寄存器的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mxc_gpio_irq_handler</span><span class="params">(<span class="keyword">struct</span> mxc_gpio_port *port, u32 irq_stat)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理端口上所有PIN脚的中断</span></span><br><span class="line">	<span class="keyword">while</span> (irq_stat != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> irqoffset = fls(irq_stat) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (port-&gt;both_edges &amp; (<span class="number">1</span> &lt;&lt; irqoffset))</span><br><span class="line">			mxc_flip_edge(port, irqoffset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//irq_find_mapping 使用domain将hw_irq转换成irq_number</span></span><br><span class="line">		generic_handle_irq(irq_find_mapping(port-&gt;domain, irqoffset));</span><br><span class="line"></span><br><span class="line">		irq_stat &amp;= ~(<span class="number">1</span> &lt;&lt; irqoffset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_handle_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过irq_number找到中断描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">//调用描述符中的处理函数，这个函数应该是在request_irq的时候设置的</span></span><br><span class="line">	generic_handle_irq_desc(irq, desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">generic_handle_irq_desc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	desc-&gt;handle_irq(irq, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="初始化中断芯片对象"><a href="#初始化中断芯片对象" class="headerlink" title="初始化中断芯片对象"></a>初始化中断芯片对象</h4><p>以上只是设置了中断的调用流程，还需要实现中断的配置，就是实现irq_chip_generic结构体。</p>
<p>irq_chip_generic 是属于中断子系统的一部分，用于抽象的描述一个中断控制器，一个中断控制器能控制中断的开关、触发方式等，所以驱动需要实现这个对象，上层的驱动才能通过中断子系统来设置gpio中断。</p>
<p>对于gpio控制器 ，本质上就是读写ISR、IMR寄存器就能完成中断的控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化GPIO控制器对应的irq_chip_generic结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">mxc_gpio_init_gc</span><span class="params">(<span class="keyword">struct</span> mxc_gpio_port *port, <span class="type">int</span> irq_base)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_generic</span> *<span class="title">gc</span>;</span>  <span class="comment">//中断芯片</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip_type</span> *<span class="title">ct</span>;</span>  <span class="comment">//中断芯片的流控</span></span><br><span class="line">	<span class="comment">//动态申请一个中断芯片对象，他控制的linux中断号为irq_base,芯片基地址，以及中断芯片处理函数</span></span><br><span class="line">	gc = irq_alloc_generic_chip(<span class="string">&quot;gpio-mxc&quot;</span>, <span class="number">1</span>, irq_base,</span><br><span class="line">				    port-&gt;base, handle_level_irq);</span><br><span class="line">	gc-&gt;private = port;</span><br><span class="line">	<span class="comment">//初始化irq_chip 即GPIO控制器的中断控制的函数</span></span><br><span class="line">	ct = gc-&gt;chip_types;</span><br><span class="line">	ct-&gt;chip.irq_ack = irq_gc_ack_set_bit;  <span class="comment">//设置中断状态寄存器</span></span><br><span class="line">	ct-&gt;chip.irq_mask = irq_gc_mask_clr_bit;  <span class="comment">//关闭某个中断</span></span><br><span class="line">	ct-&gt;chip.irq_unmask = irq_gc_mask_set_bit;  <span class="comment">//开启中断</span></span><br><span class="line">	ct-&gt;chip.irq_set_type = gpio_set_irq_type;  <span class="comment">//设置中断触发方式</span></span><br><span class="line">	ct-&gt;chip.irq_set_wake = gpio_set_wake_irq;  <span class="comment">//设置中断电源的管理</span></span><br><span class="line">	<span class="comment">//本质上上面的函数都是通过对ISR、IMR寄存器的操作就能完成</span></span><br><span class="line">	ct-&gt;regs.ack = GPIO_ISR;</span><br><span class="line">	ct-&gt;regs.mask = GPIO_IMR;</span><br><span class="line">	<span class="comment">//初始化gc</span></span><br><span class="line">	irq_setup_generic_chip(gc, IRQ_MSK(<span class="number">32</span>), IRQ_GC_INIT_NESTED_LOCK,</span><br><span class="line">			       IRQ_NOREQUEST, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/31/killer-blog/IMX6/gpio/" data-id="cmbcy7rhb001rt8mt8wim4bsc" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/31/killer-blog/IMX6/device_tree(pending)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/05/31/killer-blog/IMX6/input_subsystem/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
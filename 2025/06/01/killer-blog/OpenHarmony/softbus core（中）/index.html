<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="softbus core（中）连接必须搞定连接，才能了解后面的传输，传输就是基于连接创建的socket接口。从哪里入手？softbus_conn_manager.c： 首先要知道g_connManager这个对象，它用来管理所有的类型的连接。每种类型的连接都有对应的一个ConnectFuncInterface。 12345678910111213typedef struct &#123;    i">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/OpenHarmony/softbus%20core%EF%BC%88%E4%B8%AD%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="softbus core（中）连接必须搞定连接，才能了解后面的传输，传输就是基于连接创建的socket接口。从哪里入手？softbus_conn_manager.c： 首先要知道g_connManager这个对象，它用来管理所有的类型的连接。每种类型的连接都有对应的一个ConnectFuncInterface。 12345678910111213typedef struct &#123;    i">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-01T00:23:34.670Z">
<meta property="article:modified_time" content="2025-06-01T00:23:34.670Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/OpenHarmony/softbus core（中）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/OpenHarmony/softbus%20core%EF%BC%88%E4%B8%AD%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.670Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="softbus-core（中）"><a href="#softbus-core（中）" class="headerlink" title="softbus core（中）"></a>softbus core（中）</h2><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>必须搞定连接，才能了解后面的传输，传输就是基于连接创建的socket接口。从哪里入手？softbus_conn_manager.c：</p>
<p>首先要知道g_connManager这个对象，它用来管理所有的类型的连接。每种类型的连接都有对应的一个ConnectFuncInterface。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> (*ConnectDevice)(<span class="type">const</span> ConnectOption *option, <span class="type">uint32_t</span> requestId, <span class="type">const</span> ConnectResult *result);</span><br><span class="line">    <span class="type">int32_t</span> (*PostBytes)(<span class="type">uint32_t</span> connectionId, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">int32_t</span> len, <span class="type">int32_t</span> pid, <span class="type">int32_t</span> flag);</span><br><span class="line">    <span class="type">int32_t</span> (*DisconnectDevice)(<span class="type">uint32_t</span> connectionId);</span><br><span class="line">    <span class="type">int32_t</span> (*DisconnectDeviceNow)(<span class="type">const</span> ConnectOption *option);</span><br><span class="line">    <span class="type">int32_t</span> (*GetConnectionInfo)(<span class="type">uint32_t</span> connectionId, ConnectionInfo *info);</span><br><span class="line">    <span class="type">int32_t</span> (*StartLocalListening)(<span class="type">const</span> LocalListenerInfo *info);</span><br><span class="line">    <span class="type">int32_t</span> (*StopLocalListening)(<span class="type">const</span> LocalListenerInfo *info);</span><br><span class="line">    <span class="type">bool</span> (*CheckActiveConnection)(<span class="type">const</span> ConnectOption *info);</span><br><span class="line">&#125; ConnectFuncInterface;</span><br><span class="line"></span><br><span class="line">ConnectFuncInterface *g_connManager[CONNECT_TYPE_MAX]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>连接有通道的区分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CHANNEL_TYPE_TCP_DIRECT = <span class="number">0</span>,   </span><br><span class="line">    CHANNEL_TYPE_PROXY,    <span class="comment">//啥？</span></span><br><span class="line">    CHANNEL_TYPE_UDP,</span><br><span class="line">    CHANNEL_TYPE_AUTH,</span><br><span class="line">    CHANNEL_TYPE_BUTT,</span><br><span class="line">&#125; ChannelType;</span><br></pre></td></tr></table></figure>

<p>那么从初始化看：ConnServerInit，可以发现连接的物理层可以是wifi或蓝牙</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">g_connManagerCb.OnConnected = ConnManagerConnected;</span><br><span class="line">g_connManagerCb.OnDisconnected = ConnManagerDisconnected;</span><br><span class="line">g_connManagerCb.OnDataReceived = ConnManagerRecvData;</span><br><span class="line">SoftbusGetConfig(SOFTBUS_INT_SUPPORT_TCP_PROXY, (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;isSupportTcp, <span class="keyword">sizeof</span>(isSupportTcp));<span class="comment">//查看是否支持tcp</span></span><br><span class="line">connectObj = ConnInitTcp(&amp;g_connManagerCb);</span><br><span class="line">    InitProperty()</span><br><span class="line">    InitTcpInterface();</span><br><span class="line">    g_tcpConnCallback = g_connManagerCb;</span><br><span class="line">    g_tcpConnInfoList = CreateSoftBusList();</span><br><span class="line">    <span class="keyword">return</span> &amp;g_tcpInterface;</span><br><span class="line">connectObj = ConnInitBr(&amp;g_connManagerCb);</span><br><span class="line">connectObj = ConnInitBle(&amp;g_connManagerCb);</span><br><span class="line">g_connManager[CONNECT_TCP] = connectObj;</span><br><span class="line">g_listenerList = CreateSoftBusList();</span><br></pre></td></tr></table></figure>

<p>以tcp方式为例，可以看到ConnInitTcp()的任务就是返回了一个tcp的ConnectFuncInterface，这个接口是已经定义好了的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">InitTcpInterface</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tcpInterface.ConnectDevice = TcpConnectDevice;</span><br><span class="line">    g_tcpInterface.DisconnectDevice = TcpDisconnectDevice;</span><br><span class="line">    g_tcpInterface.DisconnectDeviceNow = TcpDisconnectDeviceNow;</span><br><span class="line">    g_tcpInterface.PostBytes = TcpPostBytes;</span><br><span class="line">    g_tcpInterface.GetConnectionInfo = TcpGetConnectionInfo;</span><br><span class="line">    g_tcpInterface.StartLocalListening = TcpStartListening;</span><br><span class="line">    g_tcpInterface.StopLocalListening = TcpStopListening;</span><br><span class="line">    g_tcpInterface.CheckActiveConnection = TcpCheckActiveConnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就需要重点来看这些函数是如何实现的，可以发现其本质就是调用softbus_adapter_socket.c中的函数，这些函数实现了对socket的封装。</p>
<p>首先看看TcpConnectDevice：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fd = OpenTcpClientSocket(option-&gt;info.ipOption.ip, <span class="string">&quot;0.0.0.0&quot;</span>, (<span class="type">uint16_t</span>)option-&gt;info.ipOption.port, <span class="literal">false</span>);</span><br><span class="line">    SoftBusSocketCreate(SOFTBUS_AF_INET, SOFTBUS_SOCK_STREAM, <span class="number">0</span>, &amp;fd);</span><br><span class="line">        socket(domain, type, protocol);</span><br><span class="line">    ConnToggleNonBlockMode(fd, <span class="literal">true</span>)</span><br><span class="line">        fcntl(fd, F_SETFL, flags);</span><br><span class="line">    SetClientOption(fd);</span><br><span class="line">        SetReuseAddr(fd, <span class="number">1</span>);</span><br><span class="line">        SetNoDelay(fd, <span class="number">1</span>);</span><br><span class="line">    BindLocalIP(fd, myIp, <span class="number">0</span>);</span><br><span class="line">        SoftBusSocketBind(fd, (SoftBusSockAddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line">        bind(socketFd, &amp;sysAddr, (<span class="type">socklen_t</span>)addrLen);</span><br><span class="line">    SoftBusSocketConnect(fd, (SoftBusSockAddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line">        connect(socketFd, &amp;sysAddr, (<span class="type">socklen_t</span>)addrLen);</span><br><span class="line">TcpConnInfoNode *tcpConnInfoNode;</span><br><span class="line">AddTcpConnInfo(tcpConnInfoNode) </span><br><span class="line">AddTrigger(option-&gt;info.ipOption.moduleId, fd, WRITE_TRIGGER)</span><br><span class="line">    SoftbusBaseListenerInfo *info = g_listenerList[module].info;</span><br><span class="line">    AddTriggerToSet(fd, triggerType)</span><br><span class="line">    AddNewFdNode(info, fd)</span><br><span class="line">    g_maxFd = MaxFd(fd, g_maxFd);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么大胆的猜测TcpPostBytes()应该也是类似的，可以看到是根据connectid来确定fd的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST_FOR_EACH_ENTRY(item, &amp;g_tcpConnInfoList-&gt;<span class="built_in">list</span>, TcpConnInfoNode, node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item-&gt;connectionId == connectionId) &#123;</span><br><span class="line">        fd = item-&gt;info.info.ipInfo.fd;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SendTcpData(fd, data, len, flag);</span><br><span class="line">    WaitEvent(fd, SOFTBUS_SOCKET_OUT, USER_TIMEOUT_MS);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)SoftBusSocketSend(fd, &amp;buf[bytes], len - bytes, <span class="number">0</span>);</span><br><span class="line">        send(socketFd, buf, len, flags);</span><br><span class="line">    WaitEvent(fd, SOFTBUS_SOCKET_OUT, timeout);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么TcpStartListening也应该是类似的简单，可以发现它创建了一个socket监听端口，然后也创建一个线程ThreadPoolWorker。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListenerModule moduleId = info-&gt;info.ipListenerInfo.moduleId;</span><br><span class="line">SoftbusBaseListener *listener = CheckTcpListener(moduleId);</span><br><span class="line">    <span class="keyword">return</span> g_tcpListenerItems[i].listener;</span><br><span class="line">SetSoftbusBaseListener(moduleId, listener);</span><br><span class="line">    memcpy_s(g_listenerList[module].listener, <span class="keyword">sizeof</span>(SoftbusBaseListener),listener, <span class="keyword">sizeof</span>(SoftbusBaseListener))</span><br><span class="line">StartBaseListener(moduleId, info-&gt;info.ipListenerInfo.ip, info-&gt;info.ipListenerInfo.port, SERVER_MODE);</span><br><span class="line">    InitListenFd(module, ip, port);</span><br><span class="line">        OpenTcpServerSocket(ip, port);</span><br><span class="line">            SoftBusSocketCreate(SOFTBUS_AF_INET, SOFTBUS_SOCK_STREAM, <span class="number">0</span>, (<span class="type">int32_t</span> *)&amp;fd);</span><br><span class="line">            SetServerOption(fd);</span><br><span class="line">            BindLocalIP(fd, ip, (<span class="type">uint16_t</span>)port);</span><br><span class="line">        SoftBusSocketListen(listenerInfo-&gt;listenFd, DEFAULT_BACKLOG);</span><br><span class="line">            listen(socketFd, backLog);</span><br><span class="line">        SoftBusSocketFdSet(listenerInfo-&gt;listenFd, &amp;g_readSet);</span><br><span class="line">    PrepareBaseListener(module, modeType);</span><br><span class="line">        g_threadPool = ThreadPoolInit(THREADPOOL_THREADNUM, THREADPOOL_QUEUE_NUM);</span><br><span class="line">            CreateThreadPool(threadNum, queueMaxNum);</span><br><span class="line">            CreateThread((Runnable)ThreadPoolWorker, (<span class="type">void</span> *)pool, &amp;attr, (<span class="type">uint32_t</span> *)&amp;(pool-&gt;pthreads[i])</span><br><span class="line">        StartThread(module, modeType);</span><br><span class="line">            ThreadPoolAddJob(g_threadPool, (<span class="type">int32_t</span>(*)(<span class="type">void</span> *))SelectThread,<span class="literal">NULL</span>, PERSISTENT, (<span class="type">uintptr_t</span>)<span class="number">0</span>);</span><br><span class="line">                CheckThreadPoolAddReady(pool, callbackFunction);</span><br><span class="line">                SoftBusCondBroadcast(&amp;(pool-&gt;queueNotEmpty));</span><br><span class="line">                    pthread_cond_broadcast((<span class="type">pthread_cond_t</span> *)*cond);    <span class="comment">//解锁一些任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadPoolWorker读取队列中的数据。这部分应该需要了解一下线程池是怎么运行的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((pool-&gt;queueCurNum == <span class="number">0</span>) &amp;&amp; !pool-&gt;poolClose) &#123;</span><br><span class="line">    SoftBusCondWait(&amp;(pool-&gt;queueNotEmpty), &amp;(pool-&gt;mutex), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">JobCheck(pool, job);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;queueCurNum == <span class="number">0</span>) &#123;</span><br><span class="line">     SoftBusCondSignal(&amp;(pool-&gt;queueEmpty));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;queueCurNum == pool-&gt;queueMaxNum - <span class="number">1</span>) &#123;</span><br><span class="line">     SoftBusCondBroadcast(&amp;(pool-&gt;queueNotFull));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TcpStartListening中发现还有一个线程SelectThread，这个线程中，应该使用select读取数据，然后调用回调函数处理数据。</p>
<h2 id="会话传输"><a href="#会话传输" class="headerlink" title="会话传输"></a>会话传输</h2><p>ServerOpenSession()表示打开一个会话传输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransOpenSession(&amp;param, &amp;(transSerializer.transInfo));</span><br><span class="line">    TransOpenChannel(param, info);</span><br><span class="line">        appInfo = GetAppInfo(param);</span><br><span class="line">        TransGetLaneInfo(param, appInfo-&gt;myData.pid, &amp;object, &amp;info)</span><br><span class="line">        TransGetConnectOption(info, &amp;connOpt)</span><br><span class="line">        transInfo-&gt;channelType = TransGetChannelType(info);</span><br><span class="line">        TransOpenChannelProc((ChannelType)transInfo-&gt;channelType, appInfo, &amp;connOpt,&amp;(transInfo-&gt;channelId))</span><br><span class="line">        TransLaneMgrAddLane(transInfo-&gt;channelId, transInfo-&gt;channelType, object,appInfo-&gt;myData.pkgName)    <span class="comment">//创建一个TransLaneInfo *newLane，添加到链表</span></span><br></pre></td></tr></table></figure>

<p>那么重点就是TransOpenChannelProc()。他有三种类型的通道哦，先从简单的udp开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">TransOpenChannelProc</span><span class="params">(ChannelType type, AppInfo *appInfo, <span class="type">const</span> ConnectOption *connOpt,</span></span><br><span class="line"><span class="params">    <span class="type">int32_t</span> *channelId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == CHANNEL_TYPE_UDP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransOpenUdpChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_INFO, <span class="string">&quot;open udp channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == CHANNEL_TYPE_PROXY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransProxyOpenProxyChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;open proxy channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransOpenDirectChannel(appInfo, connOpt, channelId) != SOFTBUS_OK) &#123;</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;open direct channel err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SOFTBUS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransOpenUdpChannel：怎么就涉及认证连接了？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrepareAppInfoForUdpOpen(connOpt, appInfo, &amp;id)</span><br><span class="line">UdpChannelInfo *newChannel = NewUdpChannelByAppInfo(appInfo);</span><br><span class="line">TransAddUdpChannel(newChannel)</span><br><span class="line">OpenAuthConnForUdpNegotiation(newChannel)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来看看CHANNEL_TYPE_PROXY类型：TransProxyOpenProxyChannel</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TransProxyOpenConnChannel</span><br><span class="line">    <span class="title function_">TransGetConn</span><span class="params">(connInfo, &amp;conn)</span></span><br><span class="line">    ProxyChannelInfo *chan;</span><br><span class="line">    TransProxyCreateChanInfo(chan, chanNewId, appInfo)</span><br><span class="line">    ProxyConnInfo *connChan;</span><br><span class="line">    TransAddConnItem(connChan)</span><br><span class="line">    result.OnConnectFailed = TransOnConnectFailed;</span><br><span class="line">    result.OnConnectSuccessed = TransOnConnectSuccessed;</span><br><span class="line">    ConnConnectDevice(&amp;(connChan-&gt;connInfo), reqId, &amp;result);</span><br><span class="line">        g_connManager[info-&gt;type]-&gt;ConnectDevice(info, requestId, result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我门session已经建立了，如何发送数据，就看 ServerSendSessionMsg：<br>哦，有两种session，认证和普通的session</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">TransSendMsg</span><span class="params">(<span class="type">int32_t</span> channelId, <span class="type">int32_t</span> channelType, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">uint32_t</span> len, <span class="type">int32_t</span> msgType)</span></span><br><span class="line">&#123;</span><br><span class="line">    SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_INFO, <span class="string">&quot;send msg: id=%d, type=%d&quot;</span>, channelId, channelType);</span><br><span class="line">    <span class="keyword">switch</span> (channelType) &#123;</span><br><span class="line">        <span class="keyword">case</span> CHANNEL_TYPE_AUTH:</span><br><span class="line">            <span class="keyword">return</span> TransSendAuthMsg(channelId, data, (<span class="type">int32_t</span>)len);</span><br><span class="line">        <span class="keyword">case</span> CHANNEL_TYPE_PROXY:</span><br><span class="line">            <span class="keyword">return</span> TransProxyPostSessionData(channelId, (<span class="type">unsigned</span> <span class="type">char</span>*)data, len, (SessionPktType)msgType);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SoftBusLog(SOFTBUS_LOG_TRAN, SOFTBUS_LOG_ERROR, <span class="string">&quot;send msg: id=%d invalid type=%d&quot;</span>, channelId, channelType);</span><br><span class="line">            <span class="keyword">return</span> SOFTBUS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只看普通的session：TransProxyPostPacketData</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TransProxyGetSendMsgChanInfo(channelId, chanInfo)</span><br><span class="line">TransProxyPackBytes(channelId, &amp;packDataInfo, flags, &amp;seq);</span><br><span class="line">TransProxyTransDataSendMsg(channelId, (<span class="type">char</span> *)packDataInfo.outData, (<span class="type">int32_t</span>)packDataInfo.outLen, flags);</span><br><span class="line">    TransProxyGetSendMsgChanInfo(channelId, info)</span><br><span class="line">    TransProxyTransAppNormalMsg(info, payLoad, payLoadLen, flag);</span><br><span class="line">        singleLen = TransProxyGetBufLen();</span><br><span class="line">        TransProxyPackAppNormalMsg(&amp;msgHead, &amp;slicehead, payLoad + offset, dataLen, &amp;bufLen);</span><br><span class="line">        TransProxyTransSendMsg(info-&gt;connId, buf, bufLen, ProxyTypeToConnPri(flag));</span><br><span class="line">            ConnPostBytes(connectionId, &amp;data);</span><br><span class="line">            g_connManager[type]-&gt;PostBytes(connectionId, data-&gt;buf, (<span class="type">int32_t</span>)(data-&gt;len), data-&gt;pid, data-&gt;flag);</span><br></pre></td></tr></table></figure>


































<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.icode9.com/content-4-825230.html">https://www.icode9.com/content-4-825230.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/OpenHarmony/softbus%20core%EF%BC%88%E4%B8%AD%EF%BC%89/" data-id="cmbcy7rhp002rt8mtdvrk72ik" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/OpenHarmony/dsoftbus_core/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/OpenHarmony/stm32mp157_ir_control/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Linux中断系统（一）进入与退出中断本文会介绍linux 中如何进入&#x2F;退出中断处理，这部分是与ARM架构相关的，对于具体的中断处理（平台无关的），有另一篇博客介绍。 首先，容我在开头就指出 一个重要的结论：linux只会让代码运行在两个空间，user space 和 kernel space，这是与平台无关的。对于ARM架构来说，user space对应user mode，kernel">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/Linux/Linux_isr_1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Linux中断系统（一）进入与退出中断本文会介绍linux 中如何进入&#x2F;退出中断处理，这部分是与ARM架构相关的，对于具体的中断处理（平台无关的），有另一篇博客介绍。 首先，容我在开头就指出 一个重要的结论：linux只会让代码运行在两个空间，user space 和 kernel space，这是与平台无关的。对于ARM架构来说，user space对应user mode，kernel">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/reg.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/irq_stack.jpg">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/svc_stack.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/svc_stack_process.jpg">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/lr_fix.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/arm_mode.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/arm_regs.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/except_vector.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/cpsr_behavior.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.641Z">
<meta property="article:modified_time" content="2025-06-01T00:26:27.023Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/05/30/hello-world/Linux/Linux_isr_1/reg.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/Linux/Linux_isr_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/Linux_isr_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.641Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux中断系统（一）进入与退出中断"><a href="#Linux中断系统（一）进入与退出中断" class="headerlink" title="Linux中断系统（一）进入与退出中断"></a>Linux中断系统（一）进入与退出中断</h1><p>本文会介绍linux 中如何进入&#x2F;退出中断处理，这部分是与ARM架构相关的，对于具体的中断处理（平台无关的），有另一篇博客介绍。</p>
<p>首先，容我在开头就指出 一个重要的结论：linux只会让代码运行在两个空间，user space 和 kernel space，这是与平台无关的。对于ARM架构来说，user space对应user mode，kernel space 则对应SVC mode。对于ARM 中的剩余mode，linux 会将其业务都放到SVC mode 中处理。例如，当IRQ产生时，cpu会短暂的进入IRQ mode，保存寄存器后，立刻切换到SVC mode，在SVC mode 中执行中断处理函数。</p>
<p>总的来说，linux 希望在user mode处理应用逻辑，在svc mode 处理其他的代码逻辑。有了这个认识，就让我们开始学习Linux 是如何从头处理arm 中断的。</p>
<h2 id="一、ARM中断"><a href="#一、ARM中断" class="headerlink" title="一、ARM中断"></a>一、ARM中断</h2><p>本文只追踪ARM 的IRQ中断，如下所示，ARM core 有R0-R15 16个通用寄存器和一个CPSR 寄存器，ARM寄存器的定义可以参考另一篇博客。这里只需要知道重点是：</p>
<p>红色框的部分是banked 寄存器，当cpu 处于user mode时，使用的是R13、R14，当切换为IRQ mode 时，R13寄存器实际上对应的是SP_svc，R14寄存器实际上对应的是LR_svc。在不同mode下，虽然寄存器在代码的命名上相同，但实际的物理电路却是不一样的。</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/reg.png" alt="image-20240312223101305"></p>
<p>当ARM core 接受到一个IRQ中断时，硬件会自动完成以下步骤：</p>
<ol>
<li>将CPSR寄存器的值复制到SPSR_irq寄存器中，保存被中断时的cpu状态</li>
<li>将返回地址保存到LR_irq寄存器中，以便将来能继续执行</li>
<li>设置CPSR，切换到IRQ mode，并且关闭中断</li>
<li>将PC 设置为中断向量表中IRQ 处理函数的地址</li>
</ol>
<p>上面4步由硬件完成后，cpu 就会去执行中断向量表IRQ处理函数，这个函数在linux 初始化时就设置好了。</p>
<h2 id="二、vector-stub"><a href="#二、vector-stub" class="headerlink" title="二、vector_stub"></a>二、vector_stub</h2><h3 id="2-1、中断向量表"><a href="#2-1、中断向量表" class="headerlink" title="2.1、中断向量表"></a>2.1、中断向量表</h3><p>我们开始进入linux 的代码世界，幸运的是，我们所需的代码都在 arch&#x2F;arm&#x2F;kernel&#x2F;entry-armv.S 中，其中中断向量表的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	.section .vectors, &quot;ax&quot;, %progbits</span><br><span class="line">.L__vectors_start:</span><br><span class="line">	W(b)	vector_rst</span><br><span class="line">	W(b)	vector_und</span><br><span class="line">	W(ldr)	pc, .L__vectors_start + 0x1000</span><br><span class="line">	W(b)	vector_pabt</span><br><span class="line">	W(b)	vector_dabt</span><br><span class="line">	W(b)	vector_addrexcptn</span><br><span class="line">	W(b)	vector_irq</span><br><span class="line">	W(b)	vector_fiq</span><br></pre></td></tr></table></figure>

<p>可以看到每个向量对应一种异常模式，可是我搜索了vector_irq，却找不到其定义，这是为何？</p>
<p>我们在文章的开头中提到，linux 希望将所有异常的实际处理逻辑都放到svc mode 中去处理，故在此，linux 定义了一个宏vector_stub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	.macro	vector_stub, name, mode, correction=0</span><br><span class="line">	.align	5</span><br><span class="line"></span><br><span class="line">vector_\name:</span><br><span class="line">	......</span><br><span class="line">ENDPROC(vector_\name)</span><br></pre></td></tr></table></figure>

<p>并且在代码中有 <code>vector_stub	irq, IRQ_MODE, 4</code> ，将其宏展开之后就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	vector_stub	irq, IRQ_MODE, 4</span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br><span class="line"></span><br><span class="line">@宏展开后：</span><br><span class="line"></span><br><span class="line">vector_irq:</span><br><span class="line">	......</span><br><span class="line">ENDPROC(vector_irq)</span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br></pre></td></tr></table></figure>

<p>原来vector_irq 就是在这里定义的。</p>
<p>vector_stub 宏的作用就是：</p>
<ol>
<li>把被打断执行的程序的寄存器保存到异常模式的栈中</li>
<li>将cpu mode切换到svc mode</li>
<li>根据被打断时的cpu mode，跳转到指定的函数处理</li>
</ol>
<p>结合文章开头说的，linux 希望将所有异常的实际处理逻辑都放到svc mode 中去处理，vector_stub概括了所有异常所需的操作，保存寄存器，切到svc mode，执行对应的代码。具体的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#name 是名称，mode 是异常模式，correction是纠正lr为下一条指令</span><br><span class="line">	.macro	vector_stub, name, mode, correction=0</span><br><span class="line"></span><br><span class="line">vector_\name:</span><br><span class="line">	# 对lr 进行纠正，将lr设置成 &quot;被打断指令&quot;的下一条指令，具体见附录说明1</span><br><span class="line">	.if \correction</span><br><span class="line">	sub	lr, lr, #\correction</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	# 将r0，lr 保存到栈中</span><br><span class="line">	stmia	sp, &#123;r0, lr&#125;</span><br><span class="line">	# 把spsr复制到lr中(spsr只能使用mrs指令访问)</span><br><span class="line">	mrs	lr, spsr</span><br><span class="line">	# 把lr保存到sp加上偏移8的地址，保存的是spsr的值</span><br><span class="line">	str	lr, [sp, #8]</span><br><span class="line"></span><br><span class="line">	# 把cpsr复制到r0</span><br><span class="line">	mrs	r0, cpsr</span><br><span class="line">	# 将r0 的mode bit 修改为SVC_MODE</span><br><span class="line">	eor	r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">	# 将r0 复制到spsr_cxsf</span><br><span class="line">	msr	spsr_cxsf, r0</span><br><span class="line"></span><br><span class="line">	# lr = lr &amp; 0x0f：lr 保存的是spsr，即取低四bit，也就是lr 保存的是cpu mode</span><br><span class="line">	and	lr, lr, #0x0f</span><br><span class="line">	# 将sp 复制到r0</span><br><span class="line">	mov	r0, sp</span><br><span class="line">    # lr = *(pc + (lr &lt;&lt; 2))，根据cpu mode更新lr 地址</span><br><span class="line">    ldr	lr, [pc, lr, lsl #2]</span><br><span class="line">    # 跳转到lr地址执行，并将spsr_cxsf 的值复制到cpsr，即切换到SVC Mode</span><br><span class="line">	movs	pc, lr</span><br><span class="line">ENDPROC(vector_\name)</span><br></pre></td></tr></table></figure>

<h3 id="2-1、vector-irq"><a href="#2-1、vector-irq" class="headerlink" title="2.1、vector_irq"></a>2.1、vector_irq</h3><p>这么看还是比较难理解，我们以vector_irq 展开后为例子进行分析，假设当前cpu 正在svc mode执行（kernel space），此时中断产生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 第一节中所述，当进入vector_irq时，lr保存的是返回地址，spsr保存的是被中断时的cpu cpsr，sp切换到SP_irq</span><br><span class="line">vector_irq:</span><br><span class="line">	# lr - 4 就是IRQ返回时要继续执行的指令</span><br><span class="line">	sub	lr, lr, #4</span><br><span class="line"></span><br><span class="line">	# 将r0，lr按地址递增保存到sp 为基地址的栈中</span><br><span class="line">	stmia	sp, &#123;r0, lr&#125;</span><br><span class="line">	# 把spsr复制到lr中(spsr只能使用mrs指令访问)</span><br><span class="line">	mrs	lr, spsr</span><br><span class="line">	# 把lr保存到sp加上偏移8的地址上，保存的是spsr的值，也就是被中断时的cpu cpsr</span><br><span class="line">	str	lr, [sp, #8]</span><br><span class="line"></span><br><span class="line">	# 把cpsr复制到r0</span><br><span class="line">	mrs	r0, cpsr</span><br><span class="line">	# 将r0 的mode bit 修改为SVC_MODE</span><br><span class="line">	eor	r0, r0, #(IRQ_MODE ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">	# 将r0 复制到spsr_cxsf</span><br><span class="line">	msr	spsr_cxsf, r0</span><br><span class="line"></span><br><span class="line">	# lr = lr &amp; 0x0f：lr 保存的是spsr，即取低四bit，也就是lr保存的是cpu mode</span><br><span class="line">	and	lr, lr, #0x0f</span><br><span class="line">	# 将sp 复制到r0</span><br><span class="line">	mov	r0, sp</span><br><span class="line">    # lr = *(pc + (lr &lt;&lt; 2))，pc 指针加上 lr &lt;&lt; 2，也就是__irq_svc的地址，lr 就是__irq_invalid的值</span><br><span class="line">    ldr	lr, [pc, lr, lsl #2]</span><br><span class="line">    # 跳转到__irq_svc执行，并将spsr_cxsf 的值复制到cpsr，即切换到SVC Mode</span><br><span class="line">	movs	pc, lr</span><br><span class="line">ENDPROC(vector_irq)</span><br><span class="line"></span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br></pre></td></tr></table></figure>

<p>执行完成后，SP_irq栈空间如图所示，并且cpu切换到svc mode，去执行__irq_svc函数，r0作为参数保存了SP_irq的值。</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/irq_stack.jpg" alt="irq_stack"></p>
<p>到此，我们可以了解vector_stub 宏所实现的目的：<strong>保存被中断的r0，lr，cpsr到异常栈中，切到svc 模式去处理异常。</strong></p>
<h2 id="三、-irq-svc"><a href="#三、-irq-svc" class="headerlink" title="三、__irq_svc"></a>三、__irq_svc</h2><p>好了，vector_stub的事告一段落，接下来就要处理与中断处理有关的逻辑了。linux 将IRQ中断处理分为两种情况：</p>
<ol>
<li>当中断产生时，cpu 正在执行用户程序</li>
<li>当中断产生时，cpu 正在执行内核代码</li>
</ol>
<p>无论哪种情况下，都需要保存被打断时刻的寄存器信息，但这两种情况所需要的处理有些不同，分别由 __irq_svc 和 __irq_user 来进行处理.</p>
<p>本节会优先分析__irq_svc，简单来说，这个函数先保存上下文，然后执行中断处理函数，在退出异常之前，检查是否需要进行抢占调度。具体代码注释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__irq_svc:</span><br><span class="line">	svc_entry          @ 保存寄存器到svc 的栈</span><br><span class="line">	irq_handler        @ 执行中断处理函数，即下一篇描述的通用中断处理流程</span><br><span class="line"></span><br><span class="line">	@以下代码是判断是否需要进行抢占调度</span><br><span class="line">	ldr	r8, [tsk, #TI_PREEMPT]		@ 获取 preempt count</span><br><span class="line">	ldr	r0, [tsk, #TI_FLAGS]		@ 获取 flags</span><br><span class="line">	teq	r8, #0                       @ 将r8 与 0 进行异或操作，若结果为0则Z标志为1，否则Z标志为0</span><br><span class="line">	movne	r0, #0				   @ 若Z为0，则将r0 强制设置为0，不允许抢占调度</span><br><span class="line">	tst	r0, #_TIF_NEED_RESCHED      @ 将r0 与 _TIF_NEED_RESCHED进行与操作，若结果为0则Z标志为1，否则为0</span><br><span class="line">	blne	svc_preempt            @ 若Z不为0，则跳转到svc_preempt 执行，进行抢占调度</span><br><span class="line"></span><br><span class="line">	svc_exit r5, irq = 1			@ 从异常退出，返回到被打断的执行流</span><br><span class="line">ENDPROC(__irq_svc)</span><br></pre></td></tr></table></figure>

<h3 id="3-1、svc-entry"><a href="#3-1、svc-entry" class="headerlink" title="3.1、svc_entry"></a>3.1、svc_entry</h3><p>在中断产生时，我们希望保存被打断执行的程序的上下文，也就是所有的寄存器信息，对于arm 来说，就是r0-&gt;r15，以及CPSR，这样中断退出后，被打断的程序就能继续执行。</p>
<p>在 vector_stub 中，我们已经保存了R0，程序返回地址LR，程序状态SPSR。那么在svc_entry中，将继续保存剩下的所有寄存器！</p>
<p>svc_entry 将要保存的r0 -&gt; r15 ，cpsr按照下图的排列顺序，保存到当前的内核栈中，kernel 的struct pt_regs 结构体表示内核栈中的寄存器信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一共有18个reg 的值，其排列如下：低地址为r0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> uregs[<span class="number">18</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/svc_stack.png" alt="image-20240313233632426"></p>
<p>接下来分析源码，以及最终栈内寄存器的局势图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.macro	svc_entry</span><br><span class="line"></span><br><span class="line">sub	sp, sp, #(SVC_REGS_SIZE - 4)  @ 将sp减去17个reg 大小，预留出17个reg 的位置</span><br><span class="line"></span><br><span class="line">stmia	sp, &#123;r1 - r12&#125;       @ 将r1-&gt;r12 的13个值依次填入预留的位置</span><br><span class="line"></span><br><span class="line"># 接下来是计算一些地址</span><br><span class="line">ldmia	r0, &#123;r3 - r5&#125;        @ 取出IRQ Stack 中r0,lr,spsr 的值到r3、r4、r5，这些值也要保存到栈中</span><br><span class="line">add	r7, sp, #S_SP - 4	     @ R7 = SP + 13个reg的大小，R7的值就是栈内r13的地址</span><br><span class="line">mov	r6, #-1			        @  r6 赋值为-1</span><br><span class="line">add	r2, sp, #(SVC_REGS_SIZE - 4)   @ R2=SP+17个reg大小，R2的值就是一开始SP的值</span><br><span class="line">str	r3, [sp, #-4]!		    @ 将r3(也就是被打断的r0)保存到sp - 4的地址</span><br><span class="line">mov	r3, lr                  @ 将lr 保存到r3</span><br><span class="line"></span><br><span class="line">@ 经过上面的操作，目前的寄存器信息如下：</span><br><span class="line">@  r2 - sp_svc 进入svc_entry时，SP_SVC的值</span><br><span class="line">@  r3 - lr_svc 进入svc_entry时，LR_SVC的值</span><br><span class="line">@  r4 - 退出中断处理后要恢复执行的地址</span><br><span class="line">@  r5 - 退出中断处理后要恢复执行的cpu 状态</span><br><span class="line">@  r6 - -1 (see pt_regs definition in ptrace.h)</span><br><span class="line">@ 将上述寄存器都保存到栈内</span><br><span class="line">stmia	r7, &#123;r2 - r6&#125;</span><br><span class="line"></span><br><span class="line">@ 似乎是访问权限相关</span><br><span class="line">get_thread_info tsk                @ 获取当前task的thread_info,保存到tsk，(tsk就是r9)</span><br><span class="line">uaccess_entry tsk, r0, r1, r2, 1   @ 保存用户空间访问的相关信息到内核栈</span><br><span class="line"></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>最终栈内的信息可以概况成下图：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/svc_stack_process.jpg" alt="中断时寄存器-1710559066915"></p>
<h3 id="3-2、svc-exit"><a href="#3-2、svc-exit" class="headerlink" title="3.2、svc_exit"></a>3.2、svc_exit</h3><p>与svc_entry 成对的是svc_exit，顾名思义，他的作用应该是恢复保存在栈中的寄存器，最终实现恢复被打断的执行流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#在irq_entry中是：svc_exit r5, irq = 1，r5保存的是要恢复的CPSR，irq=1表示中断关闭</span><br><span class="line">.macro	svc_exit, rpsr, irq = 0</span><br><span class="line"></span><br><span class="line">@ 确保中断已经关闭</span><br><span class="line">.if	\irq != 0</span><br><span class="line">.else</span><br><span class="line">disable_irq_notrace</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">@ 从栈恢复用户空间访问信息</span><br><span class="line">uaccess_exit tsk, r0, r1</span><br><span class="line"></span><br><span class="line">@ 将cpsr保存到spsr_cxsf</span><br><span class="line">msr	spsr_cxsf, \rpsr</span><br><span class="line">@ 将栈中的值恢复到r0 -&gt; pc寄存器，^ 符号会将cpsr更新为spsr_cxsf，执行完这个指令后，cpu就会恢复之前的status，并恢复之前的执行流</span><br><span class="line">ldmia	sp, &#123;r0 - pc&#125;^			@ load r0 - pc, cpsr</span><br><span class="line"></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>



<h3 id="3-3、irq-handler-svc-preempt"><a href="#3-3、irq-handler-svc-preempt" class="headerlink" title="3.3、irq_handler &amp;&amp; svc_preempt"></a>3.3、irq_handler &amp;&amp; svc_preempt</h3><p>在svc_entry 和 svc_exit 之间，由 irq_handler 负责完成中断具体逻辑的处理，从此会进入linux irq 管理的世界，与平台无关的。</p>
<p>若中断执行完成后，此时符合内核抢占，则会调用svc_prermpt 进行内核抢占调度，这就是下一话的内容了。</p>
<h2 id="四、-irq-usr"><a href="#四、-irq-usr" class="headerlink" title="四、__irq_usr"></a>四、__irq_usr</h2><p>当中断产生时，cpu正在执行用户程序，处于user mode时，vector_irq会进入到irq_usr 进行中断处理。这里的逻辑和 __irq_svc 很类似，都是保存寄存器后再进行中断处理，然后返回到被中断的地方继续执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__irq_usr:</span><br><span class="line">	usr_entry                  @ 保存寄存器</span><br><span class="line">	irq_handler                @ 中断处理</span><br><span class="line">	get_thread_info tsk        @ 获取thread_info 到r9</span><br><span class="line">	mov	why, #0                @ why 是r8</span><br><span class="line">	b	ret_to_user_from_irq  @ 返回到用户</span><br><span class="line">ENDPROC(__irq_usr)</span><br></pre></td></tr></table></figure>



<h3 id="4-1、usr-entry"><a href="#4-1、usr-entry" class="headerlink" title="4.1、usr_entry"></a>4.1、usr_entry</h3><p>usr_entry 和 svc_entry 的目的是一样的，就是将寄存器保存到当前的栈中，寄存器在栈中的排列也和struct pt_regs 一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.macro	usr_entry, trace=1, uaccess=1</span><br><span class="line"></span><br><span class="line">sub	sp, sp, #PT_REGS_SIZE     @ 在栈中预留18个reg 的位置</span><br><span class="line">   stmib	sp, &#123;r1 - r12&#125;        @ 保存r1 - r12 到栈内</span><br><span class="line"></span><br><span class="line">ldmia	r0, &#123;r3 - r5&#125;        @ 从中断栈中取出寄存器</span><br><span class="line">add	r0, sp, #S_PC			@ r0 指向栈中PC的位置</span><br><span class="line">mov	r6, #-1			        @ r6 = -1</span><br><span class="line"></span><br><span class="line">str	r3, [sp]		@ 保存之前的r0</span><br><span class="line"></span><br><span class="line">@ 保存剩余的其他寄存器</span><br><span class="line">@  r4 - lr_&lt;exception&gt;, already fixed up for correct return/restart</span><br><span class="line">@  r5 - spsr_&lt;exception&gt;</span><br><span class="line">@  r6 - orig_r0 (see pt_regs definition in ptrace.h)</span><br><span class="line">@</span><br><span class="line">@ Also, separately save sp_usr and lr_usr</span><br><span class="line">@</span><br><span class="line">stmia	r0, &#123;r4 - r6&#125;</span><br><span class="line">   stmdb	r0, &#123;sp, lr&#125;^</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>



<h3 id="4-2、ret-to-user-from-irq"><a href="#4-2、ret-to-user-from-irq" class="headerlink" title="4.2、ret_to_user_from_irq"></a>4.2、ret_to_user_from_irq</h3><p>在返回用户程序之前，也会做一些检查，查看是否需要调度、处理信号等pending job，最后通过restore_user_regs 返回到用户程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_to_user_from_irq)</span><br><span class="line">	@ 对用户空间访问的一些检查</span><br><span class="line">	ldr	r2, [tsk, #TI_ADDR_LIMIT]</span><br><span class="line">	cmp	r2, #TASK_SIZE</span><br><span class="line">	blne	addr_limit_check_failed</span><br><span class="line">	@ 检查是否需要调度、是否有信号处理、返回用户空间之前是否需要调用callback函数，若需要则进入slow_work_pending处理</span><br><span class="line">	ldr	r1, [tsk, #TI_FLAGS]</span><br><span class="line">	tst	r1, #_TIF_WORK_MASK</span><br><span class="line">	bne	slow_work_pending</span><br><span class="line">no_work_pending:</span><br><span class="line">	arch_ret_to_user r1, lr</span><br><span class="line">	ct_user_enter save = 0</span><br><span class="line"></span><br><span class="line">	restore_user_regs fast = 0, offset = 0</span><br><span class="line">ENDPROC(ret_to_user_from_irq)</span><br></pre></td></tr></table></figure>

<p>restore_user_regs 与svc_exit 的逻辑是像似的，即从栈中恢复寄存器，并跳转到被打断的地方继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.macro	restore_user_regs, fast = 0, offset = 0</span><br><span class="line">uaccess_enable r1, isb=0</span><br><span class="line"></span><br><span class="line">mov	r2, sp</span><br><span class="line">ldr	r1, [r2, #\offset + S_PSR]	@ get calling cpsr r1保存了pt_regs中的spsr，也就是发生中断时的CPSR</span><br><span class="line">ldr	lr, [r2, #\offset + S_PC]!	@ get pc lr保存了PC值，同时sp移动到了pt_regs中PC的位置</span><br><span class="line">tst	r1, #PSR_I_BIT | 0x0f </span><br><span class="line">bne	1f</span><br><span class="line">msr	spsr_cxsf, r1			@ save in spsr_svc 赋值给spsr，进行返回用户空间的准备</span><br><span class="line"></span><br><span class="line">ldmdb	r2, &#123;r0 - lr&#125;^			@ get calling r0 - lr</span><br><span class="line"></span><br><span class="line">add	sp, sp, #\offset + PT_REGS_SIZE  @ 将sp_svc恢复到进入中断时的位置</span><br><span class="line">movs	pc, lr				       @ 恢复用户程序执行，并更新cpsr</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>通过本文的学习，理解linux 对于异常处理的核心思想，就是要在内核模式下处理所有异常相关的事务。这里的内核模式，即对应cpu 的管理员模式，每个架构的cpu都有这个模式，这样就不需要care 各个平台各种差异的模式了。只需要在其他异常产生时，保存好上下文，再跳转到对应的内核模式处理即可。</p>
<p>这种思路极大的简化了异常处理的逻辑，使得linux 可以适配更多的架构。</p>
<p>那么下一篇我们就进一步学习linux 如何具体的处理一个中断事务，也就是irq_handler 函数的流程。</p>
<h2 id="六、参考书籍"><a href="#六、参考书籍" class="headerlink" title="六、参考书籍"></a>六、参考书籍</h2><ul>
<li>《arm v7 user program guide》关于寄存器、异常的章节</li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/irq_subsystem/irq_handler.html">Linux kernel的中断子系统之（六）：ARM中断处理过程 (wowotech.net)</a></li>
</ul>
<h2 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h2><p>1、从异常返回时，返回地址的修正：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/lr_fix.png" alt="image-20240316090327044"></p>
<p>2、arm 处理器模式：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/arm_mode.png" alt="image-20240323102618435"></p>
<p>3、arm regs：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/arm_regs.png" alt="image-20240323102815295"></p>
<p>4、异常向量表：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/except_vector.png" alt="image-20240323103011293"></p>
<p>5、cpsr 在进入不同异常模式时，中断的使能：</p>
<p><img src="/2025/05/30/hello-world/Linux/Linux_isr_1/cpsr_behavior.png" alt="image-20240323103129402"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/Linux_isr_1/" data-id="cmbcy7rh30010t8mt502odpzd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/Linux/mm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/Linux/Linux_isr_2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="内核线程的创建流程在驱动开发过程中，我们经常需要使用到内核线程，在一次开发中，遇到一个如下的问题： 1234567891011int my_thread()&#123;    while(1)    &#123;        ...    &#125;    return 0;&#125;kthread_run(my_thread,data,..);kthread_stop(my_thread)">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/Linux/kthread/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="内核线程的创建流程在驱动开发过程中，我们经常需要使用到内核线程，在一次开发中，遇到一个如下的问题： 1234567891011int my_thread()&#123;    while(1)    &#123;        ...    &#125;    return 0;&#125;kthread_run(my_thread,data,..);kthread_stop(my_thread)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/Linux/kthread/create_kthread.jpg">
<meta property="article:published_time" content="2025-06-01T00:24:26.641Z">
<meta property="article:modified_time" content="2025-06-01T00:26:27.015Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/05/30/hello-world/Linux/kthread/create_kthread.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/Linux/kthread" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/Linux/kthread/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.641Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内核线程的创建流程"><a href="#内核线程的创建流程" class="headerlink" title="内核线程的创建流程"></a>内核线程的创建流程</h1><p>在驱动开发过程中，我们经常需要使用到内核线程，在一次开发中，遇到一个如下的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">kthread_run(my_thread,data,..);</span><br><span class="line"></span><br><span class="line">kthread_stop(my_thread);</span><br></pre></td></tr></table></figure>

<p>在上述代码中，理想的情况是：my_thread创建完成后，就会马上开始运行，父进程则会阻塞等待my_thread()退出（kthread_stop()会设置my_thread的stop flag，并等待my_thread退出）。但是，实际上有概率发生kthread_stop() 返回-4 的错误，并且my_thread() 线程没有得到执行。</p>
<p>由此决定探索下内核线程的创建流程，其代码主要在kernel&#x2F;kthread.c，kernel&#x2F;sched&#x2F;&#x2F;core.c</p>
<h2 id="一、整体框架"><a href="#一、整体框架" class="headerlink" title="一、整体框架"></a>一、整体框架</h2><p>如图所示，内核线程创建过程有三个对象：</p>
<ol>
<li>父进程：就是创建者</li>
<li>kthreadd()：专门负责创建内核线程的一个特殊的线程</li>
<li>kthread()：所有内核线程的入口函数</li>
</ol>
<p><img src="/2025/05/30/hello-world/Linux/kthread/create_kthread.jpg" alt="内核线程的创建"></p>
<p>本质上就是父进程将函数入口my_thread()、my_data，交给kthreadd()线程去完成真正的创建job，然后父进程会阻塞等待子线程完成创建。而新线程的创建基本都是在kthreadd()线程内完成的。</p>
<h2 id="二、父进程"><a href="#二、父进程" class="headerlink" title="二、父进程"></a>二、父进程</h2><p>分析父进程创建的动作，主要是两个部分：</p>
<ol>
<li>kthread_create()</li>
<li>wake_up_process()</li>
</ol>
<p>我们的分析主要在__kthread_create_on_node()，很简答，创建一个create 对象，放进线程的入口和数据，添加到kthread_create_list 链表，然后唤醒kthreadd()线程，阻塞等待创建。当创建完成后，设置新线程调度器参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __printf(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">kthread_create_on_node</span>(<span class="title">int</span> (*<span class="title">threadfn</span>)(<span class="title">void</span> *<span class="title">data</span>),</span></span><br><span class="line"><span class="class">						    <span class="title">void</span> *<span class="title">data</span>, <span class="title">int</span> <span class="title">node</span>,</span></span><br><span class="line"><span class="class">						    <span class="title">const</span> <span class="title">char</span> <span class="title">namefmt</span>[],</span></span><br><span class="line"><span class="class">						    <span class="title">va_list</span> <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//初始化create 信息</span></span><br><span class="line">	create-&gt;threadfn = threadfn;</span><br><span class="line">	create-&gt;data = data;</span><br><span class="line">	create-&gt;node = node;</span><br><span class="line">	create-&gt;done = &amp;done;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加到链表</span></span><br><span class="line">	list_add_tail(&amp;create-&gt;<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//唤醒kthread线程</span></span><br><span class="line">	wake_up_process(kthreadd_task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待直到新线程创建完成</span></span><br><span class="line">	wait_for_completion(&amp;done);</span><br><span class="line">	</span><br><span class="line">	task = create-&gt;result;</span><br><span class="line">    <span class="comment">//设置新线程的调度方式</span></span><br><span class="line">	sched_setscheduler_nocheck(task, SCHED_NORMAL, &amp;param);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒新线程</span></span><br><span class="line">wake_up_process()</span><br></pre></td></tr></table></figure>

<p>下面重点分析kthread()</p>
<h2 id="三、kthreadd-线程"><a href="#三、kthreadd-线程" class="headerlink" title="三、kthreadd()线程"></a>三、kthreadd()线程</h2><h3 id="3-1、kthreadd"><a href="#3-1、kthreadd" class="headerlink" title="3.1、kthreadd()"></a>3.1、kthreadd()</h3><p>本节最重要的工作就是在kthreadd()线程中。kthreadd 会将kthread_create_list内的create 信息取出，拿来创建新线程，若没有线程需要创建则会一直睡眠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthreadd</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 设置kthreadd为睡眠</span></span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	    <span class="comment">// 如果kthread_create_list 链表为空，说明没有线程需要创建，调度出去</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">			schedule();</span><br><span class="line">        <span class="comment">// 被wake up</span></span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;kthread_create_lock);</span><br><span class="line">		<span class="comment">//检查 kthread_create_list</span></span><br><span class="line">        <span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line"></span><br><span class="line">			create = list_entry(kthread_create_list.next,</span><br><span class="line">					    <span class="keyword">struct</span> kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">			list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">			spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">			<span class="comment">//根据create中的信息创建线程</span></span><br><span class="line">			create_kthread(create);</span><br><span class="line"></span><br><span class="line">			spin_lock(&amp;kthread_create_lock);</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上代码，最主要的线程创建代码就在create_kthread()，create_kthread() 会将kthread() 函数作为新线程的入口地址，将create_info作为函数的参数。这意味着，当新线程创建起来后，首先是执行kthread()函数，在kthread()函数中调用我们设置的my_thread()。</p>
<h3 id="3-2、kernel-clone"><a href="#3-2、kernel-clone" class="headerlink" title="3.2、kernel_clone()"></a>3.2、kernel_clone()</h3><p>直接分析最核心的函数 kernel_clone()，另外再备注下，clone_flag为：CLONE_FS | CLONE_FILES | SIGCHLD | CLONE_VM；</p>
<ul>
<li>CLONE_FS、CLONE_FILES：复制父进程打开的目录，文件</li>
<li>SIGCHLD ：复制父进程的信号处理函数</li>
<li>CLONE_VM：复制父进程的虚拟地址空间。（这就是线程的特性）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_clone</span><span class="params">(<span class="keyword">struct</span> kernel_clone_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 clone_flags = args-&gt;flags;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//前面是一堆对clone_flag参数的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制新的线程</span></span><br><span class="line">	p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(p))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line"></span><br><span class="line">	pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">	nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">		p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">		init_completion(&amp;vfork);</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让新线程进入运行状态</span></span><br><span class="line">	wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">	put_pid(pid);</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1、copy-process"><a href="#3-2-1、copy-process" class="headerlink" title="3.2.1、copy_process()"></a>3.2.1、copy_process()</h4><p>咱们来看最主要的 copy_process()，下面简化这个函数，只取关键部分。总结一句话就是拷贝父进程的task_struct的成员，并对部分成员额外进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对flag 进行一系列检查</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从父进程复制task_struct</span></span><br><span class="line">    p = dup_task_struct(current, node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对task_struct 的成员进行初始化，很多成员涉及非常多其他功能，需要用到时再分析，只需要知道大部分成员在这里初始化</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//初始化调度器相关的成员，并选择和父进程一样的调度器策略</span></span><br><span class="line">	sched_fork(clone_flags, p);</span><br><span class="line">    <span class="comment">// 拷贝打开的文件</span></span><br><span class="line">    copy_files(clone_flags, p);</span><br><span class="line">    <span class="comment">//拷贝文件系统</span></span><br><span class="line">    copy_fs(clone_flags, p);</span><br><span class="line">    <span class="comment">//拷贝信号处理函数</span></span><br><span class="line">    copy_sighand(clone_flags, p);</span><br><span class="line">    copy_signal(clone_flags, p);</span><br><span class="line">    <span class="comment">//拷贝进程地址空间，对于线程来说，不需要独立的地址空间</span></span><br><span class="line">    copy_mm(clone_flags, p);</span><br><span class="line">    copy_namespaces(clone_flags, p);</span><br><span class="line">    copy_io(clone_flags, p);</span><br><span class="line">    <span class="comment">// 拷贝内核栈</span></span><br><span class="line">    copy_thread(clone_flags, args-&gt;<span class="built_in">stack</span>, args-&gt;stack_size, p, args-&gt;tls);</span><br><span class="line">    <span class="comment">//分配一个pid</span></span><br><span class="line">    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children, args-&gt;set_tid,</span><br><span class="line">				args-&gt;set_tid_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后是一些进程关系相关的初始化</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2、wake-up-new-task"><a href="#3-2-2、wake-up-new-task" class="headerlink" title="3.2.2、wake_up_new_task"></a>3.2.2、wake_up_new_task</h4><p>自此，线程的数据结构已经创建完成，但是线程暂时还不能运行，需要有人来将他唤醒运行。wake_up_new_task() 会将新线程设置到run queue，并检查TIF_NEED_RESCHED是否需要抢占当前线程。</p>
<p>note:</p>
<ol>
<li>run queue：每个cpu都有一个run queue，queue里的元素是线程，cpu在调度时，会从run queue中选择合适的线程进行运行。</li>
<li>TIF_NEED_RESCHED：记录在每个线程中的标志位，表示需要立刻调度当前线程。线程特定时机会检查该标志位，若举起则会马上进行线程调度，切换掉当前线程。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf.flags);</span><br><span class="line">	<span class="comment">// 设置新线程为TASK_RUNNING</span></span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程所在的run queue</span></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	post_init_entity_util_avg(p);</span><br><span class="line">	<span class="comment">//将线程放入run queue</span></span><br><span class="line">	activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">	trace_sched_wakeup_new(p);</span><br><span class="line">    <span class="comment">//检查是否需要抢占当前的线程，若需要则会设置线程的TIF_NEED_RESCHED标志位</span></span><br><span class="line">	check_preempt_curr(rq, p, WF_FORK);</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，kernel_clone() 完成了新线程数据结构的创建、并让新线程准备好被调度执行了。现在万事俱备只欠东风，这个东风就是调度时机的到来。</p>
<p>假如此时kthreadd()中没有要新建的线程，那么，kthreadd() 就会主动调用schedule()函数，发起一次线程调度。那么刚刚创建线程大概率就会开始执行。（因为有概率其他优先级更高的线程更快执行）</p>
<h2 id="四、kthread"><a href="#四、kthread" class="headerlink" title="四、kthread"></a>四、kthread</h2><p>假如此时新线程执行，根据第三节所术，新线程的入口函数是kthread()。这是因为所有内核线程在第一次执行时，还需要通知父进程，并停止运行，等待其他线程的wake up。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kthread</span><span class="params">(<span class="type">void</span> *_create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Copy data: it&#x27;s on kthread&#x27;s stack */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> =</span> _create;</span><br><span class="line">	<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">	<span class="type">void</span> *data = create-&gt;data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">self</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	self = kzalloc(<span class="keyword">sizeof</span>(*self), GFP_KERNEL);</span><br><span class="line">	set_kthread_struct(self);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">	done = xchg(&amp;create-&gt;done, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">		kfree(create);</span><br><span class="line">		do_exit(-EINTR);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!self) &#123;</span><br><span class="line">		create-&gt;result = ERR_PTR(-ENOMEM);</span><br><span class="line">		complete(done);</span><br><span class="line">		do_exit(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置my_thread</span></span><br><span class="line">	self-&gt;threadfn = threadfn;</span><br><span class="line">	self-&gt;data = data;</span><br><span class="line">	init_completion(&amp;self-&gt;exited);</span><br><span class="line">	init_completion(&amp;self-&gt;parked);</span><br><span class="line">	current-&gt;vfork_done = &amp;self-&gt;exited;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* OK, tell user we&#x27;re spawned, wait for stop or wakeup */</span></span><br><span class="line">    <span class="comment">//设置进程状态为TASK_UNINTERRUPTIBLE</span></span><br><span class="line">	__set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">	create-&gt;result = current;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Thread is going to call schedule(), do not preempt it,</span></span><br><span class="line"><span class="comment">	 * or the creator may spend more time in wait_task_inactive().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//关闭抢占</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">    <span class="comment">//complete()通知父进程，新的线程已经完成创建</span></span><br><span class="line">	complete(done);</span><br><span class="line">    <span class="comment">//执行调度程序，由于进程状态为TASK_UNINTERRUPTIBLE，故当前线程直接进入休眠</span></span><br><span class="line">	schedule_preempt_disabled();</span><br><span class="line">	<span class="comment">//开启抢占</span></span><br><span class="line">    preempt_enable();</span><br><span class="line"></span><br><span class="line">	ret = -EINTR;</span><br><span class="line">    <span class="comment">//假如设置了KTHREAD_SHOULD_STOP flag，则退出执行my_thread</span></span><br><span class="line">	<span class="keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags)) &#123;</span><br><span class="line">		cgroup_kthread_ready();</span><br><span class="line">		__kthread_parkme(self);</span><br><span class="line">        <span class="comment">//执行my_thread</span></span><br><span class="line">		ret = threadfn(data);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//退出线程</span></span><br><span class="line">	do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新线程调用complete(done)后，执行调度程序，调度器大概率会使父进程继续执行，此时父进程就会从wait_for_completion(&amp;done);处返回。具体参考第二节。随后由父进程的wake_up_process() 来唤醒my_thread()线程执行。</p>
<h2 id="五、问题复盘"><a href="#五、问题复盘" class="headerlink" title="五、问题复盘"></a>五、问题复盘</h2><p>回顾文章开头的问题，当 执行kthread_run(my_thread,data,..);之后，立刻执行kthread_stop()，会概率性出现kthread_stop() 返回-4错误。这是因为kthread_stop()会将KTHREAD_SHOULD_STOP flag举起，并等待线程退出完成。假如在kthread() 还未执行到test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags) 时，kthread_stop()已经将该flag举起，那么就会出现上述错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/Linux/kthread/" data-id="cmbcy7rh50015t8mtbsgv4h5h" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/Linux/dma-buf/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/Git/sub_repository/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
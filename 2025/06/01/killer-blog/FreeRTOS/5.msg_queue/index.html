<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="消息队列 FreeRTOS学习仓库地址：https:&#x2F;&#x2F;gitee.com&#x2F;killerp&#x2F;free-rtos_-study  消息队列是RTOS的基础数据结构，用于任务之间、任务与中断之间进行数据传递。 没有使用消息队列时，若想要在两个任务之间进行数据传递，那么必须通过全局变量来传递，而在多任务系统中，访问全局变量往往需要用户对资源进行保护，这样就使得编程变得麻烦。 消息队列封装了对共享数据的访">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/FreeRTOS/5.msg_queue/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="消息队列 FreeRTOS学习仓库地址：https:&#x2F;&#x2F;gitee.com&#x2F;killerp&#x2F;free-rtos_-study  消息队列是RTOS的基础数据结构，用于任务之间、任务与中断之间进行数据传递。 没有使用消息队列时，若想要在两个任务之间进行数据传递，那么必须通过全局变量来传递，而在多任务系统中，访问全局变量往往需要用户对资源进行保护，这样就使得编程变得麻烦。 消息队列封装了对共享数据的访">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/FreeRTOS/5.msg_queue/2.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/FreeRTOS/5.msg_queue/4.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/FreeRTOS/5.msg_queue/3.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/FreeRTOS/5.msg_queue/5.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.638Z">
<meta property="article:modified_time" content="2025-06-01T00:26:27.087Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/05/30/hello-world/FreeRTOS/5.msg_queue/2.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/FreeRTOS/5.msg_queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/5.msg_queue/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.638Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><blockquote>
<p>FreeRTOS学习仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/killerp/free-rtos_-study">https://gitee.com/killerp/free-rtos_-study</a></p>
</blockquote>
<p>消息队列是RTOS的基础数据结构，用于任务之间、任务与中断之间进行数据传递。</p>
<p>没有使用消息队列时，若想要在两个任务之间进行数据传递，那么必须通过全局变量来传递，而在多任务系统中，访问全局变量往往需要用户对资源进行保护，这样就使得编程变得麻烦。</p>
<p>消息队列封装了对共享数据的访问保护，同时还加入了阻塞等待机制。使用户编程时不用去考虑复杂的并发访问。</p>
<h3 id="一、队列的结构"><a href="#一、队列的结构" class="headerlink" title="一、队列的结构"></a>一、队列的结构</h3><p>消息队列结构体的定义如下：</p>
<ul>
<li><p>消息队列可理解为一个环形的队列，通过pcHead和pcTail将队列的首位连接起来。</p>
</li>
<li><p>pcWriteTo和pcReadFrom分别是队列的首部和尾部（若采用默认的FIFO）</p>
</li>
<li><p>队列中每个消息的大小是固定的，一个队列可容纳若干个消息，由消息大小和数量决定队列所占内存的大小</p>
</li>
<li><p>队列有两个链表，分别用于存放因发送&#x2F;接收消息而进入阻塞的任务。</p>
</li>
<li><p>队列支持锁定，当队列锁定时，中断函数不能修改以上链表，实现对数据的保护。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 消息队列 入队使用的是内存复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> /* <span class="title">The</span> <span class="title">old</span> <span class="title">naming</span> <span class="title">convention</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">prevent</span> <span class="title">breaking</span> <span class="title">kernel</span> <span class="title">aware</span> <span class="title">debuggers</span>. */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int8_t</span> * pcHead;           <span class="comment">/*&lt; 指向队列内存起始地址. */</span></span><br><span class="line">    <span class="type">int8_t</span> * pcWriteTo;        <span class="comment">/*&lt; 指向队列下一个空闲地址. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        QueuePointers_t xQueue;    <span class="comment">//TODO 当结构体作为队列时  </span></span><br><span class="line">        SemaphoreData_t xSemaphore; <span class="comment">//当作为信号量时</span></span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    List_t xTasksWaitingToSend;             <span class="comment">//链表：保存那些因发送信号量而进入阻塞的任务 （按优先级排序）</span></span><br><span class="line">    List_t xTasksWaitingToReceive;          <span class="comment">//链表：保存那些因接收信号量而进入阻塞的任务 （按优先级排序）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; <span class="comment">//队列中的消息数量</span></span><br><span class="line">    UBaseType_t uxLength;                   <span class="comment">//队列的最大消息数量</span></span><br><span class="line">    UBaseType_t uxItemSize;                 <span class="comment">//一个消息的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列上锁</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock;                <span class="comment">//队列上锁时，任务从队列接收消息的数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock;                <span class="comment">//队列上锁时，任务向队列发送的消息数量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> ucStaticallyAllocated;      <span class="comment">//标记队列的内存分配方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; xQUEUE;</span><br></pre></td></tr></table></figure>



<p>消息队列可简单的抽象成如下图片：</p>
<p>在同一时间内，只能有一个任务 or 中断在修改队列的链表。是的，队列锁并不能阻止中断向队列复制数据。</p>
<p>在这里插入图片描述</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/2.png" alt="在这里插入图片描述"></p>
<h3 id="二、创建队列"><a href="#二、创建队列" class="headerlink" title="二、创建队列"></a>二、创建队列</h3><p>创建队列的过程与创建任务类似，需要为队列结构体和队列存储区分配内存，并初始化队列结构体的成员变量。</p>
<p>以动态内存分配为例：首先分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> QueueHandle_t <span class="title function_">xQueueGenericCreate</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType )</span></span><br><span class="line"> &#123;</span><br><span class="line">     Queue_t * pxNewQueue;   <span class="comment">//指向新的队列结构体</span></span><br><span class="line">     <span class="type">size_t</span> xQueueSizeInBytes;   <span class="comment">//队列总大小（字节）</span></span><br><span class="line">     <span class="type">uint8_t</span> * pucQueueStorage;  <span class="comment">//指向队列存储区域起始地址</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//队列的长度至少为1</span></span><br><span class="line">     configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">     <span class="comment">//计算队列使用的内存大小</span></span><br><span class="line">     xQueueSizeInBytes = ( <span class="type">size_t</span> ) ( uxQueueLength * uxItemSize );</span><br><span class="line">     <span class="comment">/* 检查乘法溢出 */</span></span><br><span class="line">     configASSERT( ( uxItemSize == <span class="number">0</span> ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 检查溢出. */</span></span><br><span class="line">     configASSERT( ( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ) &gt;  xQueueSizeInBytes );</span><br><span class="line"></span><br><span class="line">     <span class="comment">//todo 申请内存， pvPortMalloc字节对齐问题</span></span><br><span class="line">     pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ); </span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>( pxNewQueue != <span class="literal">NULL</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//队列结构体与队列实际内存区域在同一连续的内存中 所以pucQueueStorage跳过Queue_t</span></span><br><span class="line">         pucQueueStorage = ( <span class="type">uint8_t</span> * ) pxNewQueue;</span><br><span class="line">         pucQueueStorage += <span class="keyword">sizeof</span>( Queue_t ); </span><br><span class="line"></span><br><span class="line">         <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">             &#123;</span><br><span class="line">                 pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;</span><br><span class="line">             &#125;</span><br><span class="line">         <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line"><span class="comment">//初始化队列结构体</span></span><br><span class="line">         prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         traceQUEUE_CREATE_FAILED( ucQueueType );</span><br><span class="line">         mtCOVERAGE_TEST_MARKER();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> pxNewQueue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>初始化队列结构体的成员变量，初始化后的内存大概为：</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/4.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseNewQueue</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint8_t</span> * pucQueueStorage,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType,</span></span><br><span class="line"><span class="params">                                   Queue_t * pxNewQueue )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//移除编译器的警告</span></span><br><span class="line">    ( <span class="type">void</span> ) ucQueueType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置队列结构体的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当队列作为信号量时，uxItemSize为0</span></span><br><span class="line">    <span class="keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pcHead不能为null，因为pcHead为null表示互斥信号量 所以设为一个确定的值</span></span><br><span class="line">        pxNewQueue-&gt;pcHead = ( <span class="type">int8_t</span> * ) pxNewQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//作为队列，pcHead指向存储区</span></span><br><span class="line">        pxNewQueue-&gt;pcHead = ( <span class="type">int8_t</span> * ) pucQueueStorage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置队列长度</span></span><br><span class="line">    pxNewQueue-&gt;uxLength = uxQueueLength;</span><br><span class="line">    pxNewQueue-&gt;uxItemSize = uxItemSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置队列 </span></span><br><span class="line">    ( <span class="type">void</span> ) xQueueGenericReset( pxNewQueue, pdTRUE );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueGenericReset</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                               BaseType_t xNewQueue )</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    </span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重新设置队列的指针</span></span><br><span class="line">        pxQueue-&gt;u.xQueue.pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">        pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;</span><br><span class="line">        </span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - <span class="number">1U</span> ) * pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;cRxLock = queueUNLOCKED;</span><br><span class="line">        pxQueue-&gt;cTxLock = queueUNLOCKED;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( xNewQueue == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不是新的队列</span></span><br><span class="line">            <span class="comment">/* xTasksWaitingToSend的任务可以发送消息，而 xTasksWaitingToReceive则继续等待 */</span></span><br><span class="line">            <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化队列使用的链表</span></span><br><span class="line">            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );</span><br><span class="line">            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pdPASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="三、发送消息到队列"><a href="#三、发送消息到队列" class="headerlink" title="三、发送消息到队列"></a>三、发送消息到队列</h3><blockquote>
<p>RTOS中发送消息的函数五花八门，但万变不离其宗，只要掌握了以下这个函数，其他的发送函数都是这个函数的变体。</p>
</blockquote>
<h4 id="任务中发送消息"><a href="#任务中发送消息" class="headerlink" title="任务中发送消息"></a>任务中发送消息</h4><p>任务调用发送消息函数、在该函数中任务会进入死循环，若任务能成功发送消息，则退出循环。否则，任务就需要进入阻塞，等待队列中出现空闲位置。</p>
<p>同时通过进入临界区来保证当前任务对队列的独占性访问。具体代码逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueGenericSend</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> pvItemToQueue,</span></span><br><span class="line"><span class="params">                              TickType_t xTicksToWait,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> BaseType_t xCopyPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//xEntryTimeSet标记任务是否已经设置过阻塞时间</span></span><br><span class="line">    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;</span><br><span class="line">    TimeOut_t xTimeOut; <span class="comment">//阻塞时间结构体</span></span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查一些错误的用法</span></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvItemToQueue == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="number">1</span> ) ) );</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进入临界区 要操作链表</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列未满或是覆盖写入时，消息可以写入队列</span></span><br><span class="line">            <span class="keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )</span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_SEND( pxQueue );</span><br><span class="line">                </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//将队列项复制到队列指定位置</span></span><br><span class="line">                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//如果有任务在等待消息</span></span><br><span class="line">                        <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//将该任务从事件链表中移出</span></span><br><span class="line">                            <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//移出的任务优先级更高，需要任务调度</span></span><br><span class="line">                                queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>( xYieldRequired != pdFALSE )    <span class="comment">//没有任务在等消息，但需要任务调度</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                taskEXIT_CRITICAL();    <span class="comment">//消息发送完成 退出临界区</span></span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//队列满不能入队 需要延时 or 退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//任务不要求延时 直接退出</span></span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">                    traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE ) <span class="comment">//未初始化阻塞</span></span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//初始化阻塞结构体，用于辅助计算阻塞时间</span></span><br><span class="line">                    vTaskInternalSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                 </span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到此、任务未能成功发送消息 需要阻塞等待</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出临界区后，其他任务或中断可能抢占当前任务（然后向队列获取消息，那么当前任务就有可能发送消息）</span></span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//挂起调度器、防止其他任务访问队列的xTasksWaitingToSend链表</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        <span class="comment">//锁住队列 防止中断修改xTasksWaitingToSend链表</span></span><br><span class="line">        prvLockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查当前任务的阻塞时间是否到达</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//阻塞时间未到，且队列中为满 则将当前任务插入队列的WaitingToSend</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueFull( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceBLOCKING_ON_QUEUE_SEND( pxQueue );</span><br><span class="line"></span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解锁队列(允许中断修改链表)</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//恢复调度器，产生任务调度，当前任务进入阻塞，等到阻塞时间到达或有其他任务读取了消息时被唤醒，然后重新进入当前循环</span></span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    portYIELD_WITHIN_API();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队列有位置，重新进入当前循环</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//超时时间到且未能成功发送消息 退出</span></span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">            traceQUEUE_SEND_FAILED( pxQueue );</span><br><span class="line">            <span class="keyword">return</span> errQUEUE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/*lint -restore */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FreeRTOS的消息是通过内存复制实现的。过程如图：先从write指针写入消息，再将write指针移动到下一个空闲位置。</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/3.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> BaseType_t <span class="title function_">prvCopyDataToQueue</span><span class="params">( Queue_t * <span class="type">const</span> pxQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> BaseType_t xPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdFALSE;</span><br><span class="line">    UBaseType_t uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当前函数必须在临界区内调用 */</span></span><br><span class="line"></span><br><span class="line">    uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line">    <span class="comment">//作为信号量的情况</span></span><br><span class="line">    <span class="keyword">if</span>( pxQueue-&gt;uxItemSize == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若是互斥信号量的话，说明信号量被释放、需要解除优先级反转</span></span><br><span class="line">                <span class="keyword">if</span>( pxQueue-&gt;uxQueueType == queueQUEUE_IS_MUTEX )</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    xReturn = xTaskPriorityDisinherit( pxQueue-&gt;u.xSemaphore.xMutexHolder );</span><br><span class="line">                    pxQueue-&gt;u.xSemaphore.xMutexHolder = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作为消息队列 发送到队列尾部（writeto）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( xPosition == queueSEND_TO_BACK )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//内存复制</span></span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pxQueue-&gt;pcWriteTo, pvItemToQueue, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">        <span class="comment">//pcWriteTo增加</span></span><br><span class="line">        pxQueue-&gt;pcWriteTo += pxQueue-&gt;uxItemSize;                                                       </span><br><span class="line">        <span class="comment">//若pcWriteTo到达内存末尾，则回到内存首部</span></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;pcWriteTo &gt;= pxQueue-&gt;u.xQueue.pcTail )                                            </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//复制到队首（pcReadFrom）</span></span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, pvItemToQueue, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom -= pxQueue-&gt;uxItemSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &lt; pxQueue-&gt;pcHead ) </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;u.xQueue.pcReadFrom = ( pxQueue-&gt;u.xQueue.pcTail - pxQueue-&gt;uxItemSize );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若是覆盖写入，则有一个消息被覆盖，uxMessagesWaiting-1</span></span><br><span class="line">        <span class="keyword">if</span>( xPosition == queueOVERWRITE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                --uxMessagesWaiting;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队成功</span></span><br><span class="line">    pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中断中发送消息"><a href="#中断中发送消息" class="headerlink" title="中断中发送消息"></a>中断中发送消息</h4><p>由于在中断中不能进入阻塞，所以需要有一个函数来另外实现在中断发送消息。与在任务中的区别在于，临界区保护以及当不满足发送条件时，直接退出函数，不会进入延时等待。</p>
<p><strong>同时，在中断中若队列上锁，则不能修改链表。这是因为中断触发时，任务可能正在访问队列链表。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueGenericSendFromISR</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> pvItemToQueue,</span></span><br><span class="line"><span class="params">                                     BaseType_t * <span class="type">const</span> pxHigherPriorityTaskWoken,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> BaseType_t xCopyPosition )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;     <span class="comment">//返回值：表示是否需要任务调度</span></span><br><span class="line">    UBaseType_t uxSavedInterruptStatus; <span class="comment">//保存中断状态</span></span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查队列</span></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvItemToQueue == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line">    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="number">1</span> ) ) );</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入临界区</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//队列未满或是覆盖写入时，消息可以写入队列</span></span><br><span class="line">        <span class="keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;    <span class="comment">//获得发送锁 </span></span><br><span class="line">            <span class="type">const</span> UBaseType_t uxPreviousMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">            traceQUEUE_SEND_FROM_ISR( pxQueue );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a</span></span><br><span class="line"><span class="comment">             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result</span></span><br><span class="line"><span class="comment">             *  in a task disinheriting a priority and prvCopyDataToQueue() can be</span></span><br><span class="line"><span class="comment">             *  called here even though the disinherit function does not check if</span></span><br><span class="line"><span class="comment">             *  the scheduler is suspended before accessing the ready lists. */</span></span><br><span class="line">            <span class="comment">//复制数据到队列</span></span><br><span class="line">            ( <span class="type">void</span> ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若队列没有被锁</span></span><br><span class="line">            <span class="keyword">if</span>( cTxLock == queueUNLOCKED )</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果有任务正在等待数据</span></span><br><span class="line">                        <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//将任务从等待链表中移除</span></span><br><span class="line">                            <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//标记有更高优先级的任务解锁 退出中断后需要任务调度</span></span><br><span class="line">                                <span class="keyword">if</span>( pxHigherPriorityTaskWoken != <span class="literal">NULL</span> )</span><br><span class="line">                                &#123;</span><br><span class="line">                                    *pxHigherPriorityTaskWoken = pdTRUE;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ( <span class="type">void</span> ) uxPreviousMessagesWaiting;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队列被锁定，增加cTxLock的值，使解锁队列的任务明白有多少消息未能成功入队</span></span><br><span class="line">                configASSERT( cTxLock != queueINT8_MAX );</span><br><span class="line"></span><br><span class="line">                pxQueue-&gt;cTxLock = ( <span class="type">int8_t</span> ) ( cTxLock + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//队列已满 不能阻塞直接退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );</span><br><span class="line">            xReturn = errQUEUE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出临界区</span></span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、接收消息"><a href="#四、接收消息" class="headerlink" title="四、接收消息"></a>四、接收消息</h3><h4 id="任务中接收消息"><a href="#任务中接收消息" class="headerlink" title="任务中接收消息"></a>任务中接收消息</h4><p>接收消息的实现与发送消息类似，同样需要在循环中，成功获取队列的消息则退出，否则进入阻塞，等待消息到来。</p>
<p>代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    BaseType_t xEntryTimeSet = pdFALSE;     <span class="comment">//标记是否初始化的阻塞时间</span></span><br><span class="line">    TimeOut_t xTimeOut;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( ( pxQueue ) );</span><br><span class="line"></span><br><span class="line">    configASSERT( !( ( ( pvBuffer ) == <span class="literal">NULL</span> ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="number">0</span> ) ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取队列中的消息数量</span></span><br><span class="line">            <span class="type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若队列中有数据</span></span><br><span class="line">            <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//复制数据到buffer，消息数量-1</span></span><br><span class="line">                prvCopyDataFromQueue( pxQueue, pvBuffer );</span><br><span class="line">                traceQUEUE_RECEIVE( pxQueue );</span><br><span class="line">                pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//消息出队后，若有任务在等待发送消息，则恢复该任务去发送</span></span><br><span class="line">                <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//将等待发送的任务移出</span></span><br><span class="line">                    <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//移出的任务优先级更高，发生抢占</span></span><br><span class="line">                        queueYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">//没有任务在等待发送</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                taskEXIT_CRITICAL();</span><br><span class="line">                <span class="keyword">return</span> pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//队列为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不作等待立刻退出</span></span><br><span class="line">                <span class="keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    taskEXIT_CRITICAL();</span><br><span class="line">                    traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                    <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( xEntryTimeSet == pdFALSE ) <span class="comment">//若未初始化阻塞时间</span></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置阻塞时间</span></span><br><span class="line">                    vTaskInternalSetTimeOutState( &amp;xTimeOut );</span><br><span class="line">                    xEntryTimeSet = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Entry time was already set. */</span></span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到此、当前任务无法成功获取消息 需要进入阻塞等待</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">        <span class="comment">//退出临界区后，其他任务或中断可能抢占当前任务（然后向队列发送消息，那么当前任务就能成功获取消息）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//挂起调度器和锁住队列，防止任务、中断修改队列的链表</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        prvLockQueue( pxQueue );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务阻塞时间未到</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列仍为空，需要继续等待</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );</span><br><span class="line">                <span class="comment">//将任务放到等待接收链表 </span></span><br><span class="line">                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );</span><br><span class="line">                prvUnlockQueue( pxQueue );  <span class="comment">//解除锁定</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//恢复调度器，产生任务调度，当前任务进入阻塞，等到阻塞时间到达或有其他任务发送了消息时被唤醒，然后重新进入当前循环</span></span><br><span class="line">                <span class="keyword">if</span>( xTaskResumeAll() == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    portYIELD_WITHIN_API();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//队列有消息了，重新进入当前循环</span></span><br><span class="line">                prvUnlockQueue( pxQueue );</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//阻塞时间到达</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            prvUnlockQueue( pxQueue );</span><br><span class="line">            ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            <span class="comment">//再次查看队列是否有消息，若有则进入当前循环 无则退出等待</span></span><br><span class="line">            <span class="keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                traceQUEUE_RECEIVE_FAILED( pxQueue );</span><br><span class="line">                <span class="keyword">return</span> errQUEUE_EMPTY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/*lint -restore */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向队列复制消息。在这里需要注意当队列的消息大小为0时，这个队列是信号量，不需要内存的复制，这个部分在下一章中讲信号量说明。</p>
<p>读取消息时，是先将read指针移动，再读取。</p>
<p><img src="/2025/05/30/hello-world/FreeRTOS/5.msg_queue/5.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvCopyDataFromQueue</span><span class="params">( Queue_t * <span class="type">const</span> pxQueue,</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> * <span class="type">const</span> pvBuffer )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pcReadFrom向前移动一个单元</span></span><br><span class="line">        pxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;          </span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否溢出、需要回到队列头</span></span><br><span class="line">        <span class="keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail ) </span><br><span class="line">        &#123;</span><br><span class="line">            pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内存复制</span></span><br><span class="line">        ( <span class="type">void</span> ) <span class="built_in">memcpy</span>( ( <span class="type">void</span> * ) pvBuffer, ( <span class="type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( <span class="type">size_t</span> ) pxQueue-&gt;uxItemSize ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="中断中接收消息"><a href="#中断中接收消息" class="headerlink" title="中断中接收消息"></a>中断中接收消息</h4><p>同理，在中断中读取消息，当队列中没有消息时，不能进入等待，必须马上退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                                 BaseType_t * <span class="type">const</span> pxHigherPriorityTaskWoken )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line">    Queue_t * <span class="type">const</span> pxQueue = xQueue;</span><br><span class="line"></span><br><span class="line">    configASSERT( pxQueue );</span><br><span class="line">    configASSERT( !( ( pvBuffer == <span class="literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="number">0U</span> ) ) );</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入临界区 保存中断状态</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取消息数量</span></span><br><span class="line">        <span class="type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否有消息</span></span><br><span class="line">        <span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int8_t</span> cRxLock = pxQueue-&gt;cRxLock;    <span class="comment">//获取接收锁</span></span><br><span class="line"></span><br><span class="line">            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );</span><br><span class="line">            <span class="comment">//数据有效，复制数据到buffer</span></span><br><span class="line">            prvCopyDataFromQueue( pxQueue, pvBuffer );</span><br><span class="line">            pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列未锁，可以修改队列链表</span></span><br><span class="line">            <span class="keyword">if</span>( cRxLock == queueUNLOCKED )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//消息出队后，队列有空闲的位置，若有任务在等待发送消息，则需要恢复该任务</span></span><br><span class="line">                <span class="keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//将等待发送的任务移出</span></span><br><span class="line">                    <span class="keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//移出的任务优先级更高，需要退出中断后启动任务调度</span></span><br><span class="line">                        <span class="keyword">if</span>( pxHigherPriorityTaskWoken != <span class="literal">NULL</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//设置返回参数</span></span><br><span class="line">                            *pxHigherPriorityTaskWoken = pdTRUE;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//队列上锁，不能操作链表</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                configASSERT( cRxLock != queueINT8_MAX );</span><br><span class="line">                <span class="comment">//设置cRxLock-1 使队列知道在其锁定的时候有消息被读取</span></span><br><span class="line">                pxQueue-&gt;cRxLock = ( <span class="type">int8_t</span> ) ( cRxLock + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功获取消息</span></span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//队列为空 立刻返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = pdFAIL;</span><br><span class="line">            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/5.msg_queue/" data-id="cmbcy7rgw000dt8mt5pks5xuv" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/FreeRTOS/3.task_2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/ESP32/solove_ESP32_SRAM_not_enough/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
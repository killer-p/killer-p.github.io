<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="任务管理（二）多任务系统在同一时刻中，只有一个任务占有CPU的使用权。一个任务长期占有CPU会影响对系统的效应能力，故任务需要在空闲的时候，通过延时&#x2F;挂起来让出CPU的使用权给其他任务，这样任务调度器才能调度其他任务运行。 一、任务延时 vTaskDelay任务延时就是当前任务将CPU让出一定时间，将任务插入延时链表中，等到延时时间到达才将任务恢复到就绪状态，等待调度运行。 其实质就是将">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/FreeRTOS/2.task_1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="任务管理（二）多任务系统在同一时刻中，只有一个任务占有CPU的使用权。一个任务长期占有CPU会影响对系统的效应能力，故任务需要在空闲的时候，通过延时&#x2F;挂起来让出CPU的使用权给其他任务，这样任务调度器才能调度其他任务运行。 一、任务延时 vTaskDelay任务延时就是当前任务将CPU让出一定时间，将任务插入延时链表中，等到延时时间到达才将任务恢复到就绪状态，等待调度运行。 其实质就是将">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-01T00:23:34.662Z">
<meta property="article:modified_time" content="2025-06-01T00:23:34.662Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/FreeRTOS/2.task_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/FreeRTOS/2.task_1/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:23:34.662Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="任务管理（二）"><a href="#任务管理（二）" class="headerlink" title="任务管理（二）"></a>任务管理（二）</h2><p>多任务系统在同一时刻中，只有一个任务占有CPU的使用权。一个任务长期占有CPU会影响对系统的效应能力，故任务需要在空闲的时候，通过延时&#x2F;挂起来让出CPU的使用权给其他任务，这样任务调度器才能调度其他任务运行。</p>
<h3 id="一、任务延时-vTaskDelay"><a href="#一、任务延时-vTaskDelay" class="headerlink" title="一、任务延时 vTaskDelay"></a>一、任务延时 vTaskDelay</h3><p>任务延时就是当前任务将CPU让出一定时间，将任务插入延时链表中，等到延时时间到达才将任务恢复到就绪状态，等待调度运行。</p>
<p>其实质就是将任务移动到延时链表&#x2F;挂起链表。</p>
<p><strong>注意进入延时函数时，会挂起调度器，这是为了防止在插入就绪链表过程中，由于中断产生打乱了代码逻辑</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (xTicksToDelay &gt; (TickType_t)<span class="number">0U</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//TODO 挂起调度器、防止中断导致任务插入就绪链表、扰乱代码逻辑</span></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当调度器挂起时，任务不能插入就绪表</span></span><br><span class="line">            <span class="comment">//添加当前任务到延时链表</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复调度器、若恢复调度器时、已经完成一次任务调度、则接下来不需要再产生一次任务调度</span></span><br><span class="line">        xAlreadyYielded = xTaskResumeAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若调度器恢复时未进行任务调度，则启动一次任务调度</span></span><br><span class="line">    <span class="keyword">if</span> (xAlreadyYielded == pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvAddCurrentTaskToDelayedList</span><span class="params">(TickType_t xTicksToWait,</span></span><br><span class="line"><span class="params">                                           <span class="type">const</span> BaseType_t xCanBlockIndefinitely)</span></span><br><span class="line">&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    <span class="type">const</span> TickType_t xConstTickCount = xTickCount; <span class="comment">//保存当前时钟计数值为常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入延时链表、设置标记</span></span><br><span class="line">    pxCurrentTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先将当前任务移出就绪链表 若返回为0说明该优先级链表为空 需要重置最高优先级</span></span><br><span class="line">    <span class="keyword">if</span> (uxListRemove(&amp;(pxCurrentTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        portRESET_READY_PRIORITY(pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若延时时间最大且无限期等待，则直接加入挂起链表 任务调度器不对其管理</span></span><br><span class="line">        <span class="keyword">if</span> ((xTicksToWait == portMAX_DELAY) &amp;&amp; (xCanBlockIndefinitely != pdFALSE))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            vListInsertEnd(&amp;xSuspendedTaskList, &amp;(pxCurrentTCB-&gt;xStateListItem));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//插入延时链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算任务下次由时钟中断唤醒的时间戳 注意时钟溢出（当前时间+需要等待的时间=下次醒来的时间点）</span></span><br><span class="line">            xTimeToWake = xConstTickCount + xTicksToWait;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将时间戳设置为任务的状态节点值</span></span><br><span class="line">            listSET_LIST_ITEM_VALUE(&amp;(pxCurrentTCB-&gt;xStateListItem), xTimeToWake);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xTimeToWake &lt; xConstTickCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//延时时间溢出、任务插入延时溢出链表</span></span><br><span class="line">                vListInsert(pxOverflowDelayedTaskList, &amp;(pxCurrentTCB-&gt;xStateListItem));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//未溢出，插入当前延时链表</span></span><br><span class="line">                vListInsert(pxDelayedTaskList, &amp;(pxCurrentTCB-&gt;xStateListItem));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新xNextTaskUnblockTime</span></span><br><span class="line">                <span class="keyword">if</span> (xTimeToWake &lt; xNextTaskUnblockTime)</span><br><span class="line">                &#123;</span><br><span class="line">                    xNextTaskUnblockTime = xTimeToWake;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */</span></span><br><span class="line">        (<span class="type">void</span>)xCanBlockIndefinitely;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、绝对任务延时-xTaskDelayUntil"><a href="#二、绝对任务延时-xTaskDelayUntil" class="headerlink" title="二、绝对任务延时 xTaskDelayUntil"></a>二、绝对任务延时 xTaskDelayUntil</h3><p>另一种延时方式：延时一个任务直到指定的时间点到来。经常用于周期性的运行一个任务。</p>
<p>使用vTaskDelay()由于任务执行的时间是不确定的（可能被中断打断），故相对延时无法实现周期信运行一个任务。而使用绝对延时xTaskDelayUntil（）能保证任务在指定的时间点唤醒，延时时间由上一次运行时的时间点与所需延时频率计算。</p>
<p>该函数不同之处在于计算延时时间、最后都同样的调用prvAddCurrentTaskToDelayedList函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskDelayUntil</span><span class="params">(TickType_t *<span class="type">const</span> pxPreviousWakeTime,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> TickType_t xTimeIncrement)</span></span><br><span class="line">&#123;</span><br><span class="line">    TickType_t xTimeToWake;</span><br><span class="line">    BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;</span><br><span class="line"></span><br><span class="line">    configASSERT(pxPreviousWakeTime);</span><br><span class="line">    configASSERT((xTimeIncrement &gt; <span class="number">0U</span>));</span><br><span class="line">    configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//TODO 挂起调度器、防止中断导致任务插入就绪链表、扰乱代码逻辑</span></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证xTickCount在本代码块内不会被修改</span></span><br><span class="line">        <span class="type">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算下次唤醒时间</span></span><br><span class="line">        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xConstTickCount &lt; *pxPreviousWakeTime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// -----cur++++++pre----- 只有当xTimeToWake在+号时才能进入延时</span></span><br><span class="line">            <span class="keyword">if</span> ((xTimeToWake &lt; *pxPreviousWakeTime) &amp;&amp; (xTimeToWake &gt; xConstTickCount))</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// +++++pre-----cur++++++ 只有当xTimeToWake在+号时才能进入延时</span></span><br><span class="line">            <span class="keyword">if</span> ((xTimeToWake &lt; *pxPreviousWakeTime) || (xTimeToWake &gt; xConstTickCount))</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新pxPreviousWakeTime</span></span><br><span class="line">        *pxPreviousWakeTime = xTimeToWake;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xShouldDelay != pdFALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY_UNTIL(xTimeToWake);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//prvAddCurrentTaskToDelayedList需要的是相对延时时间 故是xTimeToWake - xConstTickCount</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList(xTimeToWake - xConstTickCount, pdFALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复调度器、执行任务调度</span></span><br><span class="line">    xAlreadyYielded = xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xAlreadyYielded == pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xShouldDelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、终止延时"><a href="#三、终止延时" class="headerlink" title="三、终止延时"></a>三、终止延时</h3><p>有开始、就会有结束。其他任务可唤醒处于延时中的函数。其实质就是将任务移动到就绪链表、并进行任务调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskAbortDelay</span><span class="params">(TaskHandle_t xTask)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *pxTCB = xTask;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">    configASSERT(pxTCB);</span><br><span class="line">    <span class="comment">//挂起任务调度器</span></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//任务的状态为阻塞时，才能解锁</span></span><br><span class="line">        <span class="keyword">if</span> (eTaskGetState(xTask) == eBlocked)</span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从延时链表中移除</span></span><br><span class="line">            <span class="comment">//TODO  当调度器挂起时、中断不会修改任务的xStateListItem.所以在这里的操作是安全的</span></span><br><span class="line">            (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从事件链表中移除 （中断可能修改xEventListItem 故需要进入临界区）</span></span><br><span class="line">            taskENTER_CRITICAL();</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (listLIST_ITEM_CONTAINER(&amp;(pxTCB-&gt;xEventListItem)) != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">                    <span class="comment">//记录他已经解除挂起</span></span><br><span class="line">                    pxTCB-&gt;ucDelayAborted = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//退出延时后，进入就绪态（因为中断中不能访问就绪链表，故当前函数不能在中断中调用）</span></span><br><span class="line">            prvAddTaskToReadyList(pxTCB);</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//解锁任务的优先级高于当前任务优先级，发生抢占</span></span><br><span class="line">                <span class="keyword">if</span> (pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//挂起一次任务调度（因为当前调度器挂起了）</span></span><br><span class="line">                    xYieldPending = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = pdFAIL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、任务挂起"><a href="#四、任务挂起" class="headerlink" title="四、任务挂起"></a>四、任务挂起</h3><p>将指定任务挂起、该任务不会被恢复运行，除非用户代码恢复该任务。其代码逻辑就是将任务移动到挂起链表、并判断是否需要任务调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_t xTaskToSuspend)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *pxTCB;</span><br><span class="line">    <span class="comment">//进入临界区</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取任务tcb</span></span><br><span class="line">        pxTCB = prvGetTCBFromHandle(xTaskToSuspend);</span><br><span class="line"></span><br><span class="line">        traceTASK_SUSPEND(pxTCB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从就绪/阻塞链表中移除任务</span></span><br><span class="line">        <span class="keyword">if</span> (uxListRemove(&amp;(pxTCB-&gt;xStateListItem)) == (UBaseType_t)<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            taskRESET_READY_PRIORITY(pxTCB-&gt;uxPriority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从事件链表中移除任务</span></span><br><span class="line">        <span class="keyword">if</span> (listLIST_ITEM_CONTAINER(&amp;(pxTCB-&gt;xEventListItem)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将任务插入挂起链表</span></span><br><span class="line">        vListInsertEnd(&amp;xSuspendedTaskList, &amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xSchedulerRunning != pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//更新下次任务解锁时间。刚刚挂起的任务可能是下个解锁的任务</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            prvResetNextTaskUnblockTime();</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//挂起任务是正在运行的任务</span></span><br><span class="line">    <span class="keyword">if</span> (pxTCB == pxCurrentTCB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xSchedulerRunning != pdFALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前任务被挂起，执行一次任务调度</span></span><br><span class="line">            configASSERT(uxSchedulerSuspended == <span class="number">0</span>);</span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//todo 调度器关闭所以必须调整pxCurrentTCB</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (listCURRENT_LIST_LENGTH(&amp;xSuspendedTaskList) == uxCurrentNumberOfTasks)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//所有任务都被挂起 pxCurrentTCB为null，下次创建新任务时，就执行新任务</span></span><br><span class="line">                pxCurrentTCB = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新pxCurrentTCB</span></span><br><span class="line">                vTaskSwitchContext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、恢复任务"><a href="#五、恢复任务" class="headerlink" title="五、恢复任务"></a>五、恢复任务</h3><p>挂起的任务只有得到恢复才能运行。以下是函数在任务函数中调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_t xTaskToResume)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t *<span class="type">const</span> pxTCB = xTaskToResume;</span><br><span class="line"></span><br><span class="line">    configASSERT(xTaskToResume);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复的任务不可能是null 并且 不可能是正在运行的任务</span></span><br><span class="line">    <span class="keyword">if</span> ((pxTCB != pxCurrentTCB) &amp;&amp; (pxTCB != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断是否真的在挂起链表中</span></span><br><span class="line">            <span class="keyword">if</span> (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                traceTASK_RESUME(pxTCB);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//移出挂起链表、加入就绪链表</span></span><br><span class="line">                (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line">                prvAddTaskToReadyList(pxTCB);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//恢复任务的优先级较高、进行任务调度</span></span><br><span class="line">                <span class="keyword">if</span> (pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、从中断中恢复任务"><a href="#六、从中断中恢复任务" class="headerlink" title="六、从中断中恢复任务"></a>六、从中断中恢复任务</h3><p>与上一次函数的区别是：</p>
<ul>
<li><p>该函数只能在中断中调用。</p>
</li>
<li><p>在中断中进入临界区使用的函数也不一样。同时，还需要注意当调度器挂起时，不能在中断中直接修改就绪链表，而是先将任务缓存到xPendingReadyList，当调度器恢复时，再将任务移动到就绪链表。</p>
</li>
<li><p>在中断中不能进行任务调度，所以该函数的返回值表示是否需要在退出中断后进行任务调度</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskResumeFromISR</span><span class="params">(TaskHandle_t xTaskToResume)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xYieldRequired = pdFALSE; <span class="comment">//任务调度标记 由于中断中不能执行上下文切换、故使用他来代替上下文切换</span></span><br><span class="line">    TCB_t *<span class="type">const</span> pxTCB = xTaskToResume;</span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line"></span><br><span class="line">    configASSERT(xTaskToResume);</span><br><span class="line"></span><br><span class="line">    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();</span><br><span class="line">    <span class="comment">//进入中断级临界区</span></span><br><span class="line">    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR(); </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是否真的挂起</span></span><br><span class="line">        <span class="keyword">if</span> (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_RESUME_FROM_ISR(pxTCB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uxSchedulerSuspended == (UBaseType_t)pdFALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调度器运行中、若任务优先级更高、则产生任务调度</span></span><br><span class="line">                <span class="keyword">if</span> (pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority)</span><br><span class="line">                &#123;</span><br><span class="line">                    xYieldRequired = pdTRUE; <span class="comment">//需要进行任务调度</span></span><br><span class="line"></span><br><span class="line">                    xYieldPending = pdTRUE; <span class="comment">//一个任务调度请求被挂起</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将任务移动到就绪链表</span></span><br><span class="line">                (<span class="type">void</span>)uxListRemove(&amp;(pxTCB-&gt;xStateListItem));</span><br><span class="line">                prvAddTaskToReadyList(pxTCB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//调度器挂起 不能在中断中直接修改就绪链表，先将任务缓存到xPendingReadyList</span></span><br><span class="line">                vListInsertEnd(&amp;(xPendingReadyList), &amp;(pxTCB-&gt;xEventListItem));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xYieldRequired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/FreeRTOS/2.task_1/" data-id="cmbcy7rgu000at8mtglf7d98s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/OpenHarmony/HDF_PWM_Core/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/FreeRTOS/4.sem/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
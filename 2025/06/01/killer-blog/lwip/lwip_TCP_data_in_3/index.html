<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="@[toc]  一个有着接近900行代码的函数，庞大的函数，需要我们有庖丁解牛的耐心  一，简介tcp_receive(struct tcp_pcb *pcb)是tcp数据输入的末端。在之前的tcp_process()函数中，对输入tcp报文已经确定了其对应的tcp控制块。 该实现了tcp通信中的滑动窗口，快速重传与恢复，拥塞控制算法，对无序报文的处理等。并将有效数据传递给应用层。 这个函数必须分">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@[toc]  一个有着接近900行代码的函数，庞大的函数，需要我们有庖丁解牛的耐心  一，简介tcp_receive(struct tcp_pcb *pcb)是tcp数据输入的末端。在之前的tcp_process()函数中，对输入tcp报文已经确定了其对应的tcp控制块。 该实现了tcp通信中的滑动窗口，快速重传与恢复，拥塞控制算法，对无序报文的处理等。并将有效数据传递给应用层。 这个函数必须分">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/20201218151146864.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.654Z">
<meta property="article:modified_time" content="2025-06-01T00:26:26.753Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/20201218151146864.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/lwip/lwip_TCP_data_in_3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_3/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>一个有着接近900行代码的函数，庞大的函数，需要我们有庖丁解牛的耐心</p>
</blockquote>
<h2 id="一，简介"><a href="#一，简介" class="headerlink" title="一，简介"></a>一，简介</h2><p><code>tcp_receive(struct tcp_pcb *pcb)</code>是tcp数据输入的末端。在之前的tcp_process()函数中，对输入tcp报文已经确定了其对应的tcp控制块。</p>
<p>该实现了tcp通信中的滑动窗口，快速重传与恢复，拥塞控制算法，对无序报文的处理等。并将有效数据传递给应用层。</p>
<p>这个函数必须分成以下几个步骤来解。</p>
<h2 id="二，代码流程"><a href="#二，代码流程" class="headerlink" title="二，代码流程"></a>二，代码流程</h2><h3 id="1，更新发送窗口"><a href="#1，更新发送窗口" class="headerlink" title="1，更新发送窗口"></a>1，更新发送窗口</h3><p>由于接收到对方的报文中会有ackno确认序号，所以根据ackno和通告窗口anno_wnd可更新本地接收窗口的大小。当遇到0窗口通告时，还要开启坚持定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地发送窗口的右边界=上次窗口更新时的确认序号+当前发送窗口大小</span></span><br><span class="line">right_wnd_edge = pcb-&gt;snd_wnd + pcb-&gt;snd_wl2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//snd_wl1 = last seqno</span></span><br><span class="line"><span class="comment">//snd_wl2 = last ackno</span></span><br><span class="line"><span class="comment">//更新窗口三个条件：</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SEQ_LT(pcb-&gt;snd_wl1, seqno) ||  <span class="comment">//对方有发送新的数据</span></span><br><span class="line">   (pcb-&gt;snd_wl1 == seqno &amp;&amp; TCP_SEQ_LT(pcb-&gt;snd_wl2, ackno)) ||  <span class="comment">//对方无发送新的数据但接收到我方发出的数据</span></span><br><span class="line">   (pcb-&gt;snd_wl2 == ackno &amp;&amp; (<span class="type">u32_t</span>)SND_WND_SCALE(pcb, tcphdr-&gt;wnd) &gt; pcb-&gt;snd_wnd)) &#123;  <span class="comment">//无收到我方的新数据且，通告对方接收窗口大于我方发送窗口</span></span><br><span class="line">  pcb-&gt;snd_wnd = SND_WND_SCALE(pcb, tcphdr-&gt;wnd); <span class="comment">//根据通告窗口设置发送窗口</span></span><br><span class="line">  <span class="comment">//限制发送窗口</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_wnd_max &lt; pcb-&gt;snd_wnd) &#123;</span><br><span class="line">    pcb-&gt;snd_wnd_max = pcb-&gt;snd_wnd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新发送窗口的参数</span></span><br><span class="line">  pcb-&gt;snd_wl1 = seqno;</span><br><span class="line">  pcb-&gt;snd_wl2 = ackno;</span><br><span class="line">  <span class="comment">//如果发送窗口为0，即通告窗口是0，需要开启坚持定时器</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_wnd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_backoff == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* start persist timer */</span></span><br><span class="line">      pcb-&gt;persist_cnt = <span class="number">0</span>;</span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pcb-&gt;persist_backoff &gt; <span class="number">0</span>) &#123;  <span class="comment">//否则停止坚持定时器</span></span><br><span class="line">    </span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，快速重传与恢复"><a href="#2，快速重传与恢复" class="headerlink" title="2，快速重传与恢复"></a>2，快速重传与恢复</h3><p>通过检查ackno与上一次更新的ackno是否一致等条件，判断是否需要开启快速重传。退出快重传后，进入快恢复，更新重传参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!快速重传实现原理（当重复确认超过三次则认为需要启动快速重传）</span></span><br><span class="line"><span class="comment">//ackno&lt;lastack，没有确认新数据</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SEQ_LEQ(ackno, pcb-&gt;lastack)) &#123; <span class="comment">//</span></span><br><span class="line">  <span class="comment">/* Clause 2 */</span></span><br><span class="line">  <span class="keyword">if</span> (tcplen == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">/* Clause 3 */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;snd_wl2 + pcb-&gt;snd_wnd == right_wnd_edge) &#123;  <span class="comment">//通告窗口大小没变</span></span><br><span class="line">      <span class="comment">/* Clause 4 */</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;rtime &gt;= <span class="number">0</span>) &#123;  <span class="comment">//重传定时器开启，有数据等待确认</span></span><br><span class="line">        <span class="comment">/* Clause 5 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;lastack == ackno) &#123;  <span class="comment">//确认号等于最高确认号</span></span><br><span class="line">          <span class="comment">//当这里说明该ack是一个空的ack，在重复的确认某一个序号，而发送方同时有数据未被ack，说明之前报文可能丢失</span></span><br><span class="line">          found_dupack = <span class="number">1</span>; <span class="comment">//出现了重复的ack</span></span><br><span class="line">          <span class="comment">//dupacks变量加1同时防止value overflows</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">u8_t</span>)(pcb-&gt;dupacks + <span class="number">1</span>) &gt; pcb-&gt;dupacks) &#123;</span><br><span class="line">            ++pcb-&gt;dupacks;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果重复确认超过3次，可能是报文丢失了</span></span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;dupacks &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">tcpwnd_size_t</span>)(pcb-&gt;cwnd + pcb-&gt;mss) &gt; pcb-&gt;cwnd) &#123;</span><br><span class="line">              pcb-&gt;cwnd += pcb-&gt;mss;<span class="comment">//拥塞窗口增加一个报文段大小</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pcb-&gt;dupacks == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">//执行快速重传丢失报文，初始化cwnd和ssthresh</span></span><br><span class="line">            tcp_rexmit_fast(pcb);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*-------------------------------快速重传算法------------------------------------*/</span></span><br><span class="line">  <span class="comment">//不是重复ack</span></span><br><span class="line">  <span class="keyword">if</span> (!found_dupack) &#123;  </span><br><span class="line">    pcb-&gt;dupacks = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (TCP_SEQ_BETWEEN(ackno, pcb-&gt;lastack+<span class="number">1</span>, pcb-&gt;snd_nxt)) &#123;  <span class="comment">//ackno在last_ack和snd_nxt之间,正确</span></span><br><span class="line">  <span class="comment">//!若tcp处于快速重传，则退出，设置cwnd为ssthresh，这就是快恢复算法</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_INFR) &#123;</span><br><span class="line">    pcb-&gt;flags &amp;= ~TF_INFR;</span><br><span class="line">    pcb-&gt;cwnd = pcb-&gt;ssthresh;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正确的接收到数据，更新重传的参数</span></span><br><span class="line">  pcb-&gt;nrtx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pcb-&gt;rto = (pcb-&gt;sa &gt;&gt; <span class="number">3</span>) + pcb-&gt;sv;</span><br><span class="line">  pcb-&gt;dupacks = <span class="number">0</span>;</span><br><span class="line">  pcb-&gt;lastack = ackno;</span><br></pre></td></tr></table></figure>
<h3 id="3，拥塞控制算法"><a href="#3，拥塞控制算法" class="headerlink" title="3，拥塞控制算法"></a>3，拥塞控制算法</h3><p>根据cwnd与ssthresh的大小，调节cwnd的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------- 拥塞控制算法 ------------------------------------------*/</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state &gt;= ESTABLISHED) &#123;</span><br><span class="line">  <span class="comment">//!慢启动算法cwnd&lt;ssthresh cwnd增加一个报文段大小</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;cwnd &lt; pcb-&gt;ssthresh) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">tcpwnd_size_t</span>)(pcb-&gt;cwnd + pcb-&gt;mss) &gt; pcb-&gt;cwnd) &#123;</span><br><span class="line">      pcb-&gt;cwnd += pcb-&gt;mss;</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_receive: slow start cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>, pcb-&gt;cwnd));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//!拥塞避免算法</span></span><br><span class="line">    <span class="type">tcpwnd_size_t</span> new_cwnd = (pcb-&gt;cwnd + pcb-&gt;mss * pcb-&gt;mss / pcb-&gt;cwnd);</span><br><span class="line">    <span class="keyword">if</span> (new_cwnd &gt; pcb-&gt;cwnd) &#123;</span><br><span class="line">      pcb-&gt;cwnd = new_cwnd;</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_receive: congestion avoidance cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>, pcb-&gt;cwnd));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: ACK for %&quot;</span>U32_F<span class="string">&quot;, unacked-&gt;seqno %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                              ackno,</span><br><span class="line">                              pcb-&gt;unacked != <span class="literal">NULL</span>?</span><br><span class="line">                              lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno): <span class="number">0</span>,</span><br><span class="line">                              pcb-&gt;unacked != <span class="literal">NULL</span>?</span><br><span class="line">                              lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(pcb-&gt;unacked): <span class="number">0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4，更新unacked队列"><a href="#4，更新unacked队列" class="headerlink" title="4，更新unacked队列"></a>4，更新unacked队列</h3><p>由于收到了新的acked，unacked队列就要更新，删除掉被ack的报文，检查是否还有未ack的报文，决定是否开启重传定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将unacked队列中已经确认的报文删除</span></span><br><span class="line"><span class="keyword">while</span> (pcb-&gt;unacked != <span class="literal">NULL</span> &amp;&amp;  <span class="comment">//有未确认的报文</span></span><br><span class="line">       TCP_SEQ_LEQ(lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) +  <span class="comment">//unacked报文尾的序号小于输入报文确认序号？</span></span><br><span class="line">                   TCP_TCPLEN(pcb-&gt;unacked), ackno)) &#123;</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: removing %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot; from pcb-&gt;unacked\n&quot;</span>,</span><br><span class="line">                                lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno),</span><br><span class="line">                                lwip_ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">                                TCP_TCPLEN(pcb-&gt;unacked)));</span><br><span class="line">  <span class="comment">//找到被确认的报文：</span></span><br><span class="line">  next = pcb-&gt;unacked;</span><br><span class="line">  pcb-&gt;unacked = pcb-&gt;unacked-&gt;next;  <span class="comment">//下一个检查的unacked报文</span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;tcp_receive: queuelen %&quot;</span>TCPWNDSIZE_F<span class="string">&quot; ... &quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)&quot;</span>, (pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)));</span><br><span class="line"></span><br><span class="line">  pcb-&gt;snd_queuelen -= pbuf_clen(next-&gt;p);    <span class="comment">//因为lwip中未确认队列中的报文被放在了unsent队列中</span></span><br><span class="line"></span><br><span class="line">  recv_acked += next-&gt;len;  <span class="comment">//确认数据增加next-&gt;len</span></span><br><span class="line">  tcp_seg_free(next); <span class="comment">//删除该报文</span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;%&quot;</span>TCPWNDSIZE_F<span class="string">&quot; (after freeing unacked)\n&quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_queuelen != <span class="number">0</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_receive: valid queue length&quot;</span>, pcb-&gt;unacked != <span class="literal">NULL</span> ||</span><br><span class="line">                pcb-&gt;unsent != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若没有等待确认的报文，则关闭重传定时</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  pcb-&gt;rtime = <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pcb-&gt;rtime = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pcb-&gt;polltmr = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5，更新unsent队列"><a href="#5，更新unsent队列" class="headerlink" title="5，更新unsent队列"></a>5，更新unsent队列</h3><p>由于lwip将unacked队列中的部分报文放到unsent队列的首部，所以也要检查unsent对列中被确认的报文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于lwip将超时且需要重传的报文放到了unsent队列，所以需要在unsent中检查\</span></span><br><span class="line"><span class="comment">  是否有的报文已经被确认，代码与以上相似</span></span><br><span class="line"><span class="keyword">while</span> (pcb-&gt;unsent != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">       TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb-&gt;unsent-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">                       TCP_TCPLEN(pcb-&gt;unsent), pcb-&gt;snd_nxt)) &#123;</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: removing %&quot;</span>U32_F<span class="string">&quot;:%&quot;</span>U32_F<span class="string">&quot; from pcb-&gt;unsent\n&quot;</span>,</span><br><span class="line">                                lwip_ntohl(pcb-&gt;unsent-&gt;tcphdr-&gt;seqno), lwip_ntohl(pcb-&gt;unsent-&gt;tcphdr-&gt;seqno) +</span><br><span class="line">                                TCP_TCPLEN(pcb-&gt;unsent)));</span><br><span class="line">  <span class="comment">//找到已经被确认的报文：</span></span><br><span class="line">  next = pcb-&gt;unsent;</span><br><span class="line">  pcb-&gt;unsent = pcb-&gt;unsent-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pcb-&gt;unsent_oversize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;tcp_receive: queuelen %&quot;</span>TCPWNDSIZE_F<span class="string">&quot; ... &quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)&quot;</span>, (pcb-&gt;snd_queuelen &gt;= pbuf_clen(next-&gt;p)));</span><br><span class="line">  </span><br><span class="line">  pcb-&gt;snd_queuelen -= pbuf_clen(next-&gt;p);</span><br><span class="line">  recv_acked += next-&gt;len;</span><br><span class="line">  tcp_seg_free(next);</span><br><span class="line">  LWIP_DEBUGF(TCP_QLEN_DEBUG, (<span class="string">&quot;%&quot;</span>TCPWNDSIZE_F<span class="string">&quot; (after freeing unsent)\n&quot;</span>, (<span class="type">tcpwnd_size_t</span>)pcb-&gt;snd_queuelen));</span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;snd_queuelen != <span class="number">0</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_receive: valid queue length&quot;</span>,</span><br><span class="line">      pcb-&gt;unacked != <span class="literal">NULL</span> || pcb-&gt;unsent != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6，rtt测试"><a href="#6，rtt测试" class="headerlink" title="6，rtt测试"></a>6，rtt测试</h3><p>若接收的ackno大于用于rtt测试的序号，则可进行rto的计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//TODO pcb的rtt测试开启，且进行rtt测试的序号小于确认序号则可用计算rto，计算rto超时重传时间</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;rttest &amp;&amp; TCP_SEQ_LT(pcb-&gt;rtseq, ackno)) &#123; </span><br><span class="line">    m = (<span class="type">s16_t</span>)(tcp_ticks - pcb-&gt;rttest);</span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_receive: experienced rtt %&quot;</span>U16_F<span class="string">&quot; ticks (%&quot;</span>U16_F<span class="string">&quot; msec).\n&quot;</span>,</span><br><span class="line">                                m, (<span class="type">u16_t</span>)(m * TCP_SLOW_INTERVAL)));</span><br><span class="line">    m = m - (pcb-&gt;sa &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    pcb-&gt;sa += m;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      m = -m;</span><br><span class="line">    &#125;</span><br><span class="line">    m = m - (pcb-&gt;sv &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    pcb-&gt;sv += m;</span><br><span class="line">    pcb-&gt;rto = (pcb-&gt;sa &gt;&gt; <span class="number">3</span>) + pcb-&gt;sv;</span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_receive: RTO %&quot;</span>U16_F<span class="string">&quot; (%&quot;</span>U16_F<span class="string">&quot; milliseconds)\n&quot;</span>,</span><br><span class="line">                                pcb-&gt;rto, (<span class="type">u16_t</span>)(pcb-&gt;rto * TCP_SLOW_INTERVAL)));</span><br><span class="line"></span><br><span class="line">    pcb-&gt;rttest = <span class="number">0</span>;  <span class="comment">//关闭rtt测量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7，滑动窗口"><a href="#7，滑动窗口" class="headerlink" title="7，滑动窗口"></a>7，滑动窗口</h3><p>根据接收到的数据序号在接收窗口的不同位置，对不同位置的数据有不一样的裁剪：</p>
<h4 id="a，接收的数据一部分已经接受过，另一部分是新数据"><a href="#a，接收的数据一部分已经接受过，另一部分是新数据" class="headerlink" title="a，接收的数据一部分已经接受过，另一部分是新数据"></a>a，接收的数据一部分已经接受过，另一部分是新数据</h4><p>此时要把已经接收的部分丢弃，只保留新数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若期待接收的数据处于接收到的数据的中间\</span></span><br><span class="line"><span class="comment">/*------接收到的数据既有已经接受过的数据，也有新的数据，将输入数据从rcv_nxt截断，取rcv_nxt及其之后的新数据-----*/</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SEQ_BETWEEN(pcb-&gt;rcv_nxt, seqno + <span class="number">1</span>, seqno + tcplen - <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span> =</span> inseg.p; <span class="comment">//p是输入报文第一个pbuf</span></span><br><span class="line">  off = pcb-&gt;rcv_nxt - seqno; <span class="comment">//p中将要舍弃的数据的偏移 即payload向后移动的距离</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;inseg.p != NULL&quot;</span>, inseg.p);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;insane offset!&quot;</span>, (off &lt; <span class="number">0x7fff</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若输入报文的第一个pbuf里的数据都是应该舍弃的数据</span></span><br><span class="line">  <span class="keyword">if</span> (inseg.p-&gt;len &lt; off) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf too short!&quot;</span>, (((<span class="type">s32_t</span>)inseg.p-&gt;tot_len) &gt;= off));</span><br><span class="line">    new_tot_len = (<span class="type">u16_t</span>)(inseg.p-&gt;tot_len - off);  <span class="comment">//截取后的pbuf总长度</span></span><br><span class="line">    <span class="comment">//则找到recv_nxt所在那个pbuf，在这个pbuf之前的buffer都要被释放</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;len &lt; off) &#123;</span><br><span class="line">      off -= p-&gt;len;</span><br><span class="line">      <span class="comment">//!注意下面的注释，inseg.p-&gt;tot_len -= p-&gt;len;被注释是因为这些pbuf都将被释放</span></span><br><span class="line">      <span class="comment">/* KJM following line changed (with addition of new_tot_len var)</span></span><br><span class="line"><span class="comment">         to fix bug #9076</span></span><br><span class="line"><span class="comment">         inseg.p-&gt;tot_len -= p-&gt;len; */</span></span><br><span class="line">      p-&gt;tot_len = new_tot_len;</span><br><span class="line">      p-&gt;len = <span class="number">0</span>;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动输入报文的pbuf的payload指针到其recv_nxt所在的地址</span></span><br><span class="line">    <span class="keyword">if</span> (pbuf_header(p, (<span class="type">s16_t</span>)-off)) &#123;</span><br><span class="line">      <span class="comment">/* Do we need to cope with this failing?  Assert for now */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_header failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pbuf_header(inseg.p, (<span class="type">s16_t</span>)-off)) &#123;</span><br><span class="line">      <span class="comment">/* Do we need to cope with this failing?  Assert for now */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_header failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  inseg.len -= (<span class="type">u16_t</span>)(pcb-&gt;rcv_nxt - seqno); <span class="comment">//报文长度被减少了</span></span><br><span class="line">  inseg.tcphdr-&gt;seqno = seqno = pcb-&gt;rcv_nxt; <span class="comment">//tcp报文首部的序号页要改成截断后的序号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------接收到的数据既有已经接受过的数据，也有新的数据，将输入数据从rcv_nxt截断，取rcv_nxt及其之后的新数据-----*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//整个报文都是已接收的数据，回复ack即可</span></span><br><span class="line">  <span class="keyword">if</span> (TCP_SEQ_LT(seqno, pcb-&gt;rcv_nxt)) &#123;</span><br><span class="line">    <span class="comment">/* the whole segment is &lt; rcv_nxt */</span></span><br><span class="line">    <span class="comment">/* must be a duplicate of a packet that has already been correctly handled */</span></span><br><span class="line"></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: duplicate seqno %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>, seqno));</span><br><span class="line">    tcp_ack_now(pcb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b，数据正好在接收窗口左边界"><a href="#b，数据正好在接收窗口左边界" class="headerlink" title="b，数据正好在接收窗口左边界"></a>b，数据正好在接收窗口左边界</h4><p>当数据长度超过窗口大小，则将超出部分丢弃。将报文插入osseq队列，若报文与osseq队列的内容重复，则将报文重复部分丢弃。将osseq队列的有序数据赋值给recv_data指针，上层应用通告该指针读取接收的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TCP_SEQ_BETWEEN(seqno, pcb-&gt;rcv_nxt,</span><br><span class="line">                    pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd - <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">//第一种情况：接收序号正好是期待接收的，说明数据与上次是连续的</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;rcv_nxt == seqno) &#123;</span><br><span class="line">    tcplen = TCP_TCPLEN(&amp;inseg);</span><br><span class="line">    <span class="comment">//报文内容大于接收窗口，将超过接收窗口部分的内容截掉</span></span><br><span class="line">    <span class="keyword">if</span> (tcplen &gt; pcb-&gt;rcv_wnd) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG,</span><br><span class="line">                  (<span class="string">&quot;tcp_receive: other end overran receive window&quot;</span></span><br><span class="line">                   <span class="string">&quot;seqno %&quot;</span>U32_F<span class="string">&quot; len %&quot;</span>U16_F<span class="string">&quot; right edge %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                   seqno, tcplen, pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">      <span class="comment">//!若输入报文中有fin，必须从报头中删除FIN，因为我们要修剪输入报文的数据</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">        <span class="comment">/* Must remove the FIN from the header as we&#x27;re trimming</span></span><br><span class="line"><span class="comment">         * that byte of sequence-space from the packet */</span></span><br><span class="line">        TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &amp; ~(<span class="type">unsigned</span> <span class="type">int</span>)TCP_FIN);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Adjust length of segment to fit in the window. */</span></span><br><span class="line">      TCPWND_CHECK16(pcb-&gt;rcv_wnd);</span><br><span class="line">      inseg.len = (<span class="type">u16_t</span>)pcb-&gt;rcv_wnd;  <span class="comment">//修剪后的报文大小就是窗口大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//若有syn标志，则报文长度-1</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_SYN) &#123;</span><br><span class="line">        inseg.len -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      pbuf_realloc(inseg.p, inseg.len); <span class="comment">//给报文的pbuf重新分配内存</span></span><br><span class="line">      tcplen = TCP_TCPLEN(&amp;inseg);  <span class="comment">//更新修剪后的报文大小</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_receive: segment not trimmed correctly to rcv_wnd\n&quot;</span>,</span><br><span class="line">                  (seqno + tcplen) == (pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*---------------------------------------根据接收窗口修建接收的报文长度-----------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//!现在接收的数据是正常排序的，先放到osseq队列首部，具体情况见p397第九点</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;ooseq != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//fin标志说明后续无数据来了，该报文段后的报文都要删除</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG,</span><br><span class="line">                    (<span class="string">&quot;tcp_receive: received in-order FIN, binning ooseq queue\n&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pcb-&gt;ooseq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">old_ooseq</span> =</span> pcb-&gt;ooseq;</span><br><span class="line">          pcb-&gt;ooseq = pcb-&gt;ooseq-&gt;next;</span><br><span class="line">          tcp_seg_free(old_ooseq);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">/*--------------------根据输入报文，修改osseq中的数据，修剪输入数据------------------------*/</span></span><br><span class="line">        next = pcb-&gt;ooseq;</span><br><span class="line">        <span class="comment">//!因为接收的数据与上一次接收的数据是连续的，以下情况的报文段是要删除</span></span><br><span class="line">        <span class="keyword">while</span> (next &amp;&amp;</span><br><span class="line">               TCP_SEQ_GEQ(seqno + tcplen,</span><br><span class="line">                           next-&gt;tcphdr-&gt;seqno + next-&gt;len)) &#123;</span><br><span class="line">          <span class="comment">/* inseg cannot have FIN here (already processed above) */</span></span><br><span class="line">          <span class="comment">/* 如果这些即将被删除的报文段带FIN标志且输入报文段不带SYN标志 */</span></span><br><span class="line">          <span class="keyword">if</span> ((TCPH_FLAGS(next-&gt;tcphdr) &amp; TCP_FIN) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">              (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_SYN) == <span class="number">0</span>) &#123;</span><br><span class="line">            TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN); <span class="comment">//在输入报文段的TCP头中添加FIN标志</span></span><br><span class="line">            tcplen = TCP_TCPLEN(&amp;inseg);  </span><br><span class="line">          &#125;</span><br><span class="line">          prev = next;</span><br><span class="line">          next = next-&gt;next;</span><br><span class="line">          tcp_seg_free(prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//!此时seqno在osseq是最小的序号</span></span><br><span class="line">        <span class="comment">/* Now trim right side of inseg if it overlaps with the first</span></span><br><span class="line"><span class="comment">         * segment on ooseq */</span></span><br><span class="line">        <span class="comment">//如果输入报文段与osseq中出现部分重叠，则删除输入报文段中重叠部分</span></span><br><span class="line">        <span class="keyword">if</span> (next &amp;&amp;</span><br><span class="line">            TCP_SEQ_GT(seqno + tcplen,</span><br><span class="line">                       next-&gt;tcphdr-&gt;seqno)) &#123;</span><br><span class="line">          <span class="comment">/* inseg cannot have FIN here (already processed above) */</span></span><br><span class="line">          inseg.len = (<span class="type">u16_t</span>)(next-&gt;tcphdr-&gt;seqno - seqno); <span class="comment">//得到输入报文中不重叠部分的长度</span></span><br><span class="line">          <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_SYN) &#123;</span><br><span class="line">            inseg.len -= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          pbuf_realloc(inseg.p, inseg.len); <span class="comment">//给输入报文段调整长度</span></span><br><span class="line">          tcplen = TCP_TCPLEN(&amp;inseg);  <span class="comment">//再次更新报文长度</span></span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;tcp_receive: segment not trimmed correctly to ooseq queue\n&quot;</span>,</span><br><span class="line">                      (seqno + tcplen) == next-&gt;tcphdr-&gt;seqno);</span><br><span class="line">        &#125;</span><br><span class="line">        pcb-&gt;ooseq = next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*--------------------根据输入报文，修改osseq中的数据，修剪输入数据------------------------*/</span></span><br><span class="line"></span><br><span class="line">    pcb-&gt;rcv_nxt = seqno + tcplen;  <span class="comment">//更新下一个期待收到的序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the receiver&#x27;s (our) window. */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_receive: tcplen &gt; rcv_wnd\n&quot;</span>, pcb-&gt;rcv_wnd &gt;= tcplen);</span><br><span class="line">    pcb-&gt;rcv_wnd -= tcplen; <span class="comment">//本地接收窗口变小</span></span><br><span class="line"></span><br><span class="line">    tcp_update_rcv_ann_wnd(pcb);  <span class="comment">//更新通告窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将输入报文段的数据上传给应用层</span></span><br><span class="line">    <span class="keyword">if</span> (inseg.p-&gt;tot_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      recv_data = inseg.p;</span><br><span class="line">      <span class="comment">/* Since this pbuf now is the responsibility of the</span></span><br><span class="line"><span class="comment">         application, we delete our reference to it so that we won&#x27;t</span></span><br><span class="line"><span class="comment">         (mistakingly) deallocate it. */</span></span><br><span class="line">      inseg.p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果报文段有fin标志</span></span><br><span class="line">    <span class="keyword">if</span> (TCPH_FLAGS(inseg.tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: received FIN.\n&quot;</span>));</span><br><span class="line">      recv_flags |= TF_GOT_FIN; <span class="comment">//给接收处理结果置位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------------------ooseq有序数据发送到应用层------------------------------------*/</span></span><br><span class="line">    <span class="comment">//(通过比较ooseq队列中报文段的seqno和当前TCP控制块中保存的rcv_nxt来判定该报文段是否有序) </span></span><br><span class="line">    <span class="keyword">while</span> (pcb-&gt;ooseq != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">           pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno == pcb-&gt;rcv_nxt) &#123;</span><br><span class="line"></span><br><span class="line">      cseg = pcb-&gt;ooseq;</span><br><span class="line">      seqno = pcb-&gt;ooseq-&gt;tcphdr-&gt;seqno;</span><br><span class="line"></span><br><span class="line">      pcb-&gt;rcv_nxt += TCP_TCPLEN(cseg);</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_receive: ooseq tcplen &gt; rcv_wnd\n&quot;</span>,</span><br><span class="line">                  pcb-&gt;rcv_wnd &gt;= TCP_TCPLEN(cseg));</span><br><span class="line">      pcb-&gt;rcv_wnd -= TCP_TCPLEN(cseg);</span><br><span class="line"></span><br><span class="line">      tcp_update_rcv_ann_wnd(pcb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果该报文段有数据，则将数据连接到recv_data上，同时将报文的pbuf指针赋值为null</span></span><br><span class="line">      <span class="keyword">if</span> (cseg-&gt;p-&gt;tot_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Chain this pbuf onto the pbuf that we will pass to</span></span><br><span class="line"><span class="comment">           the application. */</span></span><br><span class="line">        <span class="comment">/* With window scaling, this can overflow recv_data-&gt;tot_len, but</span></span><br><span class="line"><span class="comment">           that&#x27;s not a problem since we explicitly fix that before passing</span></span><br><span class="line"><span class="comment">           recv_data to the application. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_data) &#123;</span><br><span class="line">          pbuf_cat(recv_data, cseg-&gt;p); <span class="comment">//将有序的pbuf拼接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recv_data = cseg-&gt;p;</span><br><span class="line">        &#125;</span><br><span class="line">        cseg-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若报文段中有fin标志，则设置处理结果，修改pcb的状态</span></span><br><span class="line">      <span class="keyword">if</span> (TCPH_FLAGS(cseg-&gt;tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_receive: dequeued FIN.\n&quot;</span>));</span><br><span class="line">        recv_flags |= TF_GOT_FIN;</span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state == ESTABLISHED) &#123; <span class="comment">/* force passive close or we can move to active close */</span></span><br><span class="line">          pcb-&gt;state = CLOSE_WAIT;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pcb-&gt;ooseq = cseg-&gt;next;  <span class="comment">//处理下一个ooseq报文段</span></span><br><span class="line">      tcp_seg_free(cseg); <span class="comment">//释放被拼接的报文段</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="c，数据不在左边界"><a href="#c，数据不在左边界" class="headerlink" title="c，数据不在左边界"></a>c，数据不在左边界</h4><p>说明接收的数据不是有序到达的。则将该报文插入osseq队列。接下来的代码就是如何将报文正确的插入osseq队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!seqno!=recv-&gt;nxt 说明收到无序报文，将报文插入合适的位置</span></span><br><span class="line">tcp_send_empty_ack(pcb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;ooseq == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  pcb-&gt;ooseq = tcp_seg_copy(&amp;inseg);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/*-----------------------------------处理osseq无序报文-------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  prev = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//遍历ooseq队列</span></span><br><span class="line">  <span class="keyword">for</span> (next = pcb-&gt;ooseq; next != <span class="literal">NULL</span>; next = next-&gt;next) &#123;</span><br><span class="line">    <span class="comment">//若输入的报文序号与osseq队列中的某个报文一样</span></span><br><span class="line">    <span class="keyword">if</span> (seqno == next-&gt;tcphdr-&gt;seqno) &#123;</span><br><span class="line">      <span class="comment">//若输入的报文长度大。则将输入报文插入</span></span><br><span class="line">      <span class="keyword">if</span> (inseg.len &gt; next-&gt;len) &#123;</span><br><span class="line"></span><br><span class="line">        cseg = tcp_seg_copy(&amp;inseg);</span><br><span class="line">        <span class="keyword">if</span> (cseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            prev-&gt;next = cseg;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pcb-&gt;ooseq = cseg;</span><br><span class="line">          &#125;</span><br><span class="line">          tcp_oos_insert_segment(cseg, next); <span class="comment">//替换next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//输入报文段比原报文小，啥不用干了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//输入报文段的序号在osseq队列中无</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//next是第一个osseq报文段</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//输入报文序号小于第一个osseq报文，则将输入报文放到osseq首部</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_LT(seqno, next-&gt;tcphdr-&gt;seqno)) &#123;</span><br><span class="line">          cseg = tcp_seg_copy(&amp;inseg);</span><br><span class="line">          <span class="keyword">if</span> (cseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pcb-&gt;ooseq = cseg;</span><br><span class="line">            tcp_oos_insert_segment(cseg, next); <span class="comment">//替换next的位置</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若输入序号在前一个报文与后一个报文之间，修剪前一个报文，删除下一个报文中重复的部分</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_BETWEEN(seqno, prev-&gt;tcphdr-&gt;seqno+<span class="number">1</span>, next-&gt;tcphdr-&gt;seqno<span class="number">-1</span>)) &#123;</span><br><span class="line">          cseg = tcp_seg_copy(&amp;inseg);</span><br><span class="line">          <span class="keyword">if</span> (cseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//前一个报文太长。修剪</span></span><br><span class="line">            <span class="keyword">if</span> (TCP_SEQ_GT(prev-&gt;tcphdr-&gt;seqno + prev-&gt;len, seqno)) &#123;</span><br><span class="line">              <span class="comment">/* We need to trim the prev segment. */</span></span><br><span class="line">              prev-&gt;len = (<span class="type">u16_t</span>)(seqno - prev-&gt;tcphdr-&gt;seqno);</span><br><span class="line">              pbuf_realloc(prev-&gt;p, prev-&gt;len);</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;next = cseg;</span><br><span class="line">            tcp_oos_insert_segment(cseg, next); <span class="comment">//替换next</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若next是最后一个报文，且输入报文的数据在next之后</span></span><br><span class="line">      <span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">          TCP_SEQ_GT(seqno, next-&gt;tcphdr-&gt;seqno)) &#123;</span><br><span class="line">        <span class="comment">//若next报文有fin，说明其后不应该有数据，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (TCPH_FLAGS(next-&gt;tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">          <span class="comment">/* segment &quot;next&quot; already contains all data */</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;next = tcp_seg_copy(&amp;inseg);  <span class="comment">//输入报文插入最后</span></span><br><span class="line">        <span class="keyword">if</span> (next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">//如果next与输入报文有覆盖，则修改next报文的长度</span></span><br><span class="line">          <span class="keyword">if</span> (TCP_SEQ_GT(next-&gt;tcphdr-&gt;seqno + next-&gt;len, seqno)) &#123;</span><br><span class="line">            <span class="comment">/* We need to trim the last segment. */</span></span><br><span class="line">    </span><br><span class="line">            next-&gt;len = (<span class="type">u16_t</span>)(seqno - next-&gt;tcphdr-&gt;seqno);</span><br><span class="line">            pbuf_realloc(next-&gt;p, next-&gt;len);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* check if the remote side overruns our receive window */</span></span><br><span class="line">          <span class="comment">//检查远程是不是超支我们的接收窗口</span></span><br><span class="line">          <span class="keyword">if</span> (TCP_SEQ_GT((<span class="type">u32_t</span>)tcplen + seqno, pcb-&gt;rcv_nxt + (<span class="type">u32_t</span>)pcb-&gt;rcv_wnd)) &#123;</span><br><span class="line">            LWIP_DEBUGF(TCP_INPUT_DEBUG,</span><br><span class="line">                        (<span class="string">&quot;tcp_receive: other end overran receive window&quot;</span></span><br><span class="line">                         <span class="string">&quot;seqno %&quot;</span>U32_F<span class="string">&quot; len %&quot;</span>U16_F<span class="string">&quot; right edge %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                         seqno, tcplen, pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">            <span class="comment">//!若输入报文有fin，则删除，因为我们正修改输入报文的大小来适应接收窗口</span></span><br><span class="line">            <span class="keyword">if</span> (TCPH_FLAGS(next-&gt;next-&gt;tcphdr) &amp; TCP_FIN) &#123;</span><br><span class="line">              <span class="comment">/* Must remove the FIN from the header as we&#x27;re trimming</span></span><br><span class="line"><span class="comment">               * that byte of sequence-space from the packet */</span></span><br><span class="line">              TCPH_FLAGS_SET(next-&gt;next-&gt;tcphdr, TCPH_FLAGS(next-&gt;next-&gt;tcphdr) &amp; ~TCP_FIN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Adjust length of segment to fit in the window. */</span></span><br><span class="line">            next-&gt;next-&gt;len = (<span class="type">u16_t</span>)(pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd - seqno); <span class="comment">//经过接收窗口筛选后的报文大小</span></span><br><span class="line">            pbuf_realloc(next-&gt;next-&gt;p, next-&gt;next-&gt;len); <span class="comment">//重新分配报文内存</span></span><br><span class="line">            tcplen = TCP_TCPLEN(next-&gt;next);</span><br><span class="line">            LWIP_ASSERT(<span class="string">&quot;tcp_receive: segment not trimmed correctly to rcv_wnd\n&quot;</span>,</span><br><span class="line">                        (seqno + tcplen) == (pcb-&gt;rcv_nxt + pcb-&gt;rcv_wnd));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/20201218151146864.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_3/" data-id="cmbcy7rhu0036t8mtdmqd31fi" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_in_2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
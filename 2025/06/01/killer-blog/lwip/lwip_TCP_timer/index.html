<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="@[toc]  TCP协议中许多地方是需要使用到定时功能的，如定时重传功能，保活keepalive功能，坚持定时器功能，这些定时功能会在lwip中的两个定时器函数中实现。  一，定时器时钟二，快速定时任务void tcp_fasttmr(void)比较简单，它的功能主要是每250ms处理延时发送的ack报文和fin报文，同时通知上层应用处理数据。 1234567891011121314151617">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_timer/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@[toc]  TCP协议中许多地方是需要使用到定时功能的，如定时重传功能，保活keepalive功能，坚持定时器功能，这些定时功能会在lwip中的两个定时器函数中实现。  一，定时器时钟二，快速定时任务void tcp_fasttmr(void)比较简单，它的功能主要是每250ms处理延时发送的ack报文和fin报文，同时通知上层应用处理数据。 1234567891011121314151617">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_TCP_timer/20210226004849547.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.654Z">
<meta property="article:modified_time" content="2025-06-01T00:26:26.751Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_TCP_timer/20210226004849547.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/lwip/lwip_TCP_timer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_timer/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.654Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>TCP协议中许多地方是需要使用到定时功能的，如定时重传功能，保活keepalive功能，坚持定时器功能，这些定时功能会在lwip中的两个定时器函数中实现。</p>
</blockquote>
<h2 id="一，定时器时钟"><a href="#一，定时器时钟" class="headerlink" title="一，定时器时钟"></a>一，定时器时钟</h2><h2 id="二，快速定时任务"><a href="#二，快速定时任务" class="headerlink" title="二，快速定时任务"></a>二，快速定时任务</h2><p><code>void tcp_fasttmr(void)</code>比较简单，它的功能主要是每250ms处理延时发送的ack报文和fin报文，同时通知上层应用处理数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcp_fasttmr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb</span>;</span></span><br><span class="line"></span><br><span class="line">  ++tcp_timer_ctr;</span><br><span class="line"></span><br><span class="line">tcp_fasttmr_start:</span><br><span class="line">  pcb = tcp_active_pcbs;  <span class="comment">//在active中遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;last_timer != tcp_timer_ctr) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">next</span>;</span></span><br><span class="line">      pcb-&gt;last_timer = tcp_timer_ctr;</span><br><span class="line">      <span class="comment">//发送延时的ack</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_DELAY) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: delayed ACK\n&quot;</span>));</span><br><span class="line">        tcp_ack_now(pcb);</span><br><span class="line">        tcp_output(pcb);</span><br><span class="line">        pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//发送延时的fin</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_CLOSEPEND) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: pending FIN\n&quot;</span>));</span><br><span class="line">        pcb-&gt;flags &amp;= ~(TF_CLOSEPEND);</span><br><span class="line">        tcp_close_shutdown_fin(pcb);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      next = pcb-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//若当前tcp有未被上层应用接收的数据</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tcp_active_pcbs_changed = <span class="number">0</span>;</span><br><span class="line">        tcp_process_refused_data(pcb);  <span class="comment">//通过回调函数使上层处理数据</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_active_pcbs_changed) &#123;</span><br><span class="line">          <span class="keyword">goto</span> tcp_fasttmr_start;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pcb = next; <span class="comment">//下一个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pcb = pcb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三，低速定时任务"><a href="#三，低速定时任务" class="headerlink" title="三，低速定时任务"></a>三，低速定时任务</h2><p><code>void tcp_slowtmr(void)</code>每500ms调用，该函数完成了超时重传，tcp保活功能，并会遍历<code>active</code>和<code>timewait</code>链表的PCB，删除那些超时或者出错的PCB，<strong>同时将PCB中unsent队列中的数据发送出去。一般使用tcp_write();写入数据后，数据不会马上发送，而是在定时任务中发送。</strong></p>
<h3 id="1，超时重传"><a href="#1，超时重传" class="headerlink" title="1，超时重传"></a>1，超时重传</h3><p>重点的代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求连接次数超出限制</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == SYN_SENT &amp;&amp; pcb-&gt;nrtx &gt;= TCP_SYNMAXRTX) &#123;</span><br><span class="line">  ++pcb_remove; <span class="comment">//移除增加</span></span><br><span class="line">  LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: max SYN retries reached\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据重发次数超出限制</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pcb-&gt;nrtx &gt;= TCP_MAXRTX) &#123;</span><br><span class="line">  ++pcb_remove;</span><br><span class="line">  LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: max DATA retries reached\n&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果坚持定时器已经开启</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;persist_backoff &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取坚持定时器触发值</span></span><br><span class="line">    <span class="type">u8_t</span> backoff_cnt = tcp_persist_backoff[pcb-&gt;persist_backoff<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//坚持定时器不超过触发值，则加1</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_cnt &lt; backoff_cnt) &#123;</span><br><span class="line">      pcb-&gt;persist_cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//坚持定时器触发，发送窗口探查</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_cnt &gt;= backoff_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tcp_zero_window_probe(pcb) == ERR_OK) &#123;</span><br><span class="line">        pcb-&gt;persist_cnt = <span class="number">0</span>; <span class="comment">//发送成功，清除计数值</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;persist_backoff &lt; <span class="keyword">sizeof</span>(tcp_persist_backoff)) &#123;</span><br><span class="line">          pcb-&gt;persist_backoff++; <span class="comment">//发送探查次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">//无开启坚持定时器</span></span><br><span class="line">    <span class="comment">//如果开启了超时重传定时器，则加1</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;rtime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      ++pcb-&gt;rtime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有未确认报文且重传时间到，要重传了</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;unacked != <span class="literal">NULL</span> &amp;&amp; pcb-&gt;rtime &gt;= pcb-&gt;rto) &#123;</span><br><span class="line">      LWIP_DEBUGF(TCP_RTO_DEBUG, (<span class="string">&quot;tcp_slowtmr: rtime %&quot;</span>S16_F</span><br><span class="line">                                  <span class="string">&quot; pcb-&gt;rto %&quot;</span>S16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                  pcb-&gt;rtime, pcb-&gt;rto));</span><br><span class="line"></span><br><span class="line">      ESP_STATS_TCP_PCB(pcb);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">        <span class="type">u8_t</span> backoff_idx = LWIP_MIN(pcb-&gt;nrtx, <span class="keyword">sizeof</span>(tcp_backoff)<span class="number">-1</span>);  <span class="comment">//获得重传次数，但重传次数不会超过7</span></span><br><span class="line">        <span class="comment">//动态设置rto，每次超时后，rto时间会增加</span></span><br><span class="line">        pcb-&gt;rto = ((pcb-&gt;sa &gt;&gt; <span class="number">3</span>) + pcb-&gt;sv) &lt;&lt; tcp_backoff[backoff_idx];  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pcb-&gt;rtime = <span class="number">0</span>; <span class="comment">//重置超时重传定时器</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//TODO 出现重传，说明报文丢失了，可能是网络出现阻塞，减小拥塞窗口</span></span><br><span class="line">      eff_wnd = LWIP_MIN(pcb-&gt;cwnd, pcb-&gt;snd_wnd);</span><br><span class="line">      pcb-&gt;ssthresh = eff_wnd &gt;&gt; <span class="number">1</span>; <span class="comment">//ssthresh减少到拥塞窗口的一半</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//若ssthresh比最大报文长度的两倍还小，后者的数值（限制了ssthresh的最小值）</span></span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;ssthresh &lt; (<span class="type">tcpwnd_size_t</span>)(pcb-&gt;mss &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        pcb-&gt;ssthresh = (pcb-&gt;mss &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pcb-&gt;cwnd = pcb-&gt;mss; <span class="comment">//拥塞窗口设置成最大报文长度，一个报文长度</span></span><br><span class="line">      LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_slowtmr: cwnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                   <span class="string">&quot; ssthresh %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                   pcb-&gt;cwnd, pcb-&gt;ssthresh));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//重传报文</span></span><br><span class="line">      tcp_rexmit_rto(pcb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == FIN_WAIT_2) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//TODO 处于FIN_WAIT_2的时间太长（由于对方长时间无反应）则删除</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_RXCLOSED) &#123;</span><br><span class="line">    <span class="comment">/* PCB was fully closed (either through close() or SHUT_RDWR):</span></span><br><span class="line"><span class="comment">       normal FIN-WAIT timeout handling. */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">        TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">      ++pcb_remove;</span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，保活keepalive"><a href="#2，保活keepalive" class="headerlink" title="2，保活keepalive"></a>2，保活keepalive</h3><p><strong>服务端需要检查客户端是否还能通信，若两小时内无通信，客户端发送探查报文，若客户端ack，则更新保活计时器，否则，每隔75s发送一个探查报文，若发送超过9个报文，则认为客户端已挂掉</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if KEEPALIVE should be sent */</span></span><br><span class="line"><span class="comment">//服务端需要检查客户端是否还能通信，若两小时内无通信，客户端发送探查报文，若客户端ack，则更新保活计时器</span></span><br><span class="line"><span class="comment">//否则，每隔75s发送一个探查报文，若发送超过9个报文，则认为客户端已挂掉</span></span><br><span class="line"><span class="keyword">if</span> (ip_get_option(pcb, SOF_KEEPALIVE) &amp;&amp;</span><br><span class="line">   ((pcb-&gt;state == ESTABLISHED) ||</span><br><span class="line">    (pcb-&gt;state == CLOSE_WAIT))) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发送9个以上探查报文，对方仍无反应，应该关闭tcp</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">     (pcb-&gt;keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: KEEPALIVE timeout. Aborting connection to &quot;</span>));</span><br><span class="line">    ip_addr_debug_print(TCP_DEBUG, &amp;pcb-&gt;remote_ip);</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ++pcb_remove;</span><br><span class="line">    ++pcb_reset;  <span class="comment">//复位对方</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">            (pcb-&gt;keep_idle + pcb-&gt;keep_cnt_sent * TCP_KEEP_INTVL(pcb))</span><br><span class="line">            / TCP_SLOW_INTERVAL)  <span class="comment">//发送探查报文</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    err = tcp_keepalive(pcb); </span><br><span class="line">    <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">      pcb-&gt;keep_cnt_sent++; <span class="comment">//探查次数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3，删除超时PCB"><a href="#3，删除超时PCB" class="headerlink" title="3，删除超时PCB"></a>3，删除超时PCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//若pcb的osseq队列中无序的数据超过一定时长会被丢弃</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;ooseq != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    (<span class="type">u32_t</span>)tcp_ticks - pcb-&gt;tmr &gt;= pcb-&gt;rto * TCP_OOSEQ_TIMEOUT) &#123;</span><br><span class="line">  tcp_segs_free(pcb-&gt;ooseq);</span><br><span class="line">  pcb-&gt;ooseq = <span class="literal">NULL</span>;</span><br><span class="line">  LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_slowtmr: dropping OOSEQ queued data\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一直等不到服务端回答的tcp要被移除</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == SYN_RCVD) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt;</span><br><span class="line">      TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">    ++pcb_remove;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: removing pcb stuck in SYN-RCVD\n&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在last_ack超过一定时间也被删除</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;state == LAST_ACK) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt; <span class="number">2</span> * TCP_MSL / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">    ++pcb_remove;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: removing pcb stuck in LAST-ACK\n&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上的代码中若当前PCB需要被删除，则pcb_remove不为0，具体的删除代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (pcb_remove) &#123;	<span class="comment">//不为0则需要删除pcb</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb2</span>;</span></span><br><span class="line"></span><br><span class="line">    tcp_err_fn err_fn = pcb-&gt;errf;  <span class="comment">//错误回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *err_arg;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tcp_state</span> <span class="title">last_state</span>;</span></span><br><span class="line">    tcp_pcb_purge(pcb); <span class="comment">//释放pcb部分成员，pcb结构体不会被释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: middle tcp != tcp_active_pcbs&quot;</span>, pcb != tcp_active_pcbs);</span><br><span class="line">      prev-&gt;next = pcb-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* This PCB was the first. */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: first pcb == tcp_active_pcbs&quot;</span>, tcp_active_pcbs == pcb);</span><br><span class="line">      tcp_active_pcbs = pcb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要发送重置报文</span></span><br><span class="line">    <span class="keyword">if</span> (pcb_reset) &#123;</span><br><span class="line">      tcp_rst(pcb-&gt;snd_nxt, pcb-&gt;rcv_nxt, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip,</span><br><span class="line">               pcb-&gt;local_port, pcb-&gt;remote_port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err_arg = pcb-&gt;callback_arg;</span><br><span class="line">    last_state = pcb-&gt;state;</span><br><span class="line">   </span><br><span class="line">    pcb2 = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;  <span class="comment">//获取下一个pcb</span></span><br><span class="line">    memp_free(MEMP_TCP_PCB, pcb2);  <span class="comment">//释放pcb结构体</span></span><br><span class="line"></span><br><span class="line">    tcp_active_pcbs_changed = <span class="number">0</span>;</span><br><span class="line">    TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT); <span class="comment">//调用错误回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_active_pcbs_changed) &#123;</span><br><span class="line">      <span class="keyword">goto</span> tcp_slowtmr_start;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不需要删除pcb</span></span><br><span class="line">    prev = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;  <span class="comment">//获取下一个pcb</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 定时周期到，调用回调函数</span></span><br><span class="line">    ++prev-&gt;polltmr;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;polltmr &gt;= prev-&gt;pollinterval) &#123;</span><br><span class="line">      prev-&gt;polltmr = <span class="number">0</span>;</span><br><span class="line">      LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_slowtmr: polling application\n&quot;</span>));</span><br><span class="line">      tcp_active_pcbs_changed = <span class="number">0</span>;</span><br><span class="line">      TCP_EVENT_POLL(prev, err);  <span class="comment">//!回调周期性函数</span></span><br><span class="line">      <span class="keyword">if</span> (tcp_active_pcbs_changed) &#123;</span><br><span class="line">        <span class="keyword">goto</span> tcp_slowtmr_start;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">        tcp_output(prev); <span class="comment">//输出unsent报文</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是处理active链表的pcb，接下来处理timewait的pcb，苍天饶过谁？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------遍历所有timewait的pcb-----------------------*/</span></span><br><span class="line"><span class="comment">/* Steps through all of the TIME-WAIT PCBs. */</span></span><br><span class="line">prev = <span class="literal">NULL</span>;</span><br><span class="line">pcb = tcp_tw_pcbs;</span><br><span class="line"><span class="keyword">while</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: TIME-WAIT pcb-&gt;state == TIME-WAIT&quot;</span>, pcb-&gt;state == TIME_WAIT);</span><br><span class="line">  pcb_remove = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//是否达到2MSL，是则删除</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">u32_t</span>)(tcp_ticks - pcb-&gt;tmr) &gt; <span class="number">2</span> * TCP_MSL / TCP_SLOW_INTERVAL) &#123;</span><br><span class="line">    ++pcb_remove;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb_remove) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb2</span>;</span></span><br><span class="line">    tcp_pcb_purge(pcb);</span><br><span class="line">    <span class="comment">/* Remove PCB from tcp_tw_pcbs list. */</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: middle tcp != tcp_tw_pcbs&quot;</span>, pcb != tcp_tw_pcbs);</span><br><span class="line">      prev-&gt;next = pcb-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* This PCB was the first. */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_slowtmr: first pcb == tcp_tw_pcbs&quot;</span>, tcp_tw_pcbs == pcb);</span><br><span class="line">      tcp_tw_pcbs = pcb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pcb2 = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;</span><br><span class="line">    memp_free(MEMP_TCP_PCB, pcb2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev = pcb;</span><br><span class="line">    pcb = pcb-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，小结"><a href="#四，小结" class="headerlink" title="四，小结"></a>四，小结</h2><p>tcp定时任务是tcp接收发送的动力来源，需要关注。<br><img src="/2025/05/30/hello-world/lwip/lwip_TCP_timer/20210226004849547.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_TCP_timer/" data-id="cmbcy7rhu0038t8mth6165t8i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_TCP_data_out_2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
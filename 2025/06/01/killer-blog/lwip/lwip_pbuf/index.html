<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="@[toc]  lwip使用pbuf对数据进行发送与接收，灵活的pbuf结构体使得数据在不同网络层之间传输时可以减少内存的开销，内存复制所占用的时间，一切都是为了节约内存，增加数据在不同层之间传递的速度。  一，数据在tcp&#x2F;ip层中的传递数据如何从tcp层一层层传递到最底层的物理层并发送出去呢？ 应用层需要发送的数据传递到tcp层时，tcp层给数据添加首部数据，tcp层传递给ip层时，">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/lwip/lwip_pbuf/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@[toc]  lwip使用pbuf对数据进行发送与接收，灵活的pbuf结构体使得数据在不同网络层之间传输时可以减少内存的开销，内存复制所占用的时间，一切都是为了节约内存，增加数据在不同层之间传递的速度。  一，数据在tcp&#x2F;ip层中的传递数据如何从tcp层一层层传递到最底层的物理层并发送出去呢？ 应用层需要发送的数据传递到tcp层时，tcp层给数据添加首部数据，tcp层传递给ip层时，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/2020121313384068.jpg">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/20201213112657928.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/20201213134210324.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/20201213134249515.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/20201213144729146.jpg">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/20201213143318498.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.656Z">
<meta property="article:modified_time" content="2025-06-01T00:26:26.727Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/05/30/hello-world/lwip/lwip_pbuf/2020121313384068.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/lwip/lwip_pbuf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/lwip/lwip_pbuf/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.656Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<blockquote>
<p>lwip使用pbuf对数据进行发送与接收，灵活的pbuf结构体使得数据在不同网络层之间传输时可以减少内存的开销，内存复制所占用的时间，一切都是为了节约内存，增加数据在不同层之间传递的速度。</p>
</blockquote>
<h2 id="一，数据在tcp-ip层中的传递"><a href="#一，数据在tcp-ip层中的传递" class="headerlink" title="一，数据在tcp&#x2F;ip层中的传递"></a>一，数据在tcp&#x2F;ip层中的传递</h2><p>数据如何从tcp层一层层传递到最底层的物理层并发送出去呢？</p>
<p>应用层需要发送的数据传递到tcp层时，tcp层给数据添加首部数据，tcp层传递给ip层时，ip层将tcp层的所有数据（payload和首部数据）当成发送的数据，并给这份数据添加首部，这样一层层传递下去，如图：<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/2020121313384068.jpg" alt="在这里插入图片描述"></p>
<h2 id="二，认识pbuf结构体"><a href="#二，认识pbuf结构体" class="headerlink" title="二，认识pbuf结构体"></a>二，认识pbuf结构体</h2><p>为了更好的描述以上的数据传递过程，pbuf他来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">next</span>;</span>	<span class="comment">//指向下一个pbuf</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *payload;  <span class="comment">//指向buff中的真实数据</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> tot_len;  <span class="comment">//该len与其后所有pbuf的len</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">u16_t</span> len;  <span class="comment">//payload中数据长度，不包括首部</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> type;</span><br><span class="line"></span><br><span class="line">  <span class="type">u8_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="type">u16_t</span> ref;  <span class="comment">//buffer被引用次数，包括next</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>1，pbuf结构体很简单，他支持单向链表，其核心是payload指针，该指针指向真实的数据起始地址，而payload前面的有一段长度为offset的偏移内存，这个内存是用于存放数据的首部的；这点与第一节所述一样。</strong></p>
<p>PBUF_RAM 示意图：<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213112657928.png" alt="在这里插入图片描述"><br>对于不同网络层的pbuf，其首部的数据也是不同的，所以其对应的pbuf中offset的长度也是不一样。</p>
<p>例如：tcp报文中，固定首部通常是20个字节，还有4*n的选项字段和填充字段，所以tcp层的pbuf中，offset的最小值是20，其后payload指向tcp的数据。</p>
<p><strong>2，len表示的是payload数据的长度，也就是不包括首部。</strong></p>
<p><strong>3，tot_len：表示当前pbuf和后面所有pbuf的len之和。</strong></p>
<p><strong>3，flag是记录pbuf的一些标志。其值如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** indicates this packet&#x27;s data should be immediately passed to the application */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_PUSH      0x01U <span class="comment">//立即发送</span></span></span><br><span class="line"><span class="comment">/** indicates this is a custom pbuf: pbuf_free calls pbuf_custom-&gt;custom_free_function()</span></span><br><span class="line"><span class="comment">    when the last reference is released (plus custom PBUF_RAM cannot be trimmed) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_IS_CUSTOM 0x02U</span></span><br><span class="line"><span class="comment">/** indicates this pbuf is UDP multicast to be looped back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_MCASTLOOP 0x04U <span class="comment">//udp多播返回</span></span></span><br><span class="line"><span class="comment">/** indicates this pbuf was received as link-level broadcast */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_LLBCAST   0x08U <span class="comment">//链路层的广播</span></span></span><br><span class="line"><span class="comment">/** indicates this pbuf was received as link-level multicast */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_LLMCAST   0x10U <span class="comment">//链路层的多播</span></span></span><br><span class="line"><span class="comment">/** indicates this pbuf includes a TCP FIN flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_TCP_FIN   0x20U <span class="comment">//tcp挥手标志</span></span></span><br></pre></td></tr></table></figure>

<p><strong>4，ref：表示该pbuf被外部引用的次数，也包括被上一个pbuf的next引用的情况，该变量用于防止在释放pbuf后导致内存读取错误。</strong></p>
<p><strong>5，由于payload指向的内存的性质不同，导致了pbuf的类型不同，pbuf的类型可用分为四种：在理解pbuf时，将pbuf结构体与payload指向的内存分开思考。</strong></p>
<blockquote>
<p>PBUF_RAM, 用于发送，pbuf和payload在连续的内存上<br>PBUF_ROM, pbuf在内存中，payload在外存<br>PBUF_REF, pbuf来自内存池，payload是其他程序段分配的内存，所以payload可能会被修改，发送时要复制payload;<br>PBUF_POOL， 用于接收，使用内存池分配。pbuf和payload在同一内存，pool内存大小是固定的，所以实际情况可能是多个pbuf连在一起。</p>
</blockquote>
<p>PBUF_POOL示意图：<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213134210324.png" alt="在这里插入图片描述"><br>PBUF_REF与PBUF_ROM 示意图<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213134249515.png" alt="在这里插入图片描述"></p>
<h2 id="二，创建一个pbuf"><a href="#二，创建一个pbuf" class="headerlink" title="二，创建一个pbuf"></a>二，创建一个pbuf</h2><p>通过pbuf_alloc()创建一个pbuf，要创建一个pbuf，需要知道三个参数：</p>
<p>1，这个pbuf所在的网络层，以此来确定offset的值，上层的offset不仅要为自己的首部留出空间，而且还需要为下层的首部留出空间，所以层级越高，offset越大。</p>
<p>2，存放数据的大小<br>3，pbuf的类型</p>
<p>代码如下，参考注释和第二节的各种类型的示意图，理解代码逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个pbuf</span></span><br><span class="line"><span class="comment">//layer：网络层</span></span><br><span class="line"><span class="comment">//length：数据长度</span></span><br><span class="line"><span class="comment">//type：buffer类型</span></span><br><span class="line">pbuf_alloc(pbuf_layer layer, <span class="type">u16_t</span> length, pbuf_type type)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> offset; <span class="comment">//payload在buffer的偏移</span></span><br><span class="line">  <span class="type">s32_t</span> rem_len; <span class="comment">/* remaining length */</span></span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_alloc(length=%&quot;</span>U16_F<span class="string">&quot;)\n&quot;</span>, length));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* determine header offset */</span></span><br><span class="line">  <span class="comment">//根据层级不同，计算不同的偏移空间，越高的层偏移越大</span></span><br><span class="line">  <span class="keyword">switch</span> (layer) &#123;</span><br><span class="line">  <span class="keyword">case</span> PBUF_TRANSPORT:</span><br><span class="line">    <span class="comment">/* add room for transport (often TCP) layer header */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;	</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_IP:</span><br><span class="line">    <span class="comment">/* add room for IP layer header */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_LINK:</span><br><span class="line">    <span class="comment">/* add room for link layer header */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_RAW_TX:</span><br><span class="line">    <span class="comment">/* add room for encapsulating link layer headers (e.g. 802.11) */</span></span><br><span class="line">    offset = PBUF_LINK_ENCAPSULATION_HLEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_RAW:</span><br><span class="line">    <span class="comment">/* no offset (e.g. RX buffers or chain successors) */</span></span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: bad pbuf layer&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用不同类型的内存，内存分配代码不同</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> PBUF_POOL: <span class="comment">//通过内存池分配，可能需要若干个pool</span></span><br><span class="line">    <span class="comment">/* allocate head of pbuf chain into p */</span></span><br><span class="line">    p = (<span class="keyword">struct</span> pbuf *)memp_malloc(MEMP_PBUF_POOL); <span class="comment">//先分配第一个pool</span></span><br><span class="line">    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_alloc: allocated pbuf %p\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      PBUF_POOL_IS_EMPTY();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置相关成员的值</span></span><br><span class="line">    p-&gt;type = type;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make the payload pointer point &#x27;offset&#x27; bytes into pbuf data memory */</span></span><br><span class="line">    <span class="comment">//移动payload在offset之后</span></span><br><span class="line">    p-&gt;payload = LWIP_MEM_ALIGN((<span class="type">void</span> *)((<span class="type">u8_t</span> *)p + (SIZEOF_STRUCT_PBUF + offset)));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: pbuf p-&gt;payload properly aligned&quot;</span>,</span><br><span class="line">            ((<span class="type">mem_ptr_t</span>)p-&gt;payload % MEM_ALIGNMENT) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* the total length of the pbuf chain is the requested size */</span></span><br><span class="line">    p-&gt;tot_len = length;</span><br><span class="line">    <span class="comment">/* set the length of the first pbuf in the chain */</span></span><br><span class="line">    <span class="comment">//计算第一个pbuf的payload长度：若length小于一个pool，则就是length，否则就是（pool长度-偏移）</span></span><br><span class="line">    p-&gt;len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;check p-&gt;payload + p-&gt;len does not overflow pbuf&quot;</span>,</span><br><span class="line">                ((<span class="type">u8_t</span>*)p-&gt;payload + p-&gt;len &lt;=</span><br><span class="line">                 (<span class="type">u8_t</span>*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT&quot;</span>,</span><br><span class="line">      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) &gt; <span class="number">0</span> );</span><br><span class="line">    <span class="comment">/* set reference count (needed here in case we fail) */</span></span><br><span class="line">    p-&gt;ref = <span class="number">1</span>;	<span class="comment">//引用次数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now allocate the tail of the pbuf chain */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remember first pbuf for linkage in next iteration */</span></span><br><span class="line">    r = p;	<span class="comment">//保存第一个pbuf指针</span></span><br><span class="line">    <span class="comment">/* remaining length to be allocated */</span></span><br><span class="line">    rem_len = length - p-&gt;len;  <span class="comment">//还需要分配的长度</span></span><br><span class="line">    <span class="comment">/* any remaining pbufs to be allocated? */</span></span><br><span class="line">    <span class="comment">//还要再分配pool，直到满足所需内存，除第一个pbuf外，其他pbuf不需要offset预留空间给首部\</span></span><br><span class="line"><span class="comment">      以下pbuf以链表组织在第一个pbuf后</span></span><br><span class="line">    <span class="keyword">while</span> (rem_len &gt; <span class="number">0</span>) &#123; </span><br><span class="line">      q = (<span class="keyword">struct</span> pbuf *)memp_malloc(MEMP_PBUF_POOL);</span><br><span class="line">      <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PBUF_POOL_IS_EMPTY();</span><br><span class="line">        <span class="comment">/* free chain so far allocated */</span></span><br><span class="line">        pbuf_free(p);</span><br><span class="line">        <span class="comment">/* bail out unsuccessfully */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置pbuf的字段</span></span><br><span class="line">      q-&gt;type = type;</span><br><span class="line">      q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">      q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">/* make previous pbuf point to this pbuf */</span></span><br><span class="line">      r-&gt;next = q;	<span class="comment">//将pbuf与前面的pbuf连接 </span></span><br><span class="line">      <span class="comment">/* set total length of this pbuf and next in chain */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;rem_len &lt; max_u16_t&quot;</span>, rem_len &lt; <span class="number">0xffff</span>);</span><br><span class="line">      q-&gt;tot_len = (<span class="type">u16_t</span>)rem_len;</span><br><span class="line">      <span class="comment">/* this pbuf length is pool size, unless smaller sized tail */</span></span><br><span class="line">      q-&gt;len = LWIP_MIN((<span class="type">u16_t</span>)rem_len, PBUF_POOL_BUFSIZE_ALIGNED); <span class="comment">//!不是第一个pbuf，不需要偏移</span></span><br><span class="line">      q-&gt;payload = (<span class="type">void</span> *)((<span class="type">u8_t</span> *)q + SIZEOF_STRUCT_PBUF);  <span class="comment">//payload只需要移动固定SIZEOF_STRUCT_PBUF个字节</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: pbuf q-&gt;payload properly aligned&quot;</span>,</span><br><span class="line">              ((<span class="type">mem_ptr_t</span>)q-&gt;payload % MEM_ALIGNMENT) == <span class="number">0</span>);</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;check p-&gt;payload + p-&gt;len does not overflow pbuf&quot;</span>,</span><br><span class="line">                  ((<span class="type">u8_t</span>*)p-&gt;payload + p-&gt;len &lt;=</span><br><span class="line">                   (<span class="type">u8_t</span>*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));</span><br><span class="line">      q-&gt;ref = <span class="number">1</span>; <span class="comment">//被next引用</span></span><br><span class="line">      <span class="comment">/* calculate remaining length to be allocated */</span></span><br><span class="line">      rem_len -= q-&gt;len; </span><br><span class="line">      <span class="comment">/* remember this pbuf for linkage in next iteration */</span></span><br><span class="line">      r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* end of chain */</span></span><br><span class="line">    <span class="comment">/*r-&gt;next = NULL;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PBUF_RAM:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//分配的内存=pbuf结构体大小+偏移大小+真实数据大小</span></span><br><span class="line">      <span class="type">mem_size_t</span> alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* bug #50040: Check for integer overflow when calculating alloc_len */</span></span><br><span class="line">      <span class="comment">//检验alloc_len（u16）是否溢出</span></span><br><span class="line">      <span class="keyword">if</span> (alloc_len &lt; LWIP_MEM_ALIGN_SIZE(length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* If pbuf is to be allocated in RAM, allocate memory for it. */</span></span><br><span class="line">      p = (<span class="keyword">struct</span> pbuf*)mem_malloc(alloc_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Set up internal structure of the pbuf. */</span></span><br><span class="line">    <span class="comment">//初始化pbuf成员</span></span><br><span class="line">    p-&gt;payload = LWIP_MEM_ALIGN((<span class="type">void</span> *)((<span class="type">u8_t</span> *)p + SIZEOF_STRUCT_PBUF + offset)); </span><br><span class="line">    p-&gt;len = p-&gt;tot_len = length;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: pbuf-&gt;payload properly aligned&quot;</span>,</span><br><span class="line">           ((<span class="type">mem_ptr_t</span>)p-&gt;payload % MEM_ALIGNMENT) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">/* pbuf references existing (non-volatile static constant) ROM payload? */</span></span><br><span class="line">  <span class="keyword">case</span> PBUF_ROM:</span><br><span class="line">  <span class="comment">/* pbuf references existing (externally allocated) RAM payload? */</span></span><br><span class="line">  <span class="keyword">case</span> PBUF_REF:</span><br><span class="line">    <span class="comment">/* only allocate memory for the pbuf structure */</span></span><br><span class="line">    p = (<span class="keyword">struct</span> pbuf *)memp_malloc(MEMP_PBUF);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,</span><br><span class="line">                  (<span class="string">&quot;pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n&quot;</span>,</span><br><span class="line">                  (type == PBUF_ROM) ? <span class="string">&quot;ROM&quot;</span> : <span class="string">&quot;REF&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* caller must set this field properly, afterwards */</span></span><br><span class="line">    p-&gt;payload = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;len = p-&gt;tot_len = length;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;type = type;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_alloc: erroneous type&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* set reference count */</span></span><br><span class="line">  p-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* set flags */</span></span><br><span class="line">  p-&gt;flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_alloc(length=%&quot;</span>U16_F<span class="string">&quot;) == %p\n&quot;</span>, length, (<span class="type">void</span> *)p));</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三，释放pbuf"><a href="#三，释放pbuf" class="headerlink" title="三，释放pbuf"></a>三，释放pbuf</h2><p>释放pbuf需要注意pbuf被引用的次数。</p>
<p>当pbuf的ref成员为0时，则可以被释放，其后的pbuf会被判断是否需要被释放。若ref&gt;0,则将ref-1并退出；具体的释放方式是通过调用内存释放函数进行释放，代码及注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">u8_t</span></span><br><span class="line"><span class="title function_">pbuf_free</span><span class="params">(<span class="keyword">struct</span> pbuf *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u16_t</span> type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">u8_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line">    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,</span><br><span class="line">      (<span class="string">&quot;pbuf_free(p == NULL) was called.\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_free(%p)\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line"></span><br><span class="line">  PERF_START;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pbuf_free: sane type&quot;</span>,</span><br><span class="line">    p-&gt;type == PBUF_RAM || p-&gt;type == PBUF_ROM ||</span><br><span class="line">    p-&gt;type == PBUF_REF || p-&gt;type == PBUF_POOL);</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>;  <span class="comment">//记录被释放的pbuf数量</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">u16_t</span> ref;</span><br><span class="line">    SYS_ARCH_DECL_PROTECT(old_level); <span class="comment">//申请临界保护变量</span></span><br><span class="line">    SYS_ARCH_PROTECT(old_level);  <span class="comment">//进入临界区</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_free: p-&gt;ref &gt; 0&quot;</span>, p-&gt;ref &gt; <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    ref = --(p-&gt;ref); <span class="comment">//该pbuf引用次数-1</span></span><br><span class="line">    SYS_ARCH_UNPROTECT(old_level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若引用次数为0，根据pbuf不同类型释放</span></span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="number">0</span>) &#123; </span><br><span class="line">      q = p-&gt;next;	<span class="comment">//保存下一个pbuf</span></span><br><span class="line">      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_free: deallocating %p\n&quot;</span>, (<span class="type">void</span> *)p));</span><br><span class="line">      type = p-&gt;type;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SUPPORT_CUSTOM_PBUF</span></span><br><span class="line">      <span class="keyword">if</span> ((p-&gt;flags &amp; PBUF_FLAG_IS_CUSTOM) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom</span> *<span class="title">pc</span> =</span> (<span class="keyword">struct</span> pbuf_custom*)p;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;pc-&gt;custom_free_function != NULL&quot;</span>, pc-&gt;custom_free_function != <span class="literal">NULL</span>);</span><br><span class="line">        pc-&gt;custom_free_function(p);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//pool类型释放MEMP_PBUF_POOL</span></span><br><span class="line">        <span class="keyword">if</span> (type == PBUF_POOL) &#123;</span><br><span class="line">          memp_free(MEMP_PBUF_POOL, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == PBUF_ROM || type == PBUF_REF) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ESP_LWIP</span></span><br><span class="line">          <span class="keyword">if</span> (p-&gt;l2_owner != <span class="literal">NULL</span></span><br><span class="line">              &amp;&amp; p-&gt;l2_buf != <span class="literal">NULL</span></span><br><span class="line">              &amp;&amp; p-&gt;l2_owner-&gt;l2_buffer_free_notify != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;l2_owner-&gt;l2_buffer_free_notify(p-&gt;l2_buf);</span><br><span class="line">          &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          memp_free(MEMP_PBUF, p);</span><br><span class="line">        <span class="comment">/* type == PBUF_RAM */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mem_free(p);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">//检查下一个是否也需要释放</span></span><br><span class="line">      p = q;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//不为0，退出释放</span></span><br><span class="line">      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_free: %p has ref %&quot;</span>U16_F<span class="string">&quot;, ending here.\n&quot;</span>, (<span class="type">void</span> *)p, ref));</span><br><span class="line">		</span><br><span class="line">      p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  PERF_STOP(<span class="string">&quot;pbuf_free&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四，给pbuf链表减肥"><a href="#四，给pbuf链表减肥" class="headerlink" title="四，给pbuf链表减肥"></a>四，给pbuf链表减肥</h2><p>pbuf在使用中，可能原先分配的内存过大，需要调整为小点的内存，使用函数<code>pbuf_realloc(struct pbuf *p, u16_t new_len);</code>可以为pbuf链表重新分配内存：</p>
<p>其重点是对pbuf链表的操作，即找到链表中new_len所在的那个pbuf，然后给他重新分配内存，并释放它后面的pbuf。<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213144729146.jpg" alt="在这里插入图片描述"></p>
<p>代码及注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给pbuf减肥，新的长度为new——len</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pbuf_realloc</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="type">u16_t</span> new_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">u16_t</span> rem_len; <span class="comment">/* remaining length */</span></span><br><span class="line">  <span class="type">s32_t</span> grow; <span class="comment">//需要增加的长度，其实这个值是负数，也就是长度实际上是减少</span></span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pbuf_realloc: p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;pbuf_realloc: sane p-&gt;type&quot;</span>, p-&gt;type == PBUF_POOL ||</span><br><span class="line">              p-&gt;type == PBUF_ROM ||</span><br><span class="line">              p-&gt;type == PBUF_RAM ||</span><br><span class="line">              p-&gt;type == PBUF_REF);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新长度不能大于pbuf链的总长</span></span><br><span class="line">  <span class="keyword">if</span> (new_len &gt;= p-&gt;tot_len) &#123;</span><br><span class="line">    <span class="comment">/* enlarging not yet supported */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  grow = new_len - p-&gt;tot_len;  <span class="comment">//需要减少的长度</span></span><br><span class="line"></span><br><span class="line">  rem_len = new_len;  <span class="comment">//剩余长度=全新的长度</span></span><br><span class="line">  q = p;</span><br><span class="line">  <span class="comment">//从pbuf链开始往下找，找到满足pbuf链表中长度为new_len时的pbuf</span></span><br><span class="line">  <span class="keyword">while</span> (rem_len &gt; q-&gt;len) &#123;</span><br><span class="line">    rem_len -= q-&gt;len;  <span class="comment">//每经过一个pbuf剩余长度就减少p-&gt;len</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;grow &lt; max_u16_t&quot;</span>, grow &lt; <span class="number">0xffff</span>);</span><br><span class="line">    q-&gt;tot_len += (<span class="type">u16_t</span>)grow;  <span class="comment">//该pbuf的tot_len减少</span></span><br><span class="line">    q = q-&gt;next;  <span class="comment">//下一个</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;pbuf_realloc: q != NULL&quot;</span>, q != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//找到最后一个pbuf，PBUF_RAM类型且rem_len小于pbuf原来的大小，则重新分配pbuf的大小</span></span><br><span class="line">  <span class="keyword">if</span> ((q-&gt;type == PBUF_RAM) &amp;&amp; (rem_len != q-&gt;len)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SUPPORT_CUSTOM_PBUF</span></span><br><span class="line">      &amp;&amp; ((q-&gt;flags &amp; PBUF_FLAG_IS_CUSTOM) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">     ) &#123;</span><br><span class="line">    <span class="comment">//新的pbuf=首部大小（payload-q）+rem_len</span></span><br><span class="line">    q = (<span class="keyword">struct</span> pbuf *)mem_trim(q, (<span class="type">u16_t</span>)((<span class="type">u8_t</span> *)q-&gt;payload - (<span class="type">u8_t</span> *)q) + rem_len);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;mem_trim returned q == NULL&quot;</span>, q != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调节最后一个pbuf的长度</span></span><br><span class="line">  q-&gt;len = rem_len;</span><br><span class="line">  q-&gt;tot_len = q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//q后面的pbuf不会被使用了，释放掉</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pbuf_free(q-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五，移动payload"><a href="#五，移动payload" class="headerlink" title="五，移动payload"></a>五，移动payload</h2><p>在第一节我们可以看到，payload指针在数据传递过程中需要频繁的移动，这个过程是由函数pbuf_header();实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//header_size_increment&gt;0,payload前移，数据传递下层</span></span><br><span class="line"><span class="comment">//header_size_increment&lt;0,payload后移，数据传递上层</span></span><br><span class="line">pbuf_header(<span class="keyword">struct</span> pbuf *p, <span class="type">s16_t</span> header_size_increment)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> pbuf_header_impl(p, header_size_increment, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数很简单，header_size_increment决定了payload移动的方向和距离。通过调用pbuf_header_impl();实现；<br>其中，需要判断pbuf结构体与payload指向的地址是否连续，如果连续的情况（如RAM，POOL类型）则需要注意payload指针不能超出边界。代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动pbuf首部地址</span></span><br><span class="line"><span class="comment">//header_size_increment&gt;0 首部在payload外，需要放到payload中</span></span><br><span class="line">pbuf_header_impl(<span class="keyword">struct</span> pbuf *p, <span class="type">s16_t</span> header_size_increment, <span class="type">u8_t</span> force)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u16_t</span> type;</span><br><span class="line">  <span class="type">void</span> *payload;</span><br><span class="line">  <span class="type">u16_t</span> increment_magnitude;  <span class="comment">//位移</span></span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> ((header_size_increment == <span class="number">0</span>) || (p == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算header_size_increment的绝对值</span></span><br><span class="line">  <span class="keyword">if</span> (header_size_increment &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    increment_magnitude = (<span class="type">u16_t</span>)-header_size_increment;</span><br><span class="line">    <span class="comment">/* Check that we aren&#x27;t going to move off the end of the pbuf */</span></span><br><span class="line">    LWIP_ERROR(<span class="string">&quot;increment_magnitude &lt;= p-&gt;len&quot;</span>, (increment_magnitude &lt;= p-&gt;len), <span class="keyword">return</span> <span class="number">1</span>;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    increment_magnitude = (<span class="type">u16_t</span>)header_size_increment;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  type = p-&gt;type;</span><br><span class="line">  <span class="comment">/* remember current payload pointer */</span></span><br><span class="line">  payload = p-&gt;payload; <span class="comment">//暂存原payload</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pbuf types containing payloads? */</span></span><br><span class="line">  <span class="comment">//如果payload与pbuf结构体是在连续内存，则直接移动payload</span></span><br><span class="line">  <span class="keyword">if</span> (type == PBUF_RAM || type == PBUF_POOL) &#123;</span><br><span class="line">    <span class="comment">/* set new payload pointer */</span></span><br><span class="line">    p-&gt;payload = (<span class="type">u8_t</span> *)p-&gt;payload - header_size_increment;</span><br><span class="line">    <span class="comment">/* boundary check fails? */</span></span><br><span class="line">    <span class="comment">//如果payload超过buffer头部内存边界，则复原payload，退出</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">u8_t</span> *)p-&gt;payload &lt; (<span class="type">u8_t</span> *)p + SIZEOF_STRUCT_PBUF) &#123;</span><br><span class="line">      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,</span><br><span class="line">        (<span class="string">&quot;pbuf_header: failed as %p &lt; %p (not enough space for new header size)\n&quot;</span>,</span><br><span class="line">        (<span class="type">void</span> *)p-&gt;payload, (<span class="type">void</span> *)((<span class="type">u8_t</span> *)p + SIZEOF_STRUCT_PBUF)));</span><br><span class="line">      <span class="comment">/* restore old payload pointer */</span></span><br><span class="line">      p-&gt;payload = payload;</span><br><span class="line">      <span class="comment">/* bail out unsuccessfully */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果pbuf与payload内存不连续，则无需检查是否超出边界</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == PBUF_REF || type == PBUF_ROM) &#123;</span><br><span class="line">    <span class="comment">/* hide a header in the payload? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//header_size_increment &lt; 0说明首部在payload中，将payload指针后移</span></span><br><span class="line">    <span class="keyword">if</span> ((header_size_increment &lt; <span class="number">0</span>) &amp;&amp; (increment_magnitude &lt;= p-&gt;len)) &#123;</span><br><span class="line">      <span class="comment">/* increase payload pointer */</span></span><br><span class="line">      p-&gt;payload = (<span class="type">u8_t</span> *)p-&gt;payload - header_size_increment;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((header_size_increment &gt; <span class="number">0</span>) &amp;&amp; force) &#123;</span><br><span class="line">      p-&gt;payload = (<span class="type">u8_t</span> *)p-&gt;payload - header_size_increment;  <span class="comment">//首部在payload外，payload需要前移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* cannot expand payload to front (yet!)</span></span><br><span class="line"><span class="comment">       * bail out unsuccessfully */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Unknown type */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;bad pbuf type&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* modify pbuf length fields */</span></span><br><span class="line">  <span class="comment">//更新pbuf的成员</span></span><br><span class="line">  p-&gt;len += header_size_increment;</span><br><span class="line">  p-&gt;tot_len += header_size_increment;</span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (<span class="string">&quot;pbuf_header: old %p new %p (%&quot;</span>S16_F<span class="string">&quot;)\n&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)payload, (<span class="type">void</span> *)p-&gt;payload, header_size_increment));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六，小结"><a href="#六，小结" class="headerlink" title="六，小结"></a>六，小结</h2><p>学习好pbuf，重点是理解pbuf结构体的payload成员，以及对各个类型的pbuf有一个抽象的认识。最好搭配示意图理解pbuf在数据传递过程中的灵活性。<br>pbuf是lwip协议各层数据传递的基础，掌握得好，后面事半功倍。<br>pbuf其他函数比较少用，读者可以自己去看，加深对pbuf的理解。<br><img src="/2025/05/30/hello-world/lwip/lwip_pbuf/20201213143318498.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/lwip/lwip_pbuf/" data-id="cmbcy7rhx003it8mteymwdl9i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_netif/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_UDP/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="i2c的使用以及驱动适配学习imx-i2c驱动的编写，首先查看i2c1的设备节点： 1234567891011121314151617181920212223242526i2c1: i2c@021a0000 &#123;	#address-cells &#x3D; &lt;1&gt;;	#size-cells &#x3D; &lt;0&gt;;	compatible &#x3D; &quot;fsl,imx6ul-i2c&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/IMX6/i2c/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="i2c的使用以及驱动适配学习imx-i2c驱动的编写，首先查看i2c1的设备节点： 1234567891011121314151617181920212223242526i2c1: i2c@021a0000 &#123;	#address-cells &#x3D; &lt;1&gt;;	#size-cells &#x3D; &lt;0&gt;;	compatible &#x3D; &quot;fsl,imx6ul-i2c&amp;qu">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/20160427085834756.png">
<meta property="og:image" content="http://example.com/20160427085633471.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.640Z">
<meta property="article:modified_time" content="2025-06-01T00:26:26.999Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/20160427085834756.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/IMX6/i2c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/IMX6/i2c/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.640Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="i2c的使用以及驱动适配"><a href="#i2c的使用以及驱动适配" class="headerlink" title="i2c的使用以及驱动适配"></a>i2c的使用以及驱动适配</h2><p>学习imx-i2c驱动的编写，首先查看i2c1的设备节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">		fsl,pins = &lt;</span><br><span class="line">			MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">			MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="number">0x4001b8b0</span> </span><br><span class="line">		&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在driver目录下搜索 “fsl,imx6ul-i2c” 和 “fsl,imx21-i2c”，可以找到对应的驱动程序在i2c-imx.c文件中。</p>
<p>i2c的驱动本质上也是一个platform驱动，那么我们就关注 i2c_imx_probe 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">i2c_imx_driver</span> =</span> &#123;</span><br><span class="line">	.probe = i2c_imx_probe,</span><br><span class="line">	.remove = i2c_imx_remove,</span><br><span class="line">	.driver	= &#123;</span><br><span class="line">		.name = DRIVER_NAME,</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.of_match_table = i2c_imx_dt_ids,</span><br><span class="line">		.pm = IMX_I2C_PM,</span><br><span class="line">	&#125;,</span><br><span class="line">	.id_table	= imx_i2c_devtype,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-imx-probe"><a href="#i2c-imx-probe" class="headerlink" title="i2c_imx_probe"></a>i2c_imx_probe</h3><p>负责从设备树中获取资源，做初始化。然后初始化i2c_adapter，以及i2c控制器的时钟、中断函数。为i2c的使用做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在of_match_device数组中找到当前i2c节点对应的元素</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span> of_match_device(i2c_imx_dt_ids,</span><br><span class="line">							   &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    imxi2c_platform_data 就是时钟分频值</span></span><br><span class="line"><span class="comment">    struct imxi2c_platform_data &#123;</span></span><br><span class="line"><span class="comment">	    u32 bitrate; </span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="type">void</span> __iomem *base;</span><br><span class="line">	<span class="type">int</span> irq, ret;</span><br><span class="line">	<span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line">	<span class="comment">//获取节点中interrupts指示的中断号</span></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t get irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取节点中reg指示的内存地址</span></span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//内存地址映射</span></span><br><span class="line">	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line">	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">//获取imx_i2c_hwdata，用于配置i2c寄存器</span></span><br><span class="line">	<span class="keyword">if</span> (of_id)</span><br><span class="line">		i2c_imx-&gt;hwdata = of_id-&gt;data;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)</span><br><span class="line">				platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化i2c_adapter</span></span><br><span class="line">	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line">	i2c_imx-&gt;adapter.owner		= THIS_MODULE;</span><br><span class="line">	i2c_imx-&gt;adapter.algo		= &amp;i2c_imx_algo;  <span class="comment">//重要，I2C底层驱动</span></span><br><span class="line">	i2c_imx-&gt;adapter.dev.parent	= &amp;pdev-&gt;dev;</span><br><span class="line">	i2c_imx-&gt;adapter.nr		= pdev-&gt;id;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.of_node	= pdev-&gt;dev.of_node;</span><br><span class="line">	i2c_imx-&gt;base			= base;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取节点clocks属性值</span></span><br><span class="line">	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_imx-&gt;clk)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t get I2C clock\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(i2c_imx-&gt;clk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//是能时钟</span></span><br><span class="line">	ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t enable I2C clock\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置中断服务函数</span></span><br><span class="line">	ret = devm_request_irq(&amp;pdev-&gt;dev, irq, i2c_imx_isr,</span><br><span class="line">			       IRQF_NO_SUSPEND, pdev-&gt;name, i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t claim irq %d\n&quot;</span>, irq);</span><br><span class="line">		<span class="keyword">goto</span> clk_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化等待队列</span></span><br><span class="line">	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将i2c_imx和i2c_adapter绑定</span></span><br><span class="line">	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置总线速度i2c_imx-&gt;bitrate = 100khz</span></span><br><span class="line">	i2c_imx-&gt;bitrate = IMX_I2C_BIT_RATE;</span><br><span class="line">	ret = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">				   <span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把寄存器清零</span></span><br><span class="line">    <span class="comment">//imx_i2c_write_reg(0,i2c_imx,IMX_I2C_I2CR)</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">			i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//imx_i2c_write_reg(0,i2c_imx,IMX_I2C_I2SR)</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加adapter到i2c框架</span></span><br><span class="line">	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;registration failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> clk_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定pdev和i2c_imx</span></span><br><span class="line">	platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line">    <span class="comment">//关闭时钟</span></span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;claimed irq %d\n&quot;</span>, irq);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;device resources: %pR\n&quot;</span>, res);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;adapter name: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		i2c_imx-&gt;adapter.name);</span><br><span class="line">	dev_info(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;IMX I2C adapter registered\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始dma（no used）</span></span><br><span class="line">	i2c_imx_dma_request(i2c_imx, phy_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* Return OK */</span></span><br><span class="line"></span><br><span class="line">clk_disable:</span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们先关注底层驱动的实现，当i2c_adapter被用于传输数据时，i2c_imx-&gt;adapter.algo 是真正的执行者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">	.master_xfer	= i2c_imx_xfer,  <span class="comment">//完成一组i2c消息的传输</span></span><br><span class="line">	.functionality	= i2c_imx_func,	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的master_xfer 函数负责实现一组i2c消息的传输。</p>
<h3 id="i2c传输时序"><a href="#i2c传输时序" class="headerlink" title="i2c传输时序"></a>i2c传输时序</h3><p>为此，我们先暂时来了解i2c是如何传输数据的，分为写和读两种情况：</p>
<h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><p>写数据就是主机向从机某个地址写入数据，整个过程数据都是一个方向的。如图所示：</p>
<p><img src="/20160427085834756.png" alt="20160427085834756"></p>
<p>主机先发送一个start信号，然后传输设备地址（设备地址是一个7bit的数值，第8位为1表示接下来要读，为0表示接下来要写），由于是写数据，所以第8位是0.然后传输要写入的地址，最后是若干个字节的数据，以及结束信号。</p>
<p>以上的整一个过程，由开始信号到结束信号，在linux中抽象成一个i2c_msg。</p>
<h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>读数据就是主机向从机某个地址读出数据，由于每一次传输只能是单方向的，所以需要主机先写入要读的地址，结束此次传输。再由主机开始一个新的传输，这个数据传输的方向是从机到主机。</p>
<p><img src="/20160427085633471.png" alt="20160427085633471"></p>
<p>所以，具体的过程有两次传输：第一次主机进行写数据，发送完地址后就结束此次传输。第二次传输，由于方向是从机到主机，所以第8位为1，后续是数据，以及结束信号。</p>
<p>以上两次传输，在linux中就对应两个i2c_msg。</p>
<h3 id="i2c-imx-xfer"><a href="#i2c-imx-xfer" class="headerlink" title="i2c_imx_xfer"></a>i2c_imx_xfer</h3><p>i2c_imx_xfer()的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>很简单，就是一个adapter，还有要传输的i2c_msg，i2c_imx_xfer()负责把这些msg全部执行完成。每一个msg就是一个传输过程，就是start到stop信号的这个过程，每一个过程都是单方向的传输。</p>
<p>所以有两个类型的msg，分别是写和读，对应上文提到的i2c时序。一般来说，写是比较简单的，只需要一个msg，在msg中指定从机地址以及数据缓存，数据长度，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_write_regs</span><span class="params">(<span class="keyword">struct</span> mpu6050_dev *dev, <span class="type">unsigned</span> <span class="type">char</span> reg,<span class="type">unsigned</span> <span class="type">char</span> *data,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *) dev-&gt;pri;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;  <span class="comment">//地址</span></span><br><span class="line">    msg.flags = <span class="number">0</span>;</span><br><span class="line">    tmp[<span class="number">0</span>] = reg;  <span class="comment">//要写入的寄存器</span></span><br><span class="line">    <span class="keyword">if</span>(len+<span class="number">1</span> &gt; <span class="number">256</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;tmp[<span class="number">1</span>],data,len);  <span class="comment">//写入的数据</span></span><br><span class="line">    msg.buf = tmp;  </span><br><span class="line">    msg.len = len+<span class="number">1</span>;  <span class="comment">//设置数据长度</span></span><br><span class="line">	<span class="comment">//i2c_imx_xfer()</span></span><br><span class="line">    <span class="keyword">if</span>(i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c write failed\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而读是由两个阶段完成的，首先需要一个写寄存器地址的传输，然后才是读传输，所以需要两个msg：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_read_regs</span><span class="params">(<span class="keyword">struct</span> mpu6050_dev *dev, <span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *) dev-&gt;pri;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//first transfer:send the reg addr</span></span><br><span class="line">    msg[<span class="number">0</span>].addr = client-&gt;addr;</span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;  <span class="comment">//write</span></span><br><span class="line">    msg[<span class="number">0</span>].buf = &amp;reg;</span><br><span class="line">    msg[<span class="number">0</span>].len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//second transfer:recv the reg val</span></span><br><span class="line">    msg[<span class="number">1</span>].addr = client-&gt;addr;</span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;  <span class="comment">//read</span></span><br><span class="line">    msg[<span class="number">1</span>].buf = val;</span><br><span class="line">    msg[<span class="number">1</span>].len = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//start transfer</span></span><br><span class="line">    <span class="keyword">if</span>(i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c rd failed reg=%06x len=%d\n&quot;</span>, reg, len);</span><br><span class="line">        <span class="keyword">return</span> -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_transfer()最后是调用到对应的adapter-&gt;algo-&gt;master_xfer()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_lastmsg = <span class="literal">false</span>;  <span class="comment">//最后的消息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始iic传输</span></span><br><span class="line">	result = i2c_imx_start(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> fail0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行若干消息</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == num - <span class="number">1</span>)</span><br><span class="line">			is_lastmsg = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">             <span class="comment">//不是第一个消息</span></span><br><span class="line">			<span class="comment">//产生一个repeat start信号</span></span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_RSTA;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">             <span class="comment">//若软总线busy，马上返回，说明start信号已经开始；否则，调度程序</span></span><br><span class="line">			result =  i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">goto</span> fail0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//分别处理两种消息</span></span><br><span class="line">		<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">			result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)</span><br><span class="line">				result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				result = i2c_imx_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> fail0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">fail0:</span><br><span class="line">	<span class="comment">//停止i2c传输</span></span><br><span class="line">	i2c_imx_stop(i2c_imx);</span><br><span class="line">	<span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="i2c-imx-start"><a href="#i2c-imx-start" class="headerlink" title="i2c_imx_start"></a>i2c_imx_start</h4><p>设置i2c控制器主机模式，使能中断、发送模式、应答，可以开始i2c传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置好i2c控制器</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_start</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="comment">//获取时钟分频系数</span></span><br><span class="line">	i2c_imx_set_clk(i2c_imx);</span><br><span class="line">	<span class="comment">//使能时钟</span></span><br><span class="line">	result = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	<span class="comment">//设置时钟分频系数</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;ifdr, i2c_imx, IMX_I2C_IFDR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能iic</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待控制器稳定</span></span><br><span class="line">	udelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始i2c传输</span></span><br><span class="line">	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	temp |= I2CR_MSTA;  <span class="comment">//i2c主机模式 产生一个start信号</span></span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//若软总线busy，说明start信号已经产生，马上返回；否则，调度程序</span></span><br><span class="line">	result = i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//正常时result==0</span></span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	i2c_imx-&gt;stopped = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//使能中断、发送模式、使能发送应答、关闭dma</span></span><br><span class="line">	temp |= I2CR_IIEN | I2CR_MTX | I2CR_TXAK;</span><br><span class="line">	temp &amp;= ~I2CR_DMAEN;</span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="i2c-imx-stop"><a href="#i2c-imx-stop" class="headerlink" title="i2c_imx_stop"></a>i2c_imx_stop</h4><p>这个函数用于实现主机的停止传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i2c_imx_stop</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx-&gt;stopped) &#123;</span><br><span class="line">		<span class="comment">//产生stop信号并恢复到默认的slave receive模式</span></span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		temp &amp;= ~(I2CR_MSTA | I2CR_MTX);</span><br><span class="line">		<span class="keyword">if</span> (i2c_imx-&gt;dma)</span><br><span class="line">			temp &amp;= ~I2CR_DMAEN;</span><br><span class="line">		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (is_imx1_i2c(i2c_imx)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This delay caused by an i.MXL hardware bug.</span></span><br><span class="line"><span class="comment">		 * If no (or too short) delay, no &quot;STOP&quot; bit will be generated.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		udelay(i2c_imx-&gt;disable_delay);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//等待传输完成</span></span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx-&gt;stopped) &#123;</span><br><span class="line">        <span class="comment">//若总线空闲，说明stop信号传输完成，退出</span></span><br><span class="line">		i2c_imx_bus_busy(i2c_imx, <span class="number">0</span>);</span><br><span class="line">		i2c_imx-&gt;stopped = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭iic控制器</span></span><br><span class="line">	temp = i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//关闭时钟</span></span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-imx-bus-busy"><a href="#i2c-imx-bus-busy" class="headerlink" title="i2c_imx_bus_busy"></a>i2c_imx_bus_busy</h4><p>调用该函数会出现以下情况：具体的情况在i2c_imx_bus_busy()调用处分析</p>
<ul>
<li><p>总线busy，for_busy&#x3D;1，退出</p>
</li>
<li><p>总线空闲，for_busy&#x3D;1，等待</p>
</li>
<li><p>总线busy，for_busy&#x3D;0，等待 </p>
</li>
<li><p>总线空闲，for_busy&#x3D;0,退出</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_bus_busy</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx, <span class="type">int</span> for_busy)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> orig_jiffies = jiffies;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">		<span class="comment">//检查是否产生仲裁丢失</span></span><br><span class="line">		<span class="keyword">if</span> (temp &amp; I2SR_IAL) &#123;</span><br><span class="line">			temp &amp;= ~I2SR_IAL;</span><br><span class="line">			<span class="comment">//仲裁丢失需要向该位写0</span></span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//总线正在传输数据 且 for_busy =1 退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (for_busy &amp;&amp; (temp &amp; I2SR_IBB))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//总线未在传输数据，且 for_busy = 0 退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (!for_busy &amp;&amp; !(temp &amp; I2SR_IBB))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//500ms等待是否到达</span></span><br><span class="line">		<span class="keyword">if</span> (time_after(jiffies, orig_jiffies + msecs_to_jiffies(<span class="number">500</span>))) &#123;</span><br><span class="line">			dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">				<span class="string">&quot;&lt;%s&gt; I2C bus is busy\n&quot;</span>, __func__);</span><br><span class="line">			<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调度程序</span></span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-imx-write"><a href="#i2c-imx-write" class="headerlink" title="i2c_imx_write"></a>i2c_imx_write</h4><p>实现了一个写传输，时序如下：</p>
<blockquote>
<p>start-&gt;addr-&gt;data-&gt;ack-&gt;data-&gt;ack</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_write</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx, <span class="keyword">struct</span> i2c_msg *msgs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送slave addr</span></span><br><span class="line">	imx_i2c_write_reg(msgs-&gt;addr &lt;&lt; <span class="number">1</span>, i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">	result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	result = i2c_imx_acked(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写数据</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; msgs-&gt;len; i++) &#123;</span><br><span class="line">		imx_i2c_write_reg(msgs-&gt;buf[i], i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">		result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		result = i2c_imx_acked(i2c_imx);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="i2c-imx-read"><a href="#i2c-imx-read" class="headerlink" title="i2c_imx_read"></a>i2c_imx_read</h4><p>实现了一个读传输，时序是：</p>
<blockquote>
<p>start-&gt;addr-&gt;ack-&gt;data-&gt;ack-&gt;data-&gt;ack-&gt;data-&gt;ack-&gt;data-&gt;stop</p>
</blockquote>
<p>一般情况下，在一个读传输之前，会有一个写传输，表示要读取的寄存器的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_read</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">bool</span> is_lastmsg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, result;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">    <span class="comment">//这里考虑block_Data=0</span></span><br><span class="line">	<span class="type">int</span> block_data = msgs-&gt;flags &amp; I2C_M_RECV_LEN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将slave地址写入数据寄存器</span></span><br><span class="line">	imx_i2c_write_reg((msgs-&gt;addr &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>, i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">    <span class="comment">//等待地址传输完成</span></span><br><span class="line">	result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	<span class="comment">//检查从机acked</span></span><br><span class="line">	result = i2c_imx_acked(i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立总线读取数据</span></span><br><span class="line">	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	temp &amp;= ~I2CR_MTX;  <span class="comment">//设置为接收模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置自动ack</span></span><br><span class="line">	<span class="keyword">if</span> ((msgs-&gt;len - <span class="number">1</span>) || block_data)</span><br><span class="line">		temp &amp;= ~I2CR_TXAK;</span><br><span class="line">	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">    <span class="comment">//从发送切换到接收，需要一个dummy read</span></span><br><span class="line">	imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用dma</span></span><br><span class="line">	<span class="keyword">if</span> (i2c_imx-&gt;dma &amp;&amp; msgs-&gt;len &gt;= DMA_THRESHOLD &amp;&amp; !block_data)</span><br><span class="line">		<span class="keyword">return</span> i2c_imx_dma_read(i2c_imx, msgs, is_lastmsg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取数据</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; msgs-&gt;len; i++) &#123;</span><br><span class="line">		u8 len = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">		result = i2c_imx_trx_complete(i2c_imx);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		<span class="comment">//smbus 协议的第一个字节表示数据长度</span></span><br><span class="line">		<span class="keyword">if</span> ((!i) &amp;&amp; block_data) &#123;</span><br><span class="line">            <span class="comment">//第一个字节表示有效数据长度</span></span><br><span class="line">			len = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">			<span class="keyword">if</span> ((len == <span class="number">0</span>) || (len &gt; I2C_SMBUS_BLOCK_MAX))</span><br><span class="line">				<span class="keyword">return</span> -EPROTO;</span><br><span class="line">            <span class="comment">//增加消息长度</span></span><br><span class="line">			msgs-&gt;len += len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == (msgs-&gt;len - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (is_lastmsg) &#123;</span><br><span class="line">                <span class="comment">//最后一个传输，需要提前关闭i2c</span></span><br><span class="line">                <span class="comment">//关闭 主机模式、发送模式</span></span><br><span class="line">				temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">				temp &amp;= ~(I2CR_MSTA | I2CR_MTX);</span><br><span class="line">				imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">                <span class="comment">//若总线busy等待，总线空闲退出</span></span><br><span class="line">				i2c_imx_bus_busy(i2c_imx, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//标志已经由从机停止传输</span></span><br><span class="line">				i2c_imx-&gt;stopped = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//本次传输结束，但接下来还有新的传输，需要提前切换回发送模式（因为存在延时）</span></span><br><span class="line">				temp = readb(i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">				temp |= I2CR_MTX;  </span><br><span class="line">				writeb(temp, i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == (msgs-&gt;len - <span class="number">2</span>)) &#123;</span><br><span class="line">			<span class="comment">//当接收到最后一个字节数据后不能ac，所以在倒数第二个字节的数据时，需要关闭ack</span></span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_TXAK;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((!i) &amp;&amp; block_data)</span><br><span class="line">			msgs-&gt;buf[<span class="number">0</span>] = len;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            <span class="comment">//读取数据到buf</span></span><br><span class="line">			msgs-&gt;buf[i] =  imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="iic中断"><a href="#iic中断" class="headerlink" title="iic中断"></a>iic中断</h3><p>中断的触发源有：</p>
<ul>
<li>一个字节传输完成，1个起始信号+8个数据信号&#x3D;9个时钟</li>
<li>作为从机时，接收到自己的地址</li>
<li>仲裁丢失</li>
</ul>
<p>这里中断的作用就是判断一个字节的传输是否完成，为i2c_imx_trx_complete()函数提供判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iic中断函数 </span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">i2c_imx_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> dev_id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">//判断中断位是否有效</span></span><br><span class="line">	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">	<span class="keyword">if</span> (temp &amp; I2SR_IIF) &#123;</span><br><span class="line">		<span class="comment">//保存状态寄存器</span></span><br><span class="line">		i2c_imx-&gt;i2csr = temp;</span><br><span class="line">		temp &amp;= ~I2SR_IIF;</span><br><span class="line">        <span class="comment">//清除中断标志</span></span><br><span class="line">		temp |= (i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode &amp; I2SR_IIF);</span><br><span class="line">		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">        <span class="comment">//唤醒队列，即执行i2c_imx_trx_complete</span></span><br><span class="line">		wake_up(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待传输完成</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_trx_complete</span><span class="params">(<span class="keyword">struct</span> imx_i2c_struct *i2c_imx)</span></span><br><span class="line">&#123;</span><br><span class="line">	wait_event_timeout(i2c_imx-&gt;<span class="built_in">queue</span>, i2c_imx-&gt;i2csr &amp; I2SR_IIF, HZ / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//unlikely(x)表示x中的条件成立的机率较低，用于优化编译器</span></span><br><span class="line">	<span class="comment">//判断是否产生了中断</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(i2c_imx-&gt;i2csr &amp; I2SR_IIF))) &#123;</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; Timeout\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">	&#125;</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; TRX complete\n&quot;</span>, __func__);</span><br><span class="line">	i2c_imx-&gt;i2csr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="platform-框架"><a href="#platform-框架" class="headerlink" title="platform 框架"></a>platform 框架</h2><h3 id="platform-device"><a href="#platform-device" class="headerlink" title="platform_device"></a>platform_device</h3><p>platform_device是从设备树中来的，具体如何来，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010961173/article/details/94297632">设备树和Platform架构–5–platform_device创建_huofengfeihu的博客-CSDN博客_platform_device</a></p>
<p>总结下来就是：</p>
<ul>
<li>内核函数of_platform_default_populate_init, 遍历device_node树, 生成platform_device</li>
<li>并非所有的device_node都会转换为platform_device，该节点必须含有compatible属性</li>
</ul>
<p>关于platform框架的接口定义在include&#x2F;linux&#x2F;platform_device.h。驱动开发者主要使用以下函数来获取设备的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;  <span class="comment">//设备名称</span></span><br><span class="line">	<span class="type">int</span>		id;  <span class="comment">//设备id</span></span><br><span class="line">	<span class="type">bool</span>		id_auto;  <span class="comment">//自动分配id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span>  <span class="comment">//继承基类device</span></span><br><span class="line">	u32		num_resources;  <span class="comment">//设备的资源数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span>  <span class="comment">//设备的资源</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span>  <span class="comment">//用于匹配对应驱动</span></span><br><span class="line">	<span class="type">char</span> *driver_override; <span class="comment">//用于匹配驱动的名称</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MFD cell pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arch specific additions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> platform_get_device_id(pdev)	((pdev)-&gt;id_entry)</span></span><br><span class="line"><span class="comment">//将结构体成员转换成platform_device</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_platform_device(x) container_of((x), struct platform_device, dev)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设备的资源</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *,</span></span><br><span class="line"><span class="params">					      <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//获取设备中断号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//通过属性名称获取资源</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *,</span></span><br><span class="line"><span class="params">						     <span class="type">unsigned</span> <span class="type">int</span>,</span></span><br><span class="line"><span class="params">						     <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="comment">//通过名称获取中断号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_get_irq_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="platform-driver"><a href="#platform-driver" class="headerlink" title="platform_driver"></a>platform_driver</h3><p>platform_driver需要开发者去实现其中的函数指针，注意id_table要与设备树中的compatible属性一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);  <span class="comment">//设备驱动匹配时执行</span></span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">	<span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span>  <span class="comment">//继承基类device_driver</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span>  <span class="comment">//用于和platform_device匹配</span></span><br><span class="line">	<span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_platform_driver(drv)	(container_of((drv), struct platform_driver, \</span></span><br><span class="line"><span class="meta">				 driver))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册platform_driver</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line"><span class="meta">	__platform_driver_register(drv, THIS_MODULE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非热插拔设备，也就是冷设备，在开机时就启动，所以没有匹配过程，需要用platform_driver_probe把驱动peobe()编译到 __init段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_probe(drv, probe) \</span></span><br><span class="line"><span class="meta">	__platform_driver_probe(drv, probe, THIS_MODULE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取pdev-&gt;dev.driver_data</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">platform_get_drvdata</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> dev_get_drvdata(&amp;pdev-&gt;dev);  <span class="comment">//return pdev-&gt;dev.driver_data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置pdev-&gt;dev.driver_data</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">platform_set_drvdata</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	dev_set_drvdata(&amp;pdev-&gt;dev, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/IMX6/i2c/" data-id="cmbcy7rhb001st8mt5ae897nc" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/Git/sub_repository/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/IMX6/pinctrl/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
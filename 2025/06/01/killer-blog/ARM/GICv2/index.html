<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="GIC-V2参考文章：linux kernel的中断子系统之（七）：GIC代码分析 (wowotech.net) arm_gic_architecture_specification.pdf GIC关于支持安全扩展、虚拟化的部分就不分析，先了解最基本的中断功能。 gic初始gic_v2_acpi_init() 一、介绍GIC与外设，CPU的关系可如简化：  GIC是ARM的中断控制器，用于接收so">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/ARM/GICv2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="GIC-V2参考文章：linux kernel的中断子系统之（七）：GIC代码分析 (wowotech.net) arm_gic_architecture_specification.pdf GIC关于支持安全扩展、虚拟化的部分就不分析，先了解最基本的中断功能。 gic初始gic_v2_acpi_init() 一、介绍GIC与外设，CPU的关系可如简化：  GIC是ARM的中断控制器，用于接收so">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/ARM/GICv2/GICv2-1.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/ARM/GICv2/GICv2-2.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/ARM/GICv2/GICV2-3.png">
<meta property="og:image" content="http://example.com/2025/05/30/hello-world/ARM/GICv2/GICV2-4.png">
<meta property="article:published_time" content="2025-06-01T00:24:26.632Z">
<meta property="article:modified_time" content="2025-06-01T00:26:27.119Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/05/30/hello-world/ARM/GICv2/GICv2-1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/ARM/GICv2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/ARM/GICv2/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.632Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="GIC-V2"><a href="#GIC-V2" class="headerlink" title="GIC-V2"></a>GIC-V2</h2><p>参考文章：<a target="_blank" rel="noopener" href="http://www.wowotech.net/linux_kenrel/gic_driver.html">linux kernel的中断子系统之（七）：GIC代码分析 (wowotech.net)</a></p>
<p>arm_gic_architecture_specification.pdf</p>
<p>GIC关于支持安全扩展、虚拟化的部分就不分析，先了解最基本的中断功能。</p>
<h3 id="gic初始"><a href="#gic初始" class="headerlink" title="gic初始"></a>gic初始</h3><p>gic_v2_acpi_init()</p>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>GIC与外设，CPU的关系可如简化：</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICv2-1.png" alt="未命名文件 (5)"></p>
<p>GIC是ARM的中断控制器，用于接收soc上外设的中断信号，并通知cpu进行处理。GIC可分为两个部分：distributor和cpu interface。</p>
<p>distributor负责配置中断优先级并将中断信号发送 到cpu interface，cpu interface与cpu进行物理连接，负责优先级屏蔽和抢占处理。GIC中有一个distributor和最多8个cpu interface，他们的寄存器都映射到内存中读写，寄存器的地址由GICD_prefix和GICCprefix定义。如下是GIC的框架图</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICv2-2.png" alt="image-20220625094512755"></p>
<h4 id="1-1、distributor"><a href="#1-1、distributor" class="headerlink" title="1.1、distributor"></a>1.1、distributor</h4><p>distributor收集所有外设的中断信号，决定他们的优先级，并将最高优先级的中断传输给cpu。distributor提供的编程接口有：</p>
<ul>
<li>使能全局中断</li>
<li>使能具体外设中断</li>
<li>设置中断优先级</li>
<li>设置中断的目标cpu</li>
<li>设置中断为边沿触发or电平触发</li>
<li>设置中断分组（安全扩展）</li>
</ul>
<p>另外，distributor还提供了一个中断状态机，用于设置or清除外设中断。如图：</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICV2-3.png" alt="image-20220620132505469"></p>
<ul>
<li>Inactive：没有中断产生</li>
<li>Pending：中断产生（边沿触发）</li>
<li>Active：中断产生并且正在处理</li>
<li>Active and Pending：（电平触发）</li>
</ul>
<h4 id="1-2、中断id"><a href="#1-2、中断id" class="headerlink" title="1.2、中断id"></a>1.2、中断id</h4><p>GIC支持最多1020个中断id，每一个中断id代表一个中断信号线。其中0-31是私有id，对应指定的cpu，32-1019是共享id，所有cpu都可见。这些id就是硬件中断号。</p>
<h4 id="1-3-cpu-interface"><a href="#1-3-cpu-interface" class="headerlink" title="1.3 cpu interface"></a>1.3 cpu interface</h4><p>cpu interface 一共有8个，每一个对接一个cpu，提供的编程接口有：</p>
<ul>
<li>使能具体外设中断信号传输到cpu</li>
<li>应答中断</li>
<li>指示中断处理完成</li>
<li>设置中断优先级屏蔽</li>
<li>设置优先级抢占规则</li>
<li>将最高优先级的pengding中断提供给cpu</li>
</ul>
<p>应答中断：就是gic产生的中断信号使cpu成功进入irq mode，cpu读取gic 的寄存器，获取最高优先级的pending中断id，此时distributor的状态机就会从pending变成active，表示中断正在处理。此时，假如产生另一个中断，cpu interface就可以再次产生新的中断来抢占当前active的中断。</p>
<p>指示中断处理完成：当cpu的中断处理函数运行完成后，需要两个步骤结束整个中断：</p>
<ol>
<li>priority drop：CPU将中断id写入EOI寄存器，这个中断就会从runing优先级恢复到原来的优先级，cpu此时就能响应其他的中断</li>
<li>interruption deactivation：cpu写GICC_DIR寄存器，distributor的状态机变成inactive，中断处理完成</li>
</ol>
<h3 id="二、中断处理流程和优先级"><a href="#二、中断处理流程和优先级" class="headerlink" title="二、中断处理流程和优先级"></a>二、中断处理流程和优先级</h3><h4 id="2-1-中断处理流程"><a href="#2-1-中断处理流程" class="headerlink" title="2.1 中断处理流程"></a>2.1 中断处理流程</h4><p>GIC中断处理的流程和状态机很有关系，流程如下</p>
<ol>
<li>GIC使能每个中断</li>
<li>GIC查出 enabled和pending 的中断对应的cpu</li>
<li>distributor 查找最高优先级的pending 中断，发送到对应cpu interface</li>
<li>cpu interface 判断该中断是否具有sufficient 优先级，若有则触发cpu的中断</li>
<li>cpu进入中断，从中断向量表中跳转到中断处理程序，读取GICC_IAR寄存器，获取中断id，应答中断，跳转到对应外设中断处理函数执行。中断状态机变成active</li>
<li>外设中断函数处理完成，向GIC的EOI寄存器写入中断id，恢复优先级，能响应其他中断。向GICC_DIR寄存器写入，将状态机变成inactive。</li>
</ol>
<blockquote>
<p>note</p>
<p>running 优先级，当前cpu interface的active中断的最高优先级，若没有active中断，则是idle优先级。</p>
</blockquote>
<h4 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2 优先级"></a>2.2 优先级</h4><p>GIC将中断优先级分为两个部分：分组优先级和子优先级。当中断产生时，会先比较分组优先级，分组优先级高的话可以抢占当前的中断，分组优先级相同时，再比较子优先级。</p>
<p>中断的优先级保存在寄存器 GICD_IPRIORITYRn 中，数值越小，优先级越大。优先级是一个8bit的数值，每一个位的意义如下：</p>
<p> GICC_BPR 寄存器将GICD_IPRIORITYRn 中的8bit分成两个部分：</p>
<p><img src="/2025/05/30/hello-world/ARM/GICv2/GICV2-4.png" alt="image-20220625134245519"></p>
<p>只有分组优先级高于 GICC_PMR 寄存器定义时，中断才会被响应。 GICC_PMR 寄存器用于屏蔽优先级。</p>
<h3 id="三、中断寄存器"><a href="#三、中断寄存器" class="headerlink" title="三、中断寄存器"></a>三、中断寄存器</h3><p>参考《arm_gic_architecture_specification.pdf》第四章</p>
<p>gic的地址在复位时会被采样PERIPHEBASE[39:15]，gic支持32bit、16bit、8bit的小端模式访问。</p>
<p>distributor的寄存器：</p>
<ul>
<li>Distributor Control Register：全局开关：distribute向interface发送信号</li>
<li>Interrupt Controller Type Register：安全扩展开关，CPU接口数量，支持的中断数量（32*(N+1)）</li>
<li>Distributor Implementer Identification Register：distribute的版本信息</li>
<li>Interrupt Set-Enable Registers:每一个bit表示中断从distribute到interface的开关，一个寄存器支持32个中断</li>
<li>Interrupt Clear-Enable Registers：与Interrupt Set-Enable Registers相反</li>
<li>Interrupt Set-Pending Registers：设置一个中断状态为pending，边缘触发和电平触发的pending处理是不一样的</li>
<li>Interrupt Clear-Pending Registers：中断pending清除</li>
<li>Interrupt Set-Active Registers：Writing to a Set-active bit Activates the corresponding interrupt</li>
<li>Interrupt Clear-Active Registers：Writing to a Clear-active bit Deactivates the corresponding interrupt.</li>
<li>Interrupt Priority Registers：记录每个中断的8位的优先级，值越小优先级越大</li>
<li>Interrupt Processor Targets Registers：决定将中断信号传递给哪些cpu interface</li>
<li>Interrupt Configuration Registers：配置边沿或电平触发</li>
<li>Software Generated Interrupt Register：软件中断的产生和配置</li>
<li>SGI Clear-Pending Registers：清除软件中断pending</li>
<li>SGI Set-Pending Registers：设置软件中断pending</li>
</ul>
<p>cpu interface 的寄存器：</p>
<ul>
<li><p>CPU Interface Control Register：全局中断信号开关</p>
</li>
<li><p>Interrupt Priority Mask Register：优先级过滤器，优先级高的中断才能被传递到cpu</p>
</li>
<li><p>Binary Point Register：将中断优先级分为两个部分，优先级和子优先级</p>
</li>
<li><p>Interrupt Acknowledge Register：cpu读取这个寄存器获取当前中断id，并认为是对这个中断ack，会使中断的状态从pending编程active，或者变成pending and active（电平触发）</p>
</li>
<li><p>End of Interrupt Register：写入中断号到该寄存器，表示中断处理完成</p>
</li>
<li><p>Running Priority Register：当前cpu接口的中断优先级</p>
</li>
<li><p>Highest Priority Pending Interrupt Register：就像他的名字说的</p>
</li>
<li><p>Deactivate Interrupt Register：把中断状态从active变成inactive</p>
</li>
</ul>
<blockquote>
<p>如上图，为GIC里面的中断对应的状态，当没有任何中断的时候状态为inactive。外设触发中断，distributor会将状态改为pending。当ARM处理器响应中断服务（中断服务程序响应之前，由GIC驱动会产生一个ACK信号给控制器）的时候，cpu interface在收到ACK信号后，将状态改为active或者active+pending，什么情况下是active呢？比如，外部中断是一个gpio按钮产生，假如是低电平有效，当用户按下按钮时，电平变为低电平，此时在GIC上产生电信号变化，GIC将状态改为penging，如果此时，用户突然松开了手，那么cpu interface只将状态改为active。但是如果用户没有松开手，那么cpu interface则将状态改为active+pending。所以可以了解到如果外设持续产生中断信号，那么就会出现active+pending的状态。这就是为什么绝大部分外设驱动在中断服务程序里面都会有一个清除pending状态的动作，如果不清除，即使中断服务程序处理结束返回，也会继续触发新的无用中断。<br>  另外，当中断服务程序处理结束后，通常GIC驱动还需要做一个动作叫做EOI，这个EOI一般是将两个操作合并成了一个（GICv1就是这样），但是到了GICv2，它允许将两个操作分开。那么是哪两个操作呢？即priority drop和deactivation。<br>  priority drop叫做优先级还原，即把当前中断的优先级从running priority改为响应中断之前的优先级。比如，我们给中断配置了一个优先级5，running priority数字为0， 那么肯定0的优先级高于5。当这个优先级为5的中断被CPU响应时，CPU会临时将这个中断的优先级改为0（running priority），这样可以防止被同组内的其它高优先级抢占而破坏中断流程，影响关键数据读取。当这个中断服务处理完成后，GIC又通过EOI的步骤将这个优先级变回原来的优先级5。<br>  deactivation叫做失效，即因为在GIC驱动ACK应答GIC控制器的时候，GIC控制器会把中断状态改为active或者active+penging，因此，这个deactivation可以将状态active改为inactive状态或者active+penging改为penging。<br>  在GICv2当中，它允许将两个方法分开，由软件控制，通过配置GICC_CTLR寄存器的EOImode位达到目的。如果分开，软件在中断服务程序结束后，需要做两个动作：1、写EOIR寄存器，释放running优先级；2、写GICC_DIR寄存器，修改中断状态。如果不分开，那么久只需要做一个写写EOIR寄存器的动作就可以了。</p>
</blockquote>
<h2 id="Linux中断系统"><a href="#Linux中断系统" class="headerlink" title="Linux中断系统"></a>Linux中断系统</h2><p>参考另一篇文章</p>
<h3 id="一、设备树"><a href="#一、设备树" class="headerlink" title="一、设备树"></a>一、设备树</h3><p>在imx6ul.dti中可以找到intc节点，表示GIC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;  <span class="comment">//子节点需要3个cell，eg:interrupts = &lt;GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH&gt;;</span></span></span><br><span class="line">	interrupt-controller;  <span class="comment">//中断控制器</span></span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,  <span class="comment">//distributor内存地址</span></span><br><span class="line">	      &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;   <span class="comment">//cpu interface 内存地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、驱动程序"><a href="#二、驱动程序" class="headerlink" title="二、驱动程序"></a>二、驱动程序</h3><p>GIC的驱动程序，猜测应该需要实现irq_domain，中断服务程序，初始化GIC寄存器。</p>
<h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>搜索设备树的compatible属性，确定驱动程序在irq-gic.c 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> gic_cnt __initdata;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init</span><br><span class="line"><span class="title function_">gic_of_init</span><span class="params">(<span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base;</span><br><span class="line">	<span class="type">void</span> __iomem *dist_base;</span><br><span class="line">	u32 percpu_offset;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//distributor基地址0x00a01000</span></span><br><span class="line">	dist_base = of_iomap(node, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//interface基地址0x00a02000</span></span><br><span class="line">	cpu_base = of_iomap(node, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_u32(node, <span class="string">&quot;cpu-offset&quot;</span>, &amp;percpu_offset))</span><br><span class="line">		percpu_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//初始化硬件寄存器</span></span><br><span class="line">	gic_init_bases(gic_cnt, <span class="number">-1</span>, dist_base, cpu_base, percpu_offset, node);</span><br><span class="line">    <span class="comment">//本例子中gic_cnt=0</span></span><br><span class="line">	<span class="keyword">if</span> (!gic_cnt)</span><br><span class="line">		gic_init_physaddr(node);</span><br><span class="line">	<span class="comment">//gic一般不会有parent</span></span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">		irq = irq_of_parse_and_map(node, <span class="number">0</span>);</span><br><span class="line">		gic_cascade_irq(gic_cnt, irq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//CONFIG_ARM_GIC_V2M is not set</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ARM_GIC_V2M))</span><br><span class="line">		gicv2m_of_init(node, gic_data[gic_cnt].domain);</span><br><span class="line">	<span class="comment">//每一个gic控制器都会记录</span></span><br><span class="line">	gic_cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从设备树中获取distributor和interface的基地址，然后调用gic_init_bases：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">gic_init_bases</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gic_nr, <span class="type">int</span> irq_start,</span></span><br><span class="line"><span class="params">			   <span class="type">void</span> __iomem *dist_base, <span class="type">void</span> __iomem *cpu_base,</span></span><br><span class="line"><span class="params">			   u32 percpu_offset, <span class="keyword">struct</span> device_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq_base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span>;</span></span><br><span class="line">	<span class="type">int</span> gic_irqs, irq_base, i;</span><br><span class="line">	<span class="comment">//从全局数组中获取gic对象</span></span><br><span class="line">	gic = &amp;gic_data[gic_nr];</span><br><span class="line">    </span><br><span class="line">	&#123;			<span class="comment">/* Normal, sane GIC... */</span></span><br><span class="line">		WARN(percpu_offset,</span><br><span class="line">		     <span class="string">&quot;GIC_NON_BANKED not enabled, ignoring %08x offset!&quot;</span>,</span><br><span class="line">		     percpu_offset);</span><br><span class="line">        <span class="comment">//保存地址</span></span><br><span class="line">		gic-&gt;dist_base.common_base = dist_base;</span><br><span class="line">		gic-&gt;cpu_base.common_base = cpu_base;</span><br><span class="line">		gic_set_base_accessor(gic, gic_get_common_base);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the CPU interface map to all CPUs.</span></span><br><span class="line"><span class="comment">	 * It will be refined as each CPU probes its ID.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_GIC_CPU_IF; i++)</span><br><span class="line">		gic_cpu_map[i] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find out how many interrupts are supported.</span></span><br><span class="line"><span class="comment">	 * The GIC only supports up to 1020 interrupt sources.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//获取GIC支持的中断数量</span></span><br><span class="line">	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) &amp; <span class="number">0x1f</span>;</span><br><span class="line">	gic_irqs = (gic_irqs + <span class="number">1</span>) * <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">if</span> (gic_irqs &gt; <span class="number">1020</span>)</span><br><span class="line">		gic_irqs = <span class="number">1020</span>;</span><br><span class="line">	gic-&gt;gic_irqs = gic_irqs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node) &#123;		<span class="comment">/*只考虑设备树的情况 */</span></span><br><span class="line">        <span class="comment">//添加一个irq_domain，对应GIC</span></span><br><span class="line">		gic-&gt;domain = irq_domain_add_linear(node, gic_irqs,</span><br><span class="line">						    &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">						    gic);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gic_nr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//handle_arch_irq会把handle_arch_irq指向gic_handle_irq</span></span><br><span class="line">		set_handle_irq(gic_handle_irq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置寄存器</span></span><br><span class="line">	gic_dist_init(gic);</span><br><span class="line">	gic_cpu_init(gic);</span><br><span class="line">	gic_pm_init(gic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这个GIC进行默认的配置，写寄存器</p>
<ul>
<li>gic_dist_init</li>
<li>gic_cpu_init</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">gic_dist_init</span><span class="params">(<span class="keyword">struct</span> gic_chip_data *gic)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	u32 cpumask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gic_irqs = gic-&gt;gic_irqs;  <span class="comment">//中断数量</span></span><br><span class="line">	<span class="type">void</span> __iomem *base = gic_data_dist_base(gic);  <span class="comment">//distributor基地址</span></span><br><span class="line"></span><br><span class="line">	writel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL);  <span class="comment">//关闭全局的中断传递</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set all global interrupts to this CPU only.</span></span><br><span class="line"><span class="comment">	 * 把所有中断都输出到这个cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpumask = gic_get_cpumask(gic);  <span class="comment">//获取所使用的cpu接口</span></span><br><span class="line">	cpumask |= cpumask &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	cpumask |= cpumask &lt;&lt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">4</span>)</span><br><span class="line">		writel_relaxed(cpumask, base + GIC_DIST_TARGET + i * <span class="number">4</span> / <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//默认中断配置</span></span><br><span class="line">	gic_dist_config(base, gic_irqs, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启全局的中断传递</span></span><br><span class="line">	writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">gic_dist_config</span><span class="params">(<span class="type">void</span> __iomem *base, <span class="type">int</span> gic_irqs,</span></span><br><span class="line"><span class="params">			    <span class="type">void</span> (*sync_access)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置所有中断为低电平触发</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">16</span>)</span><br><span class="line">		writel_relaxed(GICD_INT_ACTLOW_LVLTRIG,</span><br><span class="line">					base + GIC_DIST_CONFIG + i / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置默认优先级中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">4</span>)</span><br><span class="line">		writel_relaxed(GICD_INT_DEF_PRI_X4, base + GIC_DIST_PRI + i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关闭所有中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; gic_irqs; i += <span class="number">32</span>)</span><br><span class="line">		writel_relaxed(GICD_INT_EN_CLR_X32,</span><br><span class="line">					base + GIC_DIST_ENABLE_CLEAR + i / <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sync_access)</span><br><span class="line">		sync_access();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-domain-ops"><a href="#2-2-domain-ops" class="headerlink" title="2.2 domain_ops"></a>2.2 domain_ops</h4><p>GIC作为一个中断控制器，必须要实现一个irq_domain对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> <span class="title">gic_irq_domain_hierarchy_ops</span> =</span> &#123;</span><br><span class="line">	.xlate = gic_irq_domain_xlate,  <span class="comment">//从设备树中获取硬件中断号</span></span><br><span class="line">	.alloc = gic_irq_domain_alloc,  <span class="comment">//为下一个中断控制器分配irq_domain</span></span><br><span class="line">	.<span class="built_in">free</span> = irq_domain_free_irqs_top,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从设备树中获取hw_irq</span></span><br><span class="line"><span class="comment">//interrupts = &lt;GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH&gt;;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_xlate</span><span class="params">(<span class="keyword">struct</span> irq_domain *d,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> device_node *controller,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> u32 *intspec, <span class="type">unsigned</span> <span class="type">int</span> intsize,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> *out_hwirq, <span class="type">unsigned</span> <span class="type">int</span> *out_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 跳过16个SGI eg 114+16*/</span></span><br><span class="line">	*out_hwirq = intspec[<span class="number">1</span>] + <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For SPIs, we need to add 16 more to get the GIC irq ID number */</span></span><br><span class="line">    <span class="comment">//GIC_SPI == 0，当是SPI时，需要+16 eg:114+16+16</span></span><br><span class="line">	<span class="keyword">if</span> (!intspec[<span class="number">0</span>])</span><br><span class="line">		*out_hwirq += <span class="number">16</span>;</span><br><span class="line">	<span class="comment">//中断触发类型</span></span><br><span class="line">	*out_type = intspec[<span class="number">2</span>] &amp; IRQ_TYPE_SENSE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为下一个中断控制器分配irq_domain</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_phandle_args</span> *<span class="title">irq_data</span> =</span> arg;</span><br><span class="line">	<span class="comment">//获取硬件中断号</span></span><br><span class="line">	ret = gic_irq_domain_xlate(domain, irq_data-&gt;np, irq_data-&gt;args,</span><br><span class="line">				   irq_data-&gt;args_count, &amp;hwirq, &amp;type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">//硬件中断号与虚拟中断号建立映射关系</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++)</span><br><span class="line">		gic_irq_domain_map(domain, virq + i, hwirq + i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//专属中断</span></span><br><span class="line">	<span class="keyword">if</span> (hw &lt; <span class="number">32</span>) &#123;</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic_chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		set_irq_flags(irq, IRQF_VALID | IRQF_NOAUTOEN);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//spi</span></span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic_chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-中断处理函数"><a href="#2-3-中断处理函数" class="headerlink" title="2.3 中断处理函数"></a>2.3 中断处理函数</h4><p>当cpu接收到GIC传来的中断信号时，会进入IRQ模式，跳转到中断向量表irq_handler处执行中断处理：</p>
<p>entry-armv.S</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro	irq_handler  <span class="comment">//定义irq_handler宏</span></span><br><span class="line">ldr	r1, =handle_arch_irq  <span class="comment">//handle_arch_irq 地址复制到r1</span></span><br><span class="line">mov	r0, sp  <span class="comment">//sp复制r0</span></span><br><span class="line">adr	lr, BSYM(<span class="number">9997f</span>)  </span><br><span class="line">ldr	pc, [r1]  <span class="comment">//跳转handle_arch_irq</span></span><br></pre></td></tr></table></figure>

<p>而set_handle_irq()函数就是将handle_arch_irq指向gic_handle_irq，也就是当中断产生时，gic_handle_irq会首先得到执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exception_irq_entry <span class="title function_">gic_handle_irq</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 irqstat, irqnr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> &amp;gic_data[<span class="number">0</span>];</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base = gic_data_cpu_base(gic);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//读取中断ID</span></span><br><span class="line">		irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);</span><br><span class="line">        <span class="comment">//掩码过滤掉reserved</span></span><br><span class="line">		irqnr = irqstat &amp; GICC_IAR_INT_ID_MASK;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (likely(irqnr &gt; <span class="number">15</span> &amp;&amp; irqnr &lt; <span class="number">1021</span>)) &#123;</span><br><span class="line">            <span class="comment">//将hw_irq转换成irq，并调用对应irq_desc的handler进行处理</span></span><br><span class="line">			handle_domain_irq(gic-&gt;domain, irqnr, regs);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (irqnr &lt; <span class="number">16</span>) &#123;</span><br><span class="line">			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">			handle_IPI(irqnr, regs);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断描述符什么时候进行分配？答案是在驱动程序调用 irq_of_parse_and_map()的时候：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">irq_of_parse_and_map()-&gt;</span><br><span class="line">  of_irq_parse_one()</span><br><span class="line">  irq_create_of_mapping()-&gt;</span><br><span class="line">    irq_create_mapping()-&gt;</span><br><span class="line">      irq_domain_alloc_descs()-&gt;</span><br><span class="line">        irq_alloc_descs()  <span class="comment">//分配描述符</span></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/ARM/GICv2/" data-id="cmbcy7rgs0006t8mt8d0zaltx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/ARM/ARM-CortexA7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/lwip/lwip_guide/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
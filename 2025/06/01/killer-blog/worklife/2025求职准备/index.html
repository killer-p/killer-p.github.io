<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、准备问题1.1、自我介绍x哥好，我是潘润鑫，目前就职于星宸科技，我的工作内容是在Linux内核驱动中，开发和维护多媒体系统。我熟悉在Linux内核进行软件开发，解决内核常见的问题，并对Linux 内核中多媒体pipeline的搭建有一定的理解。 在工作中，我参加了3个芯片项目，主导的开发任务有：1、Sideband data设计与实现：设计开发了一套接口，用于在不同模块之间传递参数信息，该接口">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、准备问题1.1、自我介绍x哥好，我是潘润鑫，目前就职于星宸科技，我的工作内容是在Linux内核驱动中，开发和维护多媒体系统。我熟悉在Linux内核进行软件开发，解决内核常见的问题，并对Linux 内核中多媒体pipeline的搭建有一定的理解。 在工作中，我参加了3个芯片项目，主导的开发任务有：1、Sideband data设计与实现：设计开发了一套接口，用于在不同模块之间传递参数信息，该接口">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/image-20240612215136387.png?lastModify=1742087513">
<meta property="og:image" content="http://example.com/image-20240613223254395.png?lastModify=1742087513">
<meta property="article:published_time" content="2025-06-01T00:24:26.660Z">
<meta property="article:modified_time" content="2025-06-01T00:26:27.090Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image-20240612215136387.png?lastModify=1742087513">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-killer-blog/worklife/2025求职准备" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/" class="article-date">
  <time class="dt-published" datetime="2025-06-01T00:24:26.660Z" itemprop="datePublished">2025-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、准备问题"><a href="#一、准备问题" class="headerlink" title="一、准备问题"></a>一、准备问题</h2><h3 id="1-1、自我介绍"><a href="#1-1、自我介绍" class="headerlink" title="1.1、自我介绍"></a>1.1、自我介绍</h3><p>x哥好，我是潘润鑫，目前就职于星宸科技，我的工作内容是在Linux内核驱动中，开发和维护多媒体系统。我熟悉在Linux内核进行软件开发，解决内核常见的问题，并对Linux 内核中多媒体pipeline的搭建有一定的理解。</p>
<p>在工作中，我参加了3个芯片项目，主导的开发任务有：<br>1、Sideband data设计与实现：设计开发了一套接口，用于在不同模块之间传递参数信息，该接口实现高内聚低耦合，提供给其他驱动程序使用，并且复用了原有代码的逻辑，减少了工作量。<br>2、Linux系统读取RTOS系统Log：设计Linux驱动，通过寄存器与dma与CM4交互，读取CM4上RTOS系统的log<br>3、CMDQ Burst Write：针对软件写寄存器速度慢的问题，与硬件rd设计了一套软硬件方案，将写寄存器的耗时减少了70%。<br>4、DMABUF：将SDK对接到DMABUF框架中</p>
<p>在工作中，我解决了大量的Linux内核驱动BUG：<br>详见2.7、缺陷解决</p>
<p>在职期间，我取得企业明星个人奖、优秀新人奖，以及两次绩效A。</p>
<h3 id="1-2、为什么离职？"><a href="#1-2、为什么离职？" class="headerlink" title="1.2、为什么离职？"></a>1.2、为什么离职？</h3><p>1、目前的工作中测试和debug的占比较大，我希望能承担更多的软件新功能开发项目</p>
<p>2、公司业务转向FAE</p>
<h3 id="1-3、对自己的职业规划"><a href="#1-3、对自己的职业规划" class="headerlink" title="1.3、对自己的职业规划"></a>1.3、对自己的职业规划</h3><p>技术上在未来的2-3年内，进一步积累操作系统领域工作经验，能够负责较大软件项目的开发，能够提高工作效率，与同事沟通协作的效率。</p>
<h3 id="1-4、遇到最大的困难是什么"><a href="#1-4、遇到最大的困难是什么" class="headerlink" title="1.4、遇到最大的困难是什么"></a>1.4、遇到最大的困难是什么</h3><p>困难描述：在P3P FPGA验证阶段，cmdq一个单元测试出错（从未遇见过的错误），同时有CMDQ PTS新功能要验证，距离硬件frozen剩余的时间不多，必须尽快解决问题。</p>
<p>BUG描述：CMDQ Delay功能测试中，发现delay 2ms 的case实际上delay了160ms。</p>
<p>如何解决困难：</p>
<ol>
<li>认真分析错误现象，找出其中的规律、特点：2s delay 没有问题，2ms delay有问题，说明可能是硬件精度问题，检查clock，发现正常。</li>
<li>cmdq chn0 没有问题，但后续chn1、2、3有问题；询问hw rd，说chn都是使用同一套硬件，是对硬件的分时复用，实现上没有区别。</li>
<li>分析代码，发现有关中断cmd，怀疑是中断关闭太久引起，尝试注释中断的cmd。发现case 都可以pass，怀疑是中断问题，于是询问硬件RD中断的处理机制。得到的回答仍然无法解释现象。</li>
<li>将中断cmd替换成其他cmd、如 poll、null 发现也可以pass，怀疑是和cmd类型相关，于是与hw rd分享实验现象。</li>
<li>hw rd开会讨论后认为可能是riu总线延迟，导致write cmd在poll cmd之后执行，导致timeout时间设置不及时生效导致的</li>
<li>自我提升：遇到困难，保持乐观的心态。抓住问题的特点，针对性的做实验，尽量多的抓取数据，沟通时不要太发散思维。并及时与相关人员进行充分的沟通，拉通双方的信息。</li>
</ol>
<h3 id="1-5、我的核心竞争力"><a href="#1-5、我的核心竞争力" class="headerlink" title="1.5、我的核心竞争力"></a>1.5、我的核心竞争力</h3><p>丰富的debug经验，对多线程并发的理解（）<br>优秀的架构设计能力</p>
<h2 id="二、工作内容"><a href="#二、工作内容" class="headerlink" title="二、工作内容"></a>二、工作内容</h2><ul>
<li>MI SDK ：MI 即媒体接口，主要提供多媒体处理的API接口给客户，客户通过MI接口可以调用soc 上的多媒体ip，进行音视频流app的搭建。</li>
<li>mma heap：一块用于存放多媒体数据的专用内存。</li>
<li>iommu：将mma heap所在的物理地址映射到范围更大的虚拟地址，提供虚拟地址给多媒体ip访问</li>
</ul>
<h3 id="2-1、SYS内存管理"><a href="#2-1、SYS内存管理" class="headerlink" title="2.1、SYS内存管理"></a>2.1、SYS内存管理</h3><h4 id="2-1-1、mma-heap"><a href="#2-1-1、mma-heap" class="headerlink" title="2.1.1、mma heap"></a>2.1.1、mma heap</h4><p>一块用于存放多媒体数据的专用内存，由于音视频流处理过程需要使用到连续物理内存，为了满足连续物理内存的需求，sigmastar设计了一个mma heap的内存池。<br>为什么不适应dma_alloc_coherent()？是因为iommu存在，我们需要实现一个驱动去管理iommu，将物理地址映射到连续虚拟地址，提供给ip dma使用</p>
<h4 id="2-1-2、iommu"><a href="#2-1-2、iommu" class="headerlink" title="2.1.2、iommu"></a>2.1.2、iommu</h4><p>MIU 总线：与DDR进行连接。</p>
<p>既然有大块连续物理内存的需求，那么就避免不了内存碎片。为了减少内存碎片，提升内存系统利用率，引入了iommu。</p>
<blockquote>
<p>内存碎片：即有一块较大的连续地址空闲，经过若干次申请释放后，由于小块内存散布在地址空间各个角落，导致虽然总的空闲空间足够，但无法凑出一块较大的连续空间，从而导致内存申请失败。</p>
</blockquote>
<p>mma heap的原理：sigmastar 芯片中有一个iommu，用于帮助建立mma heap，他的硬件示意图如下所示：</p>
<p><img src="/image-20240612215136387.png?lastModify=1742087513" alt="image-20240612215136387"></p>
<p>sigmastar io mmu 可以将一段物理内存地址映射为另一段虚拟物理内存地址。与arm mmu最大的不同是，io mmu 是集成在内存控制器上的，其使用者包括soc 上的所有ip，如isp、venc、disp。<br>DDR上的真实物理地址PA，经过IO MMU映射后，成为虚拟物理地址VPA，VPA地址与DDR上的地址是不重叠的。VPA就是所谓的mma heap，专门给音视频流ip使用。ip发出访问VPA地址请求，会在iommu转换成对应的物理地址的访问。</p>
<p>io mmu 映射的最小单位是entry，每个entry大小可配置为32k-&gt;128k，共有4096个entry，只有一级页表，因为可以映射128M-&gt;512M的物理内存，已经足够使用了。在内存系统初始化时，会通过memblock系统保留一块物理内存，然后创建一个mma allocator，allocator 管理一段虚拟地址空间，一般来说会比真实物理地址大，这取决于entry szie。<br>当音视频流启动后，每次向mma heap内存申请时，SYS会从allocator中申请一段连续的地址，然后对这段地址使用iommu进行映射，将VPA映射到PA使地址有效。<br>释放buf 时，会解除映射。</p>
<blockquote>
<p>使用IO MMU的好处是什么？</p>
<ul>
<li><p>减少内存碎片，例如，通过将64M的内存空间映射到128M的VPA，更大的内存空间可以更好的降低内存碎片带来的影响。避免上述的总空闲内存足够，但无法凑出连续的内存空间的情况。</p>
</li>
<li><p>帮助发现use after free问题，当内存释放后，io mmu会解除映射关系。假如此时有ip 访问到未被映射的VPA，会触发异常；</p>
</li>
<li><p>帮助解决内存访问越界、在申请内存时，在内存前后申请多余的字节，但不对这些字节进行映射，如果ip访问越界，则会触发异常，打印信息。</p>
</li>
<li><p>帮助定位踩内存，MIU 内存保护，可以为一段地址空间的内存设置白名单，白名单之外的ip访问该段地址空间，会触发异常，打印信息帮助debug踩内存</p>
</li>
</ul>
</blockquote>
<h4 id="2-1-3、chunk"><a href="#2-1-3、chunk" class="headerlink" title="2.1.3、chunk"></a>2.1.3、chunk</h4><p>chunk用于描述一个较大的内存块。chunk manager是管理在一段内存上，chunk的申请和释放。chunk 的申请和释放的逻辑是：为了避免内存碎片，尽量从最合适的chunk中切割得到所需的chunk。chunk 是与硬件无关的，纯粹软件逻辑实现的。在申请chunk的时候，需要输入所需的chunk 大小、对齐要求，需要对buf 地址、大小进行字节对齐，甚至要浪费一些内存。</p>
<blockquote>
<p>为什么需要内存对齐？</p>
<p>答：硬件在访问内存的时候，一次会读取若干个字节，若数据在内存中保持字节对齐，硬件可以以最少的内存访问次数读取到所需的数据</p>
</blockquote>
<h4 id="2-1-4、ring-pool"><a href="#2-1-4、ring-pool" class="headerlink" title="2.1.4、ring pool"></a>2.1.4、ring pool</h4><p>对于ven ip，由于每次编码完成之后的码流数据大小是未知的，无法在编码前提前确定的，故其输出的buf 的大小也是未知的。那么我们就无法在编码前预申请一个指定大小的buf。</p>
<p>ring pool 就是为解决这个问题产生的设计。其核心是申请一个较大的mma buf，ven 每次编码完成后，都将帧的数据输出到该ring pool 中，并设置该帧的长度，更新写指针，同时用户也会从ring pool 的读指针中读取数据给应用层，更新读指针。当写指针达到buf 尾部时，会重新跳转到buf 首地址继续写数据。只要保证pool 的大小在一个合理的值，对于ven来说，输出buf足够大，且同时用户能及时读数据，就能确保编码能正常进行。</p>
<h4 id="2-1-5、dmabuf"><a href="#2-1-5、dmabuf" class="headerlink" title="2.1.5、dmabuf"></a>2.1.5、dmabuf</h4><p>将mma heap 对接dmabuf 框架。实现了dmabuf exporter 和 dmabuf importer。</p>
<ul>
<li><p>exporter：支持从mma heap 申请一块内存作为dmabuf，并实现attachment 的回调函数。</p>
</li>
<li><p>importer：支持从dmabuf中获取物理地址，并封装成SYS支持的buf 数据结构，用于ip的数据输出。</p>
</li>
<li><p>dma fence：在ip 输出数据结束后，唤醒poll 的线程。</p>
</li>
</ul>
<h4 id="2-1-6、cma"><a href="#2-1-6、cma" class="headerlink" title="2.1.6、cma"></a>2.1.6、cma</h4><p>连续内存管理</p>
<h4 id="2-1-7、cache"><a href="#2-1-7、cache" class="headerlink" title="2.1.7、cache"></a>2.1.7、cache</h4><p>cache line、flush cache</p>
<h4 id="2-1-9、vmap、map"><a href="#2-1-9、vmap、map" class="headerlink" title="2.1.9、vmap、map"></a>2.1.9、vmap、map</h4><h3 id="2-2、线程管理"><a href="#2-2、线程管理" class="headerlink" title="2.2、线程管理"></a>2.2、线程管理</h3><h4 id="2-2-1、线程"><a href="#2-2-1、线程" class="headerlink" title="2.2.1、线程"></a>2.2.1、线程</h4><p>一般来说，都有以下模型，一个线程负责管理一个硬件设备的输入输出。</p>
<p><img src="/image-20240613223254395.png?lastModify=1742087513" alt="image-20240613223254395"></p>
<p>我们希望中断产生后，cpu 能尽快处理中断，将输出buf 传递给后级或者用户。利用多线程的特性，为每一个ip创建一个线程，这样就算多个ip 在同时产生中断，也能有多个线程并发处理中断。</p>
<h4 id="2-2-2、buf-传递"><a href="#2-2-2、buf-传递" class="headerlink" title="2.2.2、buf 传递"></a>2.2.2、buf 传递</h4><p>视频流类似流水线，前级模块的输出作为后级模块的输入，也可以输出给用户app。<br>SYS线程中实现将前级buf传给后级，buf 传递实现是传递引用，即buf 的物理地址和长度。通过引用计数来管理buf，决定buf 何时释放。<br>sys 线程中还实现了buf 传递的时序</p>
<h3 id="2-3、CMDQ"><a href="#2-3、CMDQ" class="headerlink" title="2.3、CMDQ"></a>2.3、CMDQ</h3><h4 id="2-3-1、cmdq-原理"><a href="#2-3-1、cmdq-原理" class="headerlink" title="2.3.1、cmdq 原理"></a>2.3.1、cmdq 原理</h4><p>CMDQ 是command queue的简称。他是芯片上的一个ip，用于代替cpu 访问寄存器。<br>cmdq可以执行：读写等待寄存器的操作，同时cmdq 会维护一个脚本，不停地从脚本里读取命令去执行。<br>软件只需要往脚本里写入命令即可。</p>
<h4 id="2-3-2、作用"><a href="#2-3-2、作用" class="headerlink" title="2.3.2、作用"></a>2.3.2、作用</h4><p>在处理一帧视频图像时，cpu需要为ip设置寄存器（内存、中断、配置），图像处理完成后，cpu需要响应中断信号，并设置下一帧的寄存器。但是当linux系统cpu loading较高时，会出现cpu响应中断延迟的问题，此时会导致ip有一段时间的空闲。</p>
<p>有cmdq 时，软件可以同时将两个buf 的寄存器先填到脚本里，ip先处理一帧后，产生中断给cpu外，还会中断信号给cmdq，cmdq就会继续执行脚本，设置第二帧的寄存器。cmdq 执行速度快，ip几乎可以满载运行。</p>
<h3 id="2-4、项目经验"><a href="#2-4、项目经验" class="headerlink" title="2.4、项目经验"></a>2.4、项目经验</h3><h4 id="2-4-1、cmdq-pts"><a href="#2-4-1、cmdq-pts" class="headerlink" title="2.4.1、cmdq pts"></a>2.4.1、cmdq pts</h4><p>需求背景：当ip处理完一帧图像后，cmdq 会产生中断到cpu，在中断回调函数中会去计算done pts。若cpu 处于高负载场景时，会出现中断延迟，导致中断合并，那么这两帧图像的done pts 就出现重复，会影响到用户的视频播放。<br>为了解决这个问题，在cmdq ip 中新增计时器以及fifo queue。当ip done 完成后，由cmdq 记录当前的count 值，保存到fifo queue中。<br>当cpu中断服务函数执行时，读取fifo中的count值，与cmdq 当前count值作比较，计算差值diff。然后获取系统pts，将pts减去差值，得到真实的硬件done pts。</p>
<p>fifo的存在：若cpu 中断响应延迟很久，那么fifo 的存在可以保证有几张buf的pts信息还是能保存到的</p>
<h4 id="2-4-2、cmdq-burst-write"><a href="#2-4-2、cmdq-burst-write" class="headerlink" title="2.4.2、cmdq burst write"></a>2.4.2、cmdq burst write</h4><p>需求背景：在16路视频播放场景下，出现画面卡顿。</p>
<p>分析：</p>
<ol>
<li>首先查看系统cpu loading，发现已达到92%，怀疑是cpu问题。</li>
<li>先使用perf抓取火焰图，分析多媒体内核线程的调用，发现ISP线程在Enqueue函数中占用较多cpu 时间。</li>
<li>使用Ftrace function graph，重点查看ISP 函数的执行时间，发现执行时间700us，猜测是该函数执行时间过长，导致总的一帧buf处理时间大于2ms，从而导致来不及处理下一帧图像，而丢弃一些图像。</li>
<li>分析函数代码，发现耗时较长主要是因为写reg的时候，会先将reg写到全局变量，再拷贝到cmdq 脚本，最后cmdq 才写入reg。其中cpu 两次拷贝耗时较长。</li>
<li>为什么需要写入全局变量，再拷贝到cmdq 脚本？因为cmdq api的设计需要将reg作为输入参数，在设置输入参数时，就必定有一次拷贝。再到API内部，输入参数到cmdq 脚本，又有一次拷贝。</li>
<li>解决方案：从两个方面进行优化：</li>
<li>软件上：修改cmdq API，直接将cmdq 脚本地址暴露给ISP模块，由ISP模块直接向脚本里写入数据。</li>
<li>硬件上：增加burst write cmd，支持写连续地址的寄存器，只保留连续地址寄存器的值，删掉其他的字段，将数据量减少到1&#x2F;4</li>
<li>实测在写2000个连续寄存器，耗时可减少到1&#x2F;3</li>
</ol>
<h4 id="2-4-3、dmabuf"><a href="#2-4-3、dmabuf" class="headerlink" title="2.4.3、dmabuf"></a>2.4.3、dmabuf</h4><p>需求背景：<br>为了将SDK输出的图像对接安卓DRM显示框架显示，需要支持前端sensor的图像输出为dma-buf 格式</p>
<p>解决步骤：</p>
<ol>
<li>方案讨论，确定可行性</li>
<li>开始实作</li>
<li>实现一个dmabuf exporter，输出dmabuf 其背后的物理内存是IOMMU映射的VPA</li>
<li>实现dmabuf importer，通过attach、map attachment，获取到dmabf sgtable，然后将sg table中的sg list封装成SDK支持的buf 格式，再传给ip</li>
<li>sg_table 是 DMA 硬件操作的关键；</li>
<li>一个dmabuf可能同时被多个设备访问，为了确保物理内存能被所有设备的地址空间覆盖，需要先attach 收集设备的地址空间信息</li>
<li>map attachment时，分配物理内存，生成sg table，并将物理内存信息填入sg table，同时刷新cache？</li>
</ol>
<h4 id="2-4-4、Linux-dump-rtos-log"><a href="#2-4-4、Linux-dump-rtos-log" class="headerlink" title="2.4.4、Linux dump rtos log"></a>2.4.4、Linux dump rtos log</h4><p>需求背景：<br>在多核异构系统中，有arm core运行linux系统，riscv core运行rtos系统。<br>客户希望在调试时，可以在linux 系统中读取rtos系统的日志，并且在rtos系统奔溃时，可以抓取rtos奔溃之后留下的日志。<br>注：riscv运行在sram、arm 运行在dram，arm 无法访问sram。但可以通过dma拷贝sram数据到dram</p>
<p>解决步骤：</p>
<ol>
<li>硬件支持：使用mailbox 寄存器在两个core 之间通信，以及核间中断</li>
<li>我负责linux 端的驱动开发。主要工作是：两个部分：</li>
<li>创建&#x2F;proc&#x2F;pm_rtos&#x2F;log节点，暴露给用户抓log的接口，实现proc_ops的open回调。</li>
<li>关于proc框架的原理，一般来说用户都会使用cat 程序查看proc节点，在cat 程序中会open、read、read的大小是一个page。然后kernel 层也会申请一个page 缓存，用来给驱动输出字符串。随后kernel 会将page 拷贝到用户层。</li>
<li>在open回调中，首先要确保rtos端有正常运行，先使用bdma拷贝预先定义的结构体。（拷贝的地址和长度在mailbox寄存器）</li>
<li>假如结构体内容正确，说明rtos有正常运行。否则走异常处理流程</li>
<li>申请一块连续物理内存(dma_alloc_coherent())，8k，然后设置source和dest物理地址和大小到bdma，trigger bdma</li>
<li>等待bdma传输完成，bdma传输完成后，会产生中断，在中断中唤醒用户线程。</li>
<li>将log拼接拷贝到seq-&gt;buf中，返回给用户层</li>
<li>测试ok<br>需要关注的点：</li>
<li>cache：使用dma_alloc_coherent()申请的物理内存没有cache</li>
<li>map时是否有带cache</li>
<li>超时机制，当bdma没有done时，会退出等待</li>
<li>proc seq file 机制</li>
<li>log buf为ringbuf ，需要读写指针</li>
</ol>
<h4 id="2-4-5、code-size优化"><a href="#2-4-5、code-size优化" class="headerlink" title="2.4.5、code size优化"></a>2.4.5、code size优化</h4><p>sys模块export 很多api symbol 给其他模块使用，希望减少symbol来减少code size</p>
<p>设计一个结构体，存放若干函数指针，将之前的api函数赋值给该结构体，并export该结构体的symbol，这样外部驱动只需要引用一个symbol，就可以使用该结构体访问到对应的api。为了保持API稳定，还提供了若干宏用于兼容之前的设计，避免影响到外部驱动</p>
<p>结果上：mi sys 驱动size 减少了4k byte</p>
<h4 id="2-4-6、mi-poll-refine-优化"><a href="#2-4-6、mi-poll-refine-优化" class="headerlink" title="2.4.6、mi poll refine 优化"></a>2.4.6、mi poll refine 优化</h4><p>问题1：多进程调用 mi poll 时有概率出现读写不同步的情况，导致数据错误BUGON<br>问题2：多进程调用</p>
<h4 id="2-4-7、sideband-data设计实现"><a href="#2-4-7、sideband-data设计实现" class="headerlink" title="2.4.7、sideband data设计实现"></a>2.4.7、sideband data设计实现</h4><p>问题：视频流模块需要获取pipeline上其他模块的参数信息<br>负责内容：利用SYS 在模块间传递BUF的机制，在BUF结构体上新增成员，保存参数信息，并提供接口给模块，运行其通过接口访问参数信息。<br>设计体现了高内聚，低耦合的思想，高度抽象了参数信息，使其之具备地址，和大小两个属性。外部模块如何去定义参数信息，都不会影响到sys的代码逻辑。只需要新增参数类型。<br>参数信息的生命周期和BUF绑定，在BUF释放时，参数信息也就被释放。</p>
<h3 id="2-7、缺陷解决"><a href="#2-7、缺陷解决" class="headerlink" title="2.7、缺陷解决"></a>2.7、缺陷解决</h3><h4 id="2-7-1、VDF卡住"><a href="#2-7-1、VDF卡住" class="headerlink" title="2.7.1、VDF卡住"></a>2.7.1、VDF卡住</h4><p>现象</p>
<p>vdf 跑3chn，ctrl+c退出时，会卡住</p>
<p>分析</p>
<ol>
<li><p>首先show thread 看当前所有线程的backtrace</p>
</li>
<li><p>检查mi内核线程，发现在destroy chn 和 dequeue task里进行睡眠，于是需要分析两个线程睡眠的原因，以及代码的逻辑</p>
</li>
<li><p>vdf退出时，概率性先stop chn2，并且等待chn2 task 清空</p>
</li>
<li><p>mi thread那边会先deq in、再deq out。deq ch1 in 失败，deq chn2 成功，在deq chn1 out失败后，就跳出deq 流程。导致vdf 线程chn2 task 一直不为空</p>
</li>
<li><p>同时由于stop chn2 一直在等待，所以chn1 也一直无法stop</p>
</li>
</ol>
<p>总结</p>
<p>vdf chn 销毁顺序和sys deq 顺序不匹配导致的</p>
<h4 id="2-7-2、VDISP死锁"><a href="#2-7-2、VDISP死锁" class="headerlink" title="2.7.2、VDISP死锁"></a>2.7.2、VDISP死锁</h4><p>思路<br>死锁的解决核心是抓取系统上所有线程的backtrace，查找backtrace中在等待锁的线程，再从代码中分析造成死锁的情景。明白死锁是如何产生后即可解决。</p>
<ol>
<li>问题：vdisp 退出app时，有概率会卡死，uart可以输入</li>
<li>分析：</li>
<li>首先使用show threads 查看系统所有线程backtrace</li>
<li>关注那些在等lock 的线程,使用gdb 定位到lock的位置</li>
<li>从lock位置出发，回溯线程的函数调用路线，分析线程间锁的关系</li>
<li>定位到内核线程使用allocator，会先拿到A锁，进入vdisp API，尝试拿B锁但阻塞</li>
<li>用户线程退出app时，执行unbind，会先拿B锁，然后调用SYS 接口销毁allocator时，需要拿A锁，但阻塞</li>
<li>两个线程互相等待卡死</li>
<li>解决办法：用户退出app时，unbind函数中不需要在B锁的保护下调用SYS接口</li>
</ol>
<h4 id="2-7-3、数组越界访问"><a href="#2-7-3、数组越界访问" class="headerlink" title="2.7.3、数组越界访问"></a>2.7.3、数组越界访问</h4><ol>
<li>问题：app运行过程中，概率性出现segment fault</li>
<li>分析：</li>
<li>通过gdb 分析 核心转储文件core，定位到segment fault所在的代码</li>
<li>分析代码是指针访问错误，怀疑是数组越界</li>
<li>检查驱动代码，发现是用户没有对API返回值进行检查，将获取到的错误数据传递给API，在代码中访问错误的数据，出现里数组的越界访问</li>
<li>解决：增加检查API返回值</li>
</ol>
<h4 id="2-7-4、unmap导致的踩内存"><a href="#2-7-4、unmap导致的踩内存" class="headerlink" title="2.7.4、unmap导致的踩内存"></a>2.7.4、unmap导致的踩内存</h4><ol>
<li>问题：概率性iommu上报cpu访问非法地址</li>
<li>分析：</li>
<li>通过加log怀疑是use after free，结合app逻辑得到结果</li>
<li>释放buf时，先unmap iommu，再unmap arm mmu。在unmap arm mmu时，由于cache刷新，会将数据写到dram，但此时对应的dram已经被unmap，故iommu会报错</li>
<li>解决：将arm mmu unmap提前</li>
</ol>
<h4 id="2-7-5、delay寄存器不生效"><a href="#2-7-5、delay寄存器不生效" class="headerlink" title="2.7.5、delay寄存器不生效"></a>2.7.5、delay寄存器不生效</h4><ol>
<li>问题：单元测试中，测试cmdq delay 1ms，实际延迟100ms，设置delay timeout寄存器不生效</li>
<li>分析：</li>
<li>抓取寄存器发现值是正常的</li>
<li>由于软件流程比较简单，故询问HW RD CMDQ的下寄存器原理</li>
<li>后来猜测可能是cmdq 下delay timeout寄存器还没生效，就开始trigger wait cmd，导致使用的还是之前的timeout时间</li>
<li>解决办法 是在write timeout之后，多插入一条poll，等到真正写入reg之后再trigger wait</li>
</ol>
<h4 id="2-7-6、rcu中断风暴"><a href="#2-7-6、rcu中断风暴" class="headerlink" title="2.7.6、rcu中断风暴"></a>2.7.6、rcu中断风暴</h4><ol>
<li>问题：app运行过程中，出现rcu info报错，stall on cpu 0</li>
<li>分析：</li>
<li>一般这种警告都是由于中断风暴导致的，即一个中断频繁的触发，导致一个cpu一直处于中断模式。rcu 机制会检查到这个cpu的异常</li>
<li>接下来就是确定哪个中断异常，如果串口可用，就cat &#x2F;proc&#x2F;interrupts 看中断的信息，发现是cmdq 中断异常</li>
<li>因为是STR过程产生的，注重分析cmdq str 函数</li>
<li>与hw 沟通后得知str 过程所有reg 会被复位，irq mask也被复位。所以当str 退出之后，所有irq mask 都为0，但由于有str resume回调，正在使用的cmdq会恢复irq mask。但是此时如果申请新的cmdq，在enable 的时候会立刻触发irq，且未注册中断处理函数，这就导致irq 风暴</li>
<li>解决：在str resume 时，恢复所有irq mask，并且在enable cmdq 之前，必须先设置irq mask，中断回调函数。</li>
</ol>
<h4 id="2-7-7、驱动内存泄露"><a href="#2-7-7、驱动内存泄露" class="headerlink" title="2.7.7、驱动内存泄露"></a>2.7.7、驱动内存泄露</h4><ol>
<li>问题：app重复运行过程中出现oom</li>
<li>分析：</li>
<li>首先加大linux内存，压测，仍然出现oom</li>
<li>分析oom信息，发现是slub使用较多，于是重点分析slub</li>
<li>使用kmemleak分析，没有收获</li>
<li>使用cam os mem trace，发现是venc模块使用的内存一直增加，通过backtrace定位到alloc的申请者，发现内存泄露</li>
<li>kmemleak没有收获的原因是 cam os mem trace的存在冲突</li>
</ol>
<h4 id="2-7-7、dmafence泄露"><a href="#2-7-7、dmafence泄露" class="headerlink" title="2.7.7、dmafence泄露"></a>2.7.7、dmafence泄露</h4><ol>
<li>问题：客户压测报错：申请dma fence内存失败</li>
<li>分析：</li>
<li>开启kmemleak，没有发现错误</li>
<li>开启cam os mem trace，过滤sys，发现sys申请的内存在一直增加</li>
<li>cat &#x2F;proc&#x2F;xxx&#x2F;dmafence节点，发现存在大量dmafence，不合理</li>
<li>分析代码是否有dmafence泄露，找到问题</li>
</ol>
<h4 id="2-7-8、系统彻底卡死"><a href="#2-7-8、系统彻底卡死" class="headerlink" title="2.7.8、系统彻底卡死"></a>2.7.8、系统彻底卡死</h4><p>这种情况下，有多种原因：</p>
<ol>
<li>运行app过程中，系统突然卡死，没有输入任何错误信息</li>
<li>开启lockdep检查是否死锁</li>
<li>借助外部debug设备jtag、trace32，抓取系统信息如寄存器，log buf</li>
</ol>
<h4 id="2-7-9、oom"><a href="#2-7-9、oom" class="headerlink" title="2.7.9、oom"></a>2.7.9、oom</h4><ol>
<li>app运行过程出现oom 信息，内存不足</li>
<li>分析oom信息，确定是否是内存泄露</li>
<li>分析应用运行一段时间前后的 &#x2F;proc&#x2F;meminfo信息，看哪个值增长较大</li>
<li>看匿名页数量偏大，还是slub数量偏大，确定是内核还是应用的内存泄露</li>
<li>应用泄露：使用asan lib 重新链接应用程序，包括程序所使用的库，运行等待asan报错</li>
<li>内核泄露：使用kmemleak检查，若怀疑是MI，使用cam os mem trace</li>
</ol>
<h4 id="2-7-10、多线程竞争访问（1）"><a href="#2-7-10、多线程竞争访问（1）" class="headerlink" title="2.7.10、多线程竞争访问（1）"></a>2.7.10、多线程竞争访问（1）</h4><p>场景描述：<br>cmdq abnormal case<br>有一个硬件，每处理完成一张图像，status reg更新为idle，id reg更新为图像id。<br>但是实际场景发现BUGON，条件是status为idle，但是id与图像id不匹配。说明硬件此时没有在工作，但是可以确定软件流程中有将图像输入给硬件，而硬件却没有更新id</p>
<p>以往的情况认为这是一个硬件的BUG，status reg 不准确，故在FPGA上hw rd 新增了flag来标记idle状态。</p>
<p>分析：<br>在FPGA验证过程中，发现新的flag仍然无法解决问题。review code怀疑是图像 id没有实际的写到寄存器，于是在代码中加入log查看代码运行，查看出错时线程的执行步骤，分析代码逻辑，发现是由于多线程抢占访问共享数据导致的。</p>
<p>具体来说，有两个线程同时访问一个共享变量导致，线程A会先把task id+1，然后去trigger，但是有概率在A trigger 之前，B抢占了A的执行，然后B去检查task id和硬件status，就发现status为idle 而task id没有更新，进而判断为错误。</p>
<p>目前的修改办法是：修改线程A的处理顺序，先使用局部变量将task id + 1，trigger硬件，然后再更新全局变量task id，线程B即使抢占了A，但由于未trigger，且全局task id没有+1，故不会报错。</p>
<h4 id="2-7-11、多进程竞争访问（2）"><a href="#2-7-11、多进程竞争访问（2）" class="headerlink" title="2.7.11、多进程竞争访问（2）"></a>2.7.11、多进程竞争访问（2）</h4><p>poll<br>背景<br>用户调用 getfd api，会有以下步骤</p>
<ol>
<li>读共享变量fd是否赋值，若没有继续，有则退出</li>
<li>设置共享变量fd的值<br>问题：<br>两个进程同时使用API，在第一步会都返回没有，继续走第二步，第二步会检查到重复设置fd，出发BUGON<br>解决：<br>要在进程间做互斥访问，只能在内核里实现。将读写共享变量的接口封装为一个ioctl，在内核态枷锁互斥</li>
</ol>
<h4 id="2-7-12、多线程竞争访问（3）"><a href="#2-7-12、多线程竞争访问（3）" class="headerlink" title="2.7.12、多线程竞争访问（3）"></a>2.7.12、多线程竞争访问（3）</h4><p>sram<br>描述：<br>jpeg 和 scl 共享一个sram，线程先调用scl 回调设置sram，再调用jpeg回调设置sram。jpeg和scl 读取到的sram信息必须一致<br>问题出现就是jpeg 发现读取到的sram 信息和 scl 给的信息不一致，故BUGON</p>
<p>分析：<br>查看sram 信息的读写的代码，发现只有在free的时候会清除sram信息。查看BGON log发现每次出错时，都有disable 函数的打印，且问题只出现在切换绑定模式的情景。<br>于是分析disable 函数与sram free的关系，发现disable 函数中，会先设置flag让scl 释放sram，然后等待scl 图像处理完成。<br>在内核中有AB线程，A线程在disable 之前，正常的设置sram信息，然后调用jpeg的接口。B线程有概率在收到disable 设置的flag后，去free sram，导致A线程调用jpeg里检查不一致而BUGON</p>
<p>解决：<br>代码逻辑问题，disable时，必须要等手里的图像都处理完成后，再清除设置信息。</p>
<h4 id="2-7-13、use-after-free"><a href="#2-7-13、use-after-free" class="headerlink" title="2.7.13、use after free"></a>2.7.13、use after free</h4><p>poll<br>描述：<br>用户app调用API时打开一个设备节点时，获取一个匿名文件，并且内核会为其创建一个对象；当app调用deinit API时，会将该对象释放。但是当进程退出&#x2F;或close 文件时，由于文件有release回调，在回调中会将访问该对象，导致use after free</p>
<p>分析：<br>在修改对象的地方加log，复现场景，查看log发现上述原因。<br>解决：<br>当app调用deinit API时，会将该对象释放，同时会将其关联的数据结构的指针都置为NULL</p>
<h3 id="2-8、功能开发"><a href="#2-8、功能开发" class="headerlink" title="2.8、功能开发"></a>2.8、功能开发</h3><h4 id="2-8-1、hw-breakpoint-优化"><a href="#2-8-1、hw-breakpoint-优化" class="headerlink" title="2.8.1、hw breakpoint 优化"></a>2.8.1、hw breakpoint 优化</h4><p>hw breakpoint 在产生中断时，会一直触发中断</p>
<h2 id="三、面试经历"><a href="#三、面试经历" class="headerlink" title="三、面试经历"></a>三、面试经历</h2><h3 id="3-1、华为OD"><a href="#3-1、华为OD" class="headerlink" title="3.1、华为OD"></a>3.1、华为OD</h3><p>笔试需要中等难度题目，力扣中等题，熟能生巧，面试宝典</p>
<p>题目类型：递归，回溯，图论，搜索树，动态规划，</p>
<p>结果：机试188分，200分可进面试。失败</p>
<h3 id="3-2、卓驭"><a href="#3-2、卓驭" class="headerlink" title="3.2、卓驭"></a>3.2、卓驭</h3><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>嵌入式软件…师（底软）</p>
<p>【主要职责】: 1、负责车载嵌入式产品的软件架构设计、编码和单元测试； 2、参与软件需求分析，编写详细设计文档和开发代码，负责软件的集成测试和系统调试； 3、优化软件性能，提高系统的稳定性和可靠性；</p>
<p>4、与硬件工程师协作，确保软件与硬件的兼容性；</p>
<p>5、参与工厂测试软件的开发，分析解决量产以及售后的问题。</p>
<p>【任职要求】: 1、计算机科学与技术、电子信息工程、软件工程或相关专业本科及以上学历； 2、3年以上嵌入式软件开发经验，熟悉 C &#x2F; C +＋编程语言； 3、熟悉 Linux 内核，了解内核关于内存管理、调度等模块的基本概念，有在 Linux 下进行嵌入式软件开发的经验； 4、有STM32、 ARM 或其他嵌入式处理器开发经验者优先； 5、熟悉嵌入式软件开发流程，包括需求分析、设计、编码、测试和维护； 6、具备良好的问题解决能力、沟通能力和团队协作精神； 7、熟悉至少一种脚本语言，如 Python 、 Shell 等；</p>
<p>8、有一定的团队管理经验或者项目管理经验。</p>
<p>面试经历</p>
<ol>
<li><p>自我介绍</p>
</li>
<li><p>iommu</p>
</li>
<li><p>对cmdq 中断与线程的交互比较感兴趣，cmdq fence、dma done</p>
</li>
<li><p>有没有因为cache 导致的问题</p>
</li>
<li><p>中断线程化，调度器有哪几种，wakeup的流程</p>
</li>
<li><p>访问内存地址0 时，arm 会有什么状态</p>
</li>
<li><p>kernel panic时如何处理</p>
</li>
<li><p>qunix 微内核</p>
</li>
<li><p>相机、通用bsp、网络驱动、mcu</p>
</li>
<li><p>有没有和同事发生矛盾，怎么处理</p>
</li>
<li><p>和同事合作时，如果对方不合作，要怎么push他</p>
</li>
</ol>
<h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><ol>
<li><p>自我介绍</p>
</li>
<li><p>先考察技术：在linux系统，如何通过虚拟地址访问内存的</p>
</li>
<li><p>缺页异常程序如何工作</p>
</li>
<li><p>segmemt fault 是在缺页异常程序里被调用的吗</p>
</li>
<li><p>一个程序分为多少个段，mmap 的内存属于哪个段</p>
</li>
<li><p>有没有使用过gdb、如何跳转到指定帧</p>
</li>
<li><p>kernel panic 中的栈回溯的如何打印出来的</p>
</li>
<li><p>业务和技术的关系</p>
</li>
<li><p>职业规划</p>
</li>
<li><p>对卓驭科技的了解，有什么产品</p>
</li>
</ol>
<h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><p>了解卓驭科技 和 智能驾驶行业</p>
<p>卓驭介绍、优势：多年积累的感知、机器学习、定位、决策、规划、控制技术与智能硬件的量产经验，以及高规格的流程体系、产品安全、网络安全等车规全栈认证，提供可落地的智能驾驶解决方案。为所有人提供安全轻松的出行体验。</p>
<p>成行平台：高速、城区、停车，兼容多芯片，可扩展，双目、激目、雷达、高精地图等</p>
<p>产品：智能驾驶控制器、传感器，智能驾驶全栈算法，车规级工厂，高质量、高性能，低成本的产品</p>
<p>技术路线：</p>
<ol>
<li><p>以惯导双目为核心的传感器、高性价比、城区领航</p>
</li>
<li><p>算法：双目立体视觉</p>
</li>
<li><p>计算平台：高度集成化、平台化、性价比、安全</p>
</li>
</ol>
<p>联合高通<strong>SA8775P</strong> 实现舱驾一体，骁龙8650 已经运用</p>
<p>价值观：</p>
<ol>
<li><p>秉持公心：个人与团队的持续成长，都需要不断将自身追求与更高维度的追求相统一。持续突破自身视野的局限，主动担当、为更大的世界创造价值，个人价值也将自然而然地实现。</p>
</li>
<li><p>反思：遇到问题积极向内求解</p>
</li>
<li><p>求真：心怀对真理与客观规律的尊重，专注做真正有价值、经得起时间考验的事</p>
</li>
<li><p>积极正向：面对困难时，一个积极的心态往往能驱使我们找到建设性的思路，促进事情向正面发展，最终克服困难，并使我们从中收获进步与成长。</p>
</li>
<li><p>知行合一：真正的“知道”往往伴随行为的改变。认知升级的意义，在于帮助我们在具体的实践中塑造新的习惯、提升自身的能力；</p>
<p> 而积极的实践亦将反哺于我们的认知升级，实现螺旋上升的正向循环</p>
</li>
</ol>
<h3 id="3-3、安克创新"><a href="#3-3、安克创新" class="headerlink" title="3.3、安克创新"></a>3.3、安克创新</h3><p>一面：有录音，主要是八股文，还有项目经历，问的深度不深。<br>结果：不符合岗位，被拒绝</p>
<h3 id="3-4、元时空智能"><a href="#3-4、元时空智能" class="headerlink" title="3.4、元时空智能"></a>3.4、元时空智能</h3><p>oppo 手机内存管理、内存性能分析，bug解决<br>一面不愉快的结束了<br>居然有二面</p>
<ol>
<li>自我介绍</li>
<li>内存泄露的例子</li>
<li>死锁的例子</li>
<li>dmabuf的项目</li>
<li>内存回收<br>谈薪资</li>
</ol>
<h3 id="3-5、塞防"><a href="#3-5、塞防" class="headerlink" title="3.5、塞防"></a>3.5、塞防</h3><p>一面后无消息</p>
<h3 id="3-6、晶晨"><a href="#3-6、晶晨" class="headerlink" title="3.6、晶晨"></a>3.6、晶晨</h3><p>解码的驱动层开发、会涉及到具体的厂商业务，主要是和厂商联合开发。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/" data-id="cmbcy7ri2003wt8mt8xb704kw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/01/killer-blog/sifive/uart/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2025/06/01/killer-blog/other/tools/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/pwm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/uart/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/worklife/2025%E6%B1%82%E8%81%8C%E5%87%86%E5%A4%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/other/tools/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/01/killer-blog/sifive/i2c_LSM303AGR/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>